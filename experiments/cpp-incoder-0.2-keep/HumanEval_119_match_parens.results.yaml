name: HumanEval_119_match_parens
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpfq3mheb0: /tmp/tmpfq3mheb0.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      int count = 0;\n      for (int j = i; j\
    \ < lst.size(); j++) {\n        if (lst[j] == \")\") {\n          count++;\n \
    \       } else {\n          break;\n        }\n      }\n      if (count == 0)\
    \ {\n        ans = \"Yes\";\n        break;\n      }\n    }\n  }\n  return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpgwh62s6w: /tmp/tmpgwh62s6w.cpp:37: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n\
    \        if (lst[i] == \"(\") {\n            ans = \"Yes\";\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpz79q2d7b: /tmp/tmpz79q2d7b.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpduv5wydq: /tmp/tmpduv5wydq.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ if (s == \"No\") {\n            s = i;\n        } else {\n            if (s\
    \ == \"Yes\") {\n                ans = \"Yes\";\n                break;\n    \
    \        }\n            s += i;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp18cbi9m6: /tmp/tmp18cbi9m6.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpd1ludvna: /tmp/tmpd1ludvna.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpl3_dpbog: /tmp/tmpl3_dpbog.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ if (i == \"(\") {\n            s += \"(\";\n        } else if (i == \")\") {\n\
    \            if (s.empty()) {\n                ans = \"No\";\n               \
    \ break;\n            }\n            s += \")\";\n        } else {\n         \
    \   s += i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpg3i6py7v: /tmp/tmpg3i6py7v.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if (x.size()\
    \ == 1) {\n            s += x;\n            flag = true;\n        } else if (x.size()\
    \ > 1) {\n            s += \"(\";\n            for (auto &y : x) {\n         \
    \       s += y;\n            }\n            s += \")\";\n            flag = true;\n\
    \        }\n    }\n    return flag ? \"Yes\" : \"No\";\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphssux0i3: /tmp/tmphssux0i3.cpp:35: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            s += i;\n        }\n \
    \   }\n    if (flag) {\n        s = \"Yes\";\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphpgvgmse: /tmp/tmphpgvgmse.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string r = \"(\";\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            s += \")\";\n            r += \")\";\n        }\
    \ else if (i == \")\") {\n            s += \"(\";\n            r += \"(\";\n \
    \       } else {\n            s += i;\n            r += i;\n        }\n    }\n\
    \    return s == r;\n}\nint main() {\n    auto candidate = match_parens;\n   \
    \ assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"));\n\
    \    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"));\n\
    \    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"}))) ==\
    \ (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"(()()(\"\
    }))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"(())))\"\
    , \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaedh6khn.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpaedh6khn.cpp:29:14: error: could not convert \u2018std::operator==<char>(s,\
    \ r)\u2019 from \u2018__gnu_cxx::__enable_if<true, bool>::__type\u2019 {aka \u2018\
    bool\u2019} to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   29 |     return s == r;\n      |            ~~^~~~\n      |            \
    \  |\n      |              __gnu_cxx::__enable_if<true, bool>::__type {aka bool}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n\
    \        if (lst[i] == \"(\") {\n            int j = i + 1;\n            while\
    \ (j < n && lst[j] == \")\") {\n                j++;\n            }\n        \
    \    if (j == n) {\n                ans = \"Yes\";\n                break;\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpxy61k_vz: /tmp/tmpxy61k_vz.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> s;\n    for (auto &el : lst) {\n        if (el\
    \ == \"(\") {\n            s.push(el);\n        } else if (el == \")\") {\n  \
    \          if (s.empty()) {\n                ans = \"No\";\n                break;\n\
    \            } else {\n                s.pop();\n            }\n        }\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n \
    \   assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyguqrdag.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpyguqrdag.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ s;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpyguqrdag.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpyguqrdag.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpyguqrdag.cpp:19:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   19 |             s.push(el);\n      |             ^\n/tmp/tmpyguqrdag.cpp:21:17:\
    \ error: \u2018s\u2019 was not declared in this scope\n   21 |             if\
    \ (s.empty()) {\n      |                 ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto &i : lst) {\n        if (i\
    \ == '(') {\n            st.push('(');\n        } else if (i == ')') {\n     \
    \       if (st.empty()) {\n                ans = \"Yes\";\n                break;\n\
    \            } else {\n                st.pop();\n            }\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvtvejn9w.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpvtvejn9w.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpvtvejn9w.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmpvtvejn9w.cpp:18:15: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   18 |         if (i == '(') {\n      |             ~ ^~ ~~~\n      |    \
    \         |    |\n      |             |    char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   18 |         if (i == '(') {\n      |    \
    \              ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   18 |         if (i == '(') {\n      | \
    \                 ^~~\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   18 |         if (i ==\
    \ '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |\
    \                  ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n \
    \                from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n \
    \                from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n      |  \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n     \
    \ |                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   18 |      \
    \   if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |         if (i == '(') {\n  \
    \    |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 |         if (i == '(') {\n   \
    \   |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/memory:81,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n  \
    \               from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/queue:64,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n   \
    \              from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n         \
    \        from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |         if\
    \ (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |\
    \         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |   \
    \      if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:18:18:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   18 |         if (i == '(') {\n      |                 \
    \ ^~~\n/tmp/tmpvtvejn9w.cpp:19:13: error: \u2018st\u2019 was not declared in this\
    \ scope; did you mean \u2018lst\u2019?\n   19 |             st.push('(');\n  \
    \    |             ^~\n      |             lst\n/tmp/tmpvtvejn9w.cpp:20:22: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         } else if (i == ')') {\n      |     \
    \               ~ ^~ ~~~\n      |                    |    |\n      |         \
    \           |    char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   20 |         } else if (i == ')') {\n    \
    \  |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   20 |         } else if (i == ')') {\n \
    \     |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   20 |         } else if\
    \ (i == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 20 |         } else if (i == ')') {\n      |                         ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/ios_base.h:46,\n                \
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n  \
    \    |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n        \
    \         from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   20 |      \
    \   } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/memory:81,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n          \
    \       from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   20 |         }\
    \ else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |\
    \         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |   \
    \      } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvtvejn9w.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvtvejn9w.cpp:20:25: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\n/tmp/tmpvtvejn9w.cpp:21:17: error: \u2018st\u2019 was not declared\
    \ in this scope; did you mean \u2018lst\u2019?\n   21 |             if (st.empty())\
    \ {\n      |                 ^~\n      |                 lst\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if\
    \ (x.find(\"(\") != std::string::npos) {\n            flag = true;\n        }\n\
    \    }\n    if (flag) {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpfz_qf7ij: /tmp/tmpfz_qf7ij.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpagpz5df8: /tmp/tmpagpz5df8.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphatth74h: /tmp/tmphatth74h.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &x : lst) {\n        if (x.size() == 1) {\n   \
    \         if (x[0] == '(') {\n                ans = \"Yes\";\n               \
    \ break;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpibw66cf1: /tmp/tmpibw66cf1.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmper8acecq.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmper8acecq.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmper8acecq.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpcpzo8zz_: /tmp/tmpcpzo8zz_.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string s = \"()\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      s += \"(\";\n    } else if (lst[i] == \"\
    )\") {\n      s += \")\";\n    } else {\n      s += lst[i];\n    }\n  }\n  return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpnmad665j: /tmp/tmpnmad665j.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &s : lst) {\n        if\
    \ (s == \"(\") {\n            flag = true;\n        } else if (s == \"(\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpvy_dcs9t: /tmp/tmpvy_dcs9t.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        s += \"Yes\";\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp1ot0r5j5: /tmp/tmp1ot0r5j5.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = false;\n        }\n        if (i == \")\") {\n\
    \            flag = true;\n        }\n        if (flag) {\n            ans = \"\
    Yes\";\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpr_eqkzc0: /tmp/tmpr_eqkzc0.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo7rgonf5.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpo7rgonf5.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmpo7rgonf5.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n        else if (i == \")\") {\n            s +=\
    \ \"No\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpqn20p38y: /tmp/tmpqn20p38y.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            flag = true;\n       \
    \ }\n        if (flag) {\n            s = \"Yes\";\n        }\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpkso0xrrj: /tmp/tmpkso0xrrj.cpp:35: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else {\n            flag = false;\n    \
    \    }\n        if (flag) {\n            ans = \"Yes\";\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpccj00hgh: /tmp/tmpccj00hgh.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      int count = 0;\n      for (int j = i; j\
    \ < lst.size(); j++) {\n        if (lst[j] == \"(\") {\n          count++;\n \
    \       } else if (lst[j] == \")\") {\n          count--;\n        }\n       \
    \ if (count == 0) {\n          ans = \"Yes\";\n          break;\n        }\n \
    \     }\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpxwj5bw2c: /tmp/tmpxwj5bw2c.cpp:37: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string t = \"(\";\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            s += t;\n            t = \"\";\n        } else {\n\
    \            t += i;\n        }\n    }\n    s += t;\n    return s;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpeud62lht: /tmp/tmpeud62lht.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    bool flag = false;\n    for (auto\
    \ &x : lst) {\n        if (x == \"(\") {\n            flag = true;\n         \
    \   s += \"(\";\n        } else if (x == \")\") {\n            flag = false;\n\
    \            s += \")\";\n        } else {\n            s += x;\n        }\n \
    \   }\n    if (flag) {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpre16exis: /tmp/tmpre16exis.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n       \
    \     ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp07ajqltw: /tmp/tmp07ajqltw.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto &it : lst) {\n        if (it\
    \ == '(') {\n            st.push('(');\n        } else if (it == ')') {\n    \
    \        if (st.top() == '(') {\n                st.pop();\n            } else\
    \ {\n                ans = \"Yes\";\n                break;\n            }\n \
    \       } else {\n            ans = \"No\";\n            break;\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9jddnqa9.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmp9jddnqa9.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp9jddnqa9.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmp9jddnqa9.cpp:18:16: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   18 |         if (it == '(') {\n      |             ~~ ^~ ~~~\n      |  \
    \           |     |\n      |             |     char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (it == '(') {\n\
    \      |                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (it == '(') {\n      |            \
    \       ^~~\nIn file included from /usr/include/c++/9/regex:62,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n          \
    \       from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (it == '(') {\n\
    \      |                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (it == '(') {\n      |            \
    \       ^~~\nIn file included from /usr/include/c++/9/regex:62,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n          \
    \       from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (it == '(') {\n      |            \
    \       ^~~\nIn file included from /usr/include/c++/9/regex:62,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n          \
    \       from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   18 |         if (it\
    \ == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   18 |         if (it == '(') {\n      |    \
    \               ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   18 |         if (it == '(') {\n      |   \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |         if (it == '(') {\n\
    \      |                   ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   18 |         if (it == '(') {\n\
    \      |                   ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   18 |         if (it == '(') {\n      |\
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   18 |         if (it == '(') {\n      |            \
    \       ^~~\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   18 |         if (it == '(') {\n      |            \
    \       ^~~\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |         if (it ==\
    \ '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 18 |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   18 |         if (it\
    \ == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (it == '(') {\n      |     \
    \              ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n \
    \                from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (it == '(') {\n      |     \
    \              ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n \
    \                from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (it == '(')\
    \ {\n      |                   ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (it == '(')\
    \ {\n      |                   ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   18 |         if (it == '(') {\n      |\
    \                   ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   18 |         if (it == '(') {\n      |  \
    \                 ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   18 |        \
    \ if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   18 |         if (it == '(')\
    \ {\n      |                   ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   18 |         if (it == '(') {\n      |            \
    \       ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (it == '(') {\n      | \
    \                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (it == '(') {\n    \
    \  |                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   18 |         if (it == '(') {\n      |                   ^~~\n\
    In file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   18 |      \
    \   if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18 |         if (it == '(') {\n\
    \      |                   ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (it == '(')\
    \ {\n      |                   ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (it\
    \ == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |         if (it == '(') {\n \
    \     |                   ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 |         if (it == '(') {\n  \
    \    |                   ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   18 |         if (it == '(') {\n      |                   ^~~\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |        \
    \ if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   18 |         if (it == '(') {\n      |  \
    \                 ^~~\nIn file included from /usr/include/c++/9/memory:81,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   18 |         if (it == '(') {\n      |  \
    \                 ^~~\nIn file included from /usr/include/c++/9/queue:64,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n \
    \                from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   18 |       \
    \  if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   18 |         if (it == '(') {\n\
    \      |                   ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   18 |         if (it == '(')\
    \ {\n      |                   ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   18 |       \
    \  if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   18 |         if (it == '(') {\n      |            \
    \       ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n       \
    \          from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   18 |         if (it\
    \ == '(') {\n      |                   ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |         if\
    \ (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   18 |         if (it == '(') {\n      |    \
    \               ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   18\
    \ |         if (it == '(') {\n      |                   ^~~\nIn file included\
    \ from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   18 |         if (it == '(') {\n\
    \      |                   ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   18 |         if (it\
    \ == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |     \
    \    if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |\
    \         if (it == '(') {\n      |                   ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |        \
    \ if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |   \
    \      if (it == '(') {\n      |                   ^~~\nIn file included from\
    \ /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   18 |        \
    \ if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   18 |     \
    \    if (it == '(') {\n      |                   ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:18:19:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   18 |         if (it == '(') {\n      |                \
    \   ^~~\n/tmp/tmp9jddnqa9.cpp:19:13: error: \u2018st\u2019 was not declared in\
    \ this scope; did you mean \u2018it\u2019?\n   19 |             st.push('(');\n\
    \      |             ^~\n      |             it\n/tmp/tmp9jddnqa9.cpp:20:23: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         } else if (it == ')') {\n      |    \
    \                ~~ ^~ ~~~\n      |                    |     |\n      |      \
    \              |     char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (it ==\
    \ ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (it == ')') {\n      |     \
    \                     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (it ==\
    \ ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (it == ')') {\n      |     \
    \                     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (it == ')') {\n      |                          ^~~\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (it == ')') {\n      |     \
    \                     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (it == ')') {\n      |                          ^~~\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   20 |         } else\
    \ if (it == ')') {\n      |                          ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   20 |         } else if (it == ')') {\n    \
    \  |                          ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   20 |         } else if (it == ')') {\n   \
    \   |                          ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   20 |         } else if (it ==\
    \ ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |         } else if (it == ')') {\n      |                          ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (it == ')') {\n      |                          ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (it == ')') {\n      |                          ^~~\nIn\
    \ file included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   20 |         } else if (it == ')') {\n\
    \      |                          ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (it == ')') {\n      |     \
    \                     ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (it == ')') {\n      |     \
    \                     ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   20 |         } else if\
    \ (it == ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 20 |         } else if (it == ')') {\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/bits/ios_base.h:46,\n               \
    \  from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   20 |         } else\
    \ if (it == ')') {\n      |                          ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (it == ')') {\n     \
    \ |                          ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (it == ')') {\n     \
    \ |                          ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (it == ')') {\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (it\
    \ == ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (it\
    \ == ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   20 |         } else if (it == ')') {\n\
    \      |                          ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   20 |         } else if (it == ')') {\n  \
    \    |                          ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   20 |        \
    \ } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   20 |         } else if (it\
    \ == ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (it == ')') {\n      |     \
    \                     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (it == ')') {\n \
    \     |                          ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (it == ')') {\n\
    \      |                          ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (it == ')') {\n      |                 \
    \         ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n       \
    \          from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n      \
    \           from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   20 |      \
    \   } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   20 |         } else if (it ==\
    \ ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else if (it\
    \ == ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else\
    \ if (it == ')') {\n      |                          ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   20 |         } else if (it == ')')\
    \ {\n      |                          ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   20 |         } else if (it == ')')\
    \ {\n      |                          ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (it == ')') {\n      |                 \
    \         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n        \
    \         from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   20 |        \
    \ } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   20 |         } else if (it == ')') {\n  \
    \    |                          ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (it == ')') {\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   20 |         } else if (it == ')') {\n  \
    \    |                          ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (it ==\
    \ ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (it\
    \ == ')') {\n      |                          ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (it == ')') {\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (it == ')') {\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (it == ')') {\n      |     \
    \                     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (it == ')') {\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   20 |         } else\
    \ if (it == ')') {\n      |                          ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   20 |         }\
    \ else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   20 |         } else if (it == ')') {\n    \
    \  |                          ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (it == ')') {\n      |                          ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   20\
    \ |         } else if (it == ')') {\n      |                          ^~~\nIn\
    \ file included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   20 |         } else if (it ==\
    \ ')') {\n      |                          ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   20 |         } else\
    \ if (it == ')') {\n      |                          ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |     \
    \    } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |\
    \         } else if (it == ')') {\n      |                          ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |        \
    \ } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |   \
    \      } else if (it == ')') {\n      |                          ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   20 |        \
    \ } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   20 |     \
    \    } else if (it == ')') {\n      |                          ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9jddnqa9.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9jddnqa9.cpp:20:26: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (it == ')') {\n      |                 \
    \         ^~~\n/tmp/tmp9jddnqa9.cpp:21:17: error: \u2018st\u2019 was not declared\
    \ in this scope; did you mean \u2018it\u2019?\n   21 |             if (st.top()\
    \ == '(') {\n      |                 ^~\n      |                 it\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp6ge6dh3o: /tmp/tmp6ge6dh3o.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp9s4dlav1: /tmp/tmp9s4dlav1.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpk2qe7gqq: /tmp/tmpk2qe7gqq.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if\
    \ (x.size() == 1) {\n            flag = true;\n        }\n    }\n    if (flag)\
    \ {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmptcbbbti2: /tmp/tmptcbbbti2.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string s = \"()\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] != \"()\") {\n      s += lst[i];\n    }\n  }\n  return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpz2kouimn: /tmp/tmpz2kouimn.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp1quh6pth: /tmp/tmp1quh6pth.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    for (auto i : lst) {\n       \
    \ if (i == \"(\") {\n            ans = \"Yes\";\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpll2ussqy: /tmp/tmpll2ussqy.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n       \
    \     ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpkn64esu1: /tmp/tmpkn64esu1.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ if (s == \"No\") {\n            s = i;\n        } else {\n            if (s\
    \ == \"Yes\") {\n                ans = \"Yes\";\n                break;\n    \
    \        }\n            if (i == \")\") {\n                s += i;\n         \
    \   } else {\n                s += \"(\" + i;\n            }\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp1iqn3ora: /tmp/tmp1iqn3ora.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            s += i;\n        }\n \
    \   }\n    if (flag) {\n        s = \"Yes\";\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpi6e2ite6: /tmp/tmpi6e2ite6.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"Yes\";\n    std::string temp = \"\";\n    bool flag = false;\n    for\
    \ (auto &i : lst) {\n        if (i == \"(\") {\n            flag = true;\n   \
    \     }\n        else if (i == \")\") {\n            flag = false;\n        }\n\
    \        if (flag) {\n            temp += i;\n        }\n    }\n    if (temp ==\
    \ \"Yes\") {\n        s = \"Yes\";\n    }\n    else {\n        s = \"No\";\n \
    \   }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n  \
    \  assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp5jvwkr_4: /tmp/tmp5jvwkr_4.cpp:39: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            flag = true;\n       \
    \ }\n        if (flag) {\n            ans = \"Yes\";\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpmuwxbzq3: /tmp/tmpmuwxbzq3.cpp:35: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i][0] == '(' && lst[i][1] == ')') {\n      ans = \"Yes\";\n \
    \     break;\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate =\
    \ match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \")\"\
    }))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\", \"\
    )\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"(()(())\"\
    , \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpetlvbmt3: /tmp/tmpetlvbmt3.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    bool flag = false;\n    for (auto\
    \ i : lst) {\n        if (i == \"(\") {\n            flag = true;\n        }\n\
    \        if (i == \")\") {\n            flag = false;\n        }\n        if (flag)\
    \ {\n            s += i;\n        }\n    }\n    if (s == \"()\") {\n        ans\
    \ = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpqqerio77: /tmp/tmpqqerio77.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      for (int j = i + 1; j < lst.size(); j++)\
    \ {\n        if (lst[j] == \")\") {\n          ans = \"Yes\";\n          break;\n\
    \        }\n      }\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpzyk5beya: /tmp/tmpzyk5beya.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string str = lst[0];\n    for (int i = 1; i < lst.size();\
    \ i++) {\n        str += \")\" + lst[i];\n        if (match_parens(str.substr(1,\
    \ str.size() - 2)) == \"Yes\") {\n            ans = \"Yes\";\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy2qlozgz.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpy2qlozgz.cpp:19:36: error: could not convert \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::substr(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) const [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int](1, (str.std::__cxx11::basic_string<char>::size() - 2))\u2019 from \u2018\
    std::__cxx11::basic_string<char>\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   19 |         if (match_parens(str.substr(1, str.size() - 2)) ==\
    \ \"Yes\") {\n      |                          ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    \      |                                    |\n      |                       \
    \             std::__cxx11::basic_string<char>\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            flag = true;\n       \
    \ }\n        if (flag) {\n            s = \"Yes\";\n            break;\n     \
    \   }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp6hfd8lwk: /tmp/tmp6hfd8lwk.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s == \"(\") {\n      \
    \      ans = \"Yes\";\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpfylmwlem: /tmp/tmpfylmwlem.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp3nk7upx9: /tmp/tmp3nk7upx9.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto &x : lst) {\n        if (x.size() == 1) {\n     \
    \       s += x;\n        } else {\n            s += \"(\";\n            s += x;\n\
    \            s += \")\";\n        }\n    }\n    return s;\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpcx3dsraz: /tmp/tmpcx3dsraz.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp_ca_fksl: /tmp/tmp_ca_fksl.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            if (flag) {\n        \
    \        s += i;\n            }\n        }\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp4q2_8a2w: /tmp/tmp4q2_8a2w.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n       \
    \     ans = \"Yes\";\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpr2r1662r: /tmp/tmpr2r1662r.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string temp = \"\";\n    for (auto i : lst) {\n    \
    \    if (i == \"(\") {\n            temp = temp + i;\n        } else if (i ==\
    \ \")\") {\n            if (temp == \"()\") {\n                ans = \"Yes\";\n\
    \                break;\n            }\n            temp = temp + i;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpy_h8gzst: /tmp/tmpy_h8gzst.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") == std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpehjts24_: /tmp/tmpehjts24_.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto &x : lst) {\n        if (st.empty())\
    \ {\n            st.push(x);\n        } else if (st.top() == '(') {\n        \
    \    st.push(x);\n        } else if (st.top() == ')') {\n            if (st.top()\
    \ == '(') {\n                st.pop();\n            } else {\n               \
    \ ans = \"Yes\";\n                break;\n            }\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiskva0kd.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpiskva0kd.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpiskva0kd.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpiskva0kd.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmpiskva0kd.cpp:18:13: error: \u2018st\u2019 was not declared in this scope;\
    \ did you mean \u2018lst\u2019?\n   18 |         if (st.empty()) {\n      |  \
    \           ^~\n      |             lst\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp5kvzj007: /tmp/tmp5kvzj007.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    bool flag = false;\n    for (auto\
    \ &x : lst) {\n        if (x.size() == 1) {\n            s += x;\n        } else\
    \ {\n            s += \"(\";\n            flag = true;\n        }\n    }\n   \
    \ for (auto &x : lst) {\n        if (x.size() == 1) {\n            s += x;\n \
    \       } else {\n            s += \")\";\n            flag = false;\n       \
    \ }\n    }\n    if (flag) {\n        ans = \"Yes\";\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpsss146yl: /tmp/tmpsss146yl.cpp:41: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto &x : lst) {\n        if\
    \ (x.size() == 1) {\n            flag = false;\n            break;\n        }\n\
    \    }\n    if (flag) {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp2xs2m1gw: /tmp/tmp2xs2m1gw.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      int j = i + 1;\n      while (j < lst.size()\
    \ && lst[j] == \")\") {\n        j++;\n      }\n      if (j == lst.size()) {\n\
    \        ans = \"Yes\";\n        break;\n      }\n    }\n  }\n  return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpaik3j0jq: /tmp/tmpaik3j0jq.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb_hkv8fw.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpb_hkv8fw.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmpb_hkv8fw.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string t = \"(\";\n    std::string ans = \"No\";\n    for\
    \ (auto i : lst) {\n        if (i == \"(\") {\n            s += i;\n        }\
    \ else if (i == \")\") {\n            t += i;\n        } else {\n            ans\
    \ = \"Yes\";\n        }\n    }\n    if (s == t) {\n        ans = \"Yes\";\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n \
    \   assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpexirdrhw: /tmp/tmpexirdrhw.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string s = \"()\";\n    std::string t = \"()\";\n    bool\
    \ flag = false;\n    for (auto i : lst) {\n        if (i == \"(\") {\n       \
    \     flag = true;\n        } else if (i == \")\") {\n            flag = false;\n\
    \        } else {\n            s += i;\n        }\n    }\n    if (flag) {\n  \
    \      s += t;\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphdyissuj: /tmp/tmphdyissuj.cpp:35: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpdww30193: /tmp/tmpdww30193.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if\
    \ (x.find(\"(\") != std::string::npos) {\n            flag = true;\n        }\n\
    \        if (x.find(\")\") != std::string::npos) {\n            flag = false;\n\
    \        }\n        if (flag) {\n            ans = \"Yes\";\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpon7bq1ly: /tmp/tmpon7bq1ly.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else {\n            flag = false;\n    \
    \    }\n        if (flag) {\n            ans = \"Yes\";\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp280xn31t: /tmp/tmp280xn31t.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto &x : lst) {\n      \
    \  s += x;\n    }\n    ans = s;\n    int n = s.size();\n    int m = s.size() /\
    \ 2;\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i]\
    \ == '(') {\n            count++;\n        }\n        if (s[i] == ')') {\n   \
    \         count--;\n        }\n        if (count == 0) {\n            if (i ==\
    \ m) {\n                ans = \"Yes\";\n            }\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpdjv1kcp6: /tmp/tmpdjv1kcp6.cpp:41: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> s;\n    bool flag = true;\n    for (auto i :\
    \ lst) {\n        if (i == '(') {\n            s.push(i);\n        } else if (i\
    \ == ')') {\n            if (s.empty()) {\n                ans = \"No\";\n   \
    \             flag = false;\n                break;\n            } else {\n  \
    \              s.pop();\n            }\n        }\n    }\n    if (flag) {\n  \
    \      ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy74my7hy.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpy74my7hy.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ s;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpy74my7hy.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpy74my7hy.cpp:19:15: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   19 |         if (i == '(') {\n      |             ~ ^~ ~~~\n      |    \
    \         |    |\n      |             |    char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   19 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   19 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   19 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   19 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   19\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   19 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   19\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   19 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   19 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   19 |         if (i == '(') {\n      |    \
    \              ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   19 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   19\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   19\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   19 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   19 |         if (i == '(') {\n      | \
    \                 ^~~\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   19 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   19 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   19 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 19 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   19 |         if (i ==\
    \ '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   19 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   19 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   19 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   19 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   19 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   19 |         if (i == '(') {\n      |\
    \                  ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n \
    \                from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   19 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   19 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   19 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   19 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n \
    \                from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   19 |         if (i == '(') {\n      |  \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   19 |         if (i == '(') {\n     \
    \ |                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   19 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   19 |      \
    \   if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   19 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   19 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   19 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   19 |         if (i == '(') {\n  \
    \    |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   19 |         if (i == '(') {\n   \
    \   |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   19 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   19 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   19 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/memory:81,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n  \
    \               from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   19 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   19 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/queue:64,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n   \
    \              from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   19 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   19 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   19 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   19 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   19 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   19 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   19 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n         \
    \        from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   19 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   19 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   19 |         if\
    \ (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   19 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   19 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:19:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   19\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   19 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   19 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   19 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   19 |\
    \         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   19 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   19 |   \
    \      if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   19 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   19 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:19:18:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   19 |         if (i == '(') {\n      |                 \
    \ ^~~\n/tmp/tmpy74my7hy.cpp:20:13: error: \u2018s\u2019 was not declared in this\
    \ scope\n   20 |             s.push(i);\n      |             ^\n/tmp/tmpy74my7hy.cpp:21:22:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         } else if (i == ')') {\n      |     \
    \               ~ ^~ ~~~\n      |                    |    |\n      |         \
    \           |    char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   21 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   21 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   21 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   21 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   21 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   21 |         } else if (i == ')') {\n    \
    \  |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   21 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   21\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   21\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   21\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   21 |         } else if (i == ')') {\n \
    \     |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   21 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   21 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   21 |         } else if\
    \ (i == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 21 |         } else if (i == ')') {\n      |                         ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/ios_base.h:46,\n                \
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   21 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   21 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   21 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   21 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   21 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   21 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   21 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   21 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   21 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   21 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   21 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   21 |         } else if (i == ')') {\n  \
    \    |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   21 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   21 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n        \
    \         from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   21 |      \
    \   } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   21 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   21 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   21 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   21 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   21 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   21 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/memory:81,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n          \
    \       from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   21 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   21 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   21 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   21 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   21 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   21 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   21 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   21 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   21 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   21 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   21 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   21 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   21 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   21 |         }\
    \ else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   21 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   21 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy74my7hy.cpp:21:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   21\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   21 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   21 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   21 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   21 |\
    \         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   21 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   21 |   \
    \      } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   21 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   21 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy74my7hy.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpy74my7hy.cpp:21:25: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   21 |         } else if (i == ')') {\n      |                  \
    \       ^~~\n/tmp/tmpy74my7hy.cpp:22:17: error: \u2018s\u2019 was not declared\
    \ in this scope\n   22 |             if (s.empty()) {\n      |               \
    \  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    bool flag = false;\n    for (auto\
    \ i : lst) {\n        if (i == \"(\") {\n            flag = true;\n        } else\
    \ if (i == \")\") {\n            flag = false;\n        } else {\n           \
    \ flag = false;\n        }\n        if (flag == true) {\n            ans = \"\
    Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpltm396nq: /tmp/tmpltm396nq.cpp:35: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ if (s == \"No\") {\n            s = i;\n        } else {\n            if (s\
    \ == \"Yes\") {\n                ans = \"Yes\";\n            }\n        }\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n \
    \   assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpe3v6yddu: /tmp/tmpe3v6yddu.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"Yes\";\n    for (auto i : lst) {\n        s += \"(\" + i + \")\";\n  \
    \  }\n    s += \"(\" + lst.back() + \")\";\n    return s;\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpagmc0g04: /tmp/tmpagmc0g04.cpp:24: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    for (auto i : lst) {\n        s += i;\n    }\n    s += \")\"\
    ;\n    bool flag = true;\n    for (auto i : lst) {\n        flag = flag && s.find(i)\
    \ != std::string::npos;\n    }\n    return flag ? \"Yes\" : \"No\";\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphe5fn95n: /tmp/tmphe5fn95n.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        }\n        if (flag) {\n            ans = \"\
    Yes\";\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpsbyqsggn: /tmp/tmpsbyqsggn.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp4z98s9tv: /tmp/tmp4z98s9tv.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    std::string s = \"No\";\n    std::string\
    \ t = \"No\";\n    std::string u = \"No\";\n    std::string v = \"No\";\n    std::string\
    \ w = \"No\";\n    std::string x = \"No\";\n    std::string y = \"No\";\n    std::string\
    \ z = \"No\";\n    std::string a = \"No\";\n    std::string b = \"No\";\n    std::string\
    \ c = \"No\";\n    std::string d = \"No\";\n    std::string e = \"No\";\n    std::string\
    \ f = \"No\";\n    std::string g = \"No\";\n    std::string h = \"No\";\n    std::string\
    \ i = \"No\";\n    std::string j = \"No\";\n    std::string k = \"No\";\n    std::string\
    \ l = \"No\";\n    std::string m = \"No\";\n    std::string n = \"No\";\n    std::string\
    \ o = \"No\";\n    std::string p = \"No\";\n    std::string q = \"No\";\n    std::string\
    \ r = \"No\";\n    std::string s = \"No\";\n    std::string t = \"No\";\n    std::string\
    \ u = \"No\";\n    std::string v = \"No\";\n    std::string w = \"No\";\n    std::string\
    \ x = \"No\";\n    std::string y = \"No\";\n    std::string z = \"No\";\n    std::string\
    \ a = \"No\";\n    std::string b = \"No\";\n    std::string c = \"No\";\n    std::string\
    \ d = \"No\";\n    std::string e = \"No\";\n    std::string f = \"No\";\n    std::string\
    \ g = \"No\";\n    std::string h = \"No\";\n    std::string i = \"No\";\n    std::string\
    \ j = \"No\";\n    std::string k = \"No\";\n    std::string l = \"No\";\n    std::string\
    \ m = \"No\";\n    std::string n = \"No\";\n    std::string o = \"No\";\n    std::string\
    \ p = \"No\";\n    std::string q = \"No\";\n    std::string r = \"No\";\n    std::string\
    \ s = \"No\";\n    std::string t = \"No\";\n    std::string u = \"No\";\n    std::string\
    \ v = \"No\";\n    std::string w = \"No\";\n    std::string x = \"No\";\n    std::string\
    \ y = \"No\";\n    std::string z = \"No\";\n    std::string a = \"No\";\n    std::string\
    \ b = \"No\";\n    std::string c = \"No\";\n    std::string d = \"No\";\n    std::string\
    \ e = \"No\";\n    std::string f = \"No\";\n    std::string g = \"No\";\n    std::string\
    \ h = \"No\";\n    std::string i = \"No\";\n    std::string j = \"No\";\n    std::string\
    \ k = \"No\";\n    std::string l = \"No\";\n    std::string \n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyli44ond.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpyli44ond.cpp:43:17: error: redeclaration of \u2018std::string\
    \ s\u2019\n   43 |     std::string s = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:17:17:\
    \ note: \u2018std::string s\u2019 previously declared here\n   17 |     std::string\
    \ s = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:44:17: error: redeclaration\
    \ of \u2018std::string t\u2019\n   44 |     std::string t = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:18:17: note: \u2018std::string t\u2019\
    \ previously declared here\n   18 |     std::string t = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:45:17: error: redeclaration of \u2018std::string\
    \ u\u2019\n   45 |     std::string u = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:19:17:\
    \ note: \u2018std::string u\u2019 previously declared here\n   19 |     std::string\
    \ u = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:46:17: error: redeclaration\
    \ of \u2018std::string v\u2019\n   46 |     std::string v = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:20:17: note: \u2018std::string v\u2019\
    \ previously declared here\n   20 |     std::string v = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:47:17: error: redeclaration of \u2018std::string\
    \ w\u2019\n   47 |     std::string w = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:21:17:\
    \ note: \u2018std::string w\u2019 previously declared here\n   21 |     std::string\
    \ w = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:48:17: error: redeclaration\
    \ of \u2018std::string x\u2019\n   48 |     std::string x = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:22:17: note: \u2018std::string x\u2019\
    \ previously declared here\n   22 |     std::string x = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:49:17: error: redeclaration of \u2018std::string\
    \ y\u2019\n   49 |     std::string y = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:23:17:\
    \ note: \u2018std::string y\u2019 previously declared here\n   23 |     std::string\
    \ y = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:50:17: error: redeclaration\
    \ of \u2018std::string z\u2019\n   50 |     std::string z = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:24:17: note: \u2018std::string z\u2019\
    \ previously declared here\n   24 |     std::string z = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:51:17: error: redeclaration of \u2018std::string\
    \ a\u2019\n   51 |     std::string a = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:25:17:\
    \ note: \u2018std::string a\u2019 previously declared here\n   25 |     std::string\
    \ a = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:52:17: error: redeclaration\
    \ of \u2018std::string b\u2019\n   52 |     std::string b = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:26:17: note: \u2018std::string b\u2019\
    \ previously declared here\n   26 |     std::string b = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:53:17: error: redeclaration of \u2018std::string\
    \ c\u2019\n   53 |     std::string c = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:27:17:\
    \ note: \u2018std::string c\u2019 previously declared here\n   27 |     std::string\
    \ c = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:54:17: error: redeclaration\
    \ of \u2018std::string d\u2019\n   54 |     std::string d = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:28:17: note: \u2018std::string d\u2019\
    \ previously declared here\n   28 |     std::string d = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:55:17: error: redeclaration of \u2018std::string\
    \ e\u2019\n   55 |     std::string e = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:29:17:\
    \ note: \u2018std::string e\u2019 previously declared here\n   29 |     std::string\
    \ e = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:56:17: error: redeclaration\
    \ of \u2018std::string f\u2019\n   56 |     std::string f = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:30:17: note: \u2018std::string f\u2019\
    \ previously declared here\n   30 |     std::string f = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:57:17: error: redeclaration of \u2018std::string\
    \ g\u2019\n   57 |     std::string g = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:31:17:\
    \ note: \u2018std::string g\u2019 previously declared here\n   31 |     std::string\
    \ g = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:58:17: error: redeclaration\
    \ of \u2018std::string h\u2019\n   58 |     std::string h = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:32:17: note: \u2018std::string h\u2019\
    \ previously declared here\n   32 |     std::string h = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:59:17: error: redeclaration of \u2018std::string\
    \ i\u2019\n   59 |     std::string i = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:33:17:\
    \ note: \u2018std::string i\u2019 previously declared here\n   33 |     std::string\
    \ i = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:60:17: error: redeclaration\
    \ of \u2018std::string j\u2019\n   60 |     std::string j = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:34:17: note: \u2018std::string j\u2019\
    \ previously declared here\n   34 |     std::string j = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:61:17: error: redeclaration of \u2018std::string\
    \ k\u2019\n   61 |     std::string k = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:35:17:\
    \ note: \u2018std::string k\u2019 previously declared here\n   35 |     std::string\
    \ k = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:62:17: error: redeclaration\
    \ of \u2018std::string l\u2019\n   62 |     std::string l = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:36:17: note: \u2018std::string l\u2019\
    \ previously declared here\n   36 |     std::string l = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:63:17: error: redeclaration of \u2018std::string\
    \ m\u2019\n   63 |     std::string m = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:37:17:\
    \ note: \u2018std::string m\u2019 previously declared here\n   37 |     std::string\
    \ m = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:64:17: error: redeclaration\
    \ of \u2018std::string n\u2019\n   64 |     std::string n = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:38:17: note: \u2018std::string n\u2019\
    \ previously declared here\n   38 |     std::string n = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:65:17: error: redeclaration of \u2018std::string\
    \ o\u2019\n   65 |     std::string o = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:39:17:\
    \ note: \u2018std::string o\u2019 previously declared here\n   39 |     std::string\
    \ o = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:66:17: error: redeclaration\
    \ of \u2018std::string p\u2019\n   66 |     std::string p = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:40:17: note: \u2018std::string p\u2019\
    \ previously declared here\n   40 |     std::string p = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:67:17: error: redeclaration of \u2018std::string\
    \ q\u2019\n   67 |     std::string q = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:41:17:\
    \ note: \u2018std::string q\u2019 previously declared here\n   41 |     std::string\
    \ q = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:68:17: error: redeclaration\
    \ of \u2018std::string r\u2019\n   68 |     std::string r = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:42:17: note: \u2018std::string r\u2019\
    \ previously declared here\n   42 |     std::string r = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:69:17: error: redeclaration of \u2018std::string\
    \ s\u2019\n   69 |     std::string s = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:17:17:\
    \ note: \u2018std::string s\u2019 previously declared here\n   17 |     std::string\
    \ s = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:70:17: error: redeclaration\
    \ of \u2018std::string t\u2019\n   70 |     std::string t = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:18:17: note: \u2018std::string t\u2019\
    \ previously declared here\n   18 |     std::string t = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:71:17: error: redeclaration of \u2018std::string\
    \ u\u2019\n   71 |     std::string u = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:19:17:\
    \ note: \u2018std::string u\u2019 previously declared here\n   19 |     std::string\
    \ u = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:72:17: error: redeclaration\
    \ of \u2018std::string v\u2019\n   72 |     std::string v = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:20:17: note: \u2018std::string v\u2019\
    \ previously declared here\n   20 |     std::string v = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:73:17: error: redeclaration of \u2018std::string\
    \ w\u2019\n   73 |     std::string w = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:21:17:\
    \ note: \u2018std::string w\u2019 previously declared here\n   21 |     std::string\
    \ w = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:74:17: error: redeclaration\
    \ of \u2018std::string x\u2019\n   74 |     std::string x = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:22:17: note: \u2018std::string x\u2019\
    \ previously declared here\n   22 |     std::string x = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:75:17: error: redeclaration of \u2018std::string\
    \ y\u2019\n   75 |     std::string y = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:23:17:\
    \ note: \u2018std::string y\u2019 previously declared here\n   23 |     std::string\
    \ y = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:76:17: error: redeclaration\
    \ of \u2018std::string z\u2019\n   76 |     std::string z = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:24:17: note: \u2018std::string z\u2019\
    \ previously declared here\n   24 |     std::string z = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:77:17: error: redeclaration of \u2018std::string\
    \ a\u2019\n   77 |     std::string a = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:25:17:\
    \ note: \u2018std::string a\u2019 previously declared here\n   25 |     std::string\
    \ a = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:78:17: error: redeclaration\
    \ of \u2018std::string b\u2019\n   78 |     std::string b = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:26:17: note: \u2018std::string b\u2019\
    \ previously declared here\n   26 |     std::string b = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:79:17: error: redeclaration of \u2018std::string\
    \ c\u2019\n   79 |     std::string c = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:27:17:\
    \ note: \u2018std::string c\u2019 previously declared here\n   27 |     std::string\
    \ c = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:80:17: error: redeclaration\
    \ of \u2018std::string d\u2019\n   80 |     std::string d = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:28:17: note: \u2018std::string d\u2019\
    \ previously declared here\n   28 |     std::string d = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:81:17: error: redeclaration of \u2018std::string\
    \ e\u2019\n   81 |     std::string e = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:29:17:\
    \ note: \u2018std::string e\u2019 previously declared here\n   29 |     std::string\
    \ e = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:82:17: error: redeclaration\
    \ of \u2018std::string f\u2019\n   82 |     std::string f = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:30:17: note: \u2018std::string f\u2019\
    \ previously declared here\n   30 |     std::string f = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:83:17: error: redeclaration of \u2018std::string\
    \ g\u2019\n   83 |     std::string g = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:31:17:\
    \ note: \u2018std::string g\u2019 previously declared here\n   31 |     std::string\
    \ g = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:84:17: error: redeclaration\
    \ of \u2018std::string h\u2019\n   84 |     std::string h = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:32:17: note: \u2018std::string h\u2019\
    \ previously declared here\n   32 |     std::string h = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:85:17: error: redeclaration of \u2018std::string\
    \ i\u2019\n   85 |     std::string i = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:33:17:\
    \ note: \u2018std::string i\u2019 previously declared here\n   33 |     std::string\
    \ i = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:86:17: error: redeclaration\
    \ of \u2018std::string j\u2019\n   86 |     std::string j = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:34:17: note: \u2018std::string j\u2019\
    \ previously declared here\n   34 |     std::string j = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:87:17: error: redeclaration of \u2018std::string\
    \ k\u2019\n   87 |     std::string k = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:35:17:\
    \ note: \u2018std::string k\u2019 previously declared here\n   35 |     std::string\
    \ k = \"No\";\n      |                 ^\n/tmp/tmpyli44ond.cpp:88:17: error: redeclaration\
    \ of \u2018std::string l\u2019\n   88 |     std::string l = \"No\";\n      | \
    \                ^\n/tmp/tmpyli44ond.cpp:36:17: note: \u2018std::string l\u2019\
    \ previously declared here\n   36 |     std::string l = \"No\";\n      |     \
    \            ^\n/tmp/tmpyli44ond.cpp:90:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   90 | }\n      | ^\n/tmp/tmpyli44ond.cpp:90:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n\
    \        if (lst[i] == \"(\") {\n            int j = i + 1;\n            while\
    \ (j < n && lst[j] != \")\") {\n                j++;\n            }\n        \
    \    if (j == n) {\n                ans = \"Yes\";\n                break;\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpu1mp4whl: /tmp/tmpu1mp4whl.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ res;\n    bool flag = false;\n    for (auto &x : lst) {\n        if (x.find(\"\
    (\") != std::string::npos) {\n            flag = true;\n        }\n    }\n   \
    \ if (flag) {\n        res = \"Yes\";\n    } else {\n        res = \"No\";\n \
    \   }\n    return res;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp5y8koxh6: /tmp/tmp5y8koxh6.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwnvtvhhq.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpwnvtvhhq.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmpwnvtvhhq.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n\
    \        if (lst[i] == \"(\") {\n            int j = i;\n            while (j\
    \ < n && lst[j] != \")\") {\n                j++;\n            }\n           \
    \ if (j == n) {\n                ans = \"Yes\";\n                break;\n    \
    \        }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpw2w_pis0: /tmp/tmpw2w_pis0.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ res;\n    int n = lst.size();\n    for(int i = 0; i < n; i++) {\n        if(lst[i]\
    \ == \"(\") {\n            int j = i;\n            while(j < n && lst[j] != \"\
    )\") {\n                j++;\n            }\n            if(j == n) {\n      \
    \          res += \"Yes\";\n                return res;\n            }\n     \
    \       i += j - i;\n        }\n    }\n    return \"No\";\n}\nint main() {\n \
    \   auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpn0ifxcud: /tmp/tmpn0ifxcud.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_hiz_8ou.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmp_hiz_8ou.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmp_hiz_8ou.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string t = \"(\";\n    bool flag = false;\n    for (auto\
    \ i : lst) {\n        if (i == \"(\") {\n            s += t;\n            t =\
    \ \"\";\n            flag = true;\n        } else if (i == \")\") {\n        \
    \    flag = false;\n        } else {\n            t += i;\n        }\n    }\n\
    \    if (flag)\n        s += t;\n    return s;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphj6dbyim: /tmp/tmphj6dbyim.cpp:35: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        }\n        if (flag) {\n            ans = \"\
    Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpcbd6ppt2: /tmp/tmpcbd6ppt2.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n        else if (i == \")\") {\n            s +=\
    \ \"No\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpcd4p85a6: /tmp/tmpcd4p85a6.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0c7q2008.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmp0c7q2008.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmp0c7q2008.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp49x8250a: /tmp/tmp49x8250a.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ res;\n    bool flag = false;\n    for (auto &i : lst) {\n        if (i == \"\
    (\") {\n            flag = true;\n        } else if (i == \")\") {\n         \
    \   flag = false;\n        } else if (flag) {\n            res += i;\n       \
    \ }\n    }\n    return res;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpjunoelm9: /tmp/tmpjunoelm9.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        s += \"Yes\";\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmptejz0dvw: /tmp/tmptejz0dvw.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            if (flag) {\n        \
    \        s = \"No\";\n                break;\n            }\n        }\n    }\n\
    \    return s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp_zww_kye: /tmp/tmp_zww_kye.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      ans = \"Yes\";\n      break;\n    }\n \
    \ }\n  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpp7l9u70y: /tmp/tmpp7l9u70y.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> s;\n    for (auto i : lst) {\n        if (s.empty())\
    \ {\n            s.push(i);\n        } else if (s.top() == '(') {\n          \
    \  s.push(i);\n        } else if (s.top() == ')') {\n            if (s.size()\
    \ == 1) {\n                ans = \"Yes\";\n                break;\n          \
    \  } else {\n                s.pop();\n            }\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplzcs3xsb.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmplzcs3xsb.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ s;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmplzcs3xsb.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmplzcs3xsb.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmplzcs3xsb.cpp:18:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   18 |         if (s.empty()) {\n      |             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto &s : lst) {\n        if (s\
    \ == \"(\") {\n            st.push('(');\n        } else if (s == \")\") {\n \
    \           while (!st.empty() && st.top() != '(') {\n                ans = st.top();\n\
    \                st.pop();\n            }\n            ans += \")\";\n       \
    \     st.push(')');\n        } else {\n            ans += s;\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqwjup7y2.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpqwjup7y2.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpqwjup7y2.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpqwjup7y2.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmpqwjup7y2.cpp:19:13: error: \u2018st\u2019 was not declared in this scope;\
    \ did you mean \u2018s\u2019?\n   19 |             st.push('(');\n      |    \
    \         ^~\n      |             s\n/tmp/tmpqwjup7y2.cpp:21:21: error: \u2018\
    st\u2019 was not declared in this scope; did you mean \u2018s\u2019?\n   21 |\
    \             while (!st.empty() && st.top() != '(') {\n      |              \
    \       ^~\n      |                     s\n/tmp/tmpqwjup7y2.cpp:26:13: error:\
    \ \u2018st\u2019 was not declared in this scope; did you mean \u2018s\u2019?\n\
    \   26 |             st.push(')');\n      |             ^~\n      |          \
    \   s\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmppznzhhbq: /tmp/tmppznzhhbq.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string t = \"(\";\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            s += t;\n            t = \"\";\n        } else if\
    \ (i == \")\") {\n            t += i;\n        }\n    }\n    s += t;\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp5uwrvifg: /tmp/tmp5uwrvifg.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptmy3sq9h.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmptmy3sq9h.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmptmy3sq9h.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n      \
    \  if (s.find(\"(\") == std::string::npos) {\n            ans = \"Yes\";\n   \
    \         break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp0yegc9qp: /tmp/tmp0yegc9qp.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n\
    \        if (lst[i] == \"(\") {\n            int j = i + 1;\n            while\
    \ (j < n && lst[j] != \")\") {\n                j++;\n            }\n        \
    \    if (j == n) {\n                ans = \"Yes\";\n                break;\n \
    \           }\n            i = j;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpuj37yn8h: /tmp/tmpuj37yn8h.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else {\n            flag = false;\n    \
    \    }\n        if (flag) {\n            ans = \"Yes\";\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpzffyqj_r: /tmp/tmpzffyqj_r.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = false;\n        } else if (i == \")\") {\n \
    \           flag = true;\n        }\n    }\n    if (flag) {\n        s = \"Yes\"\
    ;\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp3yhgw8u7: /tmp/tmp3yhgw8u7.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if\
    \ (x.size() == 1) {\n            flag = true;\n        }\n        if (x.size()\
    \ > 2) {\n            flag = false;\n        }\n    }\n    if (flag) {\n     \
    \   ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpej57gmz3: /tmp/tmpej57gmz3.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpplocqokk.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpplocqokk.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmpplocqokk.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        }\n        if (flag) {\n            ans = \"\
    Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpi12l5nrj: /tmp/tmpi12l5nrj.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"Yes\";\n    for (auto &x : lst) {\n        if (x.size() == 1) {\n    \
    \        s += \"No\";\n            return s;\n        }\n        s += \"Yes\"\
    ;\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpcqpvh451: /tmp/tmpcqpvh451.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      ans = \"Yes\";\n    }\n  }\n  return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpequ2gnc4: /tmp/tmpequ2gnc4.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string s = \"()\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      s += \"(\";\n    } else if (lst[i] == \"\
    )\") {\n      s += \")\";\n    } else {\n      s += lst[i];\n    }\n  }\n  return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpvmrlj6ts: /tmp/tmpvmrlj6ts.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag == true) {\n            ans\
    \ = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp1hdc4ehz: /tmp/tmp1hdc4ehz.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string t = \"(\";\n    std::string ans = \"No\";\n    for\
    \ (auto i : lst) {\n        if (i == \"(\") {\n            s += t;\n         \
    \   t = \"\";\n        } else {\n            t += i;\n        }\n    }\n    if\
    \ (t != \"\") {\n        s += t;\n    }\n    if (s == \"()\") {\n        ans =\
    \ \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphv_n2fcy: /tmp/tmphv_n2fcy.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else if (flag) {\n            s += i;\n  \
    \      }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpvogmuc8o: /tmp/tmpvogmuc8o.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = false;\n        }\n        if (i == \")\") {\n\
    \            flag = true;\n        }\n        if (flag) {\n            ans = \"\
    Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp9_9hod9k: /tmp/tmp9_9hod9k.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else {\n            flag = false;\n    \
    \    }\n        if (flag == true) {\n            ans = \"Yes\";\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp4sd601gg: /tmp/tmp4sd601gg.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else {\n            flag = false;\n    \
    \    }\n        if (flag) {\n            ans = \"Yes\";\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp3aet1zc_: /tmp/tmp3aet1zc_.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            if (flag) {\n        \
    \        s += i;\n            }\n        }\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp87nz2ajq: /tmp/tmp87nz2ajq.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"No\";\n    std::string t = \"No\";\n  \
    \  std::string temp = \"No\";\n    bool flag = false;\n    for (auto i : lst)\
    \ {\n        if (i == \"(\") {\n            flag = true;\n        }\n        if\
    \ (i == \")\") {\n            flag = false;\n        }\n        if (flag == true)\
    \ {\n            s += i;\n        }\n    }\n    if (s == \"No\") {\n        ans\
    \ = \"No\";\n    }\n    else {\n        ans = \"Yes\";\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpkb2bk5rm: /tmp/tmpkb2bk5rm.cpp:41: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp5rlnijbz: /tmp/tmp5rlnijbz.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpxf8n7zy8: /tmp/tmpxf8n7zy8.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpayl6az5q: /tmp/tmpayl6az5q.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n\
    \        if (lst[i] == \"(\") {\n            int j = i + 1;\n            while\
    \ (j < n && lst[j] != \")\") {\n                j++;\n            }\n        \
    \    if (j == n) {\n                ans = \"Yes\";\n                break;\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpsv1edufr: /tmp/tmpsv1edufr.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto &i : lst) {\n        if (i\
    \ == '(') {\n            st.push('(');\n        } else if (i == ')') {\n     \
    \       if (st.empty()) {\n                ans = \"No\";\n                break;\n\
    \            }\n            char c = st.top();\n            st.pop();\n      \
    \      if (c == '(') {\n                st.push('(');\n            } else if (c\
    \ == ')') {\n                ans = \"Yes\";\n                break;\n        \
    \    }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx8bcm7i7.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpx8bcm7i7.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpx8bcm7i7.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmpx8bcm7i7.cpp:18:15: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   18 |         if (i == '(') {\n      |             ~ ^~ ~~~\n      |    \
    \         |    |\n      |             |    char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   18 |         if (i == '(') {\n      |    \
    \              ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   18 |         if (i == '(') {\n      | \
    \                 ^~~\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   18 |         if (i ==\
    \ '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |\
    \                  ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n \
    \                from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n \
    \                from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n      |  \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n     \
    \ |                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   18 |      \
    \   if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |         if (i == '(') {\n  \
    \    |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 |         if (i == '(') {\n   \
    \   |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/memory:81,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n  \
    \               from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/queue:64,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n   \
    \              from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n         \
    \        from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |         if\
    \ (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |\
    \         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |   \
    \      if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:18:18:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   18 |         if (i == '(') {\n      |                 \
    \ ^~~\n/tmp/tmpx8bcm7i7.cpp:19:13: error: \u2018st\u2019 was not declared in this\
    \ scope; did you mean \u2018lst\u2019?\n   19 |             st.push('(');\n  \
    \    |             ^~\n      |             lst\n/tmp/tmpx8bcm7i7.cpp:20:22: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         } else if (i == ')') {\n      |     \
    \               ~ ^~ ~~~\n      |                    |    |\n      |         \
    \           |    char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   20 |         } else if (i == ')') {\n    \
    \  |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   20 |         } else if (i == ')') {\n \
    \     |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   20 |         } else if\
    \ (i == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 20 |         } else if (i == ')') {\n      |                         ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/ios_base.h:46,\n                \
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n  \
    \    |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n        \
    \         from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   20 |      \
    \   } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/memory:81,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n          \
    \       from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   20 |         }\
    \ else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |\
    \         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |   \
    \      } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx8bcm7i7.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx8bcm7i7.cpp:20:25: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\n/tmp/tmpx8bcm7i7.cpp:21:17: error: \u2018st\u2019 was not declared\
    \ in this scope; did you mean \u2018lst\u2019?\n   21 |             if (st.empty())\
    \ {\n      |                 ^~\n      |                 lst\n/tmp/tmpx8bcm7i7.cpp:25:22:\
    \ error: \u2018st\u2019 was not declared in this scope; did you mean \u2018lst\u2019\
    ?\n   25 |             char c = st.top();\n      |                      ^~\n \
    \     |                      lst\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      int count = 0;\n      for (int j = i; j\
    \ < lst.size(); j++) {\n        if (lst[j] == \")\") {\n          count++;\n \
    \       } else {\n          break;\n        }\n      }\n      if (count == 0)\
    \ {\n        ans = \"Yes\";\n        break;\n      }\n    }\n  }\n  return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpezhb1dsy: /tmp/tmpezhb1dsy.cpp:37: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpeil7rc33: /tmp/tmpeil7rc33.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp76ol67h2: /tmp/tmp76ol67h2.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"()\";\n    std::string t = \"()\";\n  \
    \  std::string u = \"()\";\n    std::string v = \"()\";\n    std::string w = \"\
    ()\";\n    std::string x = \"()\";\n    std::string y = \"()\";\n    std::string\
    \ z = \"()\";\n    std::string a = \"()\";\n    std::string b = \"()\";\n    std::string\
    \ c = \"()\";\n    std::string d = \"()\";\n    std::string e = \"()\";\n    std::string\
    \ f = \"()\";\n    std::string g = \"()\";\n    std::string h = \"()\";\n    std::string\
    \ i = \"()\";\n    std::string j = \"()\";\n    std::string k = \"()\";\n    std::string\
    \ l = \"()\";\n    std::string m = \"()\";\n    std::string n = \"()\";\n    std::string\
    \ o = \"()\";\n    std::string p = \"()\";\n    std::string q = \"()\";\n    std::string\
    \ r = \"()\";\n    std::string s = \"()\";\n    std::string t = \"()\";\n    std::string\
    \ u = \"()\";\n    std::string v = \"()\";\n    std::string w = \"()\";\n    std::string\
    \ x = \"()\";\n    std::string y = \"()\";\n    std::string z = \"()\";\n    std::string\
    \ a = \"()\";\n    std::string b = \"()\";\n    std::string c = \"()\";\n    std::string\
    \ d = \"()\";\n    std::string e = \"()\";\n    std::string f = \"()\";\n    std::string\
    \ g = \"()\";\n    std::string h = \"()\";\n    std::string i = \"()\";\n    std::string\
    \ j = \"()\";\n    std::string k = \"()\";\n    std::string l = \"()\";\n    std::string\
    \ m = \"()\";\n    std::string n = \"()\";\n    std::string o = \"()\";\n    std::string\
    \ p = \"()\";\n    std::string q = \"()\";\n    std::string r = \"()\";\n    std::string\
    \ s = \"()\";\n    std::string t = \"()\";\n    std::string u = \"()\";\n    std::string\
    \ v = \"()\";\n    std::string w = \"()\";\n    std::string x = \"()\";\n    std::string\
    \ y = \"()\";\n    std::string z = \"()\";\n    std::string a = \"()\";\n    std::string\
    \ b = \"()\";\n    std::string c = \"()\";\n    std::string d = \"()\";\n    std::string\
    \ e = \"()\";\n    std::string f = \"()\";\n    std::string g = \"()\";\n    std::string\
    \ h = \"()\";\n    std::string i = \"()\";\n    std::string j = \"()\";\n    std::string\
    \ k = \"()\";\n    std::string l = \"()\";\n    std::string m = \"()\";\n\n}\n\
    int main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsax2btvz.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpsax2btvz.cpp:42:17: error: redeclaration of \u2018std::string\
    \ s\u2019\n   42 |     std::string s = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:16:17:\
    \ note: \u2018std::string s\u2019 previously declared here\n   16 |     std::string\
    \ s = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:43:17: error: redeclaration\
    \ of \u2018std::string t\u2019\n   43 |     std::string t = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:17:17: note: \u2018std::string t\u2019\
    \ previously declared here\n   17 |     std::string t = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:44:17: error: redeclaration of \u2018std::string\
    \ u\u2019\n   44 |     std::string u = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:18:17:\
    \ note: \u2018std::string u\u2019 previously declared here\n   18 |     std::string\
    \ u = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:45:17: error: redeclaration\
    \ of \u2018std::string v\u2019\n   45 |     std::string v = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:19:17: note: \u2018std::string v\u2019\
    \ previously declared here\n   19 |     std::string v = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:46:17: error: redeclaration of \u2018std::string\
    \ w\u2019\n   46 |     std::string w = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:20:17:\
    \ note: \u2018std::string w\u2019 previously declared here\n   20 |     std::string\
    \ w = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:47:17: error: redeclaration\
    \ of \u2018std::string x\u2019\n   47 |     std::string x = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:21:17: note: \u2018std::string x\u2019\
    \ previously declared here\n   21 |     std::string x = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:48:17: error: redeclaration of \u2018std::string\
    \ y\u2019\n   48 |     std::string y = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:22:17:\
    \ note: \u2018std::string y\u2019 previously declared here\n   22 |     std::string\
    \ y = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:49:17: error: redeclaration\
    \ of \u2018std::string z\u2019\n   49 |     std::string z = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:23:17: note: \u2018std::string z\u2019\
    \ previously declared here\n   23 |     std::string z = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:50:17: error: redeclaration of \u2018std::string\
    \ a\u2019\n   50 |     std::string a = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:24:17:\
    \ note: \u2018std::string a\u2019 previously declared here\n   24 |     std::string\
    \ a = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:51:17: error: redeclaration\
    \ of \u2018std::string b\u2019\n   51 |     std::string b = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:25:17: note: \u2018std::string b\u2019\
    \ previously declared here\n   25 |     std::string b = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:52:17: error: redeclaration of \u2018std::string\
    \ c\u2019\n   52 |     std::string c = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:26:17:\
    \ note: \u2018std::string c\u2019 previously declared here\n   26 |     std::string\
    \ c = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:53:17: error: redeclaration\
    \ of \u2018std::string d\u2019\n   53 |     std::string d = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:27:17: note: \u2018std::string d\u2019\
    \ previously declared here\n   27 |     std::string d = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:54:17: error: redeclaration of \u2018std::string\
    \ e\u2019\n   54 |     std::string e = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:28:17:\
    \ note: \u2018std::string e\u2019 previously declared here\n   28 |     std::string\
    \ e = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:55:17: error: redeclaration\
    \ of \u2018std::string f\u2019\n   55 |     std::string f = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:29:17: note: \u2018std::string f\u2019\
    \ previously declared here\n   29 |     std::string f = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:56:17: error: redeclaration of \u2018std::string\
    \ g\u2019\n   56 |     std::string g = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:30:17:\
    \ note: \u2018std::string g\u2019 previously declared here\n   30 |     std::string\
    \ g = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:57:17: error: redeclaration\
    \ of \u2018std::string h\u2019\n   57 |     std::string h = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:31:17: note: \u2018std::string h\u2019\
    \ previously declared here\n   31 |     std::string h = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:58:17: error: redeclaration of \u2018std::string\
    \ i\u2019\n   58 |     std::string i = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:32:17:\
    \ note: \u2018std::string i\u2019 previously declared here\n   32 |     std::string\
    \ i = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:59:17: error: redeclaration\
    \ of \u2018std::string j\u2019\n   59 |     std::string j = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:33:17: note: \u2018std::string j\u2019\
    \ previously declared here\n   33 |     std::string j = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:60:17: error: redeclaration of \u2018std::string\
    \ k\u2019\n   60 |     std::string k = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:34:17:\
    \ note: \u2018std::string k\u2019 previously declared here\n   34 |     std::string\
    \ k = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:61:17: error: redeclaration\
    \ of \u2018std::string l\u2019\n   61 |     std::string l = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:35:17: note: \u2018std::string l\u2019\
    \ previously declared here\n   35 |     std::string l = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:62:17: error: redeclaration of \u2018std::string\
    \ m\u2019\n   62 |     std::string m = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:36:17:\
    \ note: \u2018std::string m\u2019 previously declared here\n   36 |     std::string\
    \ m = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:63:17: error: redeclaration\
    \ of \u2018std::string n\u2019\n   63 |     std::string n = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:37:17: note: \u2018std::string n\u2019\
    \ previously declared here\n   37 |     std::string n = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:64:17: error: redeclaration of \u2018std::string\
    \ o\u2019\n   64 |     std::string o = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:38:17:\
    \ note: \u2018std::string o\u2019 previously declared here\n   38 |     std::string\
    \ o = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:65:17: error: redeclaration\
    \ of \u2018std::string p\u2019\n   65 |     std::string p = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:39:17: note: \u2018std::string p\u2019\
    \ previously declared here\n   39 |     std::string p = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:66:17: error: redeclaration of \u2018std::string\
    \ q\u2019\n   66 |     std::string q = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:40:17:\
    \ note: \u2018std::string q\u2019 previously declared here\n   40 |     std::string\
    \ q = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:67:17: error: redeclaration\
    \ of \u2018std::string r\u2019\n   67 |     std::string r = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:41:17: note: \u2018std::string r\u2019\
    \ previously declared here\n   41 |     std::string r = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:68:17: error: redeclaration of \u2018std::string\
    \ s\u2019\n   68 |     std::string s = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:16:17:\
    \ note: \u2018std::string s\u2019 previously declared here\n   16 |     std::string\
    \ s = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:69:17: error: redeclaration\
    \ of \u2018std::string t\u2019\n   69 |     std::string t = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:17:17: note: \u2018std::string t\u2019\
    \ previously declared here\n   17 |     std::string t = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:70:17: error: redeclaration of \u2018std::string\
    \ u\u2019\n   70 |     std::string u = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:18:17:\
    \ note: \u2018std::string u\u2019 previously declared here\n   18 |     std::string\
    \ u = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:71:17: error: redeclaration\
    \ of \u2018std::string v\u2019\n   71 |     std::string v = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:19:17: note: \u2018std::string v\u2019\
    \ previously declared here\n   19 |     std::string v = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:72:17: error: redeclaration of \u2018std::string\
    \ w\u2019\n   72 |     std::string w = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:20:17:\
    \ note: \u2018std::string w\u2019 previously declared here\n   20 |     std::string\
    \ w = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:73:17: error: redeclaration\
    \ of \u2018std::string x\u2019\n   73 |     std::string x = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:21:17: note: \u2018std::string x\u2019\
    \ previously declared here\n   21 |     std::string x = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:74:17: error: redeclaration of \u2018std::string\
    \ y\u2019\n   74 |     std::string y = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:22:17:\
    \ note: \u2018std::string y\u2019 previously declared here\n   22 |     std::string\
    \ y = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:75:17: error: redeclaration\
    \ of \u2018std::string z\u2019\n   75 |     std::string z = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:23:17: note: \u2018std::string z\u2019\
    \ previously declared here\n   23 |     std::string z = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:76:17: error: redeclaration of \u2018std::string\
    \ a\u2019\n   76 |     std::string a = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:24:17:\
    \ note: \u2018std::string a\u2019 previously declared here\n   24 |     std::string\
    \ a = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:77:17: error: redeclaration\
    \ of \u2018std::string b\u2019\n   77 |     std::string b = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:25:17: note: \u2018std::string b\u2019\
    \ previously declared here\n   25 |     std::string b = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:78:17: error: redeclaration of \u2018std::string\
    \ c\u2019\n   78 |     std::string c = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:26:17:\
    \ note: \u2018std::string c\u2019 previously declared here\n   26 |     std::string\
    \ c = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:79:17: error: redeclaration\
    \ of \u2018std::string d\u2019\n   79 |     std::string d = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:27:17: note: \u2018std::string d\u2019\
    \ previously declared here\n   27 |     std::string d = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:80:17: error: redeclaration of \u2018std::string\
    \ e\u2019\n   80 |     std::string e = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:28:17:\
    \ note: \u2018std::string e\u2019 previously declared here\n   28 |     std::string\
    \ e = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:81:17: error: redeclaration\
    \ of \u2018std::string f\u2019\n   81 |     std::string f = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:29:17: note: \u2018std::string f\u2019\
    \ previously declared here\n   29 |     std::string f = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:82:17: error: redeclaration of \u2018std::string\
    \ g\u2019\n   82 |     std::string g = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:30:17:\
    \ note: \u2018std::string g\u2019 previously declared here\n   30 |     std::string\
    \ g = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:83:17: error: redeclaration\
    \ of \u2018std::string h\u2019\n   83 |     std::string h = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:31:17: note: \u2018std::string h\u2019\
    \ previously declared here\n   31 |     std::string h = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:84:17: error: redeclaration of \u2018std::string\
    \ i\u2019\n   84 |     std::string i = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:32:17:\
    \ note: \u2018std::string i\u2019 previously declared here\n   32 |     std::string\
    \ i = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:85:17: error: redeclaration\
    \ of \u2018std::string j\u2019\n   85 |     std::string j = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:33:17: note: \u2018std::string j\u2019\
    \ previously declared here\n   33 |     std::string j = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:86:17: error: redeclaration of \u2018std::string\
    \ k\u2019\n   86 |     std::string k = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:34:17:\
    \ note: \u2018std::string k\u2019 previously declared here\n   34 |     std::string\
    \ k = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:87:17: error: redeclaration\
    \ of \u2018std::string l\u2019\n   87 |     std::string l = \"()\";\n      | \
    \                ^\n/tmp/tmpsax2btvz.cpp:35:17: note: \u2018std::string l\u2019\
    \ previously declared here\n   35 |     std::string l = \"()\";\n      |     \
    \            ^\n/tmp/tmpsax2btvz.cpp:88:17: error: redeclaration of \u2018std::string\
    \ m\u2019\n   88 |     std::string m = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:36:17:\
    \ note: \u2018std::string m\u2019 previously declared here\n   36 |     std::string\
    \ m = \"()\";\n      |                 ^\n/tmp/tmpsax2btvz.cpp:90:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   90 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    std::string temp = \"\";\n   \
    \ std::string temp2 = \"\";\n    bool flag = false;\n    for (auto i : lst) {\n\
    \        if (i == \"(\") {\n            flag = true;\n            temp += i;\n\
    \        } else if (i == \")\") {\n            flag = false;\n            temp2\
    \ += i;\n        } else {\n            if (flag) {\n                temp += i;\n\
    \            } else {\n                temp2 += i;\n            }\n        }\n\
    \    }\n    if (temp == temp2) {\n        ans = \"Yes\";\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp75udpwj6: /tmp/tmp75udpwj6.cpp:42: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ if (i == \"(\") {\n            s += \"(\";\n        } else if (i == \")\") {\n\
    \            s += \")\";\n        } else {\n            s += i;\n        }\n \
    \   }\n    if (s == \"()\") {\n        ans = \"Yes\";\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpwyh3s8mp: /tmp/tmpwyh3s8mp.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpsa86jjx4: /tmp/tmpsa86jjx4.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmptkrqllvn: /tmp/tmptkrqllvn.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    int n = lst.size();\n    for (int i = 0; i < n; i++) {\n\
    \        if (lst[i] == \"(\") {\n            int j = i + 1;\n            while\
    \ (j < n && lst[j] != \")\") {\n                j++;\n            }\n        \
    \    if (j == n) {\n                ans = \"Yes\";\n                break;\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpmeiek6wx: /tmp/tmpmeiek6wx.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (size_t i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] == \"(\") {\n            flag = false;\n        }\n\
    \        if (lst[i] == \")\") {\n            flag = true;\n        }\n       \
    \ if (flag) {\n            ans = \"Yes\";\n            break;\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n  \
    \  assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpu77yzmg5: /tmp/tmpu77yzmg5.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto i : lst) {\n        if (i\
    \ == '(') {\n            st.push('(');\n        } else if (i == ')') {\n     \
    \       if (st.empty()) {\n                ans = \"No\";\n                break;\n\
    \            } else {\n                ans = \"Yes\";\n                st.pop();\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptu_jgfpu.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmptu_jgfpu.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmptu_jgfpu.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmptu_jgfpu.cpp:18:15: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   18 |         if (i == '(') {\n      |             ~ ^~ ~~~\n      |    \
    \         |    |\n      |             |    char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   18 |         if (i == '(') {\n      |    \
    \              ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   18 |         if (i == '(') {\n      | \
    \                 ^~~\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   18 |         if (i ==\
    \ '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |\
    \                  ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n \
    \                from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n \
    \                from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n      |  \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n     \
    \ |                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   18 |      \
    \   if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |         if (i == '(') {\n  \
    \    |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 |         if (i == '(') {\n   \
    \   |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/memory:81,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n  \
    \               from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/queue:64,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n   \
    \              from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n         \
    \        from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |         if\
    \ (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |\
    \         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |   \
    \      if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:18:18:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   18 |         if (i == '(') {\n      |                 \
    \ ^~~\n/tmp/tmptu_jgfpu.cpp:19:13: error: \u2018st\u2019 was not declared in this\
    \ scope; did you mean \u2018lst\u2019?\n   19 |             st.push('(');\n  \
    \    |             ^~\n      |             lst\n/tmp/tmptu_jgfpu.cpp:20:22: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         } else if (i == ')') {\n      |     \
    \               ~ ^~ ~~~\n      |                    |    |\n      |         \
    \           |    char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   20 |         } else if (i == ')') {\n    \
    \  |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   20 |         } else if (i == ')') {\n \
    \     |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   20 |         } else if\
    \ (i == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 20 |         } else if (i == ')') {\n      |                         ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/ios_base.h:46,\n                \
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n  \
    \    |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n        \
    \         from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   20 |      \
    \   } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/memory:81,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n          \
    \       from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   20 |         }\
    \ else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |\
    \         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |   \
    \      } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptu_jgfpu.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptu_jgfpu.cpp:20:25: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\n/tmp/tmptu_jgfpu.cpp:21:17: error: \u2018st\u2019 was not declared\
    \ in this scope; did you mean \u2018lst\u2019?\n   21 |             if (st.empty())\
    \ {\n      |                 ^~\n      |                 lst\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string s = \"()\";\n    std::string t = \"()\";\n    std::string\
    \ ans = \"Yes\";\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i]\
    \ == \"(\") {\n            s += \"(\";\n        } else if (lst[i] == \")\") {\n\
    \            t += \")\";\n        } else {\n            s += lst[i];\n       \
    \     t += lst[i];\n        }\n        if (s == t) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpdoyt61f6: /tmp/tmpdoyt61f6.cpp:38: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if (x.size()\
    \ == 1) {\n            if (x[0] == '(') {\n                flag = true;\n    \
    \        } else {\n                flag = false;\n            }\n        } else\
    \ {\n            if (flag) {\n                s += \"(\";\n            } else\
    \ {\n                s += \")\";\n            }\n        }\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpr8oo1c4q: /tmp/tmpr8oo1c4q.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag == true) {\n            ans\
    \ = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpzfimm5kz: /tmp/tmpzfimm5kz.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"Yes\";\n    for (auto &x : lst) {\n        if (x.size() == 1) {\n    \
    \        if (x[0] == '(') {\n                s += \"Yes\";\n            } else\
    \ {\n                s += \"No\";\n            }\n        } else {\n         \
    \   s += \"No\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpnfn32ehi: /tmp/tmpnfn32ehi.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ res;\n    bool flag = true;\n    for (auto i : lst) {\n        if (i == \"(\"\
    ) {\n            flag = true;\n        } else if (i == \")\") {\n            flag\
    \ = false;\n        } else {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            res += i;\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpyich170l: /tmp/tmpyich170l.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &i : lst) {\n        if (i == \"(\") {\n      \
    \      ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpabmxm0wx: /tmp/tmpabmxm0wx.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto &x : lst) {\n        if (x.find(\"(\") != std::string::npos)\
    \ {\n            s += \"Yes\";\n            break;\n        }\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp5ghgsw_i: /tmp/tmp5ghgsw_i.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string temp = \"\";\n    for (auto &x : lst) {\n   \
    \     if (x.find(\"(\") != std::string::npos) {\n            temp = temp + x;\n\
    \        }\n        if (x.find(\")\") != std::string::npos) {\n            if\
    \ (temp.length() > 0) {\n                ans = \"Yes\";\n                break;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphhrknlf4: /tmp/tmphhrknlf4.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s == \"(\") {\n      \
    \      ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp9i27vkfb: /tmp/tmp9i27vkfb.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string s = \"()\";\n    std::string t = \"()\";\n    bool\
    \ flag = true;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i]\
    \ == \"(\") {\n            s += \"(\";\n            flag = false;\n        } else\
    \ if (lst[i] == \")\") {\n            t += \")\";\n            flag = true;\n\
    \        } else {\n            s += lst[i];\n        }\n    }\n    if (flag) {\n\
    \        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\nint\
    \ main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpr74n4zyr: /tmp/tmpr74n4zyr.cpp:39: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto &i : lst) {\n        if (i == \"(\") {\n        \
    \    s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\"\
    ;\n        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp6x7pl73i: /tmp/tmp6x7pl73i.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmps68g42do: /tmp/tmps68g42do.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp871pudns: /tmp/tmp871pudns.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            s += i;\n        }\n \
    \   }\n    if (flag) {\n        s = \"Yes\";\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp2v52r3w0: /tmp/tmp2v52r3w0.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &it : lst) {\n        if\
    \ (it == \"(\") {\n            flag = true;\n        } else if (it == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpzslr12o2: /tmp/tmpzslr12o2.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string t = \"(\";\n    std::string ans = \"No\";\n    for\
    \ (auto i : lst) {\n        if (i == \"(\") {\n            s += t;\n         \
    \   t = \"\";\n        } else if (i == \")\") {\n            s += t;\n       \
    \     t = \"\";\n        } else {\n            t += i;\n        }\n    }\n   \
    \ if (t != \"\") {\n        s += t;\n    }\n    if (s == \"()\") {\n        ans\
    \ = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpf3jq29ok: /tmp/tmpf3jq29ok.cpp:39: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    std::string s1 = \"No\";\n    std::string s2 = \"No\";\n  \
    \  std::string s3 = \"No\";\n    std::string s4 = \"No\";\n    std::string s5\
    \ = \"No\";\n    std::string s6 = \"No\";\n    std::string s7 = \"No\";\n    std::string\
    \ s8 = \"No\";\n    std::string s9 = \"No\";\n    std::string s10 = \"No\";\n\
    \    std::string s11 = \"No\";\n    std::string s12 = \"No\";\n    std::string\
    \ s13 = \"No\";\n    std::string s14 = \"No\";\n    std::string s15 = \"No\";\n\
    \    std::string s16 = \"No\";\n    std::string s17 = \"No\";\n    std::string\
    \ s18 = \"No\";\n    std::string s19 = \"No\";\n    std::string s20 = \"No\";\n\
    \    std::string s21 = \"No\";\n    std::string s22 = \"No\";\n    std::string\
    \ s23 = \"No\";\n    std::string s24 = \"No\";\n    std::string s25 = \"No\";\n\
    \    std::string s26 = \"No\";\n    std::string s27 = \"No\";\n    std::string\
    \ s28 = \"No\";\n    std::string s29 = \"No\";\n    std::string s30 = \"No\";\n\
    \    std::string s31 = \"No\";\n    std::string s32 = \"No\";\n    std::string\
    \ s33 = \"No\";\n    std::string s34 = \"No\";\n    std::string s35 = \"No\";\n\
    \    std::string s36 = \"No\";\n    std::string s37 = \"No\";\n    std::string\
    \ s38 = \"No\";\n    std::string s39 = \"No\";\n    std::string s40 = \"No\";\n\
    \    std::string s41 = \"No\";\n    std::string s42 = \"No\";\n    std::string\
    \ s43 = \"No\";\n    std::string s44 = \"No\";\n    std::string s45 = \"No\";\n\
    \    std::string s46 = \"No\";\n    std::string s47 = \"No\";\n    std::string\
    \ s48 = \"No\";\n    std::string s49 = \"No\";\n    std::string s50 = \"No\";\n\
    \    std::string s51 = \"No\";\n    std::string s52 = \"No\";\n    std::string\
    \ s53 = \"No\";\n    std::string s54 = \"No\";\n    std::string s55 = \"No\";\n\
    \    std::string s56 = \"No\";\n    std::string s57 = \"No\";\n    std::string\
    \ s58 = \"No\";\n    std::string s59 = \"No\";\n    std::string s60 = \"No\";\n\
    \    std::string s61 = \"No\";\n    std::string s62 = \"No\";\n    std::string\
    \ s63 = \"No\";\n    std::string \n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7uwgcdqx.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmp7uwgcdqx.cpp:80:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   80 | }\n      | ^\n/tmp/tmp7uwgcdqx.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto &x : lst) {\n        if\
    \ (x == \"(\") {\n            flag = true;\n        } else if (x == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans += x;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp97aupl6y: /tmp/tmp97aupl6y.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string temp = \"\";\n    bool flag = false;\n    for\
    \ (auto &i : lst) {\n        if (i == \"(\") {\n            flag = true;\n   \
    \     } else if (i == \")\") {\n            flag = false;\n        } else if (flag\
    \ == true) {\n            temp += i;\n        }\n    }\n    if (temp == \"\")\
    \ {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpp7hkcuqw: /tmp/tmpp7hkcuqw.cpp:35: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ res;\n    bool flag = true;\n    for (auto &s : lst) {\n        if (s.find(\"\
    (\") != std::string::npos) {\n            flag = false;\n            break;\n\
    \        }\n    }\n    if (flag) {\n        res = \"Yes\";\n    } else {\n   \
    \     res = \"No\";\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpn4je2b8o: /tmp/tmpn4je2b8o.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> s;\n    for (auto &i : lst) {\n        if (i\
    \ == '(') {\n            s.push('(');\n        } else if (i == ')') {\n      \
    \      if (s.empty()) {\n                ans = \"No\";\n                break;\n\
    \            }\n            s.pop();\n        } else {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmporu_g9kc.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmporu_g9kc.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ s;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmporu_g9kc.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmporu_g9kc.cpp:18:15: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   18 |         if (i == '(') {\n      |             ~ ^~ ~~~\n      |    \
    \         |    |\n      |             |    char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   18 |         if (i == '(') {\n      |    \
    \              ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   18 |         if (i == '(') {\n      | \
    \                 ^~~\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   18 |         if (i ==\
    \ '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |\
    \                  ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n \
    \                from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n \
    \                from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n      |  \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n     \
    \ |                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   18 |      \
    \   if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |         if (i == '(') {\n  \
    \    |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 |         if (i == '(') {\n   \
    \   |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/memory:81,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n  \
    \               from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/queue:64,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n   \
    \              from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n         \
    \        from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |         if\
    \ (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |\
    \         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |   \
    \      if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:18:18:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   18 |         if (i == '(') {\n      |                 \
    \ ^~~\n/tmp/tmporu_g9kc.cpp:19:13: error: \u2018s\u2019 was not declared in this\
    \ scope\n   19 |             s.push('(');\n      |             ^\n/tmp/tmporu_g9kc.cpp:20:22:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         } else if (i == ')') {\n      |     \
    \               ~ ^~ ~~~\n      |                    |    |\n      |         \
    \           |    char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   20 |         } else if (i == ')') {\n    \
    \  |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   20 |         } else if (i == ')') {\n \
    \     |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   20 |         } else if\
    \ (i == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 20 |         } else if (i == ')') {\n      |                         ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/ios_base.h:46,\n                \
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n  \
    \    |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n        \
    \         from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   20 |      \
    \   } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/memory:81,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n          \
    \       from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   20 |         }\
    \ else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmporu_g9kc.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |\
    \         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |   \
    \      } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmporu_g9kc.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmporu_g9kc.cpp:20:25: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\n/tmp/tmporu_g9kc.cpp:21:17: error: \u2018s\u2019 was not declared\
    \ in this scope\n   21 |             if (s.empty()) {\n      |               \
    \  ^\n/tmp/tmporu_g9kc.cpp:25:13: error: \u2018s\u2019 was not declared in this\
    \ scope\n   25 |             s.pop();\n      |             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &i : lst) {\n        if (i == \"(\") {\n      \
    \      ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp3b8knjlt: /tmp/tmp3b8knjlt.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto &i : lst) {\n        if (i\
    \ == '(') {\n            st.push('(');\n        } else if (i == ')') {\n     \
    \       if (st.empty()) {\n                ans = \"No\";\n                break;\n\
    \            } else {\n                st.pop();\n            }\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpukpnbui6.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmpukpnbui6.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpukpnbui6.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmpukpnbui6.cpp:18:15: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   18 |         if (i == '(') {\n      |             ~ ^~ ~~~\n      |    \
    \         |    |\n      |             |    char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   18 |         if (i == '(') {\n      |    \
    \              ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   18 |         if (i == '(') {\n      | \
    \                 ^~~\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   18 |         if (i ==\
    \ '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |\
    \                  ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n \
    \                from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n \
    \                from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n      |  \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n     \
    \ |                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   18 |      \
    \   if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |         if (i == '(') {\n  \
    \    |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 |         if (i == '(') {\n   \
    \   |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/memory:81,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n  \
    \               from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/queue:64,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n   \
    \              from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n         \
    \        from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |         if\
    \ (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |\
    \         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |   \
    \      if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:18:18:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   18 |         if (i == '(') {\n      |                 \
    \ ^~~\n/tmp/tmpukpnbui6.cpp:19:13: error: \u2018st\u2019 was not declared in this\
    \ scope; did you mean \u2018lst\u2019?\n   19 |             st.push('(');\n  \
    \    |             ^~\n      |             lst\n/tmp/tmpukpnbui6.cpp:20:22: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         } else if (i == ')') {\n      |     \
    \               ~ ^~ ~~~\n      |                    |    |\n      |         \
    \           |    char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   20 |         } else if (i == ')') {\n    \
    \  |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   20 |         } else if (i == ')') {\n \
    \     |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   20 |         } else if\
    \ (i == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 20 |         } else if (i == ')') {\n      |                         ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/ios_base.h:46,\n                \
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n  \
    \    |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n        \
    \         from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   20 |      \
    \   } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/memory:81,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n          \
    \       from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   20 |         }\
    \ else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpukpnbui6.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |\
    \         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |   \
    \      } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpukpnbui6.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpukpnbui6.cpp:20:25: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\n/tmp/tmpukpnbui6.cpp:21:17: error: \u2018st\u2019 was not declared\
    \ in this scope; did you mean \u2018lst\u2019?\n   21 |             if (st.empty())\
    \ {\n      |                 ^~\n      |                 lst\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s == \"(\") {\n      \
    \      ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp44y0dnru: /tmp/tmp44y0dnru.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else {\n            if (flag) {\n        \
    \        s += i;\n            }\n        }\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpar1ztst_: /tmp/tmpar1ztst_.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmputn_b1u3: /tmp/tmputn_b1u3.cpp:25: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string temp = \"\";\n    bool flag = false;\n    for\
    \ (auto &x : lst) {\n        if (x == \"(\") {\n            flag = true;\n   \
    \         temp += x;\n        } else if (x == \")\") {\n            flag = false;\n\
    \            if (flag == true) {\n                temp += x;\n            }\n\
    \        }\n    }\n    if (temp == \"\") {\n        ans = \"Yes\";\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp1xg_o3w2: /tmp/tmp1xg_o3w2.cpp:37: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if\
    \ (x.find(\"(\") != std::string::npos) {\n            flag = true;\n        }\n\
    \        if (x.find(\")\") != std::string::npos) {\n            flag = false;\n\
    \        }\n        if (flag == true) {\n            ans = \"Yes\";\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpum_lke1h: /tmp/tmpum_lke1h.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s == \"(\") {\n      \
    \      ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp_19vd9t0: /tmp/tmp_19vd9t0.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if\
    \ (x == \"(\") {\n            flag = true;\n        } else if (x == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpxasy3qg4: /tmp/tmpxasy3qg4.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    stack<char> st;\n    for (auto i : lst) {\n        if (i\
    \ == '(') {\n            st.push('(');\n        } else if (i == ')') {\n     \
    \       if (st.empty()) {\n                ans = \"No\";\n                break;\n\
    \            } else {\n                st.pop();\n            }\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp23irhgzs.cpp: In function \u2018std::string match_parens(std::vector<std::__cxx11::basic_string<char>\
    \ >)\u2019:\n/tmp/tmp23irhgzs.cpp:16:5: error: \u2018stack\u2019 was not declared\
    \ in this scope; did you mean \u2018std::stack\u2019?\n   16 |     stack<char>\
    \ st;\n      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp23irhgzs.cpp:16:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   16 |     stack<char> st;\n      |           ^~~~\n\
    /tmp/tmp23irhgzs.cpp:18:15: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018char\u2019\
    )\n   18 |         if (i == '(') {\n      |             ~ ^~ ~~~\n      |    \
    \         |    |\n      |             |    char\n      |             std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   18 |         if (i == '(') {\n      |    \
    \              ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::move_iterator<_IteratorL>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   18 |         if (i == '(') {\n      | \
    \                 ^~~\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/string:55,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   18 |         if (i ==\
    \ '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   18 |         if (i == '(') {\n      |      \
    \            ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n   \
    \              from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |\
    \                  ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n \
    \                from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n \
    \                from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n      |  \
    \                ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |         if (i == '(') {\n     \
    \ |                  ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   18 |      \
    \   if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |         if (i == '(') {\n  \
    \    |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 |         if (i == '(') {\n   \
    \   |                  ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   18 |         if (i == '(') {\n      |                  ^~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/memory:81,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n  \
    \               from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   18 |         if (i == '(') {\n      |   \
    \               ^~~\nIn file included from /usr/include/c++/9/queue:64,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n   \
    \              from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   18 |         if (i == '(')\
    \ {\n      |                  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   18 |       \
    \  if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   18 |         if (i == '(') {\n      |             \
    \     ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n         \
    \        from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |         if\
    \ (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   18 |         if (i == '(') {\n      |     \
    \             ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   18 |         if (i == '(') {\n      |                  ^~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:18:18: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   18\
    \ |         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   18 |         if (i == '(') {\n\
    \      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   18 |         if (i\
    \ == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   18 |\
    \         if (i == '(') {\n      |                  ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   18 |   \
    \      if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   18 |        \
    \ if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   18 |     \
    \    if (i == '(') {\n      |                  ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:18:18:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   18 |         if (i == '(') {\n      |                 \
    \ ^~~\n/tmp/tmp23irhgzs.cpp:19:13: error: \u2018st\u2019 was not declared in this\
    \ scope; did you mean \u2018lst\u2019?\n   19 |             st.push('(');\n  \
    \    |             ^~\n      |             lst\n/tmp/tmp23irhgzs.cpp:20:22: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   20 |         } else if (i == ')') {\n      |     \
    \               ~ ^~ ~~~\n      |                    |    |\n      |         \
    \           |    char\n      |                    std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::fpos<_StateT>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::pair<_T1, _T2>\u2019\n   20 |         } else if (i == ')') {\n    \
    \  |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::allocator<_CharT>\u2019\n   20 |         } else if (i == ')') {\n \
    \     |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   20 |         } else if\
    \ (i == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 20 |         } else if (i == ')') {\n      |                         ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/ios_base.h:46,\n                \
    \ from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::error_condition&\u2019\n  311 |   operator==(const error_condition&\
    \ __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included\
    \ from /usr/include/c++/9/bits/locale_facets.h:48,\n                 from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istreambuf_iterator<_CharT, _Traits>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n   20 |         } else if (i == ')') {\n      |\
    \                         ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::deque<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::array<_Tp, _Nm>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::tuple<_Tps ...>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n  \
    \    |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n   20 |         } else if (i == ')') {\n\
    \      |                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n        \
    \         from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\n   20 |      \
    \   } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::list<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp1, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\nIn file included from /usr/include/c++/9/memory:81,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n          \
    \       from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::vector<_Tp, _Alloc>\u2019\n   20 |         } else if (i == ')') {\n   \
    \   |                         ^~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::set<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i ==\
    \ ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::multiset<_Key, _Compare, _Alloc>\u2019\n   20 |         } else if (i\
    \ == ')') {\n      |                         ^~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   20 |       \
    \  } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   20 |         } else if (i == ')') {\n      |      \
    \                   ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::valarray<_Tp>\u2019\n   20 |         }\
    \ else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n   20 |         } else if (i == ')') {\n     \
    \ |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   20 |         } else if (i == ')') {\n      |                         ^~~\n\
    In file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp23irhgzs.cpp:20:25: note:   \u2018std::__cxx11::basic_string<char>\u2019\
    \ is not derived from \u2018const std::forward_list<_Tp, _Alloc>\u2019\n   20\
    \ |         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>\u2019 to \u2018std::thread::id\u2019\n\
    \  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |      \
    \        ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::normal_distribution<_RealType>\u2019\n   20 |         } else if (i == ')')\
    \ {\n      |                         ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\n   20 |         } else\
    \ if (i == ')') {\n      |                         ^~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\n   20 |\
    \         } else if (i == ')') {\n      |                         ^~~\nIn file\
    \ included from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>\u2019\n   20 |   \
    \      } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note: \
    \  \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const\
    \ __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\n   20 |        \
    \ } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\n   20 |     \
    \    } else if (i == ')') {\n      |                         ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n         \
    \        from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp23irhgzs.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp23irhgzs.cpp:20:25: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    char\u2019\n   20 |         } else if (i == ')') {\n      |                  \
    \       ^~~\n/tmp/tmp23irhgzs.cpp:21:17: error: \u2018st\u2019 was not declared\
    \ in this scope; did you mean \u2018lst\u2019?\n   21 |             if (st.empty())\
    \ {\n      |                 ^~\n      |                 lst\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        s += \"Yes\";\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpmo3rvoxl: /tmp/tmpmo3rvoxl.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpnd7pumpf: /tmp/tmpnd7pumpf.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpq9qouexs: /tmp/tmpq9qouexs.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        } else {\n            s += \"No\";\n        }\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpki6pqlbg: /tmp/tmpki6pqlbg.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n        else if (i == \")\") {\n            s +=\
    \ \"No\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpbljubj1z: /tmp/tmpbljubj1z.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag == true) {\n            ans\
    \ = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpb304nf_3: /tmp/tmpb304nf_3.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if (i\
    \ == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n  \
    \          flag = false;\n        } else if (flag == true) {\n            s +=\
    \ i;\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpmhe2k_am: /tmp/tmpmhe2k_am.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        s += \"Yes\";\n    }\n    return\
    \ s;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpfafsu4k_: /tmp/tmpfafsu4k_.cpp:23: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        }\n        else if (i == \")\") {\n            s +=\
    \ \"No\";\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = match_parens;\n    assert(candidate((std::vector<std::string>({\"()(\", \"\
    )\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\")\"\
    , \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpb8ed_2b6: /tmp/tmpb8ed_2b6.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string s = \"(\";\n    for (auto i : lst) {\n        if\
    \ (i == \"(\")\n            s += \")\";\n        else if (i == \")\")\n      \
    \      s += \"(\";\n        else\n            s += i;\n    }\n    return s;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp8oo1959a: /tmp/tmp8oo1959a.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &x : lst) {\n        if\
    \ (x.find(\"(\") != std::string::npos) {\n            flag = true;\n        }\n\
    \        if (x.find(\")\") != std::string::npos) {\n            flag = false;\n\
    \        }\n        if (flag) {\n            ans = \"Yes\";\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpdwxv4kos: /tmp/tmpdwxv4kos.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      int count = 0;\n      for (int j = i; j\
    \ < lst.size(); j++) {\n        if (lst[j] == \")\") {\n          count++;\n \
    \         if (count == lst.size() - 1) {\n            ans = \"Yes\";\n       \
    \     break;\n          }\n        } else {\n          count = 0;\n        }\n\
    \      }\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpr9p93j2y: /tmp/tmpr9p93j2y.cpp:37: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"(\";\n    std::string t = \"(\";\n    std::string ans = \"No\";\n    for\
    \ (auto i : lst) {\n        if (i == \"(\") {\n            s += t;\n         \
    \   t = \"\";\n        } else if (i == \")\") {\n            s += t;\n       \
    \     t = \"\";\n        } else {\n            t += i;\n        }\n    }\n   \
    \ if (t != \"\") {\n        s += t;\n    }\n    if (s == \"()\") {\n        ans\
    \ = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpb3rgczpf: /tmp/tmpb3rgczpf.cpp:39: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n         \
    \   s += \"Yes\";\n        } else if (i == \")\") {\n            s += \"No\";\n\
    \        }\n    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpk4mdjn4w: /tmp/tmpk4mdjn4w.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp7yjndaqf: /tmp/tmp7yjndaqf.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ s += i;\n    }\n    bool flag = true;\n    for (int i = 0; i < s.length(); i++)\
    \ {\n        if (s[i] == '(') {\n            flag = false;\n        }\n      \
    \  if (s[i] == ')') {\n            flag = true;\n        }\n    }\n    if (flag)\
    \ {\n        ans = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpyudhbxt4: /tmp/tmpyudhbxt4.cpp:37: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    for (auto &s : lst) {\n      \
    \  if (s.find(\"(\") != std::string::npos) {\n            ans = \"Yes\";\n   \
    \         break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpxrxq2mtj: /tmp/tmpxrxq2mtj.cpp:29: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string temp = \"\";\n    for (auto i : lst) {\n    \
    \    if (i == \"(\") {\n            temp += \"(\";\n        } else if (i == \"\
    )\") {\n            if (temp == \"(\") {\n                temp += \")\";\n   \
    \         } else {\n                temp += \")\";\n                ans = \"Yes\"\
    ;\n            }\n        } else {\n            temp += i;\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp33n7b6px: /tmp/tmp33n7b6px.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag == true) {\n            ans\
    \ = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp0pcqg1l3: /tmp/tmp0pcqg1l3.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string s = \"()\";\n    std::string s1 = \"()\";\n    std::string\
    \ s2 = \"()()\";\n    std::string s3 = \"()()()\";\n    std::string s4 = \"()()()()\"\
    ;\n    std::string s5 = \"()()()()()\";\n    std::string s6 = \"()()()()()()\"\
    ;\n    std::string s7 = \"()()()()()()()\";\n    std::string s8 = \"()()()()()()()()\"\
    ;\n    std::string s9 = \"()()()()()()()()()\";\n    std::string s10 = \"()()()()()()()()()()\"\
    ;\n    std::string s11 = \"()()()()()()()()()()\";\n    std::string s12 = \"()()()()()()()()()()\"\
    ;\n    std::string s13 = \"()()()()()()()()()()()\";\n    std::string s14 = \"\
    ()()()()()()()()()()()\";\n    std::string s15 = \"()()()()()()()()()()()()\"\
    ;\n    std::string s16 = \"()()()()()()()()()()()()\";\n    std::string s17 =\
    \ \"()()()()()()()()()()()()\";\n    std::string s18 = \"()()()()()()()()()()()()\"\
    ;\n    std::string s19 = \"()()()()()()()()()()()()\";\n    std::string s20 =\
    \ \"()()()()()()()()()()()()\";\n    std::string s21 = \"()()()()()()()()()()()()()\"\
    ;\n    std::string s22 = \"()()()()()()()()()()()()()\";\n    std::string s23\
    \ = \"()()()()()()()()()()()()()\";\n    std::string s24 = \"()()()()()()()()()()()()()\"\
    ;\n    std::string s25 = \"()()()()()()()()()()()()()\";\n    std::string s26\
    \ = \"()()()()()()()()()()()()()\";\n    std::string s27 = \"()()()()()()()()()()()()()\"\
    ;\n    std::string s28 = \"()()()()()()()()()()()()()\";\n    std::string s29\
    \ = \"()()()()()()()()()()()()()\";\n    std::string s30 = \"()()()()()()()()()()\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7yjxi12o.cpp:46:23: warning: missing terminating \" character\n\
    \   46 |     std::string s30 = \"()()()()()()()()()()\n      |               \
    \        ^\n/tmp/tmp7yjxi12o.cpp:46:23: error: missing terminating \" character\n\
    \   46 |     std::string s30 = \"()()()()()()()()()()\n      |               \
    \        ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7yjxi12o.cpp: In function \u2018std::string\
    \ match_parens(std::vector<std::__cxx11::basic_string<char> >)\u2019:\n/tmp/tmp7yjxi12o.cpp:47:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   47 | }\n \
    \     | ^\n/tmp/tmp7yjxi12o.cpp:47:1: error: expected \u2018,\u2019 or \u2018\
    ;\u2019 before \u2018}\u2019 token\n/tmp/tmp7yjxi12o.cpp:47:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ if (i == \"(\") {\n            s += \"(\";\n        } else if (i == \")\") {\n\
    \            s += \")\";\n        } else {\n            s += i;\n        }\n \
    \   }\n    if (s == \"()\") {\n        ans = \"Yes\";\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmped6xfovy: /tmp/tmped6xfovy.cpp:33: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    std::string s = \"\";\n    for (auto i : lst) {\n       \
    \ s += i;\n    }\n    ans = s;\n    for (auto i : lst) {\n        if (s.find(i)\
    \ != std::string::npos) {\n            ans = \"Yes\";\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpixry_ras: /tmp/tmpixry_ras.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmphxtgto14: /tmp/tmphxtgto14.cpp:31: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp4zb2c1t2: /tmp/tmp4zb2c1t2.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") != std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp2loef2nc: /tmp/tmp2loef2nc.cpp:28: int main(): Assertion `candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto &i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else if (flag) {\n            ans = \"Yes\"\
    ;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpy3nm49cm: /tmp/tmpy3nm49cm.cpp:30: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = true;\n    for (auto &s : lst) {\n        if\
    \ (s == \"(\") {\n            flag = true;\n        } else if (s == \"(\") {\n\
    \            flag = false;\n        }\n    }\n    if (flag) {\n        ans = \"\
    Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpwj4602m8: /tmp/tmpwj4602m8.cpp:32: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    bool flag = false;\n    for (auto i : lst) {\n        if\
    \ (i == \"(\") {\n            flag = true;\n        } else if (i == \")\") {\n\
    \            flag = false;\n        } else {\n            flag = false;\n    \
    \    }\n        if (flag == true) {\n            ans = \"Yes\";\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpyb4mfpu5: /tmp/tmpyb4mfpu5.cpp:34: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    for (auto i : lst) {\n       \
    \ if (i == \"(\") {\n            ans = \"Yes\";\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpzzobcj4u: /tmp/tmpzzobcj4u.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &s : lst) {\n        if (s.find(\"(\") == std::string::npos)\
    \ {\n            ans = \"Yes\";\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp25zpsthe: /tmp/tmp25zpsthe.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    // Your\
    \ code here\n    std::string ans = \"No\";\n    std::string temp = \"\";\n   \
    \ bool flag = false;\n    for (auto &x : lst) {\n        if (x.find(\"(\") !=\
    \ std::string::npos) {\n            flag = true;\n            temp += x;\n   \
    \     }\n        if (x.find(\")\") != std::string::npos) {\n            flag =\
    \ false;\n            temp += x;\n        }\n    }\n    if (flag) {\n        ans\
    \ = \"Yes\";\n    }\n    return ans;\n}\nint main() {\n    auto candidate = match_parens;\n\
    \    assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpb2v_ssfr: /tmp/tmpb2v_ssfr.cpp:36: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto i : lst) {\n        if (i == \"(\") {\n       \
    \     ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpdcsjey8d: /tmp/tmpdcsjey8d.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i] == \"(\") {\n      ans = \"Yes\";\n      break;\n    }\n \
    \ }\n  return ans;\n}\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpqkhg31da: /tmp/tmpqkhg31da.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &i : lst) {\n        if (i == \"(\") {\n      \
    \      ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp089lcuoy: /tmp/tmp089lcuoy.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ ans = \"No\";\n    for (auto &i : lst) {\n        if (i == \"(\") {\n      \
    \      ans = \"Yes\";\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpct9j7287: /tmp/tmpct9j7287.cpp:26: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n    std::string\
    \ s = \"No\";\n    for (auto &x : lst) {\n        if (x.size() == 1) {\n     \
    \       s += \"Yes\";\n            continue;\n        }\n        s += \"No\";\n\
    \    }\n    return s;\n}\nint main() {\n    auto candidate = match_parens;\n \
    \   assert(candidate((std::vector<std::string>({\"()(\", \")\"}))) == (\"Yes\"\
    ));\n    assert(candidate((std::vector<std::string>({\")\", \")\"}))) == (\"No\"\
    ));\n    assert(candidate((std::vector<std::string>({\"(()(())\", \"())())\"})))\
    \ == (\"No\"));\n    assert(candidate((std::vector<std::string>({\")())\", \"\
    (()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmpinbzeexd: /tmp/tmpinbzeexd.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of\
    \ two strings, both strings consist of open\n// parentheses '(' or close parentheses\
    \ ')' only.\n// Your job is to check if it is possible to concatenate the two\
    \ strings in\n// some order, that the resulting string will be good.\n// A string\
    \ S is considered to be good if and only if all parentheses in S\n// are balanced.\
    \ For example: the string '(())()' is good, while the string\n// '())' is not.\n\
    // Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    // Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')'])\
    \ == 'No'\nstd::string match_parens(std::vector<std::string> lst) {\n  // Your\
    \ code here\n  std::string ans = \"No\";\n  for (int i = 0; i < lst.size(); i++)\
    \ {\n    if (lst[i][0] == '(' && lst[i][lst[i].size() - 1] == ')') {\n      ans\
    \ = \"Yes\";\n      break;\n    }\n  }\n  return ans;\n}\nint main() {\n    auto\
    \ candidate = match_parens;\n    assert(candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \")\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(())\", \"())())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )())\", \"(()()(\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    (())))\", \"(()())((\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ()\", \"())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (()(\", \"()))()\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    ((((\", \"((())\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(()\", \"(()(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    )(\", \")(\"}))) == (\"No\"));\n    assert(candidate((std::vector<std::string>({\"\
    (\", \")\"}))) == (\"Yes\"));\n    assert(candidate((std::vector<std::string>({\"\
    )\", \"(\"}))) == (\"Yes\"));\n}\n"
  stdout: ''
  stderr: "tmp_mrxsl7g: /tmp/tmp_mrxsl7g.cpp:27: int main(): Assertion `candidate((std::vector<std::string>({\"\
    ()(\", \")\"}))) == (\"Yes\")' failed.\n"
  exit_code: -6
  status: Exception
