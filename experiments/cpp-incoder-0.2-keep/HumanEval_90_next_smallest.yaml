name: HumanEval_90_next_smallest
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of integers.\n\
  // Write a function next_smallest() that returns the 2nd smallest element of the\
  \ list.\n// Return None if there is no such element.\n// next_smallest([1, 2, 3,\
  \ 4, 5]) == 2\n// next_smallest([5, 1, 4, 3, 2]) == 2\n// next_smallest([]) == None\n\
  // next_smallest([1, 1]) == None\nstd::optional<long> next_smallest(std::vector<long>\
  \ lst) {\n"
tests: "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({1,\
  \ 2, 3, 4, 5}))) == (std::optional<long>(2)));\n    assert(candidate((std::vector<long>({5,\
  \ 1, 4, 3, 2}))) == (std::optional<long>(2)));\n    assert(candidate((std::vector<long>()))\
  \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({1, 1})))\
  \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({1, 1,\
  \ 1, 1, 0}))) == (std::optional<long>(1)));\n    assert(candidate((std::vector<long>({1,\
  \ 1}))) == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({-35,\
  \ 34, 12, -45}))) == (std::optional<long>(-35)));\n}\n"
completions: ["    long smallest = std::numeric_limits<long>::max();\n    long second_smallest\
    \ = std::numeric_limits<long>::max();\n    for (long i : lst) {\n        if (i\
    \ < smallest) {\n            second_smallest = smallest;\n            smallest\
    \ = i;\n        } else if (i < second_smallest) {\n            second_smallest\
    \ = i;\n        }\n    }\n    return second_smallest == std::numeric_limits<long>::max()\
    \ ? std::nullopt : second_smallest;", "    if(lst.empty())\n        return std::nullopt;\n\
    \    long min = *std::min_element(lst.begin(), lst.end());\n    for(auto it =\
    \ lst.begin(); it != lst.end(); ++it) {\n        if(*it < min)\n            min\
    \ = *it;\n    }\n    return min;", "    if (lst.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    auto it = std::find_if(lst.begin(), lst.end(), [&smallest](long x) { return\
    \ x < smallest; });\n    if (it == lst.end()) {\n        return std::nullopt;\n\
    \    }\n    smallest = *it;\n    lst.erase(it);\n    return smallest;", "    if\
    \ (lst.size() == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n   \
    \ auto it = std::find_if(lst.begin(), lst.end(), [&smallest](long x) { return\
    \ x < smallest; });\n    if (it != lst.end()) {\n        smallest = *it;\n   \
    \ }\n    return smallest;", "    // Your code here\n    if(lst.empty())\n    \
    \    return std::nullopt;\n    long min = *lst.begin();\n    long max = *lst.rbegin();\n\
    \    for(long i : lst)\n    {\n        if(i < min)\n            min = i;\n   \
    \     if(i > max)\n            max = i;\n    }\n    if(min == max)\n        return\
    \ std::nullopt;\n    long mid = min + (max - min) / 2;\n    for(long i : lst)\n\
    \    {\n        if(i < mid)\n            min = i;\n        else\n            max\
    \ = i;\n    }\n    return max;", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *it;", "    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n\
    \    for (auto it = lst.begin(); it != lst.end(); ++it) {\n        if (*it < smallest)\
    \ {\n            smallest = *it;\n        }\n    }\n    return smallest;", " \
    \   // Your code here\n    long min = std::numeric_limits<long>::max();\n    long\
    \ max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        } else if (i > max) {\n         \
    \   max = i;\n        }\n    }\n    if (min == max) {\n        return std::nullopt;\n\
    \    }\n    return max;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    if (it == lst.begin())\n        return *it;\n\
    \    auto prev = *it;\n    auto next = *std::next(it);\n    if (next == lst.end())\n\
    \        return prev;\n    if (next == lst.begin())\n        return prev;\n  \
    \  if (*prev < *next)\n        return prev;\n    return next;", "    if (lst.empty())\
    \ return std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    for (auto it = lst.begin(); it != lst.end(); ++it) {\n        if (*it < smallest)\
    \ {\n            smallest = *it;\n        }\n    }\n    return smallest;", " \
    \   if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n   \
    \ long second_smallest = *std::min_element(lst.begin(), lst.begin() + 2);\n  \
    \  if (second_smallest == smallest) {\n        return second_smallest;\n    }\n\
    \    return std::nullopt;", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    auto it = lst.begin();\n    auto it2 = lst.begin();\n    if (*it <\
    \ *it2) {\n        ++it2;\n    }\n    if (*it > *it2) {\n        ++it;\n    }\n\
    \    if (*it == *it2) {\n        return std::nullopt;\n    }\n    return *it2;",
  "    // Your code here\n    long smallest = std::numeric_limits<long>::max();\n\
    \    long second_smallest = std::numeric_limits<long>::max();\n    for (long i\
    \ : lst) {\n        if (i < smallest) {\n            second_smallest = smallest;\n\
    \            smallest = i;\n        } else if (i < second_smallest) {\n      \
    \      second_smallest = i;\n        }\n    }\n    return second_smallest == std::numeric_limits<long>::max()\
    \ ? std::nullopt : second_smallest;", "    if (lst.empty()) {\n        return\
    \ std::nullopt;\n    }\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end()) {\n        return std::nullopt;\n    }\n    return *it;",
  "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    std::vector<long> rest(std::next(lst.begin(), std::find(lst.begin(),\
    \ lst.end(), smallest)), lst.end());\n    return std::nullopt if rest.empty();\n\
    \    return *std::min_element(rest.begin(), rest.end());", "    // Your code here\n\
    \    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return max;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    return *it;", " \
    \   if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n  \
    \  long smallest = *std::min_element(lst.begin(), lst.end());\n    std::vector<long>\
    \ rest = lst;\n    rest.erase(std::remove(lst.begin(), lst.end(), smallest), lst.end());\n\
    \    if (rest.size() == 0) {\n        return std::nullopt;\n    }\n    return\
    \ next_smallest(rest);", "    // Your code here\n    if(lst.size() == 0)\n   \
    \     return std::nullopt;\n    long min = *std::min_element(lst.begin(), lst.end());\n\
    \    for(long i : lst)\n        if(i < min)\n            min = i;\n    return\
    \ min;", "    // Your code here\n    if(lst.empty())\n        return std::nullopt;\n\
    \    long min = lst[0];\n    long min_index = -1;\n    for(long i = 1; i < lst.size();\
    \ ++i)\n    {\n        if(lst[i] < min)\n        {\n            min = lst[i];\n\
    \            min_index = i;\n        }\n    }\n    return min_index == -1 ? std::nullopt\
    \ : lst[min_index + 1];", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    return *it;", "    if (lst.size() == 0)\n \
    \       return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    return *it;", " \
    \   // Your code here\n    long min = std::numeric_limits<long>::max();\n    long\
    \ min2 = std::numeric_limits<long>::max();\n    long min3 = std::numeric_limits<long>::max();\n\
    \    long min4 = std::numeric_limits<long>::max();\n    long min5 = std::numeric_limits<long>::max();\n\
    \    long min6 = std::numeric_limits<long>::max();\n    long min7 = std::numeric_limits<long>::max();\n\
    \    long min8 = std::numeric_limits<long>::max();\n    long min9 = std::numeric_limits<long>::max();\n\
    \    long min10 = std::numeric_limits<long>::max();\n    long min11 = std::numeric_limits<long>::max();\n\
    \    long min12 = std::numeric_limits<long>::max();\n    long min13 = std::numeric_limits<long>::max();\n\
    \    long min14 = std::numeric_limits<long>::max();\n    long min15 = std::numeric_limits<long>::max();\n\
    \    long min16 = std::numeric_limits<long>::max();\n    long min17 = std::numeric_limits<long>::max();\n\
    \    long min18 = std::numeric_limits<long>::max();\n    long min19 = std::numeric_limits<long>::max();\n\
    \    long min20 = std::numeric_limits<long>::max();\n    long min21 = std::numeric_limits<long>::max();\n\
    \    long min22 = std::numeric_limits<long>::max();\n    long min23 = std::numeric_limits<long>::max();\n\
    \    long min24 = std::numeric_limits<long>::max();\n    long min25 = std::numeric_limits<long>::max();\n\
    \    long min26 = std::numeric_limits<long>::max();\n    long min27 = std::numeric_limits<long>::max();\n\
    \    long min28 = std::numeric_limits<long>::max();\n    long min29 = std::numeric_limits<long>::max();\n\
    \    long min30 = std::numeric_limits<long>::max();\n    long min31 = std::numeric_limits<long>::max();\n\
    \    long min32 = std::numeric_limits<long>::max();\n    long min33 = std::numeric_limits<long>::max();\n\
    \    long min34 = std::numeric_limits<long>::max();\n    long min35 = std::numeric_limits<long>::max();\n\
    \    long min36 = std::numeric_limits<long>::max();\n    long min37 = std::numeric_limits<long>::max();\n\
    \    long ", "    if (lst.size() == 0)\n        return std::nullopt;\n    auto\
    \ it = lst.begin();\n    auto prev = *it;\n    ++it;\n    for (; it != lst.end();\
    \ ++it) {\n        if (*it < prev)\n            break;\n        prev = *it;\n\
    \    }\n    if (it == lst.end())\n        return std::nullopt;\n    return *it;",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long index = std::distance(std::begin(lst), std::find(std::begin(lst),\
    \ std::end(lst), min));\n    if (index == 0)\n        return std::nullopt;\n \
    \   return lst[index - 1];", "    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    auto it2 = std::min_element(lst.begin(), it);\n\
    \    if (it2 == lst.end())\n        return std::nullopt;\n    return *it2;", " \
    \   long smallest = *std::min_element(lst.begin(), lst.end());\n    long secondSmallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b) { return\
    \ a < b; });\n    return secondSmallest == smallest ? std::nullopt : secondSmallest;",
  "    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (auto i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return max;", "    if (lst.size()\
    \ == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n  \
    \  auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ {\n        return std::nullopt;\n    }\n    return *it;", "    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    if (lst.size() == 1) {\n \
    \       return std::nullopt;\n    }\n    for (auto it = lst.begin(); it != lst.end();\
    \ ++it) {\n        if (*it < smallest) {\n            smallest = *it;\n      \
    \  }\n    }\n    return smallest;", "    // Write your code here\n    long smallest\
    \ = std::numeric_limits<long>::max();\n    long second_smallest = std::numeric_limits<long>::max();\n\
    \    for (long i : lst) {\n        if (i < smallest) {\n            second_smallest\
    \ = smallest;\n            smallest = i;\n        } else if (i < second_smallest)\
    \ {\n            second_smallest = i;\n        }\n    }\n    return second_smallest\
    \ == std::numeric_limits<long>::max() ? std::nullopt : second_smallest;", "  \
    \  if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long min_val\
    \ = *std::min_element(lst.begin(), lst.end());\n    long max_val = *std::max_element(lst.begin(),\
    \ lst.end());\n    if (max_val == min_val) {\n        return std::nullopt;\n \
    \   }\n    if (max_val == lst[0]) {\n        return max_val;\n    }\n    if (min_val\
    \ == lst[lst.size() - 1]) {\n        return min_val;\n    }\n    if (max_val <\
    \ min_val) {\n        return std::nullopt;\n    }\n    long mid = min_val + max_val\
    \ / 2;\n    return next_smallest(lst[mid]);", "    if (lst.empty())\n        return\
    \ std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n   \
    \ if (it == lst.end())\n        return std::nullopt;\n    return *it;", "    if\
    \ (lst.empty())\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    if (second_smallest == smallest)\n        return second_smallest;\n    return\
    \ std::nullopt;", "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = lst.begin();\n\
    \    auto prev = *it;\n    if (*it == *prev)\n        return std::nullopt;\n \
    \   for (++it; it != lst.end(); ++it) {\n        if (*it < *prev) {\n        \
    \    prev = *it;\n        }\n    }\n    return prev;", "    if (lst.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    for (auto it = lst.begin(); it != lst.end(); ++it) {\n    \
    \    if (*it < smallest) {\n            smallest = *it;\n        }\n    }\n  \
    \  return smallest;", "    if (lst.empty()) return std::nullopt;\n    auto it\
    \ = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end()) return\
    \ std::nullopt;\n    return *it;", "    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    auto it2 = std::next(it);\n    if (it2 == lst.end())\n\
    \        return std::nullopt;\n    if (*it < *it2)\n        return *it2;\n   \
    \ return *it;", "    // Your code here\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n\
    \    for (long i = lst.size() - 2; i >= 0; i--) {\n        if (lst[i] < smallest)\
    \ {\n            smallest = lst[i];\n        }\n    }\n    return smallest;",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    long first = lst[0];\n\
    \    for (long i = 1;i < lst.size();++i)\n        if (lst[i] < first)\n      \
    \      first = lst[i];\n    return first;", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = lst.begin();\n    auto prev = *it;\n    ++it;\n    if (it == lst.end())\
    \ return std::nullopt;\n    auto next = *it;\n    if (next < prev) return std::nullopt;\n\
    \    return std::make_optional(next);", "    if(lst.size() == 0)\n        return\
    \ std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    for(auto it = lst.begin(); it != lst.end(); ++it)\n        if(*it < smallest)\n\
    \            smallest = *it;\n    return smallest;", "    if (lst.empty())\n \
    \       return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    return *it;", " \
    \   if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.end(),\
    \ [&smallest](long a, long b) { return a < b; });\n    if (second_smallest ==\
    \ smallest)\n        return std::nullopt;\n    return second_smallest;", "   \
    \ if (lst.empty())\n        return std::nullopt;\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    for (auto it = lst.begin(); it != lst.end(); ++it) {\n    \
    \    if (*it < min)\n            min = *it;\n    }\n    return min;", "    if\
    \ (lst.size() == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    auto\
    \ it_next = std::next(it);\n    if (*it_next < *it)\n        return *it_next;\n\
    \    return *it;", "    if (lst.empty())\n        return std::nullopt;\n    auto\
    \ it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n \
    \       return std::nullopt;\n    return *it;", "    if (lst.empty()) return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    auto it =\
    \ std::find_if(lst.begin(), lst.end(), [&smallest](long x) { return x < smallest;\
    \ });\n    if (it == lst.end()) return std::nullopt;\n    return *it;", "    if\
    \ (lst.empty())\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.end(),\
    \ [&smallest](long a, long b) { return a < b; });\n    if (second_smallest ==\
    \ smallest)\n        return std::nullopt;\n    return second_smallest;", "   \
    \ if (lst.empty())\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    for (auto it = lst.begin(); it != lst.end(); ++it) {\n    \
    \    if (*it < smallest)\n            smallest = *it;\n    }\n    return smallest;",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    auto\
    \ it_next = std::next(it);\n    if (it_next == lst.end())\n        return *it;\n\
    \    return *it_next;", "    // Your code here\n    long smallest = lst[0];\n\
    \    long second_smallest = lst[0];\n    for (long i : lst) {\n        if (i <\
    \ smallest) {\n            second_smallest = smallest;\n            smallest =\
    \ i;\n        } else if (i < second_smallest) {\n            second_smallest =\
    \ i;\n        }\n    }\n    return second_smallest == lst[0] ? std::nullopt :\
    \ second_smallest;", "    if (lst.empty()) return std::nullopt;\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    long second_smallest = *std::min_element(lst.begin(),\
    \ lst.end(), [&smallest](int a, int b) { return a < b ? a : b; });\n    return\
    \ second_smallest == smallest ? std::nullopt : second_smallest;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    if (*it == *lst.begin())\n\
    \        return std::nullopt;\n    return *it;", "    if (lst.size() == 0)\n \
    \       return std::nullopt;\n    auto it = lst.begin();\n    auto it2 = lst.begin();\n\
    \    long min2 = *it2;\n    long min1 = *it;\n    for (++it; it != lst.end();\
    \ ++it) {\n        if (*it < min1) {\n            min2 = min1;\n            min1\
    \ = *it;\n        } else if (*it < min2) {\n            min2 = *it;\n        }\n\
    \    }\n    if (min1 == min2)\n        return min1;\n    return min2;", "    if\
    \ (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    auto it = std::find(lst.begin(),\
    \ lst.end(), smallest);\n    if (it != lst.end()) {\n        smallest = *it;\n\
    \    }\n    return smallest;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    auto val = *it;\n    lst.erase(it);\n    return\
    \ val;", "    // Your code here\n    if(lst.size() == 0)\n        return std::nullopt;\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for(long i : lst)\n     \
    \   if(i < min)\n            min = i;\n        else if(i > max)\n            max\
    \ = i;\n    return max;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = lst.begin();\n    auto prev = *it;\n    for (++it; it != lst.end();\
    \ ++it) {\n        if (*it < prev)\n            break;\n        prev = *it;\n\
    \    }\n    if (it == lst.end())\n        return std::nullopt;\n    return *it;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b) { return\
    \ a < b ? a : b; });\n    return second_smallest == smallest ? std::nullopt :\
    \ second_smallest;", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n    auto\
    \ it = std::find(lst.begin(), lst.end(), smallest);\n    if (it == lst.end())\
    \ {\n        return std::nullopt;\n    }\n    auto next = std::next(it);\n   \
    \ if (*next == smallest) {\n        return std::nullopt;\n    }\n    return *next;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    if (lst.size()\
    \ == 1) {\n        return std::nullopt;\n    }\n    for (auto it = lst.begin()\
    \ + 1; it != lst.end(); ++it) {\n        if (*it < smallest) {\n            smallest\
    \ = *it;\n        }\n    }\n    return smallest;", "    if (lst.size() == 0)\n\
    \        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    std::vector<long> rest = lst;\n    rest.erase(std::remove(lst.begin(),\
    \ lst.end(), smallest), lst.end());\n    if (rest.size() == 0)\n        return\
    \ std::nullopt;\n    return next_smallest(rest);", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long smallest = lst[0];\n    for (long\
    \ i : lst) {\n        if (i < smallest) {\n            smallest = i;\n       \
    \ }\n    }\n    return smallest;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    long first = *lst.begin();\n    long second = first;\n    for (long &i :\
    \ lst) {\n        if (i < first)\n            second = i;\n    }\n    return std::optional<long>(second);",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.empty()) return std::nullopt;\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find(lst.begin(), lst.end(), min);\n    if (it\
    \ == lst.end()) return std::nullopt;\n    auto next = std::next(it);\n    if (*next\
    \ == min) return std::nullopt;\n    return next;", "    if (lst.empty())\n   \
    \     return std::nullopt;\n    auto it = lst.begin();\n    auto prev = *it;\n\
    \    ++it;\n    for (; it != lst.end(); ++it) {\n        if (*it < prev)\n   \
    \         break;\n        prev = *it;\n    }\n    if (it == lst.end())\n     \
    \   return std::nullopt;\n    return *it;", "    if (lst.size() == 0) {\n    \
    \    return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    if (second_smallest == smallest) {\n        return std::nullopt;\n    }\n\
    \    return second_smallest;", "    if (lst.empty()) {\n        return std::nullopt;\n\
    \    }\n    auto it = std::min_element(lst.begin(), lst.end());\n    if (it ==\
    \ lst.end()) {\n        return std::nullopt;\n    }\n    if (*it == *std::next(it))\
    \ {\n        return *it;\n    }\n    return std::next(it);", "    if (lst.size()\
    \ == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    auto\
    \ next = std::next(it);\n    if (*next < *it)\n        return *it;\n    return\
    \ *next;", "    // Your code here\n    if(lst.empty()){\n        return std::nullopt;\n\
    \    }\n    long min = lst[0];\n    long min_index = -1;\n    for(long i = 1;\
    \ i < lst.size(); i++){\n        if(lst[i] < min){\n            min = lst[i];\n\
    \            min_index = i;\n        }\n    }\n    if(min_index == lst.size()\
    \ - 1){\n        return std::nullopt;\n    }\n    return lst[min_index + 1];",
  "    // Your code here\n    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    auto it = lst.begin();\n    auto prev = *it;\n    ++it;\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    while (it != lst.end()) {\n        if (*it\
    \ < prev) {\n            prev = *it;\n            ++it;\n        } else {\n  \
    \          break;\n        }\n    }\n    if (it == lst.end())\n        return\
    \ std::nullopt;\n    return prev;", "    if (lst.empty()) {\n        return std::nullopt;\n\
    \    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n    std::vector<long>\
    \ remaining(lst.begin(), lst.end());\n    remaining.erase(std::remove(lst.begin(),\
    \ lst.end(), smallest), lst.end());\n    if (remaining.empty()) {\n        return\
    \ std::nullopt;\n    }\n    return next_smallest(remaining);", "    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find(lst.begin(), lst.end(), smallest);\n  \
    \  if (it == lst.end()) {\n        return std::nullopt;\n    }\n    auto next\
    \ = std::next(it);\n    if (*next < smallest) {\n        return std::nullopt;\n\
    \    }\n    return next;", "    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    auto it = lst.begin();\n    auto it2 = lst.begin();\n    for (; it != lst.end();\
    \ ++it, ++it2) {\n        if (*it < *it2)\n            return std::nullopt;\n\
    \    }\n    return *it2;", "    if (lst.empty()) {\n        return std::nullopt;\n\
    \    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n    std::vector<long>::iterator\
    \ it = std::find_if(lst.begin(), lst.end(), [&smallest](long x) { return x < smallest;\
    \ });\n    if (it == lst.end()) {\n        return std::nullopt;\n    }\n    long\
    \ next = *it;\n    lst.erase(it);\n    return next;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    return *it;", " \
    \   if (lst.empty()) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    std::vector<long> rest = lst;\n\
    \    rest.erase(std::remove(lst.begin(), lst.end(), smallest), lst.end());\n \
    \   if (rest.empty()) {\n        return std::nullopt;\n    }\n    return next_smallest(rest);",
  "    if (lst.empty()) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(std::next(lst.begin()),\
    \ lst.end());\n    if (second_smallest == smallest) return std::nullopt;\n   \
    \ return second_smallest;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    long curr = lst[0];\n    for (long &i : lst) {\n        if (i < curr)\n \
    \           return std::nullopt;\n    }\n    return curr;", "    // Your code\
    \ here\n    if(lst.empty())\n        return std::nullopt;\n    long smallest =\
    \ *std::min_element(lst.begin(), lst.end());\n    for(auto it = lst.begin(); it\
    \ != lst.end(); ++it){\n        if(*it < smallest){\n            smallest = *it;\n\
    \        }\n    }\n    return smallest;", "    if (lst.size() == 0) {\n      \
    \  return std::nullopt;\n    }\n    auto it = lst.begin();\n    auto last = lst.end();\n\
    \    auto next = std::next(it);\n    if (*it < std::min(*next, *last)) {\n   \
    \     ++it;\n        ++next;\n    }\n    if (*it == *last) {\n        return std::nullopt;\n\
    \    }\n    if (*it < std::min(*next, *last)) {\n        return std::nullopt;\n\
    \    }\n    return *it;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    return *it;", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    if (second_smallest == smallest) {\n        return std::nullopt;\n    }\n\
    \    return second_smallest;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = lst.begin();\n    auto prev = *it;\n    ++it;\n    for (; it !=\
    \ lst.end(); ++it) {\n        if (*it < prev)\n            break;\n        prev\
    \ = *it;\n    }\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n   \
    \ long second_smallest = *std::min_element(lst.begin(), lst.end(), [&smallest](int\
    \ i) { return i < smallest; });\n    return second_smallest == lst.end() ? std::nullopt\
    \ : second_smallest;", "    long min = std::numeric_limits<long>::max();\n   \
    \ long max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n   \
    \     if (i < min) {\n            min = i;\n        } else if (i > max) {\n  \
    \          max = i;\n        }\n    }\n    if (min == max) {\n        return std::nullopt;\n\
    \    }\n    return max;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    if (*it == *lst.begin())\n        return std::nullopt;\n\
    \    return *it;", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n    std::vector<long>\
    \ rest = lst;\n    rest.erase(std::remove(lst.begin(), lst.end(), smallest), lst.end());\n\
    \    if (rest.size() == 0) {\n        return std::nullopt;\n    }\n    return\
    \ next_smallest(rest);", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    long smallest = lst[0];\n    for (long i : lst) {\n        if (i <\
    \ smallest) {\n            smallest = i;\n        }\n    }\n    return smallest;",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n  \
    \  long min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n    \
    \    if (i < min) {\n            min = i;\n        } else if (i > max) {\n   \
    \         max = i;\n        }\n    }\n    return max == min ? std::nullopt : max;",
  "    if (lst.empty()) return std::nullopt;\n    long min = *lst.begin();\n    long\
    \ max = *lst.rbegin();\n    for (long i : lst) {\n        if (i < min) min = i;\n\
    \        if (i > max) max = i;\n    }\n    if (min == max) return std::nullopt;\n\
    \    if (min < max) return std::nullopt;\n    return max;", "    if (lst.size()\
    \ == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n   \
    \ long second_smallest = *std::min_element(lst.begin(), lst.end(), [&smallest](long\
    \ a, long b) { return a < b ? a : b; });\n    return second_smallest == smallest\
    \ ? std::nullopt : second_smallest;", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *it;", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *it;", "    if (lst.size() == 0)\n        return\
    \ std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n   \
    \ if (it == lst.end())\n        return std::nullopt;\n    if (*it == *lst.begin())\n\
    \        return std::nullopt;\n    auto it2 = std::min_element(lst.begin(), it);\n\
    \    if (it2 == lst.end())\n        return std::nullopt;\n    return *it2;", " \
    \   // Your code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   return second_smallest == smallest ? std::nullopt : second_smallest;", " \
    \   if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    auto it =\
    \ std::min_element(lst.begin(), lst.end());\n    if (it == lst.end()) {\n    \
    \    return std::nullopt;\n    }\n    return *it;", "    if (lst.size() == 0)\n\
    \        return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    if (*it == *lst.begin())\n\
    \        return std::nullopt;\n    return *it;", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    for (long i : lst) {\n        if (i < min) {\n            min\
    \ = i;\n        }\n    }\n    return min;", "    if (lst.empty())\n        return\
    \ std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n   \
    \ if (it == lst.end())\n        return std::nullopt;\n    return *it;", "    if\
    \ (lst.empty()) {\n        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long index = std::distance(std::begin(lst), std::find(std::begin(lst),\
    \ std::end(lst), smallest));\n    if (index == lst.size()) {\n        return std::nullopt;\n\
    \    }\n    return lst[index + 1];", "    if (lst.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    long min = lst[0];\n    for (long i : lst) {\n   \
    \     if (i < min) {\n            min = i;\n        }\n    }\n    return min;",
  "    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return max;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    long first = *lst.begin();\n    long second\
    \ = first;\n    for (long &i : lst) {\n        if (i < first)\n            second\
    \ = i;\n    }\n    return std::optional<long>(second);", "    if (lst.size() ==\
    \ 0)\n        return std::nullopt;\n    long cur = *lst.begin();\n    long next\
    \ = *lst.begin();\n    for (long &i : lst) {\n        if (i < cur) {\n       \
    \     next = i;\n        }\n    }\n    if (next == cur)\n        return std::nullopt;\n\
    \    return next;", "    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    auto it2 = std::next(it);\n    if (it2 == lst.end())\n\
    \        return std::nullopt;\n    return *it2;", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    auto it = lst.begin();\n    if (*it\
    \ < lst.front()) {\n        ++it;\n    }\n    auto last = lst.end();\n    if (it\
    \ == last) {\n        return std::nullopt;\n    }\n    auto next = std::next(it);\n\
    \    if (*next < lst.front()) {\n        ++next;\n    }\n    if (*it == *next)\
    \ {\n        return std::nullopt;\n    }\n    return *next;", "    if (lst.empty())\
    \ return std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    for (long i : lst) {\n        if (i < smallest) {\n            smallest =\
    \ i;\n        }\n    }\n    return smallest;", "    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    if (lst.size() == 1) {\n        return min;\n    }\n    for\
    \ (long i = lst.size() - 2; i >= 0; --i) {\n        if (lst[i] < min) {\n    \
    \        min = lst[i];\n        }\n    }\n    return min;", "    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    if (lst.empty()) return std::nullopt;\n\
    \    for (auto it = lst.begin(); it != lst.end(); ++it) {\n        if (*it < smallest)\
    \ {\n            smallest = *it;\n        }\n    }\n    return smallest;", " \
    \   if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.size() == 0)\n        return std::nullopt;\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    auto it = std::find_if(lst.begin(),\
    \ lst.end(), [&smallest](long x) { return x < smallest; });\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    long second = *it;\n    return std::make_optional(std::min(smallest,\
    \ second));", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n\
    \    auto it = lst.begin();\n    auto prev = *it;\n    ++it;\n    if (it == lst.end())\
    \ {\n        return std::nullopt;\n    }\n    auto next = *it;\n    if (next <\
    \ prev) {\n        std::swap(prev, next);\n    }\n    if (prev == next) {\n  \
    \      return std::nullopt;\n    }\n    if (prev > next) {\n        return prev;\n\
    \    }\n    return next;", "    if (lst.empty()) return std::nullopt;\n    auto\
    \ it = lst.begin();\n    auto it2 = lst.begin();\n    if (*it < *it2) std::iter_swap(it,\
    \ it2);\n    long cur = *it;\n    long cur2 = *it2;\n    while (it != lst.end())\
    \ {\n        if (cur2 < *it) {\n            std::iter_swap(it, it2);\n       \
    \     cur2 = *it2;\n        }\n        ++it;\n        ++it2;\n    }\n    return\
    \ cur;", "    // Your code here\n    long min = lst[0];\n    long max = lst[0];\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return max;", "    if (lst.size()\
    \ == 0)\n        return std::nullopt;\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long max = *std::max_element(lst.begin(), lst.end());\n   \
    \ if (min == max)\n        return min;\n    if (min > max)\n        return std::nullopt;\n\
    \    for (long i = min; i <= max; i++) {\n        if (lst.find(i) == lst.end())\n\
    \            return i;\n    }\n    return std::nullopt;", "    if (lst.empty())\
    \ return std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   if (second_smallest == smallest) return std::nullopt;\n    return second_smallest;",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    }\n        if (i > max) {\n            max = i;\n        }\n    }\n    if\
    \ (min == max) {\n        return std::nullopt;\n    }\n    return max;", "   \
    \ if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find_if(lst.begin(), lst.end(), [&smallest](long\
    \ x) { return x < smallest; });\n    if (it == lst.end())\n        return std::nullopt;\n\
    \    if (*it == smallest)\n        return std::nullopt;\n    std::vector<long>\
    \ new_lst;\n    new_lst.push_back(*it);\n    new_lst.insert(new_lst.end(), lst.begin(),\
    \ it);\n    return next_smallest(new_lst);", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    if (*it == *lst.begin()) return std::nullopt;\n  \
    \  return *it;", "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    long min = *lst.begin();\n\
    \    long max = *lst.rbegin();\n    for (long &i : lst) {\n        if (i < min)\n\
    \            min = i;\n        if (i > max)\n            max = i;\n    }\n   \
    \ if (min == max)\n        return std::nullopt;\n    return max;", "    // Your\
    \ code here\n    long smallest = lst[0];\n    long second_smallest = lst[0];\n\
    \    for (long i : lst) {\n        if (i < smallest) {\n            second_smallest\
    \ = smallest;\n            smallest = i;\n        } else if (i > second_smallest)\
    \ {\n            second_smallest = i;\n        }\n    }\n    return second_smallest\
    \ == smallest ? std::nullopt : second_smallest;", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(std::next(lst.begin()),\
    \ lst.end());\n    if (second_smallest == smallest) {\n        return std::nullopt;\n\
    \    }\n    return second_smallest;", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *it;", "    if (lst.size() == 0) {\n      \
    \  return std::nullopt;\n    }\n    long smallest = lst[0];\n    for (long i :\
    \ lst) {\n        if (i < smallest) {\n            smallest = i;\n        }\n\
    \    }\n    return smallest;", "    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n\
    \    for (auto it = lst.begin() + 1; it != lst.end(); ++it) {\n        if (*it\
    \ < smallest) {\n            smallest = *it;\n        }\n    }\n    return smallest;",
  "    if(lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if(it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    long min = lst[0];\n    long max = lst[0];\n    for (long i : lst)\
    \ {\n        if (i < min) {\n            min = i;\n        } else if (i > max)\
    \ {\n            max = i;\n        }\n    }\n    return std::optional<long>(max);",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    long first = lst[0];\n\
    \    long second = first;\n    for (size_t i = 1; i < lst.size(); i++) {\n   \
    \     if (lst[i] < first)\n            second = first;\n        else if (lst[i]\
    \ > second)\n            second = lst[i];\n    }\n    return second;", "    if\
    \ (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    if (second_smallest == smallest)\n        return second_smallest;\n    return\
    \ std::nullopt;", "    // Your code here\n    if(lst.empty())\n        return\
    \ std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    for(long i : lst)\n        if(i == smallest)\n            return std::nullopt;\n\
    \    return smallest;", "    if (lst.empty()) return std::nullopt;\n    auto it\
    \ = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end()) return\
    \ std::nullopt;\n    return *it;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    long min = *std::min_element(lst.begin(), lst.end());\n    long index = std::distance(std::begin(lst),\
    \ std::find(std::begin(lst), std::end(lst), min));\n    if (index == 0)\n    \
    \    return std::nullopt;\n    if (index == lst.size() - 1)\n        return min;\n\
    \    return lst[index + 1];", "    // Your code here\n    long smallest = lst[0];\n\
    \    long second_smallest = lst[0];\n    for (long i : lst) {\n        if (i <\
    \ smallest) {\n            second_smallest = smallest;\n            smallest =\
    \ i;\n        } else if (i < second_smallest) {\n            second_smallest =\
    \ i;\n        }\n    }\n    return second_smallest == smallest ? std::nullopt\
    \ : second_smallest;", "    if (lst.empty())\n        return std::nullopt;\n \
    \   auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    return *it;", "    if(lst.size() == 0)\n  \
    \      return std::nullopt;\n    long min = lst[0];\n    long min_index = -1;\n\
    \    for(long i = 1; i < lst.size(); ++i) {\n        if(lst[i] < min) {\n    \
    \        min = lst[i];\n            min_index = i;\n        }\n    }\n    if(min_index\
    \ == lst.size() - 1)\n        return std::nullopt;\n    return lst[min_index +\
    \ 1];", "    if (lst.empty()) {\n        return std::nullopt;\n    }\n    auto\
    \ it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end()) {\n\
    \        return std::nullopt;\n    }\n    return *it;", "    if (lst.empty())\
    \ return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end()) return std::nullopt;\n    return *it;", "    if (lst.empty())\
    \ return std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(std::next(lst.begin()), lst.end());\n\
    \    if (second_smallest == smallest) return std::nullopt;\n    return second_smallest;",
  "    if (lst.empty()) return std::nullopt;\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long index = std::distance(std::begin(lst), std::find_if(std::begin(lst),\
    \ std::end(lst), [min](long x) { return x < min; }));\n    if (index == lst.size())\
    \ return std::nullopt;\n    return lst[index + 1];", "    if (lst.size() == 0)\
    \ {\n        return std::nullopt;\n    }\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long index = std::distance(std::begin(lst), std::find(std::begin(lst),\
    \ std::end(lst), min));\n    if (index == lst.size() - 1) {\n        return min;\n\
    \    }\n    return next_smallest(std::next(std::begin(lst), index + 1));", " \
    \   // Your code here\n    long smallest = lst[0];\n    long second_smallest =\
    \ lst[0];\n    for (long i : lst) {\n        if (i < smallest) {\n           \
    \ second_smallest = smallest;\n            smallest = i;\n        } else if (i\
    \ < second_smallest) {\n            second_smallest = i;\n        }\n    }\n \
    \   return second_smallest == smallest ? std::nullopt : second_smallest;", " \
    \   if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    auto it =\
    \ lst.begin();\n    auto prev = *it;\n    ++it;\n    if (it == lst.end()) {\n\
    \        return std::nullopt;\n    }\n    long prev = *it;\n    while (it != lst.end())\
    \ {\n        if (*it < prev) {\n            prev = *it;\n        }\n        ++it;\n\
    \    }\n    return prev;", "    if(lst.size() == 0)\n        return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    for(auto\
    \ it = lst.begin(); it != lst.end(); ++it)\n        if(*it < smallest)\n     \
    \       smallest = *it;\n    return smallest;", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find_if(lst.begin(), lst.end(), [min](long x)\
    \ { return x < min; });\n    if (it == lst.end()) {\n        return std::nullopt;\n\
    \    }\n    return *it;", "    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    auto it =\
    \ std::find(lst.begin(), lst.end(), smallest);\n    if (it == lst.end())\n   \
    \     return std::nullopt;\n    lst.erase(it);\n    return smallest;", "    long\
    \ min = *std::min_element(lst.begin(), lst.end());\n    if (lst.empty())\n   \
    \     return std::nullopt;\n    for (long i : lst) {\n        if (i < min)\n \
    \           min = i;\n    }\n    return min;", "    long min = lst[0];\n    long\
    \ max = lst[0];\n    for (long i : lst) {\n        if (i < min) {\n          \
    \  min = i;\n        } else if (i > max) {\n            max = i;\n        }\n\
    \    }\n    if (min == max) {\n        return std::nullopt;\n    }\n    return\
    \ max;", "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = lst.begin();\n\
    \    auto it2 = lst.begin();\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n\
    \    }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it\
    \ < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n   \
    \     ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n   \
    \     ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n  \
    \  }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it\
    \ < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n   \
    \     ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n   \
    \     ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n  \
    \  }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it\
    \ < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n   \
    \     ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n   \
    \     ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n  \
    \  }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it\
    \ < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n   \
    \     ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n   \
    \     ++it2;\n    }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n  \
    \  }\n    if (*it < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it\
    \ < *it2) {\n        ++it;\n        ++it2;\n    }\n    if (*it < *it2) {\n   \
    \     ++it;\n        ++it2;\n    }\n    if (*it ", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    for (auto it = lst.begin(); it != lst.end(); ++it) {\n    \
    \    if (*it < min) {\n            min = *it;\n        }\n    }\n    return min;",
  "    // Your code here\n    if(lst.empty())\n        return std::nullopt;\n    long\
    \ smallest = *std::min_element(lst.begin(), lst.end());\n    for(auto it = lst.begin();\
    \ it != lst.end(); ++it)\n    {\n        if(*it < smallest)\n        {\n     \
    \       smallest = *it;\n        }\n    }\n    return smallest;", "    if (lst.empty())\
    \ return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end()) return std::nullopt;\n    return *it;", "    // Your\
    \ code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   return second_smallest == smallest ? std::nullopt : second_smallest;", " \
    \   if (lst.empty()) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    auto it = std::find_if(lst.begin(),\
    \ lst.end(), [&smallest](long x) { return x < smallest; });\n    if (it == lst.end())\
    \ {\n        return std::nullopt;\n    }\n    smallest = *it;\n    auto it2 =\
    \ std::find_if(lst.begin(), lst.end(), [&smallest](long x) { return x < smallest;\
    \ });\n    if (it2 == lst.end()) {\n        return std::nullopt;\n    }\n    return\
    \ *it2;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n  \
    \  long index = std::distance(std::begin(lst), std::find(std::begin(lst), std::end(lst),\
    \ smallest));\n    if (index == lst.size() - 1) {\n        return std::nullopt;\n\
    \    }\n    return lst[index + 1];", "    if(lst.empty())\n        return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    for(auto\
    \ it = lst.begin(); it != lst.end(); ++it) {\n        if(*it < smallest)\n   \
    \         smallest = *it;\n    }\n    return smallest;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    return *it;", " \
    \   if (lst.size() == 0)\n        return std::nullopt;\n    auto it = lst.begin();\n\
    \    auto prev = *it;\n    for (++it; it != lst.end(); ++it) {\n        if (*it\
    \ < prev)\n            return std::nullopt;\n        prev = *it;\n    }\n    return\
    \ prev;", "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    long smallest = std::numeric_limits<long>::max();\n    long second_smallest\
    \ = std::numeric_limits<long>::max();\n    for (long i : lst) {\n        if (i\
    \ < smallest) {\n            second_smallest = smallest;\n            smallest\
    \ = i;\n        } else if (i < second_smallest) {\n            second_smallest\
    \ = i;\n        }\n    }\n    return second_smallest == std::numeric_limits<long>::max()\
    \ ? std::nullopt : second_smallest;", "    if (lst.empty()) return std::nullopt;\n\
    \    long min = *lst.begin();\n    for (long i : lst) {\n        if (i < min)\
    \ {\n            min = i;\n        }\n    }\n    return min;", "    if(lst.size()\
    \ == 0)\n        return std::nullopt;\n    long first = *lst.begin();\n    long\
    \ second = first;\n    for(auto it = lst.begin() + 1; it != lst.end(); ++it) {\n\
    \        if(*it < first)\n            second = first;\n        else if(*it < second)\n\
    \            second = *it;\n    }\n    return second;", "    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long max = *std::max_element(lst.begin(), lst.end());\n   \
    \ if (min == max) {\n        return max;\n    }\n    if (min > max) {\n      \
    \  std::swap(min, max);\n    }\n    for (long i = min; i <= max; i++) {\n    \
    \    if (lst.find(i) != lst.end()) {\n            return i;\n        }\n    }\n\
    \    return std::nullopt;", "    if (lst.empty()) return std::nullopt;\n    auto\
    \ it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end()) return\
    \ std::nullopt;\n    return *it;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    for (auto\
    \ it = lst.begin(); it != lst.end(); ++it)\n        if (*it < smallest)\n    \
    \        smallest = *it;\n    return smallest;", "    if (lst.empty()) return\
    \ std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n   \
    \ if (it == lst.end()) return std::nullopt;\n    return *it;", "    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    for (long &i : lst) {\n        if (i < min) {\n           \
    \ min = i;\n        }\n    }\n    return min;", "    if (lst.size() == 0)\n  \
    \      return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end())\n        return std::nullopt;\n    auto val = *it;\n\
    \    lst.erase(it);\n    return val;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    return *it;", "    if(lst.size() == 0) return\
    \ std::nullopt;\n    long smallest = lst[0];\n    long second_smallest = lst[0];\n\
    \    for(long i = 1; i < lst.size(); i++) {\n        if(lst[i] < smallest) {\n\
    \            second_smallest = smallest;\n            smallest = lst[i];\n   \
    \     } else if(lst[i] < second_smallest) {\n            second_smallest = lst[i];\n\
    \        }\n    }\n    return second_smallest;", "    long min = std::numeric_limits<long>::max();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    }\n    }\n    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n\
    \    for (long i : lst) {\n        if (i == min) {\n            return std::nullopt;\n\
    \        }\n    }\n    return min;", "    if (lst.empty()) {\n        return std::nullopt;\n\
    \    }\n    auto it = lst.begin();\n    auto prev = *it;\n    ++it;\n    for (;\
    \ it != lst.end(); ++it) {\n        if (*it < prev) {\n            return prev;\n\
    \        }\n        prev = *it;\n    }\n    return prev;", "    long min = std::numeric_limits<long>::max();\n\
    \    long max = std::numeric_limits<long>::min();\n    for (auto i : lst) {\n\
    \        if (i < min) {\n            min = i;\n        }\n        if (i > max)\
    \ {\n            max = i;\n        }\n    }\n    if (min == max) {\n        return\
    \ std::nullopt;\n    }\n    return std::optional<long>(max);", "    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) {\n        return std::nullopt;\n    }\n\
    \    return *it;", "    if (lst.empty()) return std::nullopt;\n    long first\
    \ = *lst.begin();\n    long second = first;\n    for (auto it = lst.begin() +\
    \ 1; it != lst.end(); ++it) {\n        if (*it < second) {\n            second\
    \ = *it;\n        }\n    }\n    return second;", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    if (second_smallest == smallest) {\n        return std::nullopt;\n    }\n\
    \    return second_smallest;", "    if (lst.empty()) return std::nullopt;\n  \
    \  auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    if (*it == *lst.begin()) return std::nullopt;\n  \
    \  return *it;", "    // Your code here\n    long smallest = std::numeric_limits<long>::max();\n\
    \    for (long i : lst) {\n        if (i < smallest) {\n            smallest =\
    \ i;\n        }\n    }\n    if (smallest == std::numeric_limits<long>::max())\
    \ {\n        return std::nullopt;\n    }\n    for (long i : lst) {\n        if\
    \ (i == smallest) {\n            return i;\n        }\n    }\n    return std::nullopt;"]
stop_tokens:
- "\n}"
