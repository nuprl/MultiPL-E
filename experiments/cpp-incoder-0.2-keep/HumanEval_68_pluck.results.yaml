name: HumanEval_68_pluck
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_of_smalest_value = 0;\n    for (long i = 0; i <\
    \ arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value\
    \ == 0) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n                smalest_index_of_smalest_value = i;\n            } else\
    \ if (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n   \
    \             smalest_index = i;\n                smalest_index_of_smalest_value\
    \ = i;\n            }\n        }\n    }\n    if (smalest_value == 0) {\n     \
    \   return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    result.push_back(smalest_index_of_smalest_value);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpuybj4pyd: /tmp/tmpuybj4pyd.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smalest_index_value %\
    \ 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index\
    \ + 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpya0ilw0x: /tmp/tmpya0ilw0x.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2\
    \ == 0) {\n            if (arr[i] < smalest_value) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp3ka63uy2: /tmp/tmp3ka63uy2.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smallest_index = 0;\n    long smallest_value = 0;\n    long index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smallest_value == 0) {\n                smallest_value\
    \ = arr[i];\n                smallest_index = i;\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n                smallest_index\
    \ = i;\n                index = i;\n            } else if (arr[i] < smallest_value)\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n                smallest_index = i;\n                index = i;\n    \
    \        }\n        }\n    }\n    if (smallest_value == 0) {\n        return {};\n\
    \    }\n    std::vector<long> ans;\n    ans.push_back(smallest_value);\n    ans.push_back(smallest_index);\n\
    \    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n    ans.push_back(index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpzz0mq8er: /tmp/tmpzz0mq8er.cpp:67: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_value, smallest_even_index, smallest_index;\n\
    \    smallest_even_value, smallest_even_index = std::numeric_limits<long>::max(),\
    \ std::numeric_limits<long>::max();\n    smallest_index = std::numeric_limits<long>::max();\n\
    \    for (auto i : arr) {\n        if (i % 2 == 0) {\n            if (smallest_even_value\
    \ < i) {\n                smallest_even_value, smallest_even_index = i, i;\n \
    \           }\n            if (smallest_even_value == i) {\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    if (smallest_even_value == std::numeric_limits<long>::max())\
    \ {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smallest_even_value,\
    \ smallest_even_index);\n    return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvwllvn5c.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpvwllvn5c.cpp:46:62: error: no matching function for call\
    \ to \u2018std::vector<long int>::push_back(long int&, long int&)\u2019\n   46\
    \ |     result.push_back(smallest_even_value, smallest_even_index);\n      | \
    \                                                             ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpvwllvn5c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note:   candidate expects 1 argument, 2 provided\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note:   candidate expects 1 argument, 2 provided\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    long index = 0;\n    for(auto &val: arr){\n        if(val%2 == 0){\n    \
    \        if(smallest_even_count < val){\n                smallest_even_value =\
    \ val;\n                smallest_even_count = val;\n            }\n        }\n\
    \        else{\n            if(smallest_even_count == val){\n                if(smallest_even_value\
    \ < val){\n                    smallest_even_value = val;\n                  \
    \  smallest_even_count = val;\n                    smallest_value = smallest_even_count;\n\
    \                    smallest_index = index;\n                }\n            }\n\
    \            else{\n                if(smallest_even_count < val){\n         \
    \           smallest_even_value = val;\n                    smallest_even_count\
    \ = val;\n                    smallest_value = smallest_even_count;\n        \
    \            smallest_index = index;\n                }\n            }\n     \
    \   }\n        index++;\n    }\n    std::vector<long> result;\n    if(smallest_even_count\
    \ == 0){\n        result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \    }\n    else{\n        result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \        result.push_back(smallest_even_value);\n        result.push_back(smallest_even_count);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp404p1lr7: /tmp/tmp404p1lr7.cpp:77: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_in_arr =\
    \ 0;\n    long smalest_even_index_in_arr_temp = 0;\n    long smalest_even_index_in_arr_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp = 0;\n   \
    \ long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp = 0;\n    long\
    \ smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp = 0;\n    long\
    \ smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n   \
    \ long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnjyuwxbd.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpnjyuwxbd.cpp:47:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   47 |     long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpnjyuwxbd.cpp:46:10: note: \u2018long int smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   46 |     long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpnjyuwxbd.cpp:51:10: error: redeclaration of \u2018long int smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   51 |     long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpnjyuwxbd.cpp:50:10: note: \u2018long int smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   50 |     long smalest_even_index_in_arr_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpnjyuwxbd.cpp:55:1: error: expected initializer before \u2018}\u2019 token\n\
    \   55 | }\n      | ^\n/tmp/tmpnjyuwxbd.cpp:55:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_even = std::numeric_limits<long>::max();\n\
    \    long smallest_index = -1;\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] % 2 == 0) {\n            if (smallest_even > arr[i]) {\n \
    \               smallest_even = arr[i];\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even\
    \ != std::numeric_limits<long>::max()) {\n        result.push_back(smallest_even);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long temp = 0;\n    for (long i = 0; i < arr.size(); i++) {\n    \
    \    if (arr[i] % 2 == 0) {\n            temp = arr[i];\n            if (temp\
    \ < smallest_value) {\n                smallest_value = temp;\n              \
    \  smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmprfj1ws9w: /tmp/tmprfj1ws9w.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2\
    \ == 0) {\n            if (smalest_value == 0) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            } else if (smalest_value\
    \ < arr[i]) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            }\n        }\n    }\n    if (smalest_value == 0) {\n     \
    \   return result;\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpgir2m6mu: /tmp/tmpgir2m6mu.cpp:52: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smallest_value == arr[i]) {\n                smallest_even_value = arr[i];\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_even_value == 0) {\n        return result;\n    }\n\
    \    result.push_back(smallest_even_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp96bfvt09: /tmp/tmp96bfvt09.cpp:52: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       } else if (arr[i] == smalest_value) {\n            if (arr[i] < smalest_index_value)\
    \ {\n                smalest_index_value = arr[i];\n            }\n        }\n\
    \    }\n    std::vector<long> result;\n    if (smalest_index_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp2_ddt42s: /tmp/tmp2_ddt42s.cpp:55: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_index);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpsx6anwfq: /tmp/tmpsx6anwfq.cpp:49: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n  \
    \  ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpt0maq7nw: /tmp/tmpt0maq7nw.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_even = arr[0];\n    long\
    \ smallest_index = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even) {\n     \
    \           smallest_even = arr[i];\n                smallest_index = i;\n   \
    \         }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even\
    \ != 0) {\n        result.push_back(smallest_even);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpqytw2mnu: /tmp/tmpqytw2mnu.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n \
    \               smalest_value = arr[i];\n                smalest_index = i;\n\
    \            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        } else\
    \ {\n            if (smalest_value == 0) {\n                smalest_value = arr[i];\n\
    \                smalest_index2 = i;\n            } else if (smalest_value < arr[i])\
    \ {\n                smalest_value = arr[i];\n                smalest_index2 =\
    \ i;\n            }\n        }\n    }\n    std::vector<long> ans;\n    if (smalest_index\
    \ != 0) {\n        ans.push_back(smalest_value);\n        ans.push_back(smalest_index);\n\
    \    }\n    if (smalest_index2 != 0) {\n        ans.push_back(smalest_value);\n\
    \        ans.push_back(smalest_index2);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpglay1w1i: /tmp/tmpglay1w1i.cpp:65: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value = arr[0];\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeshnvm6e.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpeshnvm6e.cpp:32:10: error: redeclaration of \u2018long\
    \ int smalest_index_value\u2019\n   32 |     long smalest_index_value = arr[0];\n\
    \      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeshnvm6e.cpp:31:10: note: \u2018\
    long int smalest_index_value\u2019 previously declared here\n   31 |     long\
    \ smalest_index_value = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeshnvm6e.cpp:33:10:\
    \ error: redeclaration of \u2018long int smalest_index_value\u2019\n   33 |  \
    \   long smalest_index_value = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeshnvm6e.cpp:31:10: note: \u2018long int smalest_index_value\u2019 previously\
    \ declared here\n   31 |     long smalest_index_value = arr[0];\n      |     \
    \     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeshnvm6e.cpp:34:10: error: redeclaration of\
    \ \u2018long int smalest_index_value\u2019\n   34 |     long smalest_index_value\
    \ = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeshnvm6e.cpp:31:10:\
    \ note: \u2018long int smalest_index_value\u2019 previously declared here\n  \
    \ 31 |     long smalest_index_value = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeshnvm6e.cpp:35:10: error: redeclaration of \u2018long int smalest_index_value\u2019\
    \n   35 |     long smalest_index_value = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeshnvm6e.cpp:31:10: note: \u2018long int smalest_index_value\u2019 previously\
    \ declared here\n   31 |     long smalest_index_value = arr[0];\n      |     \
    \     ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeshnvm6e.cpp:36:10: error: redeclaration of\
    \ \u2018long int smalest_index_value\u2019\n   36 |     long smalest_index_value\
    \ = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpeshnvm6e.cpp:31:10:\
    \ note: \u2018long int smalest_index_value\u2019 previously declared here\n  \
    \ 31 |     long smalest_index_value = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeshnvm6e.cpp:37:10: error: redeclaration of \u2018long int smalest_index_value\u2019\
    \n   37 |     long smalest_index_value = arr[0];\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpeshnvm6e.cpp:31:10: note: \u2018long int smalest_index_value\u2019 previously\
    \ declared her"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_index);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp0qlfz_4t: /tmp/tmp0qlfz_4t.cpp:49: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smallest_value = 0;\n    long smallest_index = 0;\n    long index\
    \ = 0;\n    long value = 0;\n    long even_value = 0;\n    long even_index = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3ou8oclw.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp3ou8oclw.cpp:115:1: error: expected initializer before\
    \ \u2018}\u2019 token\n  115 | }\n      | ^\n/tmp/tmp3ou8oclw.cpp:115:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (smalest_value == 0) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n                smalest_index_value = arr[i];\n\
    \                smalest_index_value2 = arr[i];\n            } else if (smalest_value\
    \ == arr[i]) {\n                smalest_index_value = arr[i];\n              \
    \  smalest_index_value2 = arr[i];\n            } else if (smalest_value < arr[i])\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n                smalest_index_value = arr[i];\n                smalest_index_value2\
    \ = arr[i];\n            }\n        }\n    }\n    if (smalest_value == 0) {\n\
    \        return {};\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    ans.push_back(smalest_index_value);\n\
    \    ans.push_back(smalest_index_value2);\n    return ans;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpdiemj71_: /tmp/tmpdiemj71_.cpp:64: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n  \
    \  ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpohj3quw0: /tmp/tmpohj3quw0.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp6s8pkz5h: /tmp/tmp6s8pkz5h.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long even_value = 0;\n    long even_index = 0;\n    long index = 0;\n\
    \    long value = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3\
    \ = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long\
    \ temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n\
    \    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14\
    \ = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n   \
    \ long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21\
    \ = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n   \
    \ long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28\
    \ = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n   \
    \ long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35\
    \ = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n   \
    \ long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42\
    \ = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n   \
    \ long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49\
    \ = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n   \
    \ long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56\
    \ = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n   \
    \ long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63\
    \ = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n   \
    \ long temp67 = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n    long temp70\
    \ = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n   \
    \ long temp74 = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n    long temp77\
    \ = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n    \n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpr1lktqmd: /tmp/tmpr1lktqmd.cpp:119: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    long max_value = INT_MIN;\n    long max_index = -1;\n\
    \    long sum = 0;\n    for(long i = 0; i < arr.size(); i++) {\n        sum +=\
    \ arr[i];\n        if(sum > max_value) {\n            max_value = sum;\n     \
    \       max_index = i;\n        }\n    }\n    for(long i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] == max_value) {\n            smallest_value = max_value;\n\
    \            smallest_index = max_index;\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp2k8iw4oh: /tmp/tmp2k8iw4oh.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index2\
    \ = 0;\n    long smalest_index3 = 0;\n    long smalest_index4 = 0;\n    long smalest_index5\
    \ = 0;\n    long smalest_index6 = 0;\n    long smalest_index7 = 0;\n    long smalest_index8\
    \ = 0;\n    long smalest_index9 = 0;\n    long smalest_index10 = 0;\n    long\
    \ smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long smalest_index13\
    \ = 0;\n    long smalest_index14 = 0;\n    long smalest_index15 = 0;\n    long\
    \ smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long smalest_index18\
    \ = 0;\n    long smalest_index19 = 0;\n    long smalest_index20 = 0;\n    long\
    \ smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long smalest_index23\
    \ = 0;\n    long smalest_index24 = 0;\n    long smalest_index25 = 0;\n    long\
    \ smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long smalest_index28\
    \ = 0;\n    long smalest_index29 = 0;\n    long smalest_index30 = 0;\n    long\
    \ smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long smalest_index33\
    \ = 0;\n    long smalest_index34 = 0;\n    long smalest_index35 = 0;\n    long\
    \ smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long smalest_index38\
    \ = 0;\n    long smalest_index39 = 0;\n    long smalest_index40 = 0;\n    long\
    \ smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long smalest_index43\
    \ = 0;\n    long smalest_index44 = 0;\n    long smalest_index45 = 0;\n    long\
    \ smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long smalest_index48\
    \ = 0;\n    long smalest_index49 = 0;\n    long smalest_index50 = 0;\n    long\
    \ smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long smalest_index53\
    \ = 0;\n    long smalest_index54 = 0;\n    long smalest_index55 = 0;\n    long\
    \ smalest_index56 = 0;\n    long smalest_\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpoi07ipf2.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpoi07ipf2.cpp:87:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmpoi07ipf2.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long index = 0;\n    long even_value = 0;\n    for (long i = 0; i\
    \ < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            even_value\
    \ = arr[i];\n            index = i;\n        }\n        if (arr[i] < smallest_value)\
    \ {\n            smallest_value = arr[i];\n            smallest_index = index;\n\
    \        }\n    }\n    std::vector<long> result;\n    if (smallest_value == 0)\
    \ {\n        return result;\n    }\n    result.push_back(smallest_value);\n  \
    \  result.push_back(smallest_index);\n    return result;\n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpr0syklts: /tmp/tmpr0syklts.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_of_smalest_value = 0;\n    long smalest_index_of_smalest_value2\
    \ = 0;\n    long smalest_index_of_smalest_value3 = 0;\n    long smalest_index_of_smalest_value4\
    \ = 0;\n    long smalest_index_of_smalest_value5 = 0;\n    long smalest_index_of_smalest_value6\
    \ = 0;\n    long smalest_index_of_smalest_value7 = 0;\n    long smalest_index_of_smalest_value8\
    \ = 0;\n    long smalest_index_of_smalest_value9 = 0;\n    long smalest_index_of_smalest_value10\
    \ = 0;\n    long smalest_index_of_smalest_value11 = 0;\n    long smalest_index_of_smalest_value12\
    \ = 0;\n    long smalest_index_of_smalest_value13 = 0;\n    long smalest_index_of_smalest_value14\
    \ = 0;\n    long smalest_index_of_smalest_value15 = 0;\n    long smalest_index_of_smalest_value16\
    \ = 0;\n    long smalest_index_of_smalest_value17 = 0;\n    long smalest_index_of_smalest_value18\
    \ = 0;\n    long smalest_index_of_smalest_value19 = 0;\n    long smalest_index_of_smalest_value20\
    \ = 0;\n    long smalest_index_of_smalest_value21 = 0;\n    long smalest_index_of_smalest_value22\
    \ = 0;\n    long smalest_index_of_smalest_value23 = 0;\n    long smalest_index_of_smalest_value24\
    \ = 0;\n    long smalest_index_of_smalest_value25 = 0;\n    long smalest_index_of_smalest_value26\
    \ = 0;\n    long smalest_index_of_smalest_value27 = 0;\n    long smalest_index_of_smalest_value28\
    \ = 0;\n    long smalest_index_of_smalest_value29 = 0;\n    long smalest_index_of_smalest_value30\
    \ = 0;\n    long smalest_index_of_smalest_value31 = 0;\n    long smalest_index_of_smalest_value32\
    \ = 0;\n    long smalest_index_of_smalest_value33 = 0;\n    long smalest_index_of_smalest_value34\
    \ = 0;\n    long smalest_index_of_smalest_value35 = 0;\n    long smalest_index_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm_tf291o.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpm_tf291o.cpp:68:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   68 | }\n      | ^\n/tmp/tmpm_tf291o.cpp:68:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_of_smalest_value\
    \ = 0;\n    long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_smalest_value\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmporo13ck7.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmporo13ck7.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmporo13ck7.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0, smalest_index = 0;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value\
    \ == 0 || arr[i] < smalest_value) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpib0c5f16: /tmp/tmpib0c5f16.cpp:50: int main(): Assertion `candidate((std::vector<long>({5,\
    \ 0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_index = 0;\n    long smalest_even_index_value = 0;\n\
    \    long smalest_even_index_index2 = 0;\n    long smalest_even_index_index3 =\
    \ 0;\n    long smalest_even_index_index4 = 0;\n    long smalest_even_index_index5\
    \ = 0;\n    long smalest_even_index_index6 = 0;\n    long smalest_even_index_index7\
    \ = 0;\n    long smalest_even_index_index8 = 0;\n    long smalest_even_index_index9\
    \ = 0;\n    long smalest_even_index_index10 = 0;\n    long smalest_even_index_index11\
    \ = 0;\n    long smalest_even_index_index12 = 0;\n    long smalest_even_index_index13\
    \ = 0;\n    long smalest_even_index_index14 = 0;\n    long smalest_even_index_index15\
    \ = 0;\n    long smalest_even_index_index16 = 0;\n    long smalest_even_index_index17\
    \ = 0;\n    long smalest_even_index_index18 = 0;\n    long smalest_even_index_index19\
    \ = 0;\n    long smalest_even_index_index20 = 0;\n    long smalest_even_index_index21\
    \ = 0;\n    long smalest_even_index_index22 = 0;\n    long smalest_even_index_index23\
    \ = 0;\n    long smalest_even_index_index24 = 0;\n    long smalest_even_index_index25\
    \ = 0;\n    long smalest_even_index_index26 = 0;\n    long smalest_even_index_index27\
    \ = 0;\n    long smalest_even_index_index28 = 0;\n    long smalest_even_index_index29\
    \ = 0;\n    long smalest_even_index_index30 = 0;\n    long smalest_even_index_index31\
    \ = 0;\n    long smalest_even_index_index32 = 0;\n    long smalest_even_index_index33\
    \ = 0;\n    long smalest_even_index_index34 = 0;\n    long smalest_even_index_index35\
    \ = 0;\n    long smalest_even_index_index36 = 0;\n    long smalest_even_index_index37\
    \ = 0;\n    long smalest_even_index_index38 = 0;\n    long smalest_even_index_index39\
    \ = 0;\n    long smalest_even_index_index40 = 0;\n    long smalest_even_index_index41\
    \ = 0;\n    long smalest_even_index_index42 = 0;\n    long smalest_even\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpha58u9gr.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpha58u9gr.cpp:78:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   78 | }\n      | ^\n/tmp/tmpha58u9gr.cpp:78:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_node\
    \ = 0;\n    long even_value = 0;\n    long even_node = 0;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            smalest_even_value\
    \ = arr[i];\n            smalest_even_node = i;\n        }\n    }\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_even_value == arr[i]) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    for\
    \ (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n      \
    \      if (smalest_even_value == arr[i]) {\n                if (smalest_value\
    \ == arr[i]) {\n                    even_value = smalest_value;\n            \
    \        even_node = smalest_even_node;\n                }\n            }\n  \
    \      }\n    }\n    std::vector<long> result;\n    if (smalest_even_node == arr.size()\
    \ - 1) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    else if (smalest_even_node == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    else {\n        result.push_back(even_value);\n\
    \        result.push_back(even_node);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpx1fjofz5: /tmp/tmpx1fjofz5.cpp:80: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::vector<long>())' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    std::vector<long>\
    \ result;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmprs5c3fa5: /tmp/tmprs5c3fa5.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_value_pos = 0;\n\
    \    long smalest_even_index_pos = 0;\n    long smalest_even_value_neg = 0;\n\
    \    long smalest_even_index_neg = 0;\n    long smalest_even_value_zero = 0;\n\
    \    long smalest_even_index_zero = 0;\n    long smalest_even_value_one = 0;\n\
    \    long smalest_even_index_one = 0;\n    long smalest_even_value_two = 0;\n\
    \    long smalest_even_index_two = 0;\n    long smalest_even_value_three = 0;\n\
    \    long smalest_even_index_three = 0;\n    long smalest_even_value_four = 0;\n\
    \    long smalest_even_index_four = 0;\n    long smalest_even_value_five = 0;\n\
    \    long smalest_even_index_five = 0;\n    long smalest_even_value_six = 0;\n\
    \    long smalest_even_index_six = 0;\n    long smalest_even_value_seven = 0;\n\
    \    long smalest_even_index_seven = 0;\n    long smalest_even_value_eight = 0;\n\
    \    long smalest_even_index_eight = 0;\n    long smalest_even_value_ten = 0;\n\
    \    long smalest_even_index_ten = 0;\n    long smalest_even_value_eleven = 0;\n\
    \    long smalest_even_index_eleven = 0;\n    long smalest_even_value_twelve =\
    \ 0;\n    long smalest_even_index_twelve = 0;\n    long smalest_even_value_thirteen\
    \ = 0;\n    long smalest_even_index_thirteen = 0;\n    long smalest_even_value_fourteen\
    \ = 0;\n    long smalest_even_index_fourteen = 0;\n    long smalest_even_value_fifteen\
    \ = 0;\n    long smalest_even_index_fifteen = 0;\n    long smalest_even_value_sixteen\
    \ = 0;\n    long smalest_even_index_sixteen = 0;\n    long smalest_even_value_seventeen\
    \ = 0;\n    long smalest_even_index_seventeen = 0;\n    long smalest_even_value_eighteen\
    \ = 0;\n    long smalest_even_index_eighteen = 0;\n    long smalest_even_value_nineteen\
    \ = 0;\n    long smalest_even_index_nineteen = 0;\n    long smalest_even_value_twenty\
    \ = 0;\n    long smalest_even_index_twenty = 0;\n    \n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpvr_xwnyu: /tmp/tmpvr_xwnyu.cpp:81: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long index = 0;\n    long value = 0;\n    long temp = 0;\n    long\
    \ temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n\
    \    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9\
    \ = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n   \
    \ long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv4xx3jos.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpv4xx3jos.cpp:116:1: error: expected initializer before\
    \ \u2018}\u2019 token\n  116 | }\n      | ^\n/tmp/tmpv4xx3jos.cpp:116:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = 0;\n    for (long i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n    \
    \        smalest_index = i;\n            smalest_index_value = arr[i];\n     \
    \   } else if (arr[i] == smalest_index_value) {\n            smalest_index_value\
    \ = arr[i];\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpk4bt_jbi: /tmp/tmpk4bt_jbi.cpp:49: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value == 0) {\n                smalest_value =\
    \ arr[i];\n                smalest_index = i;\n                smalest_index_value\
    \ = arr[i];\n            } else if (smalest_value == arr[i]) {\n             \
    \   smalest_index_value = arr[i];\n                smalest_index = i;\n      \
    \      } else if (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n                smalest_index_value = arr[i];\n\
    \            }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    result.push_back(smalest_index_value);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp1e_4eyxv: /tmp/tmp1e_4eyxv.cpp:59: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array = 0;\n\
    \    long smalest_even_index_in_array_in_array_in_array_in_array_in_array = 0;\n\
    \    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7k33_s1a.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7k33_s1a.cpp:42:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   42 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7k33_s1a.cpp:41:10: note: \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   41 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7k33_s1a.cpp:51:1: error: expected initializer before \u2018}\u2019 token\n\
    \   51 | }\n      | ^\n/tmp/tmp7k33_s1a.cpp:51:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smalest_index_value %\
    \ 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp7zn08pc9: /tmp/tmp7zn08pc9.cpp:51: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_even = arr[0];\n    long smallest_index\
    \ = arr[0];\n    for (long i : arr) {\n        if (i % 2 == 0) {\n           \
    \ if (smallest_even < i) {\n                smallest_even = i;\n             \
    \   smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_even != 0) {\n        result.push_back(smallest_even);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpy0r415xy: /tmp/tmpy0r415xy.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_even = arr[0];\n    long smallest_index\
    \ = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] %\
    \ 2 == 0) {\n            if (arr[i] < smallest_even) {\n                smallest_even\
    \ = arr[i];\n                smallest_index = i;\n            }\n        } else\
    \ if (arr[i] == smallest_even) {\n            if (arr[i] < smallest_index) {\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smallest_even);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpn8wbs5cg: /tmp/tmpn8wbs5cg.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value_2 = 0;\n\
    \    long smalest_index_value_3 = 0;\n    long smalest_index_value_4 = 0;\n  \
    \  long smalest_index_value_5 = 0;\n    long smalest_index_value_6 = 0;\n    long\
    \ smalest_index_value_7 = 0;\n    long smalest_index_value_8 = 0;\n    long smalest_index_value_9\
    \ = 0;\n    long smalest_index_value_10 = 0;\n    long smalest_index_value_11\
    \ = 0;\n    long smalest_index_value_12 = 0;\n    long smalest_index_value_13\
    \ = 0;\n    long smalest_index_value_14 = 0;\n    long smalest_index_value_15\
    \ = 0;\n    long smalest_index_value_16 = 0;\n    long smalest_index_value_17\
    \ = 0;\n    long smalest_index_value_18 = 0;\n    long smalest_index_value_19\
    \ = 0;\n    long smalest_index_value_20 = 0;\n    long smalest_index_value_21\
    \ = 0;\n    long smalest_index_value_22 = 0;\n    long smalest_index_value_23\
    \ = 0;\n    long smalest_index_value_24 = 0;\n    long smalest_index_value_25\
    \ = 0;\n    long smalest_index_value_26 = 0;\n    long smalest_index_value_27\
    \ = 0;\n    long smalest_index_value_28 = 0;\n    long smalest_index_value_29\
    \ = 0;\n    long smalest_index_value_30 = 0;\n    long smalest_index_value_31\
    \ = 0;\n    long smalest_index_value_32 = 0;\n    long smalest_index_value_33\
    \ = 0;\n    long smalest_index_value_34 = 0;\n    long smalest_index_value_35\
    \ = 0;\n    long smalest_index_value_36 = 0;\n    long smalest_index_value_37\
    \ = 0;\n    long smalest_index_value_38 = 0;\n    long smalest_index_value_39\
    \ = 0;\n    long smalest_index_value_40 = 0;\n    long smalest_index_value_41\
    \ = 0;\n    long smalest_index_value_42 = 0;\n    long smalest_index_value_43\
    \ = 0;\n    long smalest_index_value_44 = 0;\n    long smalest_index_value_45\
    \ = 0;\n    long smalest_index_value_46 = 0;\n    long smalest_index_value_47\
    \ = 0;\n    long smalest_index_value_48 = 0;\n    long smalest_index_value_49\
    \ = 0;\n    long smalest_index_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpd4mt9e09.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpd4mt9e09.cpp:82:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmpd4mt9e09.cpp:82:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    long index = 0;\n    long value = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            value\
    \ = arr[i];\n            index = i;\n        }\n    }\n    if (value == 0) {\n\
    \        return {};\n    }\n    for (long i = 0; i < arr.size(); i++) {\n    \
    \    if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_value) {\n    \
    \            smallest_value = arr[i];\n                smallest_index = index;\n\
    \            }\n        }\n    }\n    return {smallest_value, smallest_index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp577qlfc4: /tmp/tmp577qlfc4.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smalest_index_value %\
    \ 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index\
    \ + 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpm2iyxktg: /tmp/tmpm2iyxktg.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp8zue7p2x: /tmp/tmp8zue7p2x.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_count = 0;\n    long smalest_even_index_count_max\
    \ = 0;\n    long smalest_even_index_count_min = 0;\n    long smalest_even_index_count_sum\
    \ = 0;\n    long smalest_even_index_count_sum2 = 0;\n    long smalest_even_index_count_sum3\
    \ = 0;\n    long smalest_even_index_count_sum4 = 0;\n    long smalest_even_index_count_sum5\
    \ = 0;\n    long smalest_even_index_count_sum6 = 0;\n    long smalest_even_index_count_sum7\
    \ = 0;\n    long smalest_even_index_count_sum8 = 0;\n    long smalest_even_index_count_sum9\
    \ = 0;\n    long smalest_even_index_count_sum10 = 0;\n    long smalest_even_index_count_sum11\
    \ = 0;\n    long smalest_even_index_count_sum12 = 0;\n    long smalest_even_index_count_sum13\
    \ = 0;\n    long smalest_even_index_count_sum14 = 0;\n    long smalest_even_index_count_sum15\
    \ = 0;\n    long smalest_even_index_count_sum16 = 0;\n    long smalest_even_index_count_sum17\
    \ = 0;\n    long smalest_even_index_count_sum18 = 0;\n    long smalest_even_index_count_sum19\
    \ = 0;\n    long smalest_even_index_count_sum20 = 0;\n    long smalest_even_index_count_sum21\
    \ = 0;\n    long smalest_even_index_count_sum22 = 0;\n    long smalest_even_index_count_sum23\
    \ = 0;\n    long smalest_even_index_count_sum24 = 0;\n    long smalest_even_index_count_sum25\
    \ = 0;\n    long smalest_even_index_count_sum26 = 0;\n    long smalest_even_index_count_sum27\
    \ = 0;\n    long smalest_even_index_count_sum28 = 0;\n    long smalest_even_index_count_sum29\
    \ = 0;\n    long smalest_even_index_count_sum30 = 0;\n    long smalest_even_index_count_sum31\
    \ = 0;\n    long smalest_even_index_count_sum32 = 0;\n    long smalest_even_index_count_sum33\
    \ = 0;\n    long smalest_even_index_count_sum34 = 0;\n    long smalest_even_index_count_sum35\
    \ = 0;\n    long smalest_even_index_count_sum36 = 0;\n    long smalest_even_index_count_sum37\
    \ = 0;\n    long smale\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp14l8e50g.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp14l8e50g.cpp:75:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   75 | }\n      | ^\n/tmp/tmp14l8e50g.cpp:75:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_count = 0;\n    long smalest_even_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index2 = 0;\n    long smalest_even_index_count_index3\
    \ = 0;\n    long smalest_even_index_count_index4 = 0;\n    long smalest_even_index_count_index5\
    \ = 0;\n    long smalest_even_index_count_index6 = 0;\n    long smalest_even_index_count_index7\
    \ = 0;\n    long smalest_even_index_count_index8 = 0;\n    long smalest_even_index_count_index9\
    \ = 0;\n    long smalest_even_index_count_index10 = 0;\n    long smalest_even_index_count_index11\
    \ = 0;\n    long smalest_even_index_count_index12 = 0;\n    long smalest_even_index_count_index13\
    \ = 0;\n    long smalest_even_index_count_index14 = 0;\n    long smalest_even_index_count_index15\
    \ = 0;\n    long smalest_even_index_count_index16 = 0;\n    long smalest_even_index_count_index17\
    \ = 0;\n    long smalest_even_index_count_index18 = 0;\n    long smalest_even_index_count_index19\
    \ = 0;\n    long smalest_even_index_count_index20 = 0;\n    long smalest_even_index_count_index21\
    \ = 0;\n    long smalest_even_index_count_index22 = 0;\n    long smalest_even_index_count_index23\
    \ = 0;\n    long smalest_even_index_count_index24 = 0;\n    long smalest_even_index_count_index25\
    \ = 0;\n    long smalest_even_index_count_index26 = 0;\n    long smalest_even_index_count_index27\
    \ = 0;\n    long smalest_even_index_count_index28 = 0;\n    long smalest_even_index_count_index29\
    \ = 0;\n    long smalest_even_index_count_index30 = 0;\n    long smalest_even_index_count_index31\
    \ = 0;\n    long smalest_even_index_count_index32 = 0;\n    long smalest_even_index_count_index33\
    \ = 0;\n    long smalest_even_index_count_index34 = 0;\n    long smalest_even_index_count_index35\
    \ = 0;\n    long smalest_even_index_count_index36 = 0;\n    long smalest_even_index_count_index37\
    \ = 0;\n    long smalest_even_index_count_index38 = 0;\n    long smalest_even_index_count_index39\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpfb55o7kv: /tmp/tmpfb55o7kv.cpp:78: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value=0;\n    long smalest_index=0;\n\
    \    long smalest_index2=0;\n    long smalest_index3=0;\n    long smalest_index4=0;\n\
    \    long smalest_index5=0;\n    long smalest_index6=0;\n    long smalest_index7=0;\n\
    \    long smalest_index8=0;\n    long smalest_index9=0;\n    long smalest_index10=0;\n\
    \    long smalest_index11=0;\n    long smalest_index12=0;\n    long smalest_index13=0;\n\
    \    long smalest_index14=0;\n    long smalest_index15=0;\n    long smalest_index16=0;\n\
    \    long smalest_index17=0;\n    long smalest_index18=0;\n    long smalest_index19=0;\n\
    \    long smalest_index20=0;\n    long smalest_index21=0;\n    long smalest_index22=0;\n\
    \    long smalest_index23=0;\n    long smalest_index24=0;\n    long smalest_index25=0;\n\
    \    long smalest_index26=0;\n    long smalest_index27=0;\n    long smalest_index28=0;\n\
    \    long smalest_index29=0;\n    long smalest_index30=0;\n    long smalest_index31=0;\n\
    \    long smalest_index32=0;\n    long smalest_index33=0;\n    long smalest_index34=0;\n\
    \    long smalest_index35=0;\n    long smalest_index36=0;\n    long smalest_index37=0;\n\
    \    long smalest_index38=0;\n    long smalest_index39=0;\n    long smalest_index40=0;\n\
    \    long smalest_index41=0;\n    long smalest_index42=0;\n    long smalest_index43=0;\n\
    \    long smalest_index44=0;\n    long smalest_index45=0;\n    long smalest_index46=0;\n\
    \    long smalest_index47=0;\n    long smalest_index48=0;\n    long smalest_index49=0;\n\
    \    long smalest_index50=0;\n    long smalest_index51=0;\n    long smalest_index52=0;\n\
    \    long smalest_index53=0;\n    long smalest_index54=0;\n    long smalest_index55=0;\n\
    \    long smale\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy565sgrz.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpy565sgrz.cpp:87:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmpy565sgrz.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0, smallest_index = 0;\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2\
    \ == 0) {\n            if (arr[i] < smalest_value) {\n                smalest_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    if (smalest_value == 0) {\n        return result;\n    }\n    result.push_back(smalest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp4lcqqnw1: /tmp/tmp4lcqqnw1.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_count =\
    \ 0;\n    long smalest_even_index_count_max = 0;\n    long smalest_even_index_count_min\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long smalest_even_index_count_min_max\
    \ = 0;\n    long smalest_even_index_count_min_max = 0;\n    long sm\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsxdorvd0.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpsxdorvd0.cpp:37:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_count_min_max\u2019\n   37 |     long smalest_even_index_count_min_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:36:10:\
    \ note: \u2018long int smalest_even_index_count_min_max\u2019 previously declared\
    \ here\n   36 |     long smalest_even_index_count_min_max = 0;\n      |      \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:38:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_min_max\u2019\n   38 |     long smalest_even_index_count_min_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:36:10:\
    \ note: \u2018long int smalest_even_index_count_min_max\u2019 previously declared\
    \ here\n   36 |     long smalest_even_index_count_min_max = 0;\n      |      \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:39:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_min_max\u2019\n   39 |     long smalest_even_index_count_min_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:36:10:\
    \ note: \u2018long int smalest_even_index_count_min_max\u2019 previously declared\
    \ here\n   36 |     long smalest_even_index_count_min_max = 0;\n      |      \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:40:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_min_max\u2019\n   40 |     long smalest_even_index_count_min_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:36:10:\
    \ note: \u2018long int smalest_even_index_count_min_max\u2019 previously declared\
    \ here\n   36 |     long smalest_even_index_count_min_max = 0;\n      |      \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:41:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_min_max\u2019\n   41 |     long smalest_even_index_count_min_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpsxdorvd0.cpp:36:10:\
    \ note: \u2018long int smalest_even_index_count_min_max\u2019 previously declared\
    \ here\n   36 |     long sma"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_node = 0;\n  \
    \  long even_value = 0;\n    long even_node = 0;\n    long even_index = 0;\n \
    \   long even_smallest_value = 0;\n    long even_smallest_index = 0;\n    long\
    \ even_smallest_even_value = 0;\n    long even_smallest_even_node = 0;\n    long\
    \ even_smallest_even_node_index = 0;\n    long even_smallest_even_node_index2\
    \ = 0;\n    long even_smallest_even_node_index3 = 0;\n    long even_smallest_even_node_index4\
    \ = 0;\n    long even_smallest_even_node_index5 = 0;\n    long even_smallest_even_node_index6\
    \ = 0;\n    long even_smallest_even_node_index7 = 0;\n    long even_smallest_even_node_index8\
    \ = 0;\n    long even_smallest_even_node_index9 = 0;\n    long even_smallest_even_node_index10\
    \ = 0;\n    long even_smallest_even_node_index11 = 0;\n    long even_smallest_even_node_index12\
    \ = 0;\n    long even_smallest_even_node_index13 = 0;\n    long even_smallest_even_node_index14\
    \ = 0;\n    long even_smallest_even_node_index15 = 0;\n    long even_smallest_even_node_index16\
    \ = 0;\n    long even_smallest_even_node_index17 = 0;\n    long even_smallest_even_node_index18\
    \ = 0;\n    long even_smallest_even_node_index19 = 0;\n    long even_smallest_even_node_index20\
    \ = 0;\n    long even_smallest_even_node_index21 = 0;\n    long even_smallest_even_node_index22\
    \ = 0;\n    long even_smallest_even_node_index23 = 0;\n    long even_smallest_even_node_index24\
    \ = 0;\n    long even_smallest_even_node_index25 = 0;\n    long even_smallest_even_node_index26\
    \ = 0;\n    long even_smallest_even_node_index27 = 0;\n    long even_smallest_even_node_index28\
    \ = 0;\n    long even_smallest_even_node_index29 = 0;\n    long even_smallest_even_node_index30\
    \ = 0;\n    long even_smallest_even_node_index31 = 0;\n    long even_smallest_even_node_index32\
    \ = 0;\n    long even\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgt946j18.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpgt946j18.cpp:74:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmpgt946j18.cpp:74:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even = arr[0];\n    long smallest_index = arr[0];\n\
    \    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (arr[i] < smallest_even) {\n                smallest_even = arr[i];\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_even != 0) {\n        result.push_back(smallest_even);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpbp69ivdb: /tmp/tmpbp69ivdb.cpp:49: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpxll1hgdh: /tmp/tmpxll1hgdh.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \        result.push_back(smalest_index + 1);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp1gjdmdga: /tmp/tmp1gjdmdga.cpp:51: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ largest_value = arr[0];\n    long largest_index = 0;\n    for (long i = 1; i\
    \ < arr.size(); i++) {\n        if (arr[i] > largest_value) {\n            largest_value\
    \ = arr[i];\n            largest_index = i;\n        }\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0)\
    \ {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_index);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp2embv888: /tmp/tmp2embv888.cpp:55: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpjersosd2: /tmp/tmpjersosd2.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_index =\
    \ 0;\n    long smalest_even_index_index_index = 0;\n    long smalest_even_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index = 0;\n    long smalest_even_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index = 0;\n\
    \    long smalest_even_index_index_index_index_index_index_index_index = 0;\n\
    \    long smalest_even_index_index_index_index_index_index_index_index_index =\
    \ 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long sm\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpesidya5g.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpesidya5g.cpp:45:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   45 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpesidya5g.cpp:44:10: note: \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \ previously declared here\n   44 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpesidya5g.cpp:46:10: error: redeclaration of \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   46 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpesidya5g.cpp:44:10: note: \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \ previously declared here\n   44 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpesidya5g.cpp:49:10: error: redeclaration of \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   49 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpesidya5g.cpp:48:10: note: \u2018"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    long smalest_index_value3 = 0;\n    long smalest_index_value4 = 0;\n    long\
    \ smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n    long smalest_index_value7\
    \ = 0;\n    long smalest_index_value8 = 0;\n    long smalest_index_value9 = 0;\n\
    \    long smalest_index_value10 = 0;\n    long smalest_index_value11 = 0;\n  \
    \  long smalest_index_value12 = 0;\n    long smalest_index_value13 = 0;\n    long\
    \ smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n    long smalest_index_value16\
    \ = 0;\n    long smalest_index_value17 = 0;\n    long smalest_index_value18 =\
    \ 0;\n    long smalest_index_value19 = 0;\n    long smalest_index_value20 = 0;\n\
    \    long smalest_index_value21 = 0;\n    long smalest_index_value22 = 0;\n  \
    \  long smalest_index_value23 = 0;\n    long smalest_index_value24 = 0;\n    long\
    \ smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n    long smalest_index_value27\
    \ = 0;\n    long smalest_index_value28 = 0;\n    long smalest_index_value29 =\
    \ 0;\n    long smalest_index_value30 = 0;\n    long smalest_index_value31 = 0;\n\
    \    long smalest_index_value32 = 0;\n    long smalest_index_value33 = 0;\n  \
    \  long smalest_index_value34 = 0;\n    long smalest_index_value35 = 0;\n    long\
    \ smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n    long smalest_index_value38\
    \ = 0;\n    long smalest_index_value39 = 0;\n    long smalest_index_value40 =\
    \ 0;\n    long smalest_index_value41 = 0;\n    long smalest_index_value42 = 0;\n\
    \    long smalest_index_value43 = 0;\n    long smalest_index_value44 = 0;\n  \
    \  long smalest_index_value45 = 0;\n    long smalest_index_value46 = 0;\n    long\
    \ smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n    long smalest_index_value49\
    \ = 0;\n    long smalest_index_value\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpb21fw5c0.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpb21fw5c0.cpp:82:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmpb21fw5c0.cpp:82:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = arr[0];\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \         smalest_index_value = arr[i];\n            smalest_index_value2 = arr[i];\n\
    \        }\n        else if (arr[i] == smalest_value) {\n            if (arr[i]\
    \ < smalest_index_value) {\n                smalest_index_value = arr[i];\n  \
    \              smalest_index_value2 = arr[i];\n            }\n        }\n    \
    \    else if (arr[i] > smalest_value) {\n            smalest_index_value = arr[i];\n\
    \            smalest_index_value2 = arr[i];\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    ans.push_back(smalest_index_value);\n    ans.push_back(smalest_index_value2);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpfrxmygpo: /tmp/tmpfrxmygpo.cpp:61: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       } else if (arr[i] == smalest_value) {\n            if (arr[i] < smalest_index_value)\
    \ {\n                smalest_index_value = arr[i];\n            }\n        }\n\
    \    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpbvnflivl: /tmp/tmpbvnflivl.cpp:51: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smallest_even_value = 0;\n   \
    \ long smallest_index = 0;\n    long smallest_value = 0;\n    long smallest_index2\
    \ = 0;\n    long smallest_value2 = 0;\n    long smallest_index3 = 0;\n    long\
    \ smallest_value3 = 0;\n    long smallest_index4 = 0;\n    long smallest_value4\
    \ = 0;\n    long smallest_index5 = 0;\n    long smallest_value5 = 0;\n    long\
    \ smallest_index6 = 0;\n    long smallest_value6 = 0;\n    long smallest_index7\
    \ = 0;\n    long smallest_value7 = 0;\n    long smallest_index8 = 0;\n    long\
    \ smallest_value8 = 0;\n    long smallest_index9 = 0;\n    long smallest_value9\
    \ = 0;\n    long smallest_index10 = 0;\n    long smallest_value10 = 0;\n    long\
    \ smallest_index11 = 0;\n    long smallest_value11 = 0;\n    long smallest_index12\
    \ = 0;\n    long smallest_value12 = 0;\n    long smallest_index13 = 0;\n    long\
    \ smallest_value13 = 0;\n    long smallest_index14 = 0;\n    long smallest_value14\
    \ = 0;\n    long smallest_index15 = 0;\n    long smallest_value15 = 0;\n    long\
    \ smallest_index16 = 0;\n    long smallest_value16 = 0;\n    long smallest_index17\
    \ = 0;\n    long smallest_value17 = 0;\n    long smallest_index18 = 0;\n    long\
    \ smallest_value18 = 0;\n    long smallest_index19 = 0;\n    long smallest_value19\
    \ = 0;\n    long smallest_index20 = 0;\n    long smallest_value20 = 0;\n    long\
    \ smallest_index21 = 0;\n    long smallest_value21 = 0;\n    long smallest_index22\
    \ = 0;\n    long smallest_value22 = 0;\n    long smallest_index23 = 0;\n    long\
    \ smallest_value23 = 0;\n    long smallest_index24 = 0;\n    long smallest_value24\
    \ = 0;\n    long smallest_index25 = 0;\n    long smallest_value25 = 0;\n    long\
    \ smallest_index26 = 0;\n    long smallest_value26 = 0;\n    long smallest_index27\
    \ = 0;\n    long smallest_value27 = 0;\n    long smallest_index28 = 0;\n    long\
    \ smallest_value28 = 0;\n    long smallest_index29 = 0;\n    long smallest_value29\
    \ = 0;\n    long smallest_index30 = 0;\n    long smallest_value30 = 0;\n    long\
    \ smallest_index31 = 0;\n    long smallest_value31 = 0;\n    long smallest_index32\
    \ = 0;\n    long smallest_value\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp96ueumat.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp96ueumat.cpp:95:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   95 | }\n      | ^\n/tmp/tmp96ueumat.cpp:95:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmphc8aiwkj.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmphc8aiwkj.cpp:36:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_in_array_in_array\u2019\n   36 |     long smalest_even_index_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphc8aiwkj.cpp:35:10:\
    \ note: \u2018long int smalest_even_index_in_array_in_array\u2019 previously declared\
    \ here\n   35 |     long smalest_even_index_in_array_in_array = 0;\n      |  \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphc8aiwkj.cpp:37:10: error:\
    \ redeclaration of \u2018long int smalest_even_index_in_array_in_array\u2019\n\
    \   37 |     long smalest_even_index_in_array_in_array = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphc8aiwkj.cpp:35:10: note: \u2018\
    long int smalest_even_index_in_array_in_array\u2019 previously declared here\n\
    \   35 |     long smalest_even_index_in_array_in_array = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphc8aiwkj.cpp:38:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_in_array_in_array\u2019\n   38 |     long\
    \ smalest_even_index_in_array_in_array = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphc8aiwkj.cpp:35:10: note: \u2018long int smalest_even_index_in_array_in_array\u2019\
    \ previously declared here\n   35 |     long smalest_even_index_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphc8aiwkj.cpp:39:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_in_array_in_array\u2019\
    \n   39 |     long smalest_even_index_in_array_in_array = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphc8aiwkj.cpp:35:10: note: \u2018\
    long int smalest_even_index_in_array_in_array\u2019 previously declared here\n\
    \   35 |     long smalest_even_index_in_array_in_array = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphc8aiwkj.cpp:40:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_in_array_in_array\u2019\n   40 |     long\
    \ smalest_even_index_in_array_in_array = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphc8aiwk"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count\
    \ = 0;\n    long index = 0;\n    for(long i = 0; i < arr.size(); i++){\n     \
    \   if(arr[i] % 2 == 0){\n            smallest_value = arr[i];\n            smallest_index\
    \ = i;\n            smallest_even_value = arr[i];\n            smallest_even_count\
    \ = 1;\n        }\n        else if(arr[i] % 2 == 0 && arr[i] < smallest_even_value){\n\
    \            smallest_value = arr[i];\n            smallest_index = i;\n     \
    \       smallest_even_value = arr[i];\n            smallest_even_count = 1;\n\
    \        }\n        else if(arr[i] % 2 == 0 && arr[i] == smallest_even_value){\n\
    \            smallest_even_count++;\n        }\n        else if(arr[i] % 2 !=\
    \ 0 && arr[i] < smallest_even_value){\n            smallest_value = arr[i];\n\
    \            smallest_index = i;\n            smallest_even_value = arr[i];\n\
    \            smallest_even_count = 1;\n        }\n        else if(arr[i] % 2 !=\
    \ 0 && arr[i] == smallest_even_value){\n            smallest_even_count++;\n \
    \       }\n        else if(arr[i] % 2 == 0 && arr[i] != smallest_even_value){\n\
    \            smallest_even_count++;\n        }\n        else if(arr[i] % 2 !=\
    \ 0 && arr[i] != smallest_even_value){\n            smallest_even_count++;\n \
    \       }\n    }\n    std::vector<long> ans;\n    ans.push_back(smallest_value);\n\
    \    ans.push_back(smallest_index);\n    ans.push_back(smallest_even_count);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmplv4v5mzf: /tmp/tmplv4v5mzf.cpp:75: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_of_smalest_value = 0;\n    long smalest_index_of_smalest_value2\
    \ = 0;\n    long smalest_index_of_smalest_value3 = 0;\n    long smalest_index_of_smalest_value4\
    \ = 0;\n    long smalest_index_of_smalest_value5 = 0;\n    long smalest_index_of_smalest_value6\
    \ = 0;\n    long smalest_index_of_smalest_value7 = 0;\n    long smalest_index_of_smalest_value8\
    \ = 0;\n    long smalest_index_of_smalest_value9 = 0;\n    long smalest_index_of_smalest_value10\
    \ = 0;\n    long smalest_index_of_smalest_value11 = 0;\n    long smalest_index_of_smalest_value12\
    \ = 0;\n    long smalest_index_of_smalest_value13 = 0;\n    long smalest_index_of_smalest_value14\
    \ = 0;\n    long smalest_index_of_smalest_value15 = 0;\n    long smalest_index_of_smalest_value16\
    \ = 0;\n    long smalest_index_of_smalest_value17 = 0;\n    long smalest_index_of_smalest_value18\
    \ = 0;\n    long smalest_index_of_smalest_value19 = 0;\n    long smalest_index_of_smalest_value20\
    \ = 0;\n    long smalest_index_of_smalest_value21 = 0;\n    long smalest_index_of_smalest_value22\
    \ = 0;\n    long smalest_index_of_smalest_value23 = 0;\n    long smalest_index_of_smalest_value24\
    \ = 0;\n    long smalest_index_of_smalest_value25 = 0;\n    long smalest_index_of_smalest_value26\
    \ = 0;\n    long smalest_index_of_smalest_value27 = 0;\n    long smalest_index_of_smalest_value28\
    \ = 0;\n    long smalest_index_of_smalest_value29 = 0;\n    long smalest_index_of_smalest_value30\
    \ = 0;\n    long smalest_index_of_smalest_value31 = 0;\n    long smalest_index_of_smalest_value32\
    \ = 0;\n    long smalest_index_of_smalest_value33 = 0;\n    long smalest_index_of_smalest_value34\
    \ = 0;\n    long smalest_index_of_smalest_value35 = 0;\n    long smalest_index_of_smalest_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp80mvmdds.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp80mvmdds.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmp80mvmdds.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0, smalest_index = 0;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value\
    \ == 0) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpowm0m725: /tmp/tmpowm0m725.cpp:50: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmphjvk9v4e: /tmp/tmphjvk9v4e.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpl0zhajwn: /tmp/tmpl0zhajwn.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    long smalest_index_value3 = 0;\n    long smalest_index_value4 = 0;\n    long\
    \ smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n    long smalest_index_value7\
    \ = 0;\n    long smalest_index_value8 = 0;\n    long smalest_index_value9 = 0;\n\
    \    long smalest_index_value10 = 0;\n    long smalest_index_value11 = 0;\n  \
    \  long smalest_index_value12 = 0;\n    long smalest_index_value13 = 0;\n    long\
    \ smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n    long smalest_index_value16\
    \ = 0;\n    long smalest_index_value17 = 0;\n    long smalest_index_value18 =\
    \ 0;\n    long smalest_index_value19 = 0;\n    long smalest_index_value20 = 0;\n\
    \    long smalest_index_value21 = 0;\n    long smalest_index_value22 = 0;\n  \
    \  long smalest_index_value23 = 0;\n    long smalest_index_value24 = 0;\n    long\
    \ smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n    long smalest_index_value27\
    \ = 0;\n    long smalest_index_value28 = 0;\n    long smalest_index_value29 =\
    \ 0;\n    long smalest_index_value30 = 0;\n    long smalest_index_value31 = 0;\n\
    \    long smalest_index_value32 = 0;\n    long smalest_index_value33 = 0;\n  \
    \  long smalest_index_value34 = 0;\n    long smalest_index_value35 = 0;\n    long\
    \ smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n    long smalest_index_value38\
    \ = 0;\n    long smalest_index_value39 = 0;\n    long smalest_index_value40 =\
    \ 0;\n    long smalest_index_value41 = 0;\n    long smalest_index_value42 = 0;\n\
    \    long smalest_index_value43 = 0;\n    long smalest_index_value44 = 0;\n  \
    \  long smalest_index_value45 = 0;\n    long smalest_index_value46 = 0;\n    long\
    \ smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n    long smalest_index_value49\
    \ = 0;\n    long smalest_index_value\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp05akly95.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp05akly95.cpp:82:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmp05akly95.cpp:82:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value == 0) {\n                smalest_value =\
    \ arr[i];\n                smalest_index = i;\n                smalest_index_value\
    \ = arr[i];\n            } else if (smalest_index_value > arr[i]) {\n        \
    \        smalest_value = arr[i];\n                smalest_index = i;\n       \
    \         smalest_index_value = arr[i];\n            }\n        }\n    }\n   \
    \ if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp2xocfvaj: /tmp/tmp2xocfvaj.cpp:58: int main(): Assertion `candidate((std::vector<long>({5,\
    \ 0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smalest_index_value %\
    \ 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index\
    \ + 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp57m3zuxr: /tmp/tmp57m3zuxr.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value == 0) {\n                smalest_value = arr[i];\n          \
    \      smalest_index = i;\n            } else if (smalest_value < arr[i]) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp5ruv6zk_: /tmp/tmp5ruv6zk_.cpp:52: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_of_smallest_value = 0;\n    long smalest_index_of_smallest_value2\
    \ = 0;\n    long smalest_index_of_smallest_value3 = 0;\n    long smalest_index_of_smallest_value4\
    \ = 0;\n    long smalest_index_of_smallest_value5 = 0;\n    long smalest_index_of_smallest_value6\
    \ = 0;\n    long smalest_index_of_smallest_value7 = 0;\n    long smalest_index_of_smallest_value8\
    \ = 0;\n    long smalest_index_of_smallest_value9 = 0;\n    long smalest_index_of_smallest_value10\
    \ = 0;\n    long smalest_index_of_smallest_value11 = 0;\n    long smalest_index_of_smallest_value12\
    \ = 0;\n    long smalest_index_of_smallest_value13 = 0;\n    long smalest_index_of_smallest_value14\
    \ = 0;\n    long smalest_index_of_smallest_value15 = 0;\n    long smalest_index_of_smallest_value16\
    \ = 0;\n    long smalest_index_of_smallest_value17 = 0;\n    long smalest_index_of_smallest_value18\
    \ = 0;\n    long smalest_index_of_smallest_value19 = 0;\n    long smalest_index_of_smallest_value20\
    \ = 0;\n    long smalest_index_of_smallest_value21 = 0;\n    long smalest_index_of_smallest_value22\
    \ = 0;\n    long smalest_index_of_smallest_value23 = 0;\n    long smalest_index_of_smallest_value24\
    \ = 0;\n    long smalest_index_of_smallest_value25 = 0;\n    long smalest_index_of_smallest_value26\
    \ = 0;\n    long smalest_index_of_smallest_value27 = 0;\n    long smalest_index_of_smallest_value28\
    \ = 0;\n    long smalest_index_of_smallest_value29 = 0;\n    long smalest_index_of_smallest_value30\
    \ = 0;\n    long smalest_index_of_smallest_value31 = 0;\n    long smalest_index_of_smallest_value32\
    \ = 0;\n    long smalest_index_of_smallest_value33 = 0;\n    long smalest_index_of_smallest_value34\
    \ = 0;\n    long smalest_index_of_smallest_value35 = 0;\n    long smalest_index_of_smallest_value36\
    \ = 0;\n    long smalest_index_of_smallest_value37 = 0;\n    long smalest_index_of_smallest_value38\
    \ = 0;\n    long sm\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpicu21d52.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpicu21d52.cpp:71:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   71 | }\n      | ^\n/tmp/tmpicu21d52.cpp:71:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value=0;\n    long smalest_index=0;\n\
    \    long smallest_value=arr[0];\n    long smallest_index=0;\n    for(long i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0){\n            if(arr[i]<smallest_value){\n          \
    \      smallest_value=arr[i];\n                smallest_index=i;\n           \
    \ }\n        }\n        else{\n            if(arr[i]<smallest_value){\n      \
    \          smalest_value=arr[i];\n                smalest_index=i;\n         \
    \   }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpr1xeoiw_: /tmp/tmpr1xeoiw_.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long index\
    \ = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0) {\n            if (smalest_value\
    \ == 0) {\n                smalest_value = i;\n                smalest_index =\
    \ index;\n            } else {\n                if (i < smalest_value) {\n   \
    \                 smalest_value = i;\n                    smalest_index = index;\n\
    \                }\n            }\n            index++;\n        }\n    }\n  \
    \  if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp2hbh3f_s: /tmp/tmp2hbh3f_s.cpp:57: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpohfznw_o: /tmp/tmpohfznw_o.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_count =\
    \ 0;\n    long smalest_even_index_count_max = 0;\n    long smalest_even_index_count_min\
    \ = 0;\n    long smalest_even_index_count_min_index = 0;\n    long smalest_even_index_count_max_index\
    \ = 0;\n    long smalest_even_index_count_min_index2 = 0;\n    long smalest_even_index_count_max_index2\
    \ = 0;\n    long smalest_even_index_count_min_index3 = 0;\n    long smalest_even_index_count_max_index3\
    \ = 0;\n    long smalest_even_index_count_min_index4 = 0;\n    long smalest_even_index_count_max_index4\
    \ = 0;\n    long smalest_even_index_count_min_index5 = 0;\n    long smalest_even_index_count_max_index5\
    \ = 0;\n    long smalest_even_index_count_min_index6 = 0;\n    long smalest_even_index_count_max_index6\
    \ = 0;\n    long smalest_even_index_count_min_index7 = 0;\n    long smalest_even_index_count_max_index7\
    \ = 0;\n    long smalest_even_index_count_min_index8 = 0;\n    long smalest_even_index_count_max_index8\
    \ = 0;\n    long smalest_even_index_count_min_index9 = 0;\n    long smalest_even_index_count_max_index9\
    \ = 0;\n    long smalest_even_index_count_min_index10 = 0;\n    long smalest_even_index_count_max_index10\
    \ = 0;\n    long smalest_even_index_count_min_index11 = 0;\n    long smalest_even_index_count_max_index11\
    \ = 0;\n    long smalest_even_index_count_min_index12 = 0;\n    long smalest_even_index_count_max_index12\
    \ = 0;\n    long smalest_even_index_count_min_index13 = 0;\n    long smalest_even_index_count_max_index13\
    \ = 0;\n    long smalest_even_index_count_min_index14 = 0;\n    long smalest_even_index_count_max_index14\
    \ = 0;\n    long smalest_even_index_count_min_index15 = 0;\n    long smalest_even_index_count_max_index15\
    \ = 0;\n    long smalest_even_index_count_min_index16 = 0;\n    long smalest_even_index_count_max_index16\
    \ = 0;\n    long smalest_even_index_count_min_index17 = 0;\n    long smalest_even_index_count_max_index17\
    \ = 0;\n    long smalest_even_index_count_min_index18 = 0;\n    long \n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqgl2zbca.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpqgl2zbca.cpp:72:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmpqgl2zbca.cpp:72:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_count = 0;\n    long smalest_even_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index2 = 0;\n    long smalest_even_index_count_index3\
    \ = 0;\n    long smalest_even_index_count_index4 = 0;\n    long smalest_even_index_count_index5\
    \ = 0;\n    long smalest_even_index_count_index6 = 0;\n    long smalest_even_index_count_index7\
    \ = 0;\n    long smalest_even_index_count_index8 = 0;\n    long smalest_even_index_count_index9\
    \ = 0;\n    long smalest_even_index_count_index10 = 0;\n    long smalest_even_index_count_index11\
    \ = 0;\n    long smalest_even_index_count_index12 = 0;\n    long smalest_even_index_count_index13\
    \ = 0;\n    long smalest_even_index_count_index14 = 0;\n    long smalest_even_index_count_index15\
    \ = 0;\n    long smalest_even_index_count_index16 = 0;\n    long smalest_even_index_count_index17\
    \ = 0;\n    long smalest_even_index_count_index18 = 0;\n    long smalest_even_index_count_index19\
    \ = 0;\n    long smalest_even_index_count_index20 = 0;\n    long smalest_even_index_count_index21\
    \ = 0;\n    long smalest_even_index_count_index22 = 0;\n    long smalest_even_index_count_index23\
    \ = 0;\n    long smalest_even_index_count_index24 = 0;\n    long smalest_even_index_count_index25\
    \ = 0;\n    long smalest_even_index_count_index26 = 0;\n    long smalest_even_index_count_index27\
    \ = 0;\n    long smalest_even_index_count_index28 = 0;\n    long smalest_even_index_count_index29\
    \ = 0;\n    long smalest_even_index_count_index30 = 0;\n    long smalest_even_index_count_index31\
    \ = 0;\n    long smalest_even_index_count_index32 = 0;\n    long smalest_even_index_count_index33\
    \ = 0;\n    long smalest_even_index_count_index34 = 0;\n    long smalest_even_index_count_index35\
    \ = 0;\n    long smalest_even_index_count_index36 = 0;\n    long smalest_even_index_count_index37\
    \ = 0;\n    long smalest_even_index_count_index38 = 0;\n    long smalest_even_index_count_index39\
    \ = 0;\n    long \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv8s3asbh.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpv8s3asbh.cpp:75:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   75 | }\n      | ^\n/tmp/tmpv8s3asbh.cpp:75:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = arr[0];\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \         smalest_index_value = smalest_index;\n            smalest_index_value2\
    \ = smalest_index_value;\n        }\n        else if (arr[i] == smalest_value)\
    \ {\n            smalest_index_value2 = smalest_index_value;\n            smalest_index_value\
    \ = i;\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index_value);\n    return ans;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmplzvfko_n: /tmp/tmplzvfko_n.cpp:54: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = arr[0];\n    int smalest_index\
    \ = 0;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp03_p1656: /tmp/tmp03_p1656.cpp:46: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_of_smalest_value = 0;\n    long smalest_index_of_smalest_value2\
    \ = 0;\n    long smalest_index_of_smalest_value3 = 0;\n    long smalest_index_of_smalest_value4\
    \ = 0;\n    long smalest_index_of_smalest_value5 = 0;\n    long smalest_index_of_smalest_value6\
    \ = 0;\n    long smalest_index_of_smalest_value7 = 0;\n    long smalest_index_of_smalest_value8\
    \ = 0;\n    long smalest_index_of_smalest_value9 = 0;\n    long smalest_index_of_smalest_value10\
    \ = 0;\n    long smalest_index_of_smalest_value11 = 0;\n    long smalest_index_of_smalest_value12\
    \ = 0;\n    long smalest_index_of_smalest_value13 = 0;\n    long smalest_index_of_smalest_value14\
    \ = 0;\n    long smalest_index_of_smalest_value15 = 0;\n    long smalest_index_of_smalest_value16\
    \ = 0;\n    long smalest_index_of_smalest_value17 = 0;\n    long smalest_index_of_smalest_value18\
    \ = 0;\n    long smalest_index_of_smalest_value19 = 0;\n    long smalest_index_of_smalest_value20\
    \ = 0;\n    long smalest_index_of_smalest_value21 = 0;\n    long smalest_index_of_smalest_value22\
    \ = 0;\n    long smalest_index_of_smalest_value23 = 0;\n    long smalest_index_of_smalest_value24\
    \ = 0;\n    long smalest_index_of_smalest_value25 = 0;\n    long smalest_index_of_smalest_value26\
    \ = 0;\n    long smalest_index_of_smalest_value27 = 0;\n    long smalest_index_of_smalest_value28\
    \ = 0;\n    long smalest_index_of_smalest_value29 = 0;\n    long smalest_index_of_smalest_value30\
    \ = 0;\n    long smalest_index_of_smalest_value31 = 0;\n    long smalest_index_of_smalest_value32\
    \ = 0;\n    long smalest_index_of_smalest_value33 = 0;\n    long smalest_index_of_smalest_value34\
    \ = 0;\n    long smalest_index_of_smalest_value35 = 0;\n    long smalest_index_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_39zqv9y.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp_39zqv9y.cpp:68:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   68 | }\n      | ^\n/tmp/tmp_39zqv9y.cpp:68:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value_index = arr[0];\n\
    \    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \         smalest_index_value = arr[i];\n            smalest_index_value_index\
    \ = arr[i];\n        } else if (arr[i] == smalest_value) {\n            if (arr[i]\
    \ < smalest_index_value) {\n                smalest_index_value = arr[i];\n  \
    \              smalest_index_value_index = i;\n            }\n        }\n    }\n\
    \    std::vector<long> ans;\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index_value);\n\
    \    ans.push_back(smalest_index_value_index);\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpxwms6pw_: /tmp/tmpxwms6pw_.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smalest_index_value %\
    \ 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \        result.push_back(smalest_index_value);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp8mkt5n5s: /tmp/tmp8mkt5n5s.cpp:53: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpcmgx83ev: /tmp/tmpcmgx83ev.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_index =\
    \ 0;\n    long smalest_even_index_index_index = 0;\n    long smalest_even_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index = 0;\n    long smalest_even_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index = 0;\n\
    \    long smalest_even_index_index_index_index_index_index_index_index = 0;\n\
    \    long smalest_even_index_index_index_index_index_index_index_index_index =\
    \ 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ny3m_lv.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7ny3m_lv.cpp:45:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   45 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ny3m_lv.cpp:44:10: note: \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \ previously declared here\n   44 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ny3m_lv.cpp:46:10: error: redeclaration of \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   46 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ny3m_lv.cpp:44:10: note: \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \ previously declared here\n   44 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ny3m_lv.cpp:49:10: error: redeclaration of \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   49 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ny3m_lv.cpp:48:10: note: \u2018"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpxms4wzw1: /tmp/tmpxms4wzw1.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    if (smalest_value\
    \ == 0) {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp8gyml7lr: /tmp/tmp8gyml7lr.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value=arr[0];\n    long\
    \ smalest_index=0;\n    long even_value=0;\n    for(long i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0){\n            even_value=arr[i];\n        }\n       \
    \ if(even_value<smalest_value){\n            smalest_value=even_value;\n     \
    \       smalest_index=i;\n        }\n    }\n    std::vector<long> result;\n  \
    \  result.push_back(smalest_value);\n    result.push_back(smalest_index);\n  \
    \  return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpo5503aml: /tmp/tmpo5503aml.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0)\
    \ {\n            if (smallest_value == 0) {\n                smallest_value =\
    \ i;\n                smallest_index = index;\n            } else if (smallest_value\
    \ < i) {\n                smallest_value = i;\n                smallest_index\
    \ = index;\n            }\n            index++;\n        }\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smallest_value);\n    res.push_back(smallest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp5mz1cnns: /tmp/tmp5mz1cnns.cpp:52: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_value = arr[0];\n   \
    \ long smallest_index = 0;\n    long smallest_even_value = 0;\n    for (long i\
    \ = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smallest_value == arr[i]) {\n                smallest_even_value = arr[i];\n\
    \                smallest_index = i;\n            } else if (smallest_even_value\
    \ == arr[i]) {\n                smallest_even_value = arr[i];\n              \
    \  smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(smallest_even_value);\n    ans.push_back(smallest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp5mr6_uxs: /tmp/tmp5mr6_uxs.cpp:51: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = arr[0];\n    long\
    \ smalest_index = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value_temp\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value == arr[i]) {\n                smalest_index\
    \ = i;\n                smalest_index_value = arr[i];\n                smalest_index_value_temp\
    \ = smalest_index_value;\n            }\n            else {\n                if\
    \ (smalest_index_value == smalest_index_value_temp) {\n                    smalest_index\
    \ = i;\n                    smalest_index_value = arr[i];\n                }\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp6oh5_oz5: /tmp/tmp6oh5_oz5.cpp:56: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here.\n    long smalest_value = arr[0];\n   \
    \ long smalest_index = 0;\n    long smalest_index_of_smalest_value = 0;\n    long\
    \ smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv2i0odux.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpv2i0odux.cpp:68:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   68 | }\n      | ^\n/tmp/tmpv2i0odux.cpp:68:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_of_smalest_value = 0;\n    long smalest_index_of_smalest_value2\
    \ = 0;\n    long smalest_index_of_smalest_value3 = 0;\n    long smalest_index_of_smalest_value4\
    \ = 0;\n    long smalest_index_of_smalest_value5 = 0;\n    long smalest_index_of_smalest_value6\
    \ = 0;\n    long smalest_index_of_smalest_value7 = 0;\n    long smalest_index_of_smalest_value8\
    \ = 0;\n    long smalest_index_of_smalest_value9 = 0;\n    long smalest_index_of_smalest_value10\
    \ = 0;\n    long smalest_index_of_smalest_value11 = 0;\n    long smalest_index_of_smalest_value12\
    \ = 0;\n    long smalest_index_of_smalest_value13 = 0;\n    long smalest_index_of_smalest_value14\
    \ = 0;\n    long smalest_index_of_smalest_value15 = 0;\n    long smalest_index_of_smalest_value16\
    \ = 0;\n    long smalest_index_of_smalest_value17 = 0;\n    long smalest_index_of_smalest_value18\
    \ = 0;\n    long smalest_index_of_smalest_value19 = 0;\n    long smalest_index_of_smalest_value20\
    \ = 0;\n    long smalest_index_of_smalest_value21 = 0;\n    long smalest_index_of_smalest_value22\
    \ = 0;\n    long smalest_index_of_smalest_value23 = 0;\n    long smalest_index_of_smalest_value24\
    \ = 0;\n    long smalest_index_of_smalest_value25 = 0;\n    long smalest_index_of_smalest_value26\
    \ = 0;\n    long smalest_index_of_smalest_value27 = 0;\n    long smalest_index_of_smalest_value28\
    \ = 0;\n    long smalest_index_of_smalest_value29 = 0;\n    long smalest_index_of_smalest_value30\
    \ = 0;\n    long smalest_index_of_smalest_value31 = 0;\n    long smalest_index_of_smalest_value32\
    \ = 0;\n    long smalest_index_of_smalest_value33 = 0;\n    long smalest_index_of_smalest_value34\
    \ = 0;\n    long smalest_index_of_smalest_value35 = 0;\n    long smalest_index_of_smalest_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpymewkel2.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpymewkel2.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmpymewkel2.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long even_value\
    \ = 0;\n    long even_index = 0;\n    long index = 0;\n    long value = 0;\n \
    \   long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 =\
    \ 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpo_c7e373: /tmp/tmpo_c7e373.cpp:118: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_of_smalest_value = 0;\n    long smalest_index_of_smalest_value2\
    \ = 0;\n    long smalest_index_of_smalest_value3 = 0;\n    long smalest_index_of_smalest_value4\
    \ = 0;\n    long smalest_index_of_smalest_value5 = 0;\n    long smalest_index_of_smalest_value6\
    \ = 0;\n    long smalest_index_of_smalest_value7 = 0;\n    long smalest_index_of_smalest_value8\
    \ = 0;\n    long smalest_index_of_smalest_value9 = 0;\n    long smalest_index_of_smalest_value10\
    \ = 0;\n    long smalest_index_of_smalest_value11 = 0;\n    long smalest_index_of_smalest_value12\
    \ = 0;\n    long smalest_index_of_smalest_value13 = 0;\n    long smalest_index_of_smalest_value14\
    \ = 0;\n    long smalest_index_of_smalest_value15 = 0;\n    long smalest_index_of_smalest_value16\
    \ = 0;\n    long smalest_index_of_smalest_value17 = 0;\n    long smalest_index_of_smalest_value18\
    \ = 0;\n    long smalest_index_of_smalest_value19 = 0;\n    long smalest_index_of_smalest_value20\
    \ = 0;\n    long smalest_index_of_smalest_value21 = 0;\n    long smalest_index_of_smalest_value22\
    \ = 0;\n    long smalest_index_of_smalest_value23 = 0;\n    long smalest_index_of_smalest_value24\
    \ = 0;\n    long smalest_index_of_smalest_value25 = 0;\n    long smalest_index_of_smalest_value26\
    \ = 0;\n    long smalest_index_of_smalest_value27 = 0;\n    long smalest_index_of_smalest_value28\
    \ = 0;\n    long smalest_index_of_smalest_value29 = 0;\n    long smalest_index_of_smalest_value30\
    \ = 0;\n    long smalest_index_of_smalest_value31 = 0;\n    long smalest_index_of_smalest_value32\
    \ = 0;\n    long smalest_index_of_smalest_value33 = 0;\n    long smalest_index_of_smalest_value34\
    \ = 0;\n    long smalest_index_of_smalest_value35 = 0;\n    long smalest_index_of_smalest_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw3_gj_09.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpw3_gj_09.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmpw3_gj_09.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_value_index =\
    \ 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0)\
    \ {\n            if (smalest_value == 0) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n                smalest_even_value = arr[i]\
    \ % 2;\n                smalest_even_index = i;\n                smalest_even_value_index\
    \ = i;\n            } else if (smalest_value == arr[i]) {\n                smalest_even_value_index++;\n\
    \            } else {\n                smalest_value = arr[i];\n             \
    \   smalest_index = i;\n                smalest_even_value = arr[i] % 2;\n   \
    \             smalest_even_index = i;\n                smalest_even_value_index\
    \ = i;\n            }\n        } else {\n            if (smalest_value == 0) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \                smalest_even_value = arr[i] % 2;\n                smalest_even_index\
    \ = i;\n                smalest_even_value_index = i;\n            } else if (smalest_value\
    \ == arr[i]) {\n                smalest_even_value_index++;\n            } else\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n                smalest_even_value = arr[i] % 2;\n                smalest_even_index\
    \ = i;\n                smalest_even_value_index = i;\n            }\n       \
    \ }\n    }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    if (smalest_even_value_index == smalest_even_index) {\n        res.push_back(smalest_even_value);\n\
    \        res.push_back(smalest_even_index);\n    } else {\n        res.push_back(smalest_even_value);\n\
    \        res.push_back(smalest_even_index);\n        res.push_back(smalest_even_value_index);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpik7v_7al: /tmp/tmpik7v_7al.cpp:87: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_count =\
    \ 0;\n    long smalest_even_index_count_index = 0;\n    long smalest_even_index_count_index_count\
    \ = 0;\n    long smalest_even_index_count_index_count_index = 0;\n    long smalest_even_index_count_index_count_index_count\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index = 0;\n\
    \    long smalest_even_index_count_index_count_index_count_index_count = 0;\n\
    \    long smalest_even_index_count_index_count_index_count_index_count_index =\
    \ 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index_count_index_count_\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1w_fzk1t.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp1w_fzk1t.cpp:41:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_count_index_count_index_count_index_count_index\u2019\
    \n   41 |     long smalest_even_index_count_index_count_index_count_index_count_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1w_fzk1t.cpp:40:10: note: \u2018long int smalest_even_index_count_index_count_index_count_index_count_index\u2019\
    \ previously declared here\n   40 |     long smalest_even_index_count_index_count_index_count_index_count_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1w_fzk1t.cpp:44:10: error: redeclaration of \u2018long int smalest_even_index_count_index_count_index_count_index_count_index_count_index\u2019\
    \n   44 |     long smalest_even_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1w_fzk1t.cpp:43:10: note: \u2018long int smalest_even_index_count_index_count_index_count_index_count_index_count_index\u2019\
    \ previously declared here\n   43 |     long smalest_even_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1w_fzk1t.cpp:48:10: error: redeclaration of \u2018long int smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index\u2019\
    \n   48 |     long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1w_fzk1t.cpp:47:10: note: \u2018long int smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index\u2019\
    \ previously declared here\n   47 |     long smalest_even_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = 0;\n      |      "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = arr[0];\n    long smallest_index = 0;\n  \
    \  for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smallest_value)\
    \ {\n            smallest_value = arr[i];\n            smallest_index = i;\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smallest_value % 2 ==\
    \ 0) {\n        result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \    } else {\n        result.push_back(smallest_value + 1);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmphpz4l3t7: /tmp/tmphpz4l3t7.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp83qlrpc2: /tmp/tmp83qlrpc2.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_index = 0;\n\
    \    long index = 0;\n    long even_value = 0;\n    long even_index = 0;\n   \
    \ long temp = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ % 2 == 0) {\n            even_value = arr[i];\n            even_index = i;\n\
    \        }\n        if (arr[i] < smallest_value) {\n            smallest_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n        if (arr[i] %\
    \ 2 == 0 && arr[i] < smallest_even_value) {\n            smallest_even_value =\
    \ arr[i];\n            smallest_even_index = i;\n        }\n    }\n    if (smallest_value\
    \ == 0) {\n        return {};\n    }\n    if (smallest_even_index == smallest_index)\
    \ {\n        return { smallest_even_index, even_index };\n    }\n    if (smallest_even_index\
    \ < smallest_index) {\n        temp = smallest_even_index;\n        smallest_even_index\
    \ = smallest_index;\n        smallest_even_value = even_value;\n        smallest_index\
    \ = temp;\n    }\n    std::vector<long> res;\n    res.push_back(smallest_value);\n\
    \    res.push_back(smallest_index);\n    res.push_back(smallest_even_index);\n\
    \    res.push_back(smallest_even_value);\n    return res;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpi_xex4i9: /tmp/tmpi_xex4i9.cpp:73: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_even_value = 0;\n    for (long i = 1; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n          \
    \      smalest_value = arr[i];\n                smalest_index = i;\n         \
    \       smalest_even_value = arr[i] / 2;\n            } else {\n             \
    \   if (arr[i] < smalest_even_value) {\n                    smalest_value = arr[i];\n\
    \                    smalest_index = i;\n                    smalest_even_value\
    \ = arr[i] / 2;\n                }\n            }\n        }\n    }\n    if (smalest_value\
    \ == 0) {\n        return {};\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp6y78ueh1: /tmp/tmp6y78ueh1.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ even_value = 0;\n    long even_index = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            even_value = arr[i];\n \
    \           even_index = i;\n        }\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    if (smalest_value == even_value) {\n        result.push_back(even_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpc60j6o7o: /tmp/tmpc60j6o7o.cpp:56: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_of_smalest_value\
    \ = 0;\n    long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_smalest_value\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp8d4dsqqs.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp8d4dsqqs.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmp8d4dsqqs.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    long smalest_index_value2 = 0;\n    long smalest_index_value3 = 0;\n\
    \    long smalest_index_value4 = 0;\n    long smalest_index_value5 = 0;\n    long\
    \ smalest_index_value6 = 0;\n    long smalest_index_value7 = 0;\n    long smalest_index_value8\
    \ = 0;\n    long smalest_index_value9 = 0;\n    long smalest_index_value10 = 0;\n\
    \    long smalest_index_value11 = 0;\n    long smalest_index_value12 = 0;\n  \
    \  long smalest_index_value13 = 0;\n    long smalest_index_value14 = 0;\n    long\
    \ smalest_index_value15 = 0;\n    long smalest_index_value16 = 0;\n    long smalest_index_value17\
    \ = 0;\n    long smalest_index_value18 = 0;\n    long smalest_index_value19 =\
    \ 0;\n    long smalest_index_value20 = 0;\n    long smalest_index_value21 = 0;\n\
    \    long smalest_index_value22 = 0;\n    long smalest_index_value23 = 0;\n  \
    \  long smalest_index_value24 = 0;\n    long smalest_index_value25 = 0;\n    long\
    \ smalest_index_value26 = 0;\n    long smalest_index_value27 = 0;\n    long smalest_index_value28\
    \ = 0;\n    long smalest_index_value29 = 0;\n    long smalest_index_value30 =\
    \ 0;\n    long smalest_index_value31 = 0;\n    long smalest_index_value32 = 0;\n\
    \    long smalest_index_value33 = 0;\n    long smalest_index_value34 = 0;\n  \
    \  long smalest_index_value35 = 0;\n    long smalest_index_value36 = 0;\n    long\
    \ smalest_index_value37 = 0;\n    long smalest_index_value38 = 0;\n    long smalest_index_value39\
    \ = 0;\n    long smalest_index_value40 = 0;\n    long smalest_index_value41 =\
    \ 0;\n    long smalest_index_value42 = 0;\n    long smalest_index_value43 = 0;\n\
    \    long smalest_index_value44 = 0;\n    long smalest_index_value45 = 0;\n  \
    \  long smalest_index_value46 = 0;\n    long smalest_index_value47 = 0;\n    long\
    \ smalest_index_value48 = 0;\n    long smalest_index_value49 = 0;\n    long smalest_index_value50\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp8szuax0o: /tmp/tmp8szuax0o.cpp:85: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    long index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0) {\n  \
    \          if (smallest_even_count < i) {\n                smallest_even_value\
    \ = i;\n                smallest_even_count = i;\n                smallest_value\
    \ = i;\n                smallest_index = index;\n            }\n            smallest_even_count++;\n\
    \        } else {\n            if (smallest_even_count == i) {\n             \
    \   smallest_value = i;\n                smallest_index = index;\n           \
    \ }\n        }\n        index++;\n    }\n    std::vector<long> result;\n    if\
    \ (smallest_even_count == 0) {\n        return result;\n    }\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpz3dfn8o0: /tmp/tmpz3dfn8o0.cpp:62: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_of_smalest_value = 0;\n    long smalest_index_of_smalest_value2\
    \ = 0;\n    long smalest_index_of_smalest_value3 = 0;\n    long smalest_index_of_smalest_value4\
    \ = 0;\n    long smalest_index_of_smalest_value5 = 0;\n    long smalest_index_of_smalest_value6\
    \ = 0;\n    long smalest_index_of_smalest_value7 = 0;\n    long smalest_index_of_smalest_value8\
    \ = 0;\n    long smalest_index_of_smalest_value9 = 0;\n    long smalest_index_of_smalest_value10\
    \ = 0;\n    long smalest_index_of_smalest_value11 = 0;\n    long smalest_index_of_smalest_value12\
    \ = 0;\n    long smalest_index_of_smalest_value13 = 0;\n    long smalest_index_of_smalest_value14\
    \ = 0;\n    long smalest_index_of_smalest_value15 = 0;\n    long smalest_index_of_smalest_value16\
    \ = 0;\n    long smalest_index_of_smalest_value17 = 0;\n    long smalest_index_of_smalest_value18\
    \ = 0;\n    long smalest_index_of_smalest_value19 = 0;\n    long smalest_index_of_smalest_value20\
    \ = 0;\n    long smalest_index_of_smalest_value21 = 0;\n    long smalest_index_of_smalest_value22\
    \ = 0;\n    long smalest_index_of_smalest_value23 = 0;\n    long smalest_index_of_smalest_value24\
    \ = 0;\n    long smalest_index_of_smalest_value25 = 0;\n    long smalest_index_of_smalest_value26\
    \ = 0;\n    long smalest_index_of_smalest_value27 = 0;\n    long smalest_index_of_smalest_value28\
    \ = 0;\n    long smalest_index_of_smalest_value29 = 0;\n    long smalest_index_of_smalest_value30\
    \ = 0;\n    long smalest_index_of_smalest_value31 = 0;\n    long smalest_index_of_smalest_value32\
    \ = 0;\n    long smalest_index_of_smalest_value33 = 0;\n    long smalest_index_of_smalest_value34\
    \ = 0;\n    long smalest_index_of_smalest_value35 = 0;\n    long smalest_index_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp22x52tt3.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp22x52tt3.cpp:68:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   68 | }\n      | ^\n/tmp/tmp22x52tt3.cpp:68:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    long index = 0;\n    long temp = 0;\n    long temp2\
    \ = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    \n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp0e3jqnu7: /tmp/tmp0e3jqnu7.cpp:119: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ largest_value = 0;\n    long largest_index = 0;\n    for(long i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] > largest_value) {\n            largest_value = arr[i];\n\
    \            largest_index = i;\n        }\n        if(arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    std::vector<long> result;\n    if(smalest_value % 2 == 0)\
    \ {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(largest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp6oyo2pyp: /tmp/tmp6oyo2pyp.cpp:56: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = arr[0];\n    long smalest_index\
    \ = 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0)\
    \ {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpxi_ltum8: /tmp/tmpxi_ltum8.cpp:48: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpkg_p4npk: /tmp/tmpkg_p4npk.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    long index = 0;\n    long even_value = 0;\n    long even_count = 0;\n   \
    \ long even_index = 0;\n    long even_value2 = 0;\n    long even_count2 = 0;\n\
    \    long even_index2 = 0;\n    long even_value3 = 0;\n    long even_count3 =\
    \ 0;\n    long even_index3 = 0;\n    long even_value4 = 0;\n    long even_count4\
    \ = 0;\n    long even_index4 = 0;\n    long even_value5 = 0;\n    long even_count5\
    \ = 0;\n    long even_index5 = 0;\n    long even_value6 = 0;\n    long even_count6\
    \ = 0;\n    long even_index6 = 0;\n    long even_value7 = 0;\n    long even_count7\
    \ = 0;\n    long even_index7 = 0;\n    long even_value8 = 0;\n    long even_count8\
    \ = 0;\n    long even_index8 = 0;\n    long even_value9 = 0;\n    long even_count9\
    \ = 0;\n    long even_index9 = 0;\n    long even_value10 = 0;\n    long even_count10\
    \ = 0;\n    long even_index10 = 0;\n    long even_value11 = 0;\n    long even_count11\
    \ = 0;\n    long even_index11 = 0;\n    long even_value12 = 0;\n    long even_count12\
    \ = 0;\n    long even_index12 = 0;\n    long even_value13 = 0;\n    long even_count13\
    \ = 0;\n    long even_index13 = 0;\n    long even_value14 = 0;\n    long even_count14\
    \ = 0;\n    long even_index14 = 0;\n    long even_value15 = 0;\n    long even_count15\
    \ = 0;\n    long even_index15 = 0;\n    long even_value16 = 0;\n    long even_count16\
    \ = 0;\n    long even_index16 = 0;\n    long even_value17 = 0;\n    long even_count17\
    \ = 0;\n    long even_index17 = 0;\n    long even_value18 = 0;\n    long even_count18\
    \ = 0;\n    long even_index18 = 0;\n    long even_value19 = 0;\n    long even_count19\
    \ = 0;\n    long even_index19 = 0;\n    long even_value20 = 0;\n    long even_count20\
    \ = 0;\n    long even_index20 = 0;\n    long even_value21 = 0;\n    long even_count21\
    \ = 0;\n    long even_index21 = 0;\n    long even_value22 = 0;\n    long even_count22\
    \ = 0;\n    long even_index22 = 0;\n    long even_value23 = 0;\n    long even_count23\
    \ = 0;\n    long even_index23 = 0;\n    long even_value24\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpis3g864h.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpis3g864h.cpp:105:1: error: expected initializer before\
    \ \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmpis3g864h.cpp:105:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_even_value = 0;\n    long smalest_even_index = 0;\n    for (long i =\
    \ 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_even_value\
    \ == 0) {\n                smalest_even_value = arr[i];\n                smalest_even_index\
    \ = i;\n            } else {\n                if (arr[i] < smalest_even_value)\
    \ {\n                    smalest_even_value = arr[i];\n                    smalest_even_index\
    \ = i;\n                }\n            }\n        } else {\n            if (smalest_value\
    \ == 0) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            } else {\n                if (arr[i] < smalest_value) {\n\
    \                    smalest_value = arr[i];\n                    smalest_index\
    \ = i;\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_even_value == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_even_value);\n\
    \        result.push_back(smalest_even_index);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    long smalest_index_value3 = 0;\n    long smalest_index_value4 = 0;\n    long\
    \ smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n    long smalest_index_value7\
    \ = 0;\n    long smalest_index_value8 = 0;\n    long smalest_index_value9 = 0;\n\
    \    long smalest_index_value10 = 0;\n    long smalest_index_value11 = 0;\n  \
    \  long smalest_index_value12 = 0;\n    long smalest_index_value13 = 0;\n    long\
    \ smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n    long smalest_index_value16\
    \ = 0;\n    long smalest_index_value17 = 0;\n    long smalest_index_value18 =\
    \ 0;\n    long smalest_index_value19 = 0;\n    long smalest_index_value20 = 0;\n\
    \    long smalest_index_value21 = 0;\n    long smalest_index_value22 = 0;\n  \
    \  long smalest_index_value23 = 0;\n    long smalest_index_value24 = 0;\n    long\
    \ smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n    long smalest_index_value27\
    \ = 0;\n    long smalest_index_value28 = 0;\n    long smalest_index_value29 =\
    \ 0;\n    long smalest_index_value30 = 0;\n    long smalest_index_value31 = 0;\n\
    \    long smalest_index_value32 = 0;\n    long smalest_index_value33 = 0;\n  \
    \  long smalest_index_value34 = 0;\n    long smalest_index_value35 = 0;\n    long\
    \ smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n    long smalest_index_value38\
    \ = 0;\n    long smalest_index_value39 = 0;\n    long smalest_index_value40 =\
    \ 0;\n    long smalest_index_value41 = 0;\n    long smalest_index_value42 = 0;\n\
    \    long smalest_index_value43 = 0;\n    long smalest_index_value44 = 0;\n  \
    \  long smalest_index_value45 = 0;\n    long smalest_index_value46 = 0;\n    long\
    \ smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n    long smalest_index_value49\
    \ = 0;\n    long smalest_index_value\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp3btihe75.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp3btihe75.cpp:82:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmp3btihe75.cpp:82:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmplteyqxqq: /tmp/tmplteyqxqq.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long index = 0;\n    long value = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            value = arr[i];\n      \
    \      index = i;\n        }\n    }\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_value)\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = index;\n            }\n        }\n    }\n    std::vector<long> result;\n \
    \   result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp0hovwerw: /tmp/tmp0hovwerw.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_value = arr[0];\n    long smallest_index = 0;\n\
    \    long smallest_value = arr[0];\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value)\
    \ {\n                smallest_even_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    std::vector<long> result;\n    if\
    \ (smallest_index != 0) {\n        result.push_back(smallest_even_value);\n  \
    \      result.push_back(smallest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpcmjtrov9: /tmp/tmpcmjtrov9.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index2\
    \ = 0;\n    long smalest_index3 = 0;\n    long smalest_index4 = 0;\n    long smalest_index5\
    \ = 0;\n    long smalest_index6 = 0;\n    long smalest_index7 = 0;\n    long smalest_index8\
    \ = 0;\n    long smalest_index9 = 0;\n    long smalest_index10 = 0;\n    long\
    \ smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long smalest_index13\
    \ = 0;\n    long smalest_index14 = 0;\n    long smalest_index15 = 0;\n    long\
    \ smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long smalest_index18\
    \ = 0;\n    long smalest_index19 = 0;\n    long smalest_index20 = 0;\n    long\
    \ smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long smalest_index23\
    \ = 0;\n    long smalest_index24 = 0;\n    long smalest_index25 = 0;\n    long\
    \ smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long smalest_index28\
    \ = 0;\n    long smalest_index29 = 0;\n    long smalest_index30 = 0;\n    long\
    \ smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long smalest_index33\
    \ = 0;\n    long smalest_index34 = 0;\n    long smalest_index35 = 0;\n    long\
    \ smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long smalest_index38\
    \ = 0;\n    long smalest_index39 = 0;\n    long smalest_index40 = 0;\n    long\
    \ smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long smalest_index43\
    \ = 0;\n    long smalest_index44 = 0;\n    long smalest_index45 = 0;\n    long\
    \ smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long smalest_index48\
    \ = 0;\n    long smalest_index49 = 0;\n    long smalest_index50 = 0;\n    long\
    \ smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long smalest_index53\
    \ = 0;\n    long smalest_index54 = 0;\n    long smalest_index55 = 0;\n    long\
    \ smalest_index56 = 0;\n    long smalest_\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpaaegohsy.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpaaegohsy.cpp:87:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmpaaegohsy.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_even_value = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array = 0;\n\
    \    long smalest_even_index_in_array_in_array_in_array_in_array_in_array = 0;\n\
    \    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long sm\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk04jg_qx.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpk04jg_qx.cpp:42:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   42 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk04jg_qx.cpp:41:10: note: \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   41 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk04jg_qx.cpp:46:10: error: redeclaration of \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   46 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk04jg_qx.cpp:45:10: note: \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   45 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk04jg_qx.cpp:50:10: error: redeclaration of \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_ar"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    long smalest_index_value2 = 0;\n    long smalest_index_value3 = 0;\n\
    \    long smalest_index_value4 = 0;\n    long smalest_index_value5 = 0;\n    long\
    \ smalest_index_value6 = 0;\n    long smalest_index_value7 = 0;\n    long smalest_index_value8\
    \ = 0;\n    long smalest_index_value9 = 0;\n    long smalest_index_value10 = 0;\n\
    \    long smalest_index_value11 = 0;\n    long smalest_index_value12 = 0;\n  \
    \  long smalest_index_value13 = 0;\n    long smalest_index_value14 = 0;\n    long\
    \ smalest_index_value15 = 0;\n    long smalest_index_value16 = 0;\n    long smalest_index_value17\
    \ = 0;\n    long smalest_index_value18 = 0;\n    long smalest_index_value19 =\
    \ 0;\n    long smalest_index_value20 = 0;\n    long smalest_index_value21 = 0;\n\
    \    long smalest_index_value22 = 0;\n    long smalest_index_value23 = 0;\n  \
    \  long smalest_index_value24 = 0;\n    long smalest_index_value25 = 0;\n    long\
    \ smalest_index_value26 = 0;\n    long smalest_index_value27 = 0;\n    long smalest_index_value28\
    \ = 0;\n    long smalest_index_value29 = 0;\n    long smalest_index_value30 =\
    \ 0;\n    long smalest_index_value31 = 0;\n    long smalest_index_value32 = 0;\n\
    \    long smalest_index_value33 = 0;\n    long smalest_index_value34 = 0;\n  \
    \  long smalest_index_value35 = 0;\n    long smalest_index_value36 = 0;\n    long\
    \ smalest_index_value37 = 0;\n    long smalest_index_value38 = 0;\n    long smalest_index_value39\
    \ = 0;\n    long smalest_index_value40 = 0;\n    long smalest_index_value41 =\
    \ 0;\n    long smalest_index_value42 = 0;\n    long smalest_index_value43 = 0;\n\
    \    long smalest_index_value44 = 0;\n    long smalest_index_value45 = 0;\n  \
    \  long smalest_index_value46 = 0;\n    long smalest_index_value47 = 0;\n    long\
    \ smalest_index_value48 = 0;\n    long smalest_index_value49 = 0;\n    long smalest_index_value50\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpkez_insm: /tmp/tmpkez_insm.cpp:85: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    long smalest_value = arr[0];\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (smalest_even_value == 0) {\n                smalest_even_value\
    \ = arr[i];\n                smalest_even_index = i;\n            }\n        \
    \    if (smalest_even_value < arr[i]) {\n                smalest_even_value =\
    \ arr[i];\n                smalest_even_index = i;\n            }\n        }\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_even_value == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_even_value);\n\
    \        result.push_back(smalest_even_index);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp0o50rxvr: /tmp/tmp0o50rxvr.cpp:62: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = 0;\n    long smallest_index = 0;\n    std::vector<long>\
    \ result;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] < smallest_value)\
    \ {\n            smallest_value = arr[i];\n            smallest_index = i;\n \
    \       }\n    }\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpnwkacmyd: /tmp/tmpnwkacmyd.cpp:44: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here.\n    long smalest_value = 0, smalest_index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value == 0) {\n        return\
    \ result;\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpqei150ek: /tmp/tmpqei150ek.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long index = 0;\n    for(long i = 0; i < arr.size(); i++) {\n    \
    \    if(arr[i] % 2 == 0) {\n            smallest_value = arr[i];\n           \
    \ smallest_index = i;\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(smallest_value);\n\
    \    ans.push_back(smallest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmplpmirg7r: /tmp/tmplpmirg7r.cpp:48: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::vector<long>())' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    long index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if\
    \ (arr[i] % 2 == 0) {\n            if (smallest_even_count < arr[i]) {\n     \
    \           smallest_even_value = arr[i];\n                smallest_even_count\
    \ = arr[i];\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n    }\n    std::vector<long> result;\n    if\
    \ (smallest_even_count == 0) {\n        return result;\n    }\n    result.push_back(smallest_even_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpphjrp87w: /tmp/tmpphjrp87w.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpuslb8b2j: /tmp/tmpuslb8b2j.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_of_smalest_value\
    \ = 0;\n    long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_smalest_value\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp890m_rmp.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp890m_rmp.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmp890m_rmp.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_count = 0;\n    long smalest_even_index_count_max\
    \ = 0;\n    long smalest_even_index_count_min = 0;\n    long smalest_even_index_count_sum\
    \ = 0;\n    long smalest_even_index_count_sum2 = 0;\n    long smalest_even_index_count_sum3\
    \ = 0;\n    long smalest_even_index_count_sum4 = 0;\n    long smalest_even_index_count_sum5\
    \ = 0;\n    long smalest_even_index_count_sum6 = 0;\n    long smalest_even_index_count_sum7\
    \ = 0;\n    long smalest_even_index_count_sum8 = 0;\n    long smalest_even_index_count_sum9\
    \ = 0;\n    long smalest_even_index_count_sum10 = 0;\n    long smalest_even_index_count_sum11\
    \ = 0;\n    long smalest_even_index_count_sum12 = 0;\n    long smalest_even_index_count_sum13\
    \ = 0;\n    long smalest_even_index_count_sum14 = 0;\n    long smalest_even_index_count_sum15\
    \ = 0;\n    long smalest_even_index_count_sum16 = 0;\n    long smalest_even_index_count_sum17\
    \ = 0;\n    long smalest_even_index_count_sum18 = 0;\n    long smalest_even_index_count_sum19\
    \ = 0;\n    long smalest_even_index_count_sum20 = 0;\n    long smalest_even_index_count_sum21\
    \ = 0;\n    long smalest_even_index_count_sum22 = 0;\n    long smalest_even_index_count_sum23\
    \ = 0;\n    long smalest_even_index_count_sum24 = 0;\n    long smalest_even_index_count_sum25\
    \ = 0;\n    long smalest_even_index_count_sum26 = 0;\n    long smalest_even_index_count_sum27\
    \ = 0;\n    long smalest_even_index_count_sum28 = 0;\n    long smalest_even_index_count_sum29\
    \ = 0;\n    long smalest_even_index_count_sum30 = 0;\n    long smalest_even_index_count_sum31\
    \ = 0;\n    long smalest_even_index_count_sum32 = 0;\n    long smalest_even_index_count_sum33\
    \ = 0;\n    long smalest_even_index_count_sum34 = 0;\n    long smalest_even_index_count_sum35\
    \ = 0;\n    long smalest_even_index_count_sum36 = 0;\n    long smalest_even_index_count_sum37\
    \ = 0;\n    long sm\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfzstx3xb.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpfzstx3xb.cpp:75:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   75 | }\n      | ^\n/tmp/tmpfzstx3xb.cpp:75:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_count =\
    \ 0;\n    long smalest_even_index_count_max = 0;\n    long smalest_even_index_count_min\
    \ = 0;\n    long smalest_even_index_count_temp = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smalest_even_index_count_temp_max\
    \ = 0;\n    long smalest_even_index_count_temp_min = 0;\n    long smale\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpim38saoq.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpim38saoq.cpp:39:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_count_temp_max\u2019\n   39 |     long smalest_even_index_count_temp_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpim38saoq.cpp:37:10:\
    \ note: \u2018long int smalest_even_index_count_temp_max\u2019 previously declared\
    \ here\n   37 |     long smalest_even_index_count_temp_max = 0;\n      |     \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpim38saoq.cpp:40:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_temp_min\u2019\n   40 |     long\
    \ smalest_even_index_count_temp_min = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpim38saoq.cpp:38:10: note: \u2018long int smalest_even_index_count_temp_min\u2019\
    \ previously declared here\n   38 |     long smalest_even_index_count_temp_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpim38saoq.cpp:41:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_temp_max\u2019\
    \n   41 |     long smalest_even_index_count_temp_max = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpim38saoq.cpp:37:10: note: \u2018long int smalest_even_index_count_temp_max\u2019\
    \ previously declared here\n   37 |     long smalest_even_index_count_temp_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpim38saoq.cpp:42:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_temp_min\u2019\
    \n   42 |     long smalest_even_index_count_temp_min = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpim38saoq.cpp:38:10: note: \u2018long int smalest_even_index_count_temp_min\u2019\
    \ previously declared here\n   38 |     long smalest_even_index_count_temp_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpim38saoq.cpp:43:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_temp_max\u2019\
    \n   43 |     long smalest_even_index_count_temp_max = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpim38saoq.cpp:37:10: note: \u2018long int smalest_even_index_count_temp_max\u2019\
    \ previously declar"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smallest_value = arr[0];\n   \
    \ long smallest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n    \
    \    if (arr[i] < smallest_value) {\n            smallest_value = arr[i];\n  \
    \          smallest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpabwuuf9q: /tmp/tmpabwuuf9q.cpp:46: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n  \
    \  ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp8f284gkv: /tmp/tmp8f284gkv.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpxwzzp7xm: /tmp/tmpxwzzp7xm.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = 0, smalest_index\
    \ = 0;\n    std::vector<long> result;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n \
    \               smalest_value = arr[i];\n                smalest_index = i;\n\
    \            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmppjtexmbs: /tmp/tmppjtexmbs.cpp:51: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_count =\
    \ 0;\n    long smalest_even_index_count_max = 0;\n    long smalest_even_index_count_min\
    \ = 0;\n    long smalest_even_index_count_sum = 0;\n    long smalest_even_index_count_sum_max\
    \ = 0;\n    long smalest_even_index_count_sum_min = 0;\n    long smalest_even_index_count_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_max = 0;\n    long smalest_even_index_count_sum_sum_min\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb2fk8j0n.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpb2fk8j0n.cpp:43:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_count_sum_sum_sum\u2019\n   43 |     long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb2fk8j0n.cpp:42:10:\
    \ note: \u2018long int smalest_even_index_count_sum_sum_sum\u2019 previously declared\
    \ here\n   42 |     long smalest_even_index_count_sum_sum_sum = 0;\n      |  \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb2fk8j0n.cpp:44:10: error:\
    \ redeclaration of \u2018long int smalest_even_index_count_sum_sum_sum\u2019\n\
    \   44 |     long smalest_even_index_count_sum_sum_sum = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb2fk8j0n.cpp:42:10: note: \u2018\
    long int smalest_even_index_count_sum_sum_sum\u2019 previously declared here\n\
    \   42 |     long smalest_even_index_count_sum_sum_sum = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb2fk8j0n.cpp:45:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_sum_sum_sum\u2019\n   45 |     long\
    \ smalest_even_index_count_sum_sum_sum = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb2fk8j0n.cpp:42:10: note: \u2018long int smalest_even_index_count_sum_sum_sum\u2019\
    \ previously declared here\n   42 |     long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb2fk8j0n.cpp:46:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_sum_sum_sum\u2019\
    \n   46 |     long smalest_even_index_count_sum_sum_sum = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb2fk8j0n.cpp:42:10: note: \u2018\
    long int smalest_even_index_count_sum_sum_sum\u2019 previously declared here\n\
    \   42 |     long smalest_even_index_count_sum_sum_sum = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpb2fk8j0n.cpp:47:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_sum_sum_sum\u2019\n   47 |     long\
    \ smalest_even_index_count_sum_sum_sum = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb2fk8j0"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = 0;\n    long smallest_index = 0;\n    long\
    \ smallest_even_value = 0;\n    std::vector<long> result;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            smallest_even_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n        if (arr[i] <\
    \ smallest_even_value) {\n            smallest_value = arr[i];\n            smallest_index\
    \ = i;\n        }\n    }\n    if (smallest_even_value) {\n        result.push_back(smallest_even_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp85t_2fsw: /tmp/tmp85t_2fsw.cpp:54: int main(): Assertion `candidate((std::vector<long>({5,\
    \ 0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = arr[0];\n    long\
    \ smalest_index = 0;\n    long smalest_index_value = arr[0];\n    long smalest_index_index\
    \ = 0;\n    long smalest_index_index_value = arr[0];\n    long smalest_index_index_index\
    \ = 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n        if (arr[i] < smalest_index_value) {\n            smalest_index_value\
    \ = arr[i];\n            smalest_index_index = i;\n        }\n        if (arr[i]\
    \ < smalest_index_index_value) {\n            smalest_index_index_value = arr[i];\n\
    \            smalest_index_index_index = i;\n        }\n        if (arr[i] < smalest_index_index_index_value)\
    \ {\n            smalest_index_index_index_value = arr[i];\n            smalest_index_index_index_index\
    \ = i;\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    ans.push_back(smalest_index_value);\n\
    \    ans.push_back(smalest_index_index);\n    ans.push_back(smalest_index_index_value);\n\
    \    ans.push_back(smalest_index_index_index);\n    ans.push_back(smalest_index_index_index_value);\n\
    \    ans.push_back(smalest_index_index_index_index);\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz33tndp1.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpz33tndp1.cpp:49:22: error: \u2018smalest_index_index_index_value\u2019\
    \ was not declared in this scope; did you mean \u2018smalest_index_index_index\u2019\
    ?\n   49 |         if (arr[i] < smalest_index_index_index_value) {\n      |  \
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                \
    \      smalest_index_index_index\n/tmp/tmpz33tndp1.cpp:51:13: error: \u2018smalest_index_index_index_index\u2019\
    \ was not declared in this scope; did you mean \u2018smalest_index_index_index\u2019\
    ?\n   51 |             smalest_index_index_index_index = i;\n      |         \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |             smalest_index_index_index\n\
    /tmp/tmpz33tndp1.cpp:61:19: error: \u2018smalest_index_index_index_value\u2019\
    \ was not declared in this scope; did you mean \u2018smalest_index_index_index\u2019\
    ?\n   61 |     ans.push_back(smalest_index_index_index_value);\n      |      \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                   smalest_index_index_index\n\
    /tmp/tmpz33tndp1.cpp:62:19: error: \u2018smalest_index_index_index_index\u2019\
    \ was not declared in this scope; did you mean \u2018smalest_index_index_index\u2019\
    ?\n   62 |     ans.push_back(smalest_index_index_index_index);\n      |      \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                   smalest_index_index_index\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0, smalest_index = 0;\n    long even_value\
    \ = 0;\n    long index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0)\
    \ {\n            even_value = i;\n            index = i;\n        }\n        if\
    \ (i == smalest_value) {\n            smalest_index = index;\n        }\n    \
    \    if (i == even_value) {\n            smalest_value = i;\n        }\n    }\n\
    \    std::vector<long> res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp17mvfjwi: /tmp/tmp17mvfjwi.cpp:51: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n   \
    \     if (arr[i] % 2 == 0) {\n            smallest_value = arr[i];\n         \
    \   smallest_index = i;\n        }\n    }\n    if (smallest_value == 0) {\n  \
    \      return {};\n    }\n    std::vector<long> result;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        if (arr[i] == smallest_value) {\n          \
    \  result.push_back(smallest_value);\n            result.push_back(index);\n \
    \       }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp11uaoczi: /tmp/tmp11uaoczi.cpp:53: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smallest_index = INT_MAX;\n    for (long i = 1; i < arr.size(); i++) {\n   \
    \     if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n   \
    \         smalest_index = i;\n        }\n        if (arr[i] < smallest_index)\
    \ {\n            smallest_index = arr[i];\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_index != INT_MAX) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmptv6fr56h: /tmp/tmptv6fr56h.cpp:51: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ largest_index = 0;\n    long largest_value = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n        if (arr[i] > largest_value)\
    \ {\n            largest_value = arr[i];\n            largest_index = i;\n   \
    \     }\n    }\n    if (largest_index == largest_value) {\n        std::vector<long>\
    \ result;\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \        return result;\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(largest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmps50fvjwu: /tmp/tmps50fvjwu.cpp:56: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    long smalest_index_value3 = 0;\n    long smalest_index_value4 = 0;\n    long\
    \ smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n    long smalest_index_value7\
    \ = 0;\n    long smalest_index_value8 = 0;\n    long smalest_index_value9 = 0;\n\
    \    long smalest_index_value10 = 0;\n    long smalest_index_value11 = 0;\n  \
    \  long smalest_index_value12 = 0;\n    long smalest_index_value13 = 0;\n    long\
    \ smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n    long smalest_index_value16\
    \ = 0;\n    long smalest_index_value17 = 0;\n    long smalest_index_value18 =\
    \ 0;\n    long smalest_index_value19 = 0;\n    long smalest_index_value20 = 0;\n\
    \    long smalest_index_value21 = 0;\n    long smalest_index_value22 = 0;\n  \
    \  long smalest_index_value23 = 0;\n    long smalest_index_value24 = 0;\n    long\
    \ smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n    long smalest_index_value27\
    \ = 0;\n    long smalest_index_value28 = 0;\n    long smalest_index_value29 =\
    \ 0;\n    long smalest_index_value30 = 0;\n    long smalest_index_value31 = 0;\n\
    \    long smalest_index_value32 = 0;\n    long smalest_index_value33 = 0;\n  \
    \  long smalest_index_value34 = 0;\n    long smalest_index_value35 = 0;\n    long\
    \ smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n    long smalest_index_value38\
    \ = 0;\n    long smalest_index_value39 = 0;\n    long smalest_index_value40 =\
    \ 0;\n    long smalest_index_value41 = 0;\n    long smalest_index_value42 = 0;\n\
    \    long smalest_index_value43 = 0;\n    long smalest_index_value44 = 0;\n  \
    \  long smalest_index_value45 = 0;\n    long smalest_index_value46 = 0;\n    long\
    \ smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n    long smalest_index_value49\
    \ = 0;\n    long smalest_index_value\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpsiwbbx_f.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpsiwbbx_f.cpp:82:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmpsiwbbx_f.cpp:82:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    long smalest_index_value2 = 0;\n    long smalest_index_value3 = 0;\n\
    \    long smalest_index_value4 = 0;\n    long smalest_index_value5 = 0;\n    long\
    \ smalest_index_value6 = 0;\n    long smalest_index_value7 = 0;\n    long smalest_index_value8\
    \ = 0;\n    long smalest_index_value9 = 0;\n    long smalest_index_value10 = 0;\n\
    \    long smalest_index_value11 = 0;\n    long smalest_index_value12 = 0;\n  \
    \  long smalest_index_value13 = 0;\n    long smalest_index_value14 = 0;\n    long\
    \ smalest_index_value15 = 0;\n    long smalest_index_value16 = 0;\n    long smalest_index_value17\
    \ = 0;\n    long smalest_index_value18 = 0;\n    long smalest_index_value19 =\
    \ 0;\n    long smalest_index_value20 = 0;\n    long smalest_index_value21 = 0;\n\
    \    long smalest_index_value22 = 0;\n    long smalest_index_value23 = 0;\n  \
    \  long smalest_index_value24 = 0;\n    long smalest_index_value25 = 0;\n    long\
    \ smalest_index_value26 = 0;\n    long smalest_index_value27 = 0;\n    long smalest_index_value28\
    \ = 0;\n    long smalest_index_value29 = 0;\n    long smalest_index_value30 =\
    \ 0;\n    long smalest_index_value31 = 0;\n    long smalest_index_value32 = 0;\n\
    \    long smalest_index_value33 = 0;\n    long smalest_index_value34 = 0;\n  \
    \  long smalest_index_value35 = 0;\n    long smalest_index_value36 = 0;\n    long\
    \ smalest_index_value37 = 0;\n    long smalest_index_value38 = 0;\n    long smalest_index_value39\
    \ = 0;\n    long smalest_index_value40 = 0;\n    long smalest_index_value41 =\
    \ 0;\n    long smalest_index_value42 = 0;\n    long smalest_index_value43 = 0;\n\
    \    long smalest_index_value44 = 0;\n    long smalest_index_value45 = 0;\n  \
    \  long smalest_index_value46 = 0;\n    long smalest_index_value47 = 0;\n    long\
    \ smalest_index_value48 = 0;\n    long smalest_index_value49 = 0;\n    long smalest_index_value50\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpu3rkr2bg: /tmp/tmpu3rkr2bg.cpp:85: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpyjc7sgj5: /tmp/tmpyjc7sgj5.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    long index = 0;\n    long value = 0;\n    std::vector<long>\
    \ result;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 ==\
    \ 0) {\n            smallest_value = arr[i];\n            smallest_index = i;\n\
    \        }\n    }\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i]\
    \ == smallest_value) {\n            result.push_back(smallest_value);\n      \
    \      result.push_back(smallest_index);\n        }\n    }\n    if(result.size()\
    \ == 0) {\n        return result;\n    }\n    for(long i = 0; i < result.size();\
    \ i++) {\n        if(result[i] % 2 == 0) {\n            value = result[i];\n \
    \           index = result[i + 1];\n        }\n    }\n    result.push_back(value);\n\
    \    result.push_back(index);\n    return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpvltccukn: /tmp/tmpvltccukn.cpp:62: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_of_smalest_value\
    \ = 0;\n    long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_smalest_value\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_yb_w9aa.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp_yb_w9aa.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmp_yb_w9aa.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    for(long i = 0; i < arr.size(); i++){\n        if(arr[i] % 2 == 0){\n   \
    \         if(smallest_even_count < arr[i]){\n                smallest_even_value\
    \ = arr[i];\n                smallest_even_count = arr[i];\n                smallest_index\
    \ = i;\n            }\n        }\n        else{\n            if(smallest_even_count\
    \ == arr[i]){\n                if(smallest_even_value < arr[i]){\n           \
    \         smallest_even_value = arr[i];\n                    smallest_index =\
    \ i;\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smallest_even_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpkdirbd_c: /tmp/tmpkdirbd_c.cpp:58: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpct_77mg_: /tmp/tmpct_77mg_.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n  \
    \  ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpszucgn7t: /tmp/tmpszucgn7t.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_value = arr[0];\n   \
    \ long smallest_index = 0;\n    long smallest_even_value = 0;\n    std::vector<long>\
    \ result;\n    for(long i = 0; i < arr.size(); i++){\n        if(arr[i] % 2 ==\
    \ 0){\n            if(smallest_value == 0){\n                smallest_value =\
    \ arr[i];\n                smallest_index = i;\n                smallest_even_value\
    \ = arr[i] % 2;\n            }\n            else if(smallest_value == arr[i] %\
    \ 2){\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n                smallest_even_value = arr[i] % 2;\n            }\n   \
    \         else if(smallest_value == arr[i] % 2 && smallest_even_value>arr[i] %\
    \ 2){\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n                smallest_even_value = arr[i] % 2;\n            }\n   \
    \         else if(smallest_value == arr[i] % 2 && smallest_even_value==arr[i]\
    \ % 2){\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n                smallest_even_value = arr[i] % 2;\n            }\n   \
    \     }\n    }\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpk255jaz4: /tmp/tmpk255jaz4.cpp:64: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = arr[0];\n    long smallest_index = 0;\n  \
    \  std::vector<long> result;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smallest_value) {\n            smallest_value = arr[i];\n\
    \            smallest_index = i;\n        }\n    }\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp500rbojm: /tmp/tmp500rbojm.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = 0;\n    for (long i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n    \
    \        smalest_index = i;\n            smalest_index_value = arr[i];\n     \
    \   }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp9i1d13m0: /tmp/tmp9i1d13m0.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    long temp = 0;\n    long count = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            temp\
    \ = arr[i];\n            count++;\n        }\n    }\n    if (count == 0) {\n \
    \       return {};\n    }\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_value) {\n     \
    \           smallest_value = arr[i];\n                smallest_index = i;\n  \
    \          }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpjbhnw8vw: /tmp/tmpjbhnw8vw.cpp:58: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smallest_value)\
    \ {\n            smallest_value = arr[i];\n            smallest_index = i;\n \
    \       }\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpc4h6gf52: /tmp/tmpc4h6gf52.cpp:46: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpjhadc9qk: /tmp/tmpjhadc9qk.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = arr[0];\n    long smalest_index\
    \ = 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpq2zxj7p3: /tmp/tmpq2zxj7p3.cpp:46: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp586tmh_x: /tmp/tmp586tmh_x.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0) {\n          \
    \  if (smalest_value < i) {\n                smalest_value = i;\n            \
    \    smalest_index = index;\n            }\n        }\n        index++;\n    }\n\
    \    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpzt0753y1: /tmp/tmpzt0753y1.cpp:51: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp6fzv40wj: /tmp/tmp6fzv40wj.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even = arr[0];\n    long smallest_index = arr[0];\n\
    \    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (smallest_even < arr[i]) {\n                smallest_even = arr[i];\n\
    \                smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_even != 0) {\n        result.push_back(smallest_even);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpw0sdswoq: /tmp/tmpw0sdswoq.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    long smallest_even_min_index = -1;\n    for(long i = 1; i < arr.size(); i++)\
    \ {\n        if(arr[i] % 2 == 0) {\n            smallest_even_count++;\n     \
    \       if(smallest_even_count > smallest_even_min_index) {\n                smallest_even_min_index\
    \ = smallest_even_count;\n                smallest_even_value = arr[i];\n    \
    \        }\n        } else {\n            smallest_even_count = 0;\n        }\n\
    \        if(arr[i] < smallest_value) {\n            smallest_value = arr[i];\n\
    \            smallest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if(smallest_even_min_index != -1) {\n        result.push_back(smallest_even_value);\n\
    \        result.push_back(smallest_even_min_index);\n    } else {\n        result.push_back(smallest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = arr[0];\n    long smalest_index\
    \ = 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0)\
    \ {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpus4k732y: /tmp/tmpus4k732y.cpp:51: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = arr[0];\n    long\
    \ smallest_index = arr[0];\n    long smallest_index_value = arr[0];\n    long\
    \ smallest_index_value_2 = arr[0];\n    for (long i = 1; i < arr.size(); i++)\
    \ {\n        if (arr[i] < smallest_value) {\n            smallest_value = arr[i];\n\
    \            smallest_index = i;\n        }\n        if (arr[i] < smallest_index_value)\
    \ {\n            smallest_index_value = arr[i];\n            smallest_index_value_2\
    \ = arr[i];\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    result.push_back(smallest_index_value);\n\
    \    result.push_back(smallest_index_value_2);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_vin5873.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp_vin5873.cpp:35:22: error: \u2018smallest_value\u2019\
    \ was not declared in this scope; did you mean \u2018smalest_value\u2019?\n  \
    \ 35 |         if (arr[i] < smallest_value) {\n      |                      ^~~~~~~~~~~~~~\n\
    \      |                      smalest_value\n/tmp/tmp_vin5873.cpp:45:22: error:\
    \ \u2018smallest_value\u2019 was not declared in this scope; did you mean \u2018\
    smalest_value\u2019?\n   45 |     result.push_back(smallest_value);\n      | \
    \                     ^~~~~~~~~~~~~~\n      |                      smalest_value\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_count = 0;\n    long smalest_even_index_count_index\
    \ = 0;\n    long smalest_even_index_count_index2 = 0;\n    long smalest_even_index_count_index3\
    \ = 0;\n    long smalest_even_index_count_index4 = 0;\n    long smalest_even_index_count_index5\
    \ = 0;\n    long smalest_even_index_count_index6 = 0;\n    long smalest_even_index_count_index7\
    \ = 0;\n    long smalest_even_index_count_index8 = 0;\n    long smalest_even_index_count_index9\
    \ = 0;\n    long smalest_even_index_count_index10 = 0;\n    long smalest_even_index_count_index11\
    \ = 0;\n    long smalest_even_index_count_index12 = 0;\n    long smalest_even_index_count_index13\
    \ = 0;\n    long smalest_even_index_count_index14 = 0;\n    long smalest_even_index_count_index15\
    \ = 0;\n    long smalest_even_index_count_index16 = 0;\n    long smalest_even_index_count_index17\
    \ = 0;\n    long smalest_even_index_count_index18 = 0;\n    long smalest_even_index_count_index19\
    \ = 0;\n    long smalest_even_index_count_index20 = 0;\n    long smalest_even_index_count_index21\
    \ = 0;\n    long smalest_even_index_count_index22 = 0;\n    long smalest_even_index_count_index23\
    \ = 0;\n    long smalest_even_index_count_index24 = 0;\n    long smalest_even_index_count_index25\
    \ = 0;\n    long smalest_even_index_count_index26 = 0;\n    long smalest_even_index_count_index27\
    \ = 0;\n    long smalest_even_index_count_index28 = 0;\n    long smalest_even_index_count_index29\
    \ = 0;\n    long smalest_even_index_count_index30 = 0;\n    long smalest_even_index_count_index31\
    \ = 0;\n    long smalest_even_index_count_index32 = 0;\n    long smalest_even_index_count_index33\
    \ = 0;\n    long smalest_even_index_count_index34 = 0;\n    long smalest_even_index_count_index35\
    \ = 0;\n    long smalest_even_index_count_index36 = 0;\n    long smalest_even_index_count_index37\
    \ = 0;\n    long smalest_even_index_count_index38 = 0;\n    long smalest_even_index_count_index39\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpa9t5mto7: /tmp/tmpa9t5mto7.cpp:78: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n \
    \           smallest_even_count++;\n            if(smallest_even_count == smallest_even_value\
    \ && smallest_even_value == arr[i]) {\n                smallest_even_value = arr[i];\n\
    \                smallest_index = i;\n            }\n        }\n        else {\n\
    \            smallest_value = arr[i];\n            smallest_index = i;\n     \
    \   }\n    }\n    std::vector<long> result;\n    if(smallest_even_count == smallest_even_value\
    \ && smallest_even_value == arr[0]) {\n        result.push_back(smallest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    else {\n        result.push_back(smallest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmps_ul_etb: /tmp/tmps_ul_etb.cpp:60: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long even_value = 0;\n    long even_index = 0;\n    long index = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp8y2eqwwx: /tmp/tmp8y2eqwwx.cpp:118: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    long smalest_index_value3 = 0;\n    long smalest_index_value4 = 0;\n    long\
    \ smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n    long smalest_index_value7\
    \ = 0;\n    long smalest_index_value8 = 0;\n    long smalest_index_value9 = 0;\n\
    \    long smalest_index_value10 = 0;\n    long smalest_index_value11 = 0;\n  \
    \  long smalest_index_value12 = 0;\n    long smalest_index_value13 = 0;\n    long\
    \ smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n    long smalest_index_value16\
    \ = 0;\n    long smalest_index_value17 = 0;\n    long smalest_index_value18 =\
    \ 0;\n    long smalest_index_value19 = 0;\n    long smalest_index_value20 = 0;\n\
    \    long smalest_index_value21 = 0;\n    long smalest_index_value22 = 0;\n  \
    \  long smalest_index_value23 = 0;\n    long smalest_index_value24 = 0;\n    long\
    \ smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n    long smalest_index_value27\
    \ = 0;\n    long smalest_index_value28 = 0;\n    long smalest_index_value29 =\
    \ 0;\n    long smalest_index_value30 = 0;\n    long smalest_index_value31 = 0;\n\
    \    long smalest_index_value32 = 0;\n    long smalest_index_value33 = 0;\n  \
    \  long smalest_index_value34 = 0;\n    long smalest_index_value35 = 0;\n    long\
    \ smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n    long smalest_index_value38\
    \ = 0;\n    long smalest_index_value39 = 0;\n    long smalest_index_value40 =\
    \ 0;\n    long smalest_index_value41 = 0;\n    long smalest_index_value42 = 0;\n\
    \    long smalest_index_value43 = 0;\n    long smalest_index_value44 = 0;\n  \
    \  long smalest_index_value45 = 0;\n    long smalest_index_value46 = 0;\n    long\
    \ smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n    long smalest_index_value49\
    \ = 0;\n    long smalest_index_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprqrm4mqr.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmprqrm4mqr.cpp:82:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmprqrm4mqr.cpp:82:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    std::vector<long> result;\n    for(long i = 0; i <\
    \ arr.size(); i++){\n        if(arr[i] % 2 == 0){\n            if(arr[i] < smallest_value){\n\
    \                smallest_value = arr[i];\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpilz3ei0z: /tmp/tmpilz3ei0z.cpp:47: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    long index = 0;\n    long even_value = 0;\n    long even_count = 0;\n   \
    \ long temp = 0;\n    long count = 0;\n    long temp2 = 0;\n    long count2 =\
    \ 0;\n    long temp3 = 0;\n    long count3 = 0;\n    long temp4 = 0;\n    long\
    \ count4 = 0;\n    long temp5 = 0;\n    long count5 = 0;\n    long temp6 = 0;\n\
    \    long count6 = 0;\n    long temp7 = 0;\n    long count7 = 0;\n    long temp8\
    \ = 0;\n    long count8 = 0;\n    long temp9 = 0;\n    long count9 = 0;\n    long\
    \ temp10 = 0;\n    long count10 = 0;\n    long temp11 = 0;\n    long count11 =\
    \ 0;\n    long temp12 = 0;\n    long count12 = 0;\n    long temp13 = 0;\n    long\
    \ count13 = 0;\n    long temp14 = 0;\n    long count14 = 0;\n    long temp15 =\
    \ 0;\n    long count15 = 0;\n    long temp16 = 0;\n    long count16 = 0;\n   \
    \ long temp17 = 0;\n    long count17 = 0;\n    long temp18 = 0;\n    long count18\
    \ = 0;\n    long temp19 = 0;\n    long count19 = 0;\n    long temp20 = 0;\n  \
    \  long count20 = 0;\n    long temp21 = 0;\n    long count21 = 0;\n    long temp22\
    \ = 0;\n    long count22 = 0;\n    long temp23 = 0;\n    long count23 = 0;\n \
    \   long temp24 = 0;\n    long count24 = 0;\n    long temp25 = 0;\n    long count25\
    \ = 0;\n    long temp26 = 0;\n    long count26 = 0;\n    long temp27 = 0;\n  \
    \  long count27 = 0;\n    long temp28 = 0;\n    long count28 = 0;\n    long temp29\
    \ = 0;\n    long count29 = 0;\n    long temp30 = 0;\n    long count30 = 0;\n \
    \   long temp31 = 0;\n    long count31 = 0;\n    long temp32 = 0;\n    long count32\
    \ = 0;\n    long temp33 = 0;\n    long count33 = 0;\n    long temp34 = 0;\n  \
    \  long count34 = 0;\n    long temp35 = 0;\n    long count35 = 0;\n    long temp36\
    \ = 0;\n    long count36 = 0;\n    long temp37 = 0;\n    long count37 = 0;\n \
    \   long temp38 = 0;\n    long count38 = 0;\n    long temp39 = 0;\n    long count39\
    \ = 0;\n    long temp40\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_bh0zda7.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp_bh0zda7.cpp:116:1: error: expected initializer before\
    \ \u2018}\u2019 token\n  116 | }\n      | ^\n/tmp/tmp_bh0zda7.cpp:116:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    std::vector<long>\
    \ ans;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpvzig0rwe: /tmp/tmpvzig0rwe.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    long smalest_index_value2 = 0;\n    long smalest_index_value3 = 0;\n\
    \    long smalest_index_value4 = 0;\n    long smalest_index_value5 = 0;\n    long\
    \ smalest_index_value6 = 0;\n    long smalest_index_value7 = 0;\n    long smalest_index_value8\
    \ = 0;\n    long smalest_index_value9 = 0;\n    long smalest_index_value10 = 0;\n\
    \    long smalest_index_value11 = 0;\n    long smalest_index_value12 = 0;\n  \
    \  long smalest_index_value13 = 0;\n    long smalest_index_value14 = 0;\n    long\
    \ smalest_index_value15 = 0;\n    long smalest_index_value16 = 0;\n    long smalest_index_value17\
    \ = 0;\n    long smalest_index_value18 = 0;\n    long smalest_index_value19 =\
    \ 0;\n    long smalest_index_value20 = 0;\n    long smalest_index_value21 = 0;\n\
    \    long smalest_index_value22 = 0;\n    long smalest_index_value23 = 0;\n  \
    \  long smalest_index_value24 = 0;\n    long smalest_index_value25 = 0;\n    long\
    \ smalest_index_value26 = 0;\n    long smalest_index_value27 = 0;\n    long smalest_index_value28\
    \ = 0;\n    long smalest_index_value29 = 0;\n    long smalest_index_value30 =\
    \ 0;\n    long smalest_index_value31 = 0;\n    long smalest_index_value32 = 0;\n\
    \    long smalest_index_value33 = 0;\n    long smalest_index_value34 = 0;\n  \
    \  long smalest_index_value35 = 0;\n    long smalest_index_value36 = 0;\n    long\
    \ smalest_index_value37 = 0;\n    long smalest_index_value38 = 0;\n    long smalest_index_value39\
    \ = 0;\n    long smalest_index_value40 = 0;\n    long smalest_index_value41 =\
    \ 0;\n    long smalest_index_value42 = 0;\n    long smalest_index_value43 = 0;\n\
    \    long smalest_index_value44 = 0;\n    long smalest_index_value45 = 0;\n  \
    \  long smalest_index_value46 = 0;\n    long smalest_index_value47 = 0;\n    long\
    \ smalest_index_value48 = 0;\n    long smalest_index_value49 = 0;\n    long smalest_index_value50\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpy5cun11u: /tmp/tmpy5cun11u.cpp:85: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value=0;\n    long smalest_index=0;\n\
    \    long smalest_index_value=0;\n    long smalest_index_value2=0;\n    long smalest_index_value3=0;\n\
    \    long smalest_index_value4=0;\n    long smalest_index_value5=0;\n    long\
    \ smalest_index_value6=0;\n    long smalest_index_value7=0;\n    long smalest_index_value8=0;\n\
    \    long smalest_index_value9=0;\n    long smalest_index_value10=0;\n    long\
    \ smalest_index_value11=0;\n    long smalest_index_value12=0;\n    long smalest_index_value13=0;\n\
    \    long smalest_index_value14=0;\n    long smalest_index_value15=0;\n    long\
    \ smalest_index_value16=0;\n    long smalest_index_value17=0;\n    long smalest_index_value18=0;\n\
    \    long smalest_index_value19=0;\n    long smalest_index_value20=0;\n    long\
    \ smalest_index_value21=0;\n    long smalest_index_value22=0;\n    long smalest_index_value23=0;\n\
    \    long smalest_index_value24=0;\n    long smalest_index_value25=0;\n    long\
    \ smalest_index_value26=0;\n    long smalest_index_value27=0;\n    long smalest_index_value28=0;\n\
    \    long smalest_index_value29=0;\n    long smalest_index_value30=0;\n    long\
    \ smalest_index_value31=0;\n    long smalest_index_value32=0;\n    long smalest_index_value33=0;\n\
    \    long smalest_index_value34=0;\n    long smalest_index_value35=0;\n    long\
    \ smalest_index_value36=0;\n    long smalest_index_value37=0;\n    long smalest_index_value38=0;\n\
    \    long smalest_index_value39=0;\n    long smalest_index_value40=0;\n    long\
    \ smalest_index_value41=0;\n    long smalest_index_value42=0;\n    long smalest_index_value43=0;\n\
    \    long smalest_index_value44=0;\n    long smalest_index_value45=0;\n    long\
    \ smalest_index_value46=0;\n    long smalest_index_value47=0;\n    long smalest_index_value48=0;\n\
    \    long smalest_index_value49=0;\n    \n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp7c1jru1j: /tmp/tmp7c1jru1j.cpp:85: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value2 = 0;\n\
    \    long smalest_index_value3 = 0;\n    long smalest_index_value4 = 0;\n    long\
    \ smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n    long smalest_index_value7\
    \ = 0;\n    long smalest_index_value8 = 0;\n    long smalest_index_value9 = 0;\n\
    \    long smalest_index_value10 = 0;\n    long smalest_index_value11 = 0;\n  \
    \  long smalest_index_value12 = 0;\n    long smalest_index_value13 = 0;\n    long\
    \ smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n    long smalest_index_value16\
    \ = 0;\n    long smalest_index_value17 = 0;\n    long smalest_index_value18 =\
    \ 0;\n    long smalest_index_value19 = 0;\n    long smalest_index_value20 = 0;\n\
    \    long smalest_index_value21 = 0;\n    long smalest_index_value22 = 0;\n  \
    \  long smalest_index_value23 = 0;\n    long smalest_index_value24 = 0;\n    long\
    \ smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n    long smalest_index_value27\
    \ = 0;\n    long smalest_index_value28 = 0;\n    long smalest_index_value29 =\
    \ 0;\n    long smalest_index_value30 = 0;\n    long smalest_index_value31 = 0;\n\
    \    long smalest_index_value32 = 0;\n    long smalest_index_value33 = 0;\n  \
    \  long smalest_index_value34 = 0;\n    long smalest_index_value35 = 0;\n    long\
    \ smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n    long smalest_index_value38\
    \ = 0;\n    long smalest_index_value39 = 0;\n    long smalest_index_value40 =\
    \ 0;\n    long smalest_index_value41 = 0;\n    long smalest_index_value42 = 0;\n\
    \    long smalest_index_value43 = 0;\n    long smalest_index_value44 = 0;\n  \
    \  long smalest_index_value45 = 0;\n    long smalest_index_value46 = 0;\n    long\
    \ smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n    long smalest_index_value49\
    \ = 0;\n    long smalest_index_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjb9fex1y.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpjb9fex1y.cpp:82:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmpjb9fex1y.cpp:82:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    long smallest_index_value = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smallest_value) {\n            smallest_value =\
    \ arr[i];\n            smallest_index = i;\n            smallest_index_value =\
    \ arr[i];\n        }\n    }\n    std::vector<long> result;\n    if (smallest_value\
    \ == 0) {\n        result.push_back(smallest_index_value);\n    } else {\n   \
    \     result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpthg9ysan: /tmp/tmpthg9ysan.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value = arr[0];\n    long\
    \ smalest_index = 0;\n    long smalest_even_value = 0;\n    for (long i = 0; i\
    \ < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value\
    \ == arr[i]) {\n                smalest_even_value = arr[i];\n               \
    \ smalest_index = i;\n            } else if (smalest_value == arr[i] && smalest_index\
    \ != i) {\n                smalest_even_value = arr[i];\n                smalest_index\
    \ = i;\n            }\n        }\n    }\n    std::vector<long> result;\n    if\
    \ (smalest_even_value == 0) {\n        return result;\n    }\n    result.push_back(smalest_even_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp2ydt74t0: /tmp/tmp2ydt74t0.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index = 0;\n \
    \   long smalest_even_index_count = 0;\n    long smalest_even_value_count = 0;\n\
    \    long smalest_value_index = 0;\n    long smalest_value_index_count = 0;\n\
    \    long smalest_value_index_count_temp = 0;\n    long smalest_value_index_count_temp2\
    \ = 0;\n    long smalest_value_index_count_temp3 = 0;\n    long smalest_value_index_count_temp4\
    \ = 0;\n    long smalest_value_index_count_temp5 = 0;\n    long smalest_value_index_count_temp6\
    \ = 0;\n    long smalest_value_index_count_temp7 = 0;\n    long smalest_value_index_count_temp8\
    \ = 0;\n    long smalest_value_index_count_temp9 = 0;\n    long smalest_value_index_count_temp10\
    \ = 0;\n    long smalest_value_index_count_temp11 = 0;\n    long smalest_value_index_count_temp12\
    \ = 0;\n    long smalest_value_index_count_temp13 = 0;\n    long smalest_value_index_count_temp14\
    \ = 0;\n    long smalest_value_index_count_temp15 = 0;\n    long smalest_value_index_count_temp16\
    \ = 0;\n    long smalest_value_index_count_temp17 = 0;\n    long smalest_value_index_count_temp18\
    \ = 0;\n    long smalest_value_index_count_temp19 = 0;\n    long smalest_value_index_count_temp20\
    \ = 0;\n    long smalest_value_index_count_temp21 = 0;\n    long smalest_value_index_count_temp22\
    \ = 0;\n    long smalest_value_index_count_temp23 = 0;\n    long smalest_value_index_count_temp24\
    \ = 0;\n    long smalest_value_index_count_temp25 = 0;\n    long smalest_value_index_count_temp26\
    \ = 0;\n    long smalest_value_index_count_temp27 = 0;\n    long smalest_value_index_count_temp28\
    \ = 0;\n    long smalest_value_index_count_temp29 = 0;\n    long smalest_value_index_count_temp30\
    \ = 0;\n    long smalest_value_index_count_temp31 = 0;\n    long smalest_value_index_count_temp32\
    \ = 0;\n    long smalest_value_index_count_temp33 = 0;\n    long smalest_value_index_count_temp34\
    \ = 0;\n    long smalest_value_index_count_temp35 = 0;\n    long smalest_value_index_count_temp36\
    \ = 0;\n    long smalest_value_index_count_temp37\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprzjfcvbj.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmprzjfcvbj.cpp:75:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   75 | }\n      | ^\n/tmp/tmprzjfcvbj.cpp:75:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smalest_index_value %\
    \ 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index\
    \ + 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpkrv8y_eg: /tmp/tmpkrv8y_eg.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here.\n    long smallest_value = 0;\n    long\
    \ smallest_index = 0;\n    long index = 0;\n    for(long i = 0; i < arr.size();\
    \ i++){\n        if(arr[i] % 2 == 0){\n            if(smallest_value == 0){\n\
    \                smallest_value = arr[i];\n                smallest_index = i;\n\
    \            }\n            else if(arr[i] < smallest_value){\n              \
    \  smallest_value = arr[i];\n                smallest_index = i;\n           \
    \ }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpr2sw7gm3: /tmp/tmpr2sw7gm3.cpp:54: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::vector<long>())' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0, smalest_index = 0;\n    std::vector<long>\
    \ res;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0)\
    \ {\n            if(smalest_value == 0 || smalest_value < arr[i]) {\n        \
    \        smalest_value = arr[i];\n                smalest_index = i;\n       \
    \     }\n        }\n    }\n    if(smalest_index != 0) {\n        res.push_back(smalest_value);\n\
    \        res.push_back(smalest_index);\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp4e_eiv36: /tmp/tmp4e_eiv36.cpp:47: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_in_array\
    \ = 0;\n    long smalest_even_index_in_array_index = 0;\n    long smalest_even_index_in_array_value\
    \ = 0;\n    long smalest_even_index_in_array_value_index = 0;\n    long smalest_even_index_in_array_value_value\
    \ = 0;\n    long smalest_even_index_in_array_value_value_index = 0;\n    long\
    \ smalest_even_index_in_array_value_value_value = 0;\n    long smalest_even_index_in_array_value_value_value_index\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_value = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_index = 0;\n    long smalest_even_index_in_array_value_value_value_value\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_index = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_value = 0;\n    long smalest_even_index_in_array_value_value_value_index\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_value = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_index = 0;\n    long smalest_even_index_in_array_value_value_value_value\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_index = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_value = 0;\n    long smalest_even_index_in_array_value_value_value_index\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_value = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_index = 0;\n    long smalest_even_index_in_array_value_value_value_value\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_index = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_value = 0;\n    long smalest_even_index_in_array_value_value_value_index\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_value = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_index = 0;\n    long smalest_even_index_in_array_value_value_value_value\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_index = 0;\n  \
    \  long smalest_even_index_in_array_value_value_value_value = 0;\n    long smalest_even_index_in_array_value_value_value_index\
    \ = 0;\n    long smalest_even_index_in_array_value_value_value_value = 0;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptks0el4j.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmptks0el4j.cpp:42:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_in_array_value_value_value_index\u2019\n   42 |     long\
    \ smalest_even_index_in_array_value_value_value_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptks0el4j.cpp:40:10: note: \u2018long int smalest_even_index_in_array_value_value_value_index\u2019\
    \ previously declared here\n   40 |     long smalest_even_index_in_array_value_value_value_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptks0el4j.cpp:43:10: error: redeclaration of \u2018long int smalest_even_index_in_array_value_value_value_value\u2019\
    \n   43 |     long smalest_even_index_in_array_value_value_value_value = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptks0el4j.cpp:41:10:\
    \ note: \u2018long int smalest_even_index_in_array_value_value_value_value\u2019\
    \ previously declared here\n   41 |     long smalest_even_index_in_array_value_value_value_value\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptks0el4j.cpp:44:10: error: redeclaration of \u2018long int smalest_even_index_in_array_value_value_value_index\u2019\
    \n   44 |     long smalest_even_index_in_array_value_value_value_index = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptks0el4j.cpp:40:10:\
    \ note: \u2018long int smalest_even_index_in_array_value_value_value_index\u2019\
    \ previously declared here\n   40 |     long smalest_even_index_in_array_value_value_value_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptks0el4j.cpp:45:10: error: redeclaration of \u2018long int smalest_even_index_in_array_value_value_value_value\u2019\
    \n   45 |     long smalest_even_index_in_array_value_value_value_value = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptks0el4j.cpp:41:10:\
    \ note: \u2018long int smalest_even_index_in_array_value_value_value_value\u2019\
    \ previously declared here\n   41 |    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_of_smalest_value = 0;\n    long smalest_index_of_smalest_value2\
    \ = 0;\n    long smalest_index_of_smalest_value3 = 0;\n    long smalest_index_of_smalest_value4\
    \ = 0;\n    long smalest_index_of_smalest_value5 = 0;\n    long smalest_index_of_smalest_value6\
    \ = 0;\n    long smalest_index_of_smalest_value7 = 0;\n    long smalest_index_of_smalest_value8\
    \ = 0;\n    long smalest_index_of_smalest_value9 = 0;\n    long smalest_index_of_smalest_value10\
    \ = 0;\n    long smalest_index_of_smalest_value11 = 0;\n    long smalest_index_of_smalest_value12\
    \ = 0;\n    long smalest_index_of_smalest_value13 = 0;\n    long smalest_index_of_smalest_value14\
    \ = 0;\n    long smalest_index_of_smalest_value15 = 0;\n    long smalest_index_of_smalest_value16\
    \ = 0;\n    long smalest_index_of_smalest_value17 = 0;\n    long smalest_index_of_smalest_value18\
    \ = 0;\n    long smalest_index_of_smalest_value19 = 0;\n    long smalest_index_of_smalest_value20\
    \ = 0;\n    long smalest_index_of_smalest_value21 = 0;\n    long smalest_index_of_smalest_value22\
    \ = 0;\n    long smalest_index_of_smalest_value23 = 0;\n    long smalest_index_of_smalest_value24\
    \ = 0;\n    long smalest_index_of_smalest_value25 = 0;\n    long smalest_index_of_smalest_value26\
    \ = 0;\n    long smalest_index_of_smalest_value27 = 0;\n    long smalest_index_of_smalest_value28\
    \ = 0;\n    long smalest_index_of_smalest_value29 = 0;\n    long smalest_index_of_smalest_value30\
    \ = 0;\n    long smalest_index_of_smalest_value31 = 0;\n    long smalest_index_of_smalest_value32\
    \ = 0;\n    long smalest_index_of_smalest_value33 = 0;\n    long smalest_index_of_smalest_value34\
    \ = 0;\n    long smalest_index_of_smalest_value35 = 0;\n    long smalest_index_of_smalest_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaa2t9i19.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpaa2t9i19.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmpaa2t9i19.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmptnbclsw1: /tmp/tmptnbclsw1.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = arr[0];\n    long smallest_index = 0;\n  \
    \  for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smallest_value)\
    \ {\n            smallest_value = arr[i];\n            smallest_index = i;\n \
    \       }\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp212mmesn: /tmp/tmp212mmesn.cpp:45: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpvkbv0yrn: /tmp/tmpvkbv0yrn.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ < smalest_value) {\n            smalest_value = arr[i];\n            smalest_index\
    \ = i;\n        }\n        if (arr[i] == smalest_value) {\n            index =\
    \ i;\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpws1a28y7: /tmp/tmpws1a28y7.cpp:49: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_index =\
    \ 0;\n    long smalest_even_index_index_index = 0;\n    long smalest_even_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index = 0;\n    long smalest_even_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index = 0;\n\
    \    long smalest_even_index_index_index_index_index_index_index_index = 0;\n\
    \    long smalest_even_index_index_index_index_index_index_index_index_index =\
    \ 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n    long sm\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpax9kagd5.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpax9kagd5.cpp:45:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   45 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpax9kagd5.cpp:44:10: note: \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \ previously declared here\n   44 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpax9kagd5.cpp:46:10: error: redeclaration of \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   46 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpax9kagd5.cpp:44:10: note: \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \ previously declared here\n   44 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpax9kagd5.cpp:49:10: error: redeclaration of \u2018long int smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\u2019\
    \n   49 |     long smalest_even_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpax9kagd5.cpp:48:10: note: \u2018"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    long smalest_index_value_index = 0;\n   \
    \ long smalest_index_value_index_value = arr[0];\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \           smalest_index_value_index = i;\n            smalest_index_value_index_value\
    \ = arr[i];\n        }\n        else if (arr[i] == smalest_value) {\n        \
    \    if (arr[i] < smalest_index_value) {\n                smalest_index_value\
    \ = arr[i];\n                smalest_index_value_index = i;\n                smalest_index_value_index_value\
    \ = arr[i];\n            }\n        }\n    }\n    std::vector<long> ans;\n   \
    \ ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n    ans.push_back(smalest_index_value);\n\
    \    ans.push_back(smalest_index_value_index);\n    ans.push_back(smalest_index_value_index_value);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpbzwf5map: /tmp/tmpbzwf5map.cpp:60: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index2\
    \ = 0;\n    long smalest_index3 = 0;\n    long smalest_index4 = 0;\n    long smalest_index5\
    \ = 0;\n    long smalest_index6 = 0;\n    long smalest_index7 = 0;\n    long smalest_index8\
    \ = 0;\n    long smalest_index9 = 0;\n    long smalest_index10 = 0;\n    long\
    \ smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long smalest_index13\
    \ = 0;\n    long smalest_index14 = 0;\n    long smalest_index15 = 0;\n    long\
    \ smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long smalest_index18\
    \ = 0;\n    long smalest_index19 = 0;\n    long smalest_index20 = 0;\n    long\
    \ smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long smalest_index23\
    \ = 0;\n    long smalest_index24 = 0;\n    long smalest_index25 = 0;\n    long\
    \ smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long smalest_index28\
    \ = 0;\n    long smalest_index29 = 0;\n    long smalest_index30 = 0;\n    long\
    \ smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long smalest_index33\
    \ = 0;\n    long smalest_index34 = 0;\n    long smalest_index35 = 0;\n    long\
    \ smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long smalest_index38\
    \ = 0;\n    long smalest_index39 = 0;\n    long smalest_index40 = 0;\n    long\
    \ smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long smalest_index43\
    \ = 0;\n    long smalest_index44 = 0;\n    long smalest_index45 = 0;\n    long\
    \ smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long smalest_index48\
    \ = 0;\n    long smalest_index49 = 0;\n    long smalest_index50 = 0;\n    long\
    \ smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long smalest_index53\
    \ = 0;\n    long smalest_index54 = 0;\n    long smalest_index55 = 0;\n    long\
    \ smalest_index56 = 0;\n    long smalest_\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppu0fcozg.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppu0fcozg.cpp:87:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmppu0fcozg.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ index = 0;\n    long even_value = 0;\n    for (auto &i : arr) {\n        if\
    \ (i % 2 == 0) {\n            even_value = i;\n        }\n        if (i == smalest_value)\
    \ {\n            smalest_index = index;\n        }\n        index++;\n    }\n\
    \    if (smalest_index == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp8b1mkhp_: /tmp/tmp8b1mkhp_.cpp:52: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value == 0) {\n                smalest_value = arr[i];\n          \
    \      smalest_index = i;\n            } else if (smalest_value < arr[i]) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    if (smalest_value\
    \ != 0) {\n        ans.push_back(smalest_value);\n        ans.push_back(smalest_index);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpy_urb583: /tmp/tmpy_urb583.cpp:51: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long smalest_value=0;\n    long smalest_index=0;\n\
    \    long smallest_value=arr[0];\n    long smallest_index=0;\n    for(long i=0;i<arr.size();i++){\n\
    \        if(arr[i]%2==0){\n            if(arr[i]<smallest_value){\n          \
    \      smallest_value=arr[i];\n                smallest_index=i;\n           \
    \ }\n        }\n        else{\n            if(arr[i]<smallest_value){\n      \
    \          smalest_value=arr[i];\n                smalest_index=i;\n         \
    \   }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpfujfvt2l: /tmp/tmpfujfvt2l.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = 0;\n    long smallest_index = 0;\n    long\
    \ smallest_even_value = 0;\n    long smallest_even_count = 0;\n    long index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smallest_even_count < arr[i]) {\n                smallest_even_value\
    \ = arr[i];\n                smallest_even_count = arr[i];\n                smallest_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n            else\
    \ {\n                if (arr[i] < smallest_value) {\n                    smallest_value\
    \ = arr[i];\n                    smallest_index = i;\n                }\n    \
    \        }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even_count\
    \ == 0) {\n        result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \    }\n    else {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp8a77b336: /tmp/tmp8a77b336.cpp:63: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0, smalest_index = 0;\n    long even_value\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            even_value = arr[i];\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    if (smalest_value == 0)\
    \ {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smalest_value) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpfx090zmt: /tmp/tmpfx090zmt.cpp:61: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = 0;\n    long smallest_index = 0;\n    long\
    \ smallest_even_value = 0;\n    std::vector<long> result;\n    for(long i = 0;\
    \ i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n            smallest_even_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n        else {\n    \
    \        if(smallest_even_value < arr[i]) {\n                smallest_even_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    if(smallest_even_value == 0) {\n        return result;\n    }\n   \
    \ result.push_back(smallest_even_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmphjvhmbgy: /tmp/tmphjvhmbgy.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long smallest_even_value = 0;\n    long smallest_even_count = 0;\n\
    \    long index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0) {\n  \
    \          if (smallest_even_count == 0) {\n                smallest_even_count\
    \ = 1;\n                smallest_even_value = i;\n                smallest_value\
    \ = i;\n                smallest_index = index;\n            } else if (smallest_even_count\
    \ == 1) {\n                smallest_even_count++;\n                smallest_even_value\
    \ = i;\n                smallest_value = i;\n                smallest_index =\
    \ index;\n            } else if (smallest_even_count > 1) {\n                smallest_even_count\
    \ = 1;\n                smallest_even_value = i;\n                smallest_value\
    \ = i;\n                smallest_index = index;\n            }\n        } else\
    \ {\n            if (smallest_even_count == 0) {\n                smallest_even_count\
    \ = 1;\n                smallest_even_value = i;\n                smallest_value\
    \ = i;\n                smallest_index = index;\n            } else if (smallest_even_count\
    \ == 1) {\n                smallest_even_count++;\n                smallest_even_value\
    \ = i;\n                smallest_value = i;\n                smallest_index =\
    \ index;\n            } else if (smallest_even_count > 1) {\n                smallest_even_count\
    \ = 1;\n                smallest_even_value = i;\n                smallest_value\
    \ = i;\n                smallest_index = index;\n            }\n        }\n  \
    \      index++;\n    }\n    if (smallest_even_count == 0) {\n        return {};\n\
    \    }\n    std::vector<long> result;\n    result.push_back(smallest_even_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp0t5i4g6w: /tmp/tmp0t5i4g6w.cpp:83: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index2\
    \ = 0;\n    long smalest_index3 = 0;\n    long smalest_index4 = 0;\n    long smalest_index5\
    \ = 0;\n    long smalest_index6 = 0;\n    long smalest_index7 = 0;\n    long smalest_index8\
    \ = 0;\n    long smalest_index9 = 0;\n    long smalest_index10 = 0;\n    long\
    \ smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long smalest_index13\
    \ = 0;\n    long smalest_index14 = 0;\n    long smalest_index15 = 0;\n    long\
    \ smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long smalest_index18\
    \ = 0;\n    long smalest_index19 = 0;\n    long smalest_index20 = 0;\n    long\
    \ smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long smalest_index23\
    \ = 0;\n    long smalest_index24 = 0;\n    long smalest_index25 = 0;\n    long\
    \ smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long smalest_index28\
    \ = 0;\n    long smalest_index29 = 0;\n    long smalest_index30 = 0;\n    long\
    \ smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long smalest_index33\
    \ = 0;\n    long smalest_index34 = 0;\n    long smalest_index35 = 0;\n    long\
    \ smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long smalest_index38\
    \ = 0;\n    long smalest_index39 = 0;\n    long smalest_index40 = 0;\n    long\
    \ smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long smalest_index43\
    \ = 0;\n    long smalest_index44 = 0;\n    long smalest_index45 = 0;\n    long\
    \ smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long smalest_index48\
    \ = 0;\n    long smalest_index49 = 0;\n    long smalest_index50 = 0;\n    long\
    \ smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long smalest_index53\
    \ = 0;\n    long smalest_index54 = 0;\n    long smalest_index55 = 0;\n    long\
    \ smalest_index56 = 0;\n    long smalest_\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmph04qfchy.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmph04qfchy.cpp:87:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmph04qfchy.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smalest_index3 = 0;\n    long smalest_index4\
    \ = 0;\n    long smalest_index5 = 0;\n    long smalest_index6 = 0;\n    long smalest_index7\
    \ = 0;\n    long smalest_index8 = 0;\n    long smalest_index9 = 0;\n    long smalest_index10\
    \ = 0;\n    long smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long\
    \ smalest_index13 = 0;\n    long smalest_index14 = 0;\n    long smalest_index15\
    \ = 0;\n    long smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long\
    \ smalest_index18 = 0;\n    long smalest_index19 = 0;\n    long smalest_index20\
    \ = 0;\n    long smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long\
    \ smalest_index23 = 0;\n    long smalest_index24 = 0;\n    long smalest_index25\
    \ = 0;\n    long smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long\
    \ smalest_index28 = 0;\n    long smalest_index29 = 0;\n    long smalest_index30\
    \ = 0;\n    long smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long\
    \ smalest_index33 = 0;\n    long smalest_index34 = 0;\n    long smalest_index35\
    \ = 0;\n    long smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long\
    \ smalest_index38 = 0;\n    long smalest_index39 = 0;\n    long smalest_index40\
    \ = 0;\n    long smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long\
    \ smalest_index43 = 0;\n    long smalest_index44 = 0;\n    long smalest_index45\
    \ = 0;\n    long smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long\
    \ smalest_index48 = 0;\n    long smalest_index49 = 0;\n    long smalest_index50\
    \ = 0;\n    long smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long\
    \ smalest_index53 = 0;\n    long smalest_index54 = 0;\n    long smalest_index55\
    \ = 0;\n    long smalest_index56 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpfn9jstq2: /tmp/tmpfn9jstq2.cpp:91: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index2\
    \ = 0;\n    long smalest_index3 = 0;\n    long smalest_index4 = 0;\n    long smalest_index5\
    \ = 0;\n    long smalest_index6 = 0;\n    long smalest_index7 = 0;\n    long smalest_index8\
    \ = 0;\n    long smalest_index9 = 0;\n    long smalest_index10 = 0;\n    long\
    \ smalest_index11 = 0;\n    long smalest_index12 = 0;\n    long smalest_index13\
    \ = 0;\n    long smalest_index14 = 0;\n    long smalest_index15 = 0;\n    long\
    \ smalest_index16 = 0;\n    long smalest_index17 = 0;\n    long smalest_index18\
    \ = 0;\n    long smalest_index19 = 0;\n    long smalest_index20 = 0;\n    long\
    \ smalest_index21 = 0;\n    long smalest_index22 = 0;\n    long smalest_index23\
    \ = 0;\n    long smalest_index24 = 0;\n    long smalest_index25 = 0;\n    long\
    \ smalest_index26 = 0;\n    long smalest_index27 = 0;\n    long smalest_index28\
    \ = 0;\n    long smalest_index29 = 0;\n    long smalest_index30 = 0;\n    long\
    \ smalest_index31 = 0;\n    long smalest_index32 = 0;\n    long smalest_index33\
    \ = 0;\n    long smalest_index34 = 0;\n    long smalest_index35 = 0;\n    long\
    \ smalest_index36 = 0;\n    long smalest_index37 = 0;\n    long smalest_index38\
    \ = 0;\n    long smalest_index39 = 0;\n    long smalest_index40 = 0;\n    long\
    \ smalest_index41 = 0;\n    long smalest_index42 = 0;\n    long smalest_index43\
    \ = 0;\n    long smalest_index44 = 0;\n    long smalest_index45 = 0;\n    long\
    \ smalest_index46 = 0;\n    long smalest_index47 = 0;\n    long smalest_index48\
    \ = 0;\n    long smalest_index49 = 0;\n    long smalest_index50 = 0;\n    long\
    \ smalest_index51 = 0;\n    long smalest_index52 = 0;\n    long smalest_index53\
    \ = 0;\n    long smalest_index54 = 0;\n    long smalest_index55 = 0;\n    long\
    \ smalest_index56 = 0;\n    long smalest_\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpf6nxzf9h.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpf6nxzf9h.cpp:87:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmpf6nxzf9h.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_even_value = 0;\n    long smalest_even_node = 0;\n    long smalest_even_node_index\
    \ = 0;\n    long smalest_even_node_even_value = 0;\n    long smalest_even_node_even_value_index\
    \ = 0;\n    long smalest_even_node_even_value_index2 = 0;\n    long smalest_even_node_even_value_index3\
    \ = 0;\n    long smalest_even_node_even_value_index4 = 0;\n    long smalest_even_node_even_value_index5\
    \ = 0;\n    long smalest_even_node_even_value_index6 = 0;\n    long smalest_even_node_even_value_index7\
    \ = 0;\n    long smalest_even_node_even_value_index8 = 0;\n    long smalest_even_node_even_value_index9\
    \ = 0;\n    long smalest_even_node_even_value_index10 = 0;\n    long smalest_even_node_even_value_index11\
    \ = 0;\n    long smalest_even_node_even_value_index12 = 0;\n    long smalest_even_node_even_value_index13\
    \ = 0;\n    long smalest_even_node_even_value_index14 = 0;\n    long smalest_even_node_even_value_index15\
    \ = 0;\n    long smalest_even_node_even_value_index16 = 0;\n    long smalest_even_node_even_value_index17\
    \ = 0;\n    long smalest_even_node_even_value_index18 = 0;\n    long smalest_even_node_even_value_index19\
    \ = 0;\n    long smalest_even_node_even_value_index20 = 0;\n    long smalest_even_node_even_value_index21\
    \ = 0;\n    long smalest_even_node_even_value_index22 = 0;\n    long smalest_even_node_even_value_index23\
    \ = 0;\n    long smalest_even_node_even_value_index24 = 0;\n    long smalest_even_node_even_value_index25\
    \ = 0;\n    long smalest_even_node_even_value_index26 = 0;\n    long smalest_even_node_even_value_index27\
    \ = 0;\n    long smalest_even_node_even_value_index28 = 0;\n    long smalest_even_node_even_value_index29\
    \ = 0;\n    long smalest_even_node_even_value_index30 = 0;\n    long smalest_even_node_even_value_index31\
    \ = 0;\n    long smalest_even_node_even_value_index32 = 0;\n    long smalest_even_node_even_value\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc09o17hc.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpc09o17hc.cpp:68:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   68 | }\n      | ^\n/tmp/tmpc09o17hc.cpp:68:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    long smalest_index_value2 = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0)\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n                smalest_index_value = arr[i];\n                smalest_index_value2\
    \ = arr[i];\n            } else if (smalest_value == arr[i]) {\n             \
    \   smalest_index_value = arr[i];\n                smalest_index_value2 = arr[i];\n\
    \            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n                smalest_index_value\
    \ = arr[i];\n                smalest_index_value2 = arr[i];\n            } else\
    \ if (smalest_value > arr[i]) {\n                smalest_value = arr[i];\n   \
    \             smalest_index = i;\n                smalest_index_value = arr[i];\n\
    \                smalest_index_value2 = arr[i];\n            }\n        }\n  \
    \  }\n    std::vector<long> ans;\n    if (smalest_value == 0) {\n        ans.push_back(smalest_index_value);\n\
    \        ans.push_back(smalest_index);\n        return ans;\n    }\n    ans.push_back(smalest_index_value);\n\
    \    ans.push_back(smalest_index);\n    ans.push_back(smalest_index_value2);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpfsuou6u8: /tmp/tmpfsuou6u8.cpp:69: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    long\
    \ smalest_index_value = arr[0];\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n            smalest_index_value = arr[i];\n \
    \       }\n    }\n    std::vector<long> result;\n    if (smalest_index_value %\
    \ 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpc7uzmi5x: /tmp/tmpc7uzmi5x.cpp:51: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpswr38lzf: /tmp/tmpswr38lzf.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_value=0;\n    long smalest_index=0;\n\
    \    long smallest_value=INT_MAX;\n    long smallest_index=INT_MAX;\n    for(long\
    \ i=0;i<arr.size();i++){\n        if(arr[i]%2==0){\n            if(arr[i]<smallest_value){\n\
    \                smallest_value=arr[i];\n                smallest_index=i;\n \
    \           }\n        }\n        else{\n            if(arr[i]<smallest_value){\n\
    \                smallest_value=arr[i];\n                smallest_index=i;\n \
    \           }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpa_0kymun: /tmp/tmpa_0kymun.cpp:56: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \ }\n    }\n    std::vector<long> result;\n    if (smalest_value % 2 == 0) {\n\
    \        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmplk_tr9jn: /tmp/tmplk_tr9jn.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
