language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp9u2wnslv: /tmp/tmp9u2wnslv.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwf_zy8xf: /tmp/tmpwf_zy8xf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level += c;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level_size = std::max(current_level_size, levels.size());\n   \
    \         levels.push_back(current_level_size);\n            current_level.clear();\n\
    \        } else {\n            current_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu2cwiw6e.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpu2cwiw6e.cpp:17:76: error: no matching function for call to \u2018\
    max(long int&, std::vector<long int>::size_type)\u2019\n   17 |             current_level_size\
    \ = std::max(current_level_size, levels.size());\n      |                    \
    \                                                        ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpu2cwiw6e.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpu2cwiw6e.cpp:17:76: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    })\n   17 |             current_level_size = std::max(current_level_size, levels.size());\n\
    \      |                                                                     \
    \       ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n     \
    \            from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpu2cwiw6e.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu2cwiw6e.cpp:17:76:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long\
    \ unsigned"
  stdout: ''
  timestamp: 1660113041
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_parens = \"\";\n    for (auto c : paren_string) {\n    \
    \    if (c == '(') {\n            curr_parens += c;\n        } else if (c == ')')\
    \ {\n            curr_parens = curr_parens.substr(0, curr_parens.size() - 1);\n\
    \            long curr_level = levels.size();\n            long curr_level_parens\
    \ = curr_parens.size();\n            long curr_level_open = levels.size();\n \
    \           long curr_level_closed = levels.size();\n            long curr_level_open_p\
    \ = levels.size();\n            long curr_level_closed_p = levels.size();\n  \
    \          long curr_level_open_c = levels.size();\n            long curr_level_closed_c\
    \ = levels.size();\n            long curr_level_open_p_c = levels.size();\n  \
    \          long curr_level_closed_p_c = levels.size();\n            long curr_level_open_c_p\
    \ = levels.size();\n            long curr_level_closed_c_p = levels.size();\n\
    \            long curr_level_open_p_c_p = levels.size();\n            long curr_level_closed_p_c_p\
    \ = levels.size();\n            long curr_level_open_c_c_p = levels.size();\n\
    \            long curr_level_closed_c_c_p = levels.size();\n            long curr_level_open_p_c_c_p\
    \ = levels.size();\n            long curr_level_closed_p_c_c_p = levels.size();\n\
    \            long curr_level_open_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_p = levels.size();\n            long\
    \ curr_level_open_c_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_c_p = levels.size();\n           \
    \ long curr_level_open_c_c_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_c_c_p = levels.size();\n         \
    \   long curr_level_open_c_c_c_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_c_c_c_p = levels.size();\n       \
    \     long curr_level_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmptfxtrj_r.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmptfxtrj_r.cpp:51:1: error: expected initializer before \u2018}\u2019\
    \ token\n   51 | }\n      | ^\n/tmp/tmptfxtrj_r.cpp:52:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   52 | int main() {\n     \
    \ |            ^\n/tmp/tmptfxtrj_r.cpp:57:1: error: expected \u2018}\u2019 at\
    \ end of input\n   57 | }\n      | ^\n/tmp/tmptfxtrj_r.cpp:11:33: note: to match\
    \ this \u2018{\u2019\n   11 |     for (auto c : paren_string) {\n      |     \
    \                            ^\n/tmp/tmptfxtrj_r.cpp:57:1: error: expected \u2018\
    }\u2019 at end of input\n   57 | }\n      | ^\n/tmp/tmptfxtrj_r.cpp:8:65: note:\
    \ to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmptfxtrj_r.cpp:57:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   57 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        }\n        paren_levels[paren_level]\
    \ = current_level;\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113043
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_level = paren_string.substr(0, i);\n            level++;\n       \
    \ } else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpvkfrha3l: /tmp/tmpvkfrha3l.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_first_paren =\
    \ true;\n    for (auto c : paren_string) {\n        if (c == '(') {\n        \
    \    if (is_first_paren) {\n                is_first_paren = false;\n        \
    \        level++;\n                paren_level = std::to_string(level);\n    \
    \        } else {\n                levels[level - 1]++;\n            }\n     \
    \   } else if (c == ')') {\n            if (is_first_paren) {\n              \
    \  is_first_paren = false;\n                level--;\n                paren_level\
    \ = std::to_string(level);\n            } else {\n                levels[level\
    \ - 1]--;\n            }\n        } else {\n            levels[level - 1]++;\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long paren_level = 0;\n  long\
    \ paren_level_count = 0;\n  long paren_level_max_count = 0;\n  for (size_t i =\
    \ 0; i < paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n    \
    \  paren_level_count++;\n      if (paren_level_count > paren_level_max_count)\
    \ {\n        paren_level_max_count = paren_level_count;\n      }\n      paren_levels.push_back(paren_level);\n\
    \      paren_level_count = 0;\n    } else if (paren_string[i] == ')') {\n    \
    \  paren_level_count--;\n      if (paren_level_count < 0) {\n        throw std::runtime_error(\"\
    Invalid input\");\n      }\n      paren_levels.push_back(paren_level);\n     \
    \ paren_level_count = 0;\n    } else {\n      paren_level_count = 0;\n    }\n\
    \  }\n  paren_levels.push_back(paren_level);\n  return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::runtime_error'\n \
    \ what():  Invalid input\n"
  stdout: ''
  timestamp: 1660113043
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  if (paren_level_count == 0) {\n                paren_levels.push_back(paren_level);\n\
    \                paren_level_count = 0;\n            }\n        }\n        paren_level++;\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp82ppfqqv: /tmp/tmp82ppfqqv.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113043
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwf_zy8xf: /tmp/tmpwf_zy8xf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.substr(1, paren_string.length() - 2).split(' ');\n\
    \  long max_level = 0;\n  for (long i = 0; i < paren_levels.size(); i++) {\n \
    \   if (paren_levels[i] > max_level) {\n      max_level = paren_levels[i];\n \
    \   }\n  }\n  std::vector<long> nested_paren_levels;\n  for (long i = 0; i < paren_levels.size();\
    \ i++) {\n    nested_paren_levels.push_back(max_level);\n  }\n  return nested_paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm5om8du9.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpm5om8du9.cpp:10:68: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(1,\
    \ paren_string.length() - 2).split(' ');\n      |                            \
    \                                        ^~~~~\n"
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n        } else if (c == ')') {\n            is_closed = true;\n   \
    \     } else if (is_open && is_closed) {\n            result.push_back(level);\n\
    \            is_open = false;\n            is_closed = false;\n        } else\
    \ if (is_open) {\n            level++;\n        } else if (is_closed) {\n    \
    \        level--;\n        }\n    }\n    if (is_open || is_closed) {\n       \
    \ result.push_back(level);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpbqoeuv5t: /tmp/tmpbqoeuv5t.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level = 1;\n    long paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_count = 1;\n    long paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_count = 1;\n    long\
    \ paren_level_max_paren_level_max_paren_level_max_count = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_\n}\nint main() {\n   \
    \ auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9vj1ip4u.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp9vj1ip4u.cpp:34:1: error: expected initializer before \u2018}\u2019\
    \ token\n   34 | }\n      | ^\n/tmp/tmp9vj1ip4u.cpp:34:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113041
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_start =\
    \ 0;\n    long paren_level_end = 0;\n    long paren_level_end_index = 0;\n   \
    \ long paren_level_end_index2 = 0;\n    long paren_level_end_index3 = 0;\n   \
    \ long paren_level_end_index4 = 0;\n    long paren_level_end_index5 = 0;\n   \
    \ long paren_level_end_index6 = 0;\n    long paren_level_end_index7 = 0;\n   \
    \ long paren_level_end_index8 = 0;\n    long paren_level_end_index9 = 0;\n   \
    \ long paren_level_end_index10 = 0;\n    long paren_level_end_index11 = 0;\n \
    \   long paren_level_end_index12 = 0;\n    long paren_level_end_index13 = 0;\n\
    \    long paren_level_end_index14 = 0;\n    long paren_level_end_index15 = 0;\n\
    \    long paren_level_end_index16 = 0;\n    long paren_level_end_index17 = 0;\n\
    \    long paren_level_end_index18 = 0;\n    long paren_level_end_index19 = 0;\n\
    \    long paren_level_end_index20 = 0;\n    long paren_level_end_index21 = 0;\n\
    \    long paren_level_end_index22 = 0;\n    long paren_level_end_index23 = 0;\n\
    \    long paren_level_end_index24 = 0;\n    long paren_level_end_index25 = 0;\n\
    \    long paren_level_end_index26 = 0;\n    long paren_level_end_index27 = 0;\n\
    \    long paren_level_end_index28 = 0;\n    long paren_level_end_index29 = 0;\n\
    \    long paren_level_end_index30 = 0;\n    long paren_level_end_index31 = 0;\n\
    \    long paren_level_end_index32 = 0;\n    long paren_level_end_index33 = 0;\n\
    \    long paren_level_end_index34 = 0;\n    long paren_level_end_index35 = 0;\n\
    \    long paren_level_end_index36 = 0;\n    long paren_level_end_index37 = 0;\n\
    \    long paren_level_end_index38 = 0;\n    long paren_level_end_index39 = 0;\n\
    \    long paren_level_end_index40 = 0;\n    long paren_level_end_index41 = 0;\n\
    \    long paren_level_end_index42 = 0;\n    long paren_level_end_index43 = 0;\n\
    \    long paren_level_end_index44 = 0;\n    long paren_level_end_index45 = 0;\n\
    \    long paren_level_end_index46 = 0;\n    long paren_level_end_index47 = 0;\n\
    \    long paren_level_end_index48 = 0;\n\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp53iqtosk: /tmp/tmp53iqtosk.cpp:66: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 1;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_index\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_index\
    \ = 0;\n    long paren_level_count_max_paren = 0;\n    long paren_level_count_min_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren = 0;\n    long paren_level_count_min_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren = 0;\n    long paren_level_count_min_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren = 0;\n    long\
    \ paren_level_count_min_paren_paren_paren_paren = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren = 0;\n  \
    \  long paren_level_count_max_paren_paren_paren_paren_paren_paren = 0;\n    long\
    \ paren_level_count_min_paren_paren_paren_paren_paren_paren = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph_r1ez85.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmph_r1ez85.cpp:35:10: error: redeclaration of \u2018long int paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \n   35 |     long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph_r1ez85.cpp:33:10: note: \u2018long int paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \ previously declared here\n   33 |     long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph_r1ez85.cpp:36:10: error: redeclaration of \u2018long int paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \n   36 |     long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph_r1ez85.cpp:34:10: note: \u2018long int paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \ previously declared here\n   34 |     long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmph_r1ez85.cpp:40:1: error: expected initializer before \u2018}\u2019 token\n\
    \   40 | }\n      | ^\n/tmp/tmph_r1ez85.cpp:40:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   ++level;\n    } else if (c == ')') {\n      --level;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpsocu2a1j: /tmp/tmpsocu2a1j.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(max_level);\n            max_level++;\n\
    \        } else if (c == ')') {\n            max_level = std::max(max_level, paren_levels.back());\n\
    \            paren_levels.pop_back();\n        } else {\n            max_level\
    \ = std::max(max_level, paren_levels.back());\n        }\n    }\n    paren_levels.push_back(max_level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp03rqo82n: /tmp/tmp03rqo82n.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            level++;\n            paren_char = \"\
    (\";\n        } else if (c == ')') {\n            level--;\n            paren_char\
    \ = \")\";\n        } else {\n            paren_char += c;\n        }\n      \
    \  if (level == 0 && paren_char != \"()\") {\n            levels.push_back(level);\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpdmz869lh: /tmp/tmpdmz869lh.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113043
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwf_zy8xf: /tmp/tmpwf_zy8xf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long max_level = 0;\n    long level = 0;\n    long index = 0;\n    bool is_open\
    \ = false;\n    bool is_closed = false;\n    for (auto c : paren_string) {\n \
    \       if (c == '(') {\n            is_open = true;\n            level++;\n \
    \       }\n        else if (c == ')') {\n            is_closed = true;\n     \
    \       level--;\n        }\n        else if (c == ' ') {\n            if (is_open)\
    \ {\n                result.push_back(level);\n                is_open = false;\n\
    \            }\n        }\n        else if (is_open) {\n            is_closed\
    \ = false;\n        }\n    }\n    if (is_open) {\n        result.push_back(level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpforzp594: /tmp/tmpforzp594.cpp:41: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_count =\
    \ 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqlfrlmy4.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpqlfrlmy4.cpp:16:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   16 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqlfrlmy4.cpp:14:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   14 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqlfrlmy4.cpp:17:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   17 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqlfrlmy4.cpp:15:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   15 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqlfrlmy4.cpp:18:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   18 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqlfrlmy4.cpp:14:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   14 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqlfrlmy4.cpp:19:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   19 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqlfrlmy4.cpp:15:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   15 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqlfrlmy4.cpp:20:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   20 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqlfrlmy4.cpp:14:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   14 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqlfrlmy4.cpp:21:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   21 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqlfrlmy4.cpp:15:1"
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_length = 0;\n    bool is_first_level\
    \ = true;\n    for (auto c : paren_string) {\n        if (c == '(') {\n      \
    \      curr_level = curr_level + c;\n            curr_level_length++;\n      \
    \  } else if (c == ')') {\n            curr_level = curr_level.substr(0, curr_level_length);\n\
    \            curr_level_length--;\n            if (curr_level_length == 0) {\n\
    \                levels.push_back(curr_level.length());\n                is_first_level\
    \ = false;\n            }\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpbmd9nj6d: /tmp/tmpbmd9nj6d.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long max_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            current_level++;\n            if (current_level\
    \ > max_level) {\n                max_level = current_level;\n            }\n\
    \        } else if (c == ')') {\n            current_level--;\n        }\n   \
    \     paren_levels.push_back(current_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpmlt4ea23: /tmp/tmpmlt4ea23.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 0;\n    long paren_level = 0;\n    for (size_t i = 0; i\
    \ < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       paren_levels[paren_level] = paren_level + 1;\n        } else if (paren_string[i]\
    \ == ')') {\n            paren_levels[paren_level] = paren_levels[paren_level\
    \ - 1];\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   paren_level++;\n            paren_level_counter++;\n        } else if (c ==\
    \ ')') {\n            paren_level--;\n            paren_level_counter--;\n   \
    \         if (paren_level == 0 && paren_level_counter == 0) {\n              \
    \  paren_levels[paren_levels.size() - 1] = current_level;\n                current_level++;\n\
    \            }\n        }\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min =\
    \ 0;\n    long paren_level_count_sum = 0;\n    long paren_level_count_sum2 = 0;\n\
    \    long paren_level_count_sum3 = 0;\n    long paren_level_count_sum4 = 0;\n\
    \    long paren_level_count_sum5 = 0;\n    long paren_level_count_sum6 = 0;\n\
    \    long paren_level_count_sum7 = 0;\n    long paren_level_count_sum8 = 0;\n\
    \    long paren_level_count_sum9 = 0;\n    long paren_level_count_sum10 = 0;\n\
    \    long paren_level_count_sum11 = 0;\n    long paren_level_count_sum12 = 0;\n\
    \    long paren_level_count_sum13 = 0;\n    long paren_level_count_sum14 = 0;\n\
    \    long paren_level_count_sum15 = 0;\n    long paren_level_count_sum16 = 0;\n\
    \    long paren_level_count_sum17 = 0;\n    long paren_level_count_sum18 = 0;\n\
    \    long paren_level_count_sum19 = 0;\n    long paren_level_count_sum20 = 0;\n\
    \    long paren_level_count_sum21 = 0;\n    long paren_level_count_sum22 = 0;\n\
    \    long paren_level_count_sum23 = 0;\n    long paren_level_count_sum24 = 0;\n\
    \    long paren_level_count_sum25 = 0;\n    long paren_level_count_sum26 = 0;\n\
    \    long paren_level_count_sum27 = 0;\n    long paren_level_count_sum28 = 0;\n\
    \    long paren_level_count_sum29 = 0;\n    long paren_level_count_sum30 = 0;\n\
    \    long paren_level_count_sum31 = 0;\n    long paren_level_count_sum32 = 0;\n\
    \    long paren_level_count_sum33 = 0;\n    long paren_level_count_sum34 = 0;\n\
    \    long paren_level_count_sum35 = 0;\n    long paren_level_count_sum36 = 0;\n\
    \    long paren_level_count_sum37 = 0;\n    long paren_level_count_sum38 = 0;\n\
    \    long paren_level_count_sum39 = 0;\n    long paren_level_count_sum40 = 0;\n\
    \    long paren_level_count_sum41 = 0;\n    long paren_level_count_sum42 = 0;\n\
    \    long paren_level_count_sum43 = 0;\n    long paren_level_count_sum44 = 0;\n\
    \    long paren_level_count_sum45 = 0;\n    long paren_level_count_sum46 = 0;\n\
    \    long paren_level_count_sum47 = 0;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmptfn1msji: /tmp/tmptfn1msji.cpp:65: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113041
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            current_level = current_level + \"(\";\n        }\
    \ else if (c == ')') {\n            current_level = current_level.substr(0, current_level.size()-1);\n\
    \            levels.push_back(std::stoi(current_level));\n            current_level.clear();\n\
    \        } else {\n            current_level = current_level + c;\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_parens = \"\";\n    std::string curr_level = \"\";\n   \
    \ for (auto c : paren_string) {\n        if (c == '(') {\n            curr_parens\
    \ += c;\n        } else if (c == ')') {\n            curr_parens = curr_parens.substr(0,\
    \ curr_parens.size() - 1);\n            long curr_level = std::count(curr_parens.begin(),\
    \ curr_parens.end(), '(');\n            curr_level = std::max(curr_level, std::count(curr_parens.begin(),\
    \ curr_parens.end(), ')'));\n            curr_level++;\n            curr_parens\
    \ = \"\";\n            levels.push_back(curr_level);\n        } else {\n     \
    \       curr_parens += c;\n        }\n    }\n    return levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp29g95jkh: /tmp/tmp29g95jkh.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpvzv2cvwf: /tmp/tmpvzv2cvwf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwf_zy8xf: /tmp/tmpwf_zy8xf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_stack;\n    long level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_stack += c;\n        } else if\
    \ (c == ')') {\n            long new_level = level;\n            while (paren_stack.size()\
    \ > 0) {\n                if (paren_stack.back() == '(') {\n                 \
    \   new_level++;\n                    paren_stack.pop_back();\n              \
    \  } else if (paren_stack.back() == ')') {\n                    new_level--;\n\
    \                    paren_stack.pop_back();\n                }\n            }\n\
    \            levels[level++] = new_level;\n            paren_stack = \"\";\n \
    \       } else {\n            paren_stack += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \  std::vector<long> paren_levels_temp;\n  paren_levels_temp.push_back(paren_levels);\n\
    \  long paren_levels_sum = 0;\n  while (paren_levels_sum < paren_levels) {\n \
    \   paren_levels_sum += paren_levels_temp[paren_levels_sum];\n    paren_levels_temp.push_back(paren_levels_sum);\n\
    \  }\n  return paren_levels_temp;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpzxnmgjts.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzxnmgjts.cpp:10:65: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                         ^~~~~\n/tmp/tmpzxnmgjts.cpp:12:43: error:\
    \ no matching function for call to \u2018std::vector<long int>::push_back(std::vector<long\
    \ int>&)\u2019\n   12 |   paren_levels_temp.push_back(paren_levels);\n      |\
    \                                           ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzxnmgjts.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35: note:   no known\
    \ conversion for argument 1 from \u2018std::vector<long int>\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018std::vector<long int>::value_type&&\u2019 {aka \u2018long in"
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.size() -\
    \ 1) + \")\";\n        } else {\n            curr_level = curr_level + c;\n  \
    \      }\n        if (curr_level.find(\"(\") == std::string::npos) {\n       \
    \     levels.push_back(std::stoi(curr_level));\n        }\n    }\n    return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp99cwd7vz: /tmp/tmp99cwd7vz.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpi4j4j0zv: /tmp/tmpi4j4j0zv.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels.push_back(std::stoi(paren_level));\n            paren_level.clear();\n\
    \        } else {\n            paren_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels);\n\
    \    long paren_level = 0;\n    long paren_levels_temp_index = 0;\n    long paren_levels_temp_size\
    \ = 0;\n    for (long i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == ')') {\n            paren_levels_temp[paren_levels_temp_index] = paren_level;\n\
    \            paren_levels_temp_index++;\n            paren_levels_temp_size++;\n\
    \            if (paren_levels_temp_index == paren_levels_temp.size()) {\n    \
    \            paren_levels_temp.push_back(paren_level);\n            }\n      \
    \      paren_level++;\n        }\n        else if (paren_string[i] == '(') {\n\
    \            paren_level++;\n        }\n    }\n    std::vector<long> paren_levels_temp_reversed;\n\
    \    paren_levels_temp_reversed.reserve(paren_levels_temp.size());\n    for (long\
    \ i = 0; i < paren_levels_temp.size(); i++) {\n        paren_levels_temp_reversed.push_back(paren_levels_temp[paren_levels_temp_reversed.size()\
    \ - 1 - i]);\n    }\n    return paren_levels_temp_reversed;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb89o45u2.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpb89o45u2.cpp:10:67: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                           ^~~~~\n/tmp/tmpb89o45u2.cpp:12:31:\
    \ error: cannot convert \u2018std::vector<long int>\u2019 to \u2018std::vector<long\
    \ int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n   12 |     paren_levels_temp.reserve(paren_levels);\n\
    \      |                               ^~~~~~~~~~~~\n      |                 \
    \              |\n      |                               std::vector<long int>\n\
    In file included from /usr/include/c++/9/vector:72,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb89o45u2.cpp:2:\n/usr/include/c++/9/bits/vector.tcc:67:23:\
    \ note:   initializing argument 1 of \u2018void std::vector<_Tp, _Alloc>::reserve(std::vector<_Tp,\
    \ _Alloc>::size_type) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n   67 |    \
    \ reserve(size_type __n)\n      |             ~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660113041
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        } else {\n            assert(current_level\
    \ == paren_level);\n            paren_levels[paren_level] = current_level;\n \
    \       }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long level = 0;\n  for (char\
    \ c : paren_string) {\n    if (c == '(') {\n      ++level;\n    } else if (c ==\
    \ ')') {\n      --level;\n    }\n    paren_levels.push_back(level);\n  }\n  return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpvnp90ufh: /tmp/tmpvnp90ufh.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  if (paren_level_count == 0) {\n                paren_level++;\n           \
    \ }\n        }\n        paren_levels[paren_level_count] = paren_level;\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long paren_level = 0;\n  for\
    \ (auto c : paren_string) {\n    if (c == '(') {\n      paren_level++;\n    }\
    \ else if (c == ')') {\n      paren_level--;\n    }\n    paren_levels.push_back(paren_level);\n\
    \  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpo4t6i6uk: /tmp/tmpo4t6i6uk.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_open = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level = \"\";\n        } else if (c == ')') {\n \
    \           is_open = false;\n            level++;\n            paren_level +=\
    \ c;\n        } else if (is_open) {\n            level++;\n            paren_level\
    \ += c;\n        } else {\n            levels[level - 1]++;\n            paren_level\
    \ += c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n            if (paren_level == 0) {\n\
    \                paren_levels.push(paren_level);\n            }\n        }\n \
    \       level++;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd0vka41b.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpd0vka41b.cpp:18:30: error: \u2018class std::vector<long int>\u2019\
    \ has no member named \u2018push\u2019\n   18 |                 paren_levels.push(paren_level);\n\
    \      |                              ^~~~\n"
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        paren_char = paren_string[i];\n       \
    \ if (paren_char == '(') {\n            level++;\n        } else if (paren_char\
    \ == ')') {\n            level--;\n        }\n        if (level == 0) {\n    \
    \        levels.push_back(level);\n        }\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9te11kgb.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp9te11kgb.cpp:14:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   14 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9te11kgb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp9te11kgb.cpp:14:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   14\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9te11kgb.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp9te11kgb.cpp:14:27: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ "
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    long paren_level = 0;\n\
    \    for (auto &c : paren_string) {\n        if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpla7pryyb.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpla7pryyb.cpp:71:24: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   71 |             paren_level\n      |                        ^\n \
    \     |                        ;\n   72 | }\n      | ~                       \n\
    /tmp/tmpla7pryyb.cpp:73:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n/tmp/tmpla7pryyb.cpp:78:1:\
    \ error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpla7pryyb.cpp:13:34:\
    \ note: to match this \u2018{\u2019\n   13 |     for (auto &c : paren_string)\
    \ {\n      |                                  ^\n/tmp/tmpla7pryyb.cpp:78:1: error:\
    \ expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpla7pryyb.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpla7pryyb.cpp:78:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   78 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpdjubm129: /tmp/tmpdjubm129.cpp:71: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_counter = 0;\n    bool is_first_paren\
    \ = true;\n    bool is_last_paren = true;\n    bool is_last_paren_level = true;\n\
    \    bool is_last_paren_level_counter = true;\n    long paren_level_counter_inner\
    \ = 1;\n    long paren_level_counter_outer = 1;\n    long paren_level_counter_outer_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner = 1;\n    long paren_level_counter_outer_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner = 1;\n    long\
    \ paren_level_counter_outer_inner_inner_inner_inner_inner = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr772y8eg.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpr772y8eg.cpp:30:10: error: redeclaration of \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \n   30 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpr772y8eg.cpp:29:10: note: \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \ previously declared here\n   29 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpr772y8eg.cpp:31:10: error: redeclaration of \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \n   31 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpr772y8eg.cpp:29:10: note: \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \ previously declared here\n   29 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpr772y8eg.cpp:34:10: error: redeclaration of \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \n   34 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_parens = \"\";\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            curr_parens += c;\n        } else if\
    \ (c == ')') {\n            curr_parens = curr_parens.substr(0, curr_parens.size()\
    \ - 1);\n            level += 1;\n            levels[level - 1] += 1;\n      \
    \  } else if (c == ' ') {\n            levels[level - 1] += 1;\n        }\n  \
    \  }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmptilhh3rh: /tmp/tmptilhh3rh.cpp:61: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_open = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level = c;\n        } else if (c == ')') {\n    \
    \        is_open = false;\n            levels[level] = std::max(levels[level],\
    \ level);\n            level++;\n        } else if (is_open) {\n            levels[level]\
    \ = std::max(levels[level], level);\n            level++;\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113044
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmptilhh3rh: /tmp/tmptilhh3rh.cpp:61: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long max_level = 0;\n    long paren_level =\
    \ 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n           \
    \ paren_level++;\n            if (paren_level > max_level) {\n               \
    \ max_level = paren_level;\n            }\n        } else if (c == ')') {\n  \
    \          paren_level--;\n            if (paren_level < current_level) {\n  \
    \              current_level = paren_level;\n            }\n        }\n    }\n\
    \    paren_levels.push_back(current_level);\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp3owgev3j: /tmp/tmp3owgev3j.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_level;\n\
    \    paren_level.reserve(paren_string.size());\n    long paren_level_count = 0;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n        }\n\
    \        paren_level.push_back(paren_level_count);\n    }\n    return paren_level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpxr3or07b: /tmp/tmpxr3or07b.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = \"(\";\n        } else if (c == ')') {\n\
    \            curr_level = \")\";\n        } else {\n            curr_level +=\
    \ c;\n        }\n        if (curr_level.length() == 0) {\n            levels.push_back(levels.size());\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmphfird4gt: /tmp/tmphfird4gt.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpoyrfgxvi: /tmp/tmpoyrfgxvi.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto &c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113044
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_stack;\n    long level = 0;\n    bool is_open = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_stack += c;\n        } else if (c == ')') {\n   \
    \         is_open = false;\n            level++;\n            paren_stack += c;\n\
    \        } else if (is_open) {\n            level++;\n            paren_stack\
    \ += c;\n        } else {\n            levels[level - 1]++;\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmptilhh3rh: /tmp/tmptilhh3rh.cpp:61: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 1;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpq95407vt: /tmp/tmpq95407vt.cpp:61: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        } else if (c == ' ') {\n  \
    \          paren_levels[current_level] = paren_level;\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter_max = 0;\n    long paren_level_counter_max_index\
    \ = 0;\n    long paren_level_counter_max_index2 = 0;\n    long paren_level_counter_max_index3\
    \ = 0;\n    long paren_level_counter_max_index4 = 0;\n    long paren_level_counter_max_index5\
    \ = 0;\n    long paren_level_counter_max_index6 = 0;\n    long paren_level_counter_max_index7\
    \ = 0;\n    long paren_level_counter_max_index8 = 0;\n    long paren_level_counter_max_index9\
    \ = 0;\n    long paren_level_counter_max_index10 = 0;\n    long paren_level_counter_max_index11\
    \ = 0;\n    long paren_level_counter_max_index12 = 0;\n    long paren_level_counter_max_index13\
    \ = 0;\n    long paren_level_counter_max_index14 = 0;\n    long paren_level_counter_max_index15\
    \ = 0;\n    long paren_level_counter_max_index16 = 0;\n    long paren_level_counter_max_index17\
    \ = 0;\n    long paren_level_counter_max_index18 = 0;\n    long paren_level_counter_max_index19\
    \ = 0;\n    long paren_level_counter_max_index20 = 0;\n    long paren_level_counter_max_index21\
    \ = 0;\n    long paren_level_counter_max_index22 = 0;\n    long paren_level_counter_max_index23\
    \ = 0;\n    long paren_level_counter_max_index24 = 0;\n    long paren_level_counter_max_index25\
    \ = 0;\n    long paren_level_counter_max_index26 = 0;\n    long paren_level_counter_max_index27\
    \ = 0;\n    long paren_level_counter_max_index28 = 0;\n    long paren_level_counter_max_index29\
    \ = 0;\n    long paren_level_counter_max_index30 = 0;\n    long paren_level_counter_max_index31\
    \ = 0;\n    long paren_level_counter_max_index32 = 0;\n    long paren_level_counter_max_index33\
    \ = 0;\n    long paren_level_counter_max_index34 = 0;\n    long paren_level_counter_max_index35\
    \ = 0;\n    long paren_level_counter_max_index36 = 0;\n    long paren_level_counter_max_index37\
    \ = 0;\n    long paren_level_counter_max_index38 = 0;\n    long paren_level_counter_max_index39\
    \ = 0;\n    long paren_level_counter_max_index40 = 0;\n    long paren_level_counter_max_index41\
    \ = 0;\n    long paren_level_counter_max_index42 = 0;\n    long paren_level_counter_max_index43\
    \ = 0;\n    long paren_level_counter_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpkl6lfiex.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpkl6lfiex.cpp:58:1: error: expected initializer before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmpkl6lfiex.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(max_level);\n            max_level++;\n\
    \        } else if (c == ')') {\n            max_level = std::max(max_level, paren_levels[paren_levels.size()\
    \ - 1]);\n            paren_levels.erase(paren_levels.begin() + paren_levels.size()\
    \ - 1);\n        } else {\n            max_level = std::max(max_level, paren_levels[paren_levels.size()\
    \ - 1] + 1);\n        }\n    }\n    paren_levels.push_back(max_level);\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpb5i3rs14: /tmp/tmpb5i3rs14.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level++;\n        } else if (c == ')') {\n      \
    \      is_open = false;\n            paren_level--;\n        } else if (is_open)\
    \ {\n            paren_level++;\n        } else {\n            paren_level--;\n\
    \        }\n        if (paren_level == level) {\n            paren_levels[paren_level\
    \ - 1]++;\n        }\n        level++;\n    }\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpcwniru9v: /tmp/tmpcwniru9v.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long level = 0;\n    long paren_level = 0;\n\
    \    long paren_level_counter = 0;\n    long paren_level_counter2 = 0;\n    long\
    \ paren_level_counter3 = 0;\n    long paren_level_counter4 = 0;\n    long paren_level_counter5\
    \ = 0;\n    long paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n\
    \    long paren_level_counter8 = 0;\n    long paren_level_counter9 = 0;\n    long\
    \ paren_level_counter10 = 0;\n    long paren_level_counter11 = 0;\n    long paren_level_counter12\
    \ = 0;\n    long paren_level_counter13 = 0;\n    long paren_level_counter14 =\
    \ 0;\n    long paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n\
    \    long paren_level_counter17 = 0;\n    long paren_level_counter18 = 0;\n  \
    \  long paren_level_counter19 = 0;\n    long paren_level_counter20 = 0;\n    long\
    \ paren_level_counter21 = 0;\n    long paren_level_counter22 = 0;\n    long paren_level_counter23\
    \ = 0;\n    long paren_level_counter24 = 0;\n    long paren_level_counter25 =\
    \ 0;\n    long paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n\
    \    long paren_level_counter28 = 0;\n    long paren_level_counter29 = 0;\n  \
    \  long paren_level_counter30 = 0;\n    long paren_level_counter31 = 0;\n    long\
    \ paren_level_counter32 = 0;\n    long paren_level_counter33 = 0;\n    long paren_level_counter34\
    \ = 0;\n    long paren_level_counter35 = 0;\n    long paren_level_counter36 =\
    \ 0;\n    long paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n\
    \    long paren_level_counter39 = 0;\n    long paren_level_counter40 = 0;\n  \
    \  long paren_level_counter41 = 0;\n    long paren_level_counter42 = 0;\n    long\
    \ paren_level_counter43 = 0;\n    long paren_level_counter44 = 0;\n    long paren_level_counter45\
    \ = 0;\n    long paren_level_counter46 = 0;\n    long paren_level_counter47 =\
    \ 0;\n    long paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n\
    \    long paren_level_counter50 = 0;\n    long paren_level_counter51 = 0;\n  \
    \  long paren_level_counter52 = 0;\n    long paren_level_counter53 = 0;\n    long\
    \ paren_level_counter54 = 0;\n    long paren_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcp2quckj.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpcp2quckj.cpp:68:1: error: expected initializer before \u2018}\u2019\
    \ token\n   68 | }\n      | ^\n/tmp/tmpcp2quckj.cpp:68:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpdjubm129: /tmp/tmpdjubm129.cpp:71: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_size = 0;\n    for (size_t i\
    \ = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n\
    \            curr_level = paren_string.substr(0, i);\n            curr_level_size\
    \ = levels.size();\n            levels.push_back(curr_level_size);\n        }\
    \ else if (paren_string[i] == ')') {\n            long level_size = levels[curr_level_size];\n\
    \            long level_index = curr_level_size;\n            while (level_index\
    \ > 0) {\n                level_index--;\n                if (levels[level_index]\
    \ == level_size) {\n                    levels[level_index] = level_index + 1;\n\
    \                    break;\n                }\n            }\n            curr_level_size\
    \ = level_index;\n        } else {\n            curr_level += paren_string[i];\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp9379qe23: /tmp/tmp9379qe23.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    std::string paren_char;\n    std::string paren_char2;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        paren_char =\
    \ paren_string[i];\n        paren_char2 = paren_string[paren_string.size() - 1\
    \ - i];\n        if (paren_char == '(' && paren_char2 == ')') {\n            level++;\n\
    \        } else if (paren_char == '(' && paren_char2 != ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7glql7kp.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp7glql7kp.cpp:16:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   16 |         if (paren_char == '(' && paren_char2\
    \ == ')') {\n      |             ~~~~~~~~~~ ^~ ~~~\n      |             |    \
    \         |\n      |             |             char\n      |             std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7glql7kp.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp7glql7kp.cpp:16:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   16\
    \ |         if (paren_char == '(' && paren_char2 == ')') {\n      |          \
    \                 ^~~\nIn file included from /usr/include/c++/9/regex:62,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7glql7kp.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp7glql7kp.cpp:16:27: note:   mismatched types "
  stdout: ''
  timestamp: 1660113044
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    long paren_level = 0;\n\
    \    long paren_level_max = 0;\n    long paren_level_cur = 0;\n    long paren_level_cur_index\
    \ = 0;\n    long paren_level_cur_max = 0;\n    long paren_level_cur_cur = 0;\n\
    \    long paren_level_cur_cur_index = 0;\n    long paren_level_cur_cur_max = 0;\n\
    \    long paren_level_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_index = 0;\n    long paren_level_cur_cur_cur_cur_max\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_index = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_max\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_index = 0;\n    long\
    \ paren_level_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_index = 0;\n\
    \    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index = 0;\n\
    \    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long\
    \ paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_max =\
    \ 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur = 0;\n\
    \    long paren_level_cur_cur_cur_cur_\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6u7rjg34.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp6u7rjg34.cpp:45:10: error: redeclaration of \u2018long int paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\u2019\
    \n   45 |     long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index =\
    \ 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp6u7rjg34.cpp:42:10: note: \u2018long int paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\u2019\
    \ previously declared here\n   42 |     long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp6u7rjg34.cpp:49:1: error: expected initializer before \u2018}\u2019 token\n\
    \   49 | }\n      | ^\n/tmp/tmp6u7rjg34.cpp:49:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + c;\n        } else if (c ==\
    \ ')') {\n            curr_level = curr_level.substr(0, curr_level.length() -\
    \ 1);\n            long level_of_nesting = curr_level.length();\n            levels.push_back(level_of_nesting);\n\
    \            curr_level = \"\";\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpr29s89pu: /tmp/tmpr29s89pu.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        paren_char = paren_string[i];\n       \
    \ if (paren_char == '(') {\n            level++;\n        } else if (paren_char\
    \ == ')') {\n            level--;\n        }\n        levels.push_back(level);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpybyqwb4l.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpybyqwb4l.cpp:14:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   14 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpybyqwb4l.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpybyqwb4l.cpp:14:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   14\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpybyqwb4l.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpybyqwb4l.cpp:14:27: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ "
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(level == 0);\n  paren_levels.push_back(level);\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp428ypaah: /tmp/tmp428ypaah.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter_max = 0;\n    long paren_level_counter_max_index\
    \ = 0;\n    long paren_level_counter_max_index2 = 0;\n    long paren_level_counter_max_index3\
    \ = 0;\n    long paren_level_counter_max_index4 = 0;\n    long paren_level_counter_max_index5\
    \ = 0;\n    long paren_level_counter_max_index6 = 0;\n    long paren_level_counter_max_index7\
    \ = 0;\n    long paren_level_counter_max_index8 = 0;\n    long paren_level_counter_max_index9\
    \ = 0;\n    long paren_level_counter_max_index10 = 0;\n    long paren_level_counter_max_index11\
    \ = 0;\n    long paren_level_counter_max_index12 = 0;\n    long paren_level_counter_max_index13\
    \ = 0;\n    long paren_level_counter_max_index14 = 0;\n    long paren_level_counter_max_index15\
    \ = 0;\n    long paren_level_counter_max_index16 = 0;\n    long paren_level_counter_max_index17\
    \ = 0;\n    long paren_level_counter_max_index18 = 0;\n    long paren_level_counter_max_index19\
    \ = 0;\n    long paren_level_counter_max_index20 = 0;\n    long paren_level_counter_max_index21\
    \ = 0;\n    long paren_level_counter_max_index22 = 0;\n    long paren_level_counter_max_index23\
    \ = 0;\n    long paren_level_counter_max_index24 = 0;\n    long paren_level_counter_max_index25\
    \ = 0;\n    long paren_level_counter_max_index26 = 0;\n    long paren_level_counter_max_index27\
    \ = 0;\n    long paren_level_counter_max_index28 = 0;\n    long paren_level_counter_max_index29\
    \ = 0;\n    long paren_level_counter_max_index30 = 0;\n    long paren_level_counter_max_index31\
    \ = 0;\n    long paren_level_counter_max_index32 = 0;\n    long paren_level_counter_max_index33\
    \ = 0;\n    long paren_level_counter_max_index34 = 0;\n    long paren_level_counter_max_index35\
    \ = 0;\n    long paren_level_counter_max_index36 = 0;\n    long paren_level_counter_max_index37\
    \ = 0;\n    long paren_level_counter_max_index38 = 0;\n    long paren_level_counter_max_index39\
    \ = 0;\n    long paren_level_counter_max_index40 = 0;\n    long paren_level_counter_max_index41\
    \ = 0;\n    long paren_level_counter_max_index42 = 0;\n    long paren_level_counter_max_index43\
    \ = 0;\n    long paren_level_counter_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpkl6lfiex.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpkl6lfiex.cpp:58:1: error: expected initializer before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmpkl6lfiex.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwf_zy8xf: /tmp/tmpwf_zy8xf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_size = 0;\n    for (size_t i\
    \ = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n\
    \            curr_level_size = levels.size();\n            curr_level = paren_string.substr(0,\
    \ i);\n            levels.push_back(curr_level_size);\n        } else if (paren_string[i]\
    \ == ')') {\n            long level_size = levels[curr_level_size];\n        \
    \    long level_index = curr_level_size;\n            while (level_index < levels.size()\
    \ && levels[level_index] == level_size) {\n                level_index++;\n  \
    \          }\n            levels.erase(levels.begin() + level_index);\n      \
    \      curr_level_size = levels.size();\n            curr_level = paren_string.substr(0,\
    \ i);\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_index2 = 0;\n    long paren_level_max_index3 =\
    \ 0;\n    long paren_level_max_index4 = 0;\n    long paren_level_max_index5 =\
    \ 0;\n    long paren_level_max_index6 = 0;\n    long paren_level_max_index7 =\
    \ 0;\n    long paren_level_max_index8 = 0;\n    long paren_level_max_index9 =\
    \ 0;\n    long paren_level_max_index10 = 0;\n    long paren_level_max_index11\
    \ = 0;\n    long paren_level_max_index12 = 0;\n    long paren_level_max_index13\
    \ = 0;\n    long paren_level_max_index14 = 0;\n    long paren_level_max_index15\
    \ = 0;\n    long paren_level_max_index16 = 0;\n    long paren_level_max_index17\
    \ = 0;\n    long paren_level_max_index18 = 0;\n    long paren_level_max_index19\
    \ = 0;\n    long paren_level_max_index20 = 0;\n    long paren_level_max_index21\
    \ = 0;\n    long paren_level_max_index22 = 0;\n    long paren_level_max_index23\
    \ = 0;\n    long paren_level_max_index24 = 0;\n    long paren_level_max_index25\
    \ = 0;\n    long paren_level_max_index26 = 0;\n    long paren_level_max_index27\
    \ = 0;\n    long paren_level_max_index28 = 0;\n    long paren_level_max_index29\
    \ = 0;\n    long paren_level_max_index30 = 0;\n    long paren_level_max_index31\
    \ = 0;\n    long paren_level_max_index32 = 0;\n    long paren_level_max_index33\
    \ = 0;\n    long paren_level_max_index34 = 0;\n    long paren_level_max_index35\
    \ = 0;\n    long paren_level_max_index36 = 0;\n    long paren_level_max_index37\
    \ = 0;\n    long paren_level_max_index38 = 0;\n    long paren_level_max_index39\
    \ = 0;\n    long paren_level_max_index40 = 0;\n    long paren_level_max_index41\
    \ = 0;\n    long paren_level_max_index42 = 0;\n    long paren_level_max_index43\
    \ = 0;\n    long paren_level_max_index44 = 0;\n    long paren_level_max_index45\
    \ = 0;\n    long paren_level_max_index46 = 0;\n    long paren_level_max_index47\
    \ = 0;\n    long paren_level_max_index\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzhu4bh80.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzhu4bh80.cpp:62:1: error: expected initializer before \u2018}\u2019\
    \ token\n   62 | }\n      | ^\n/tmp/tmpzhu4bh80.cpp:62:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113044
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels[0] = 1;\n  paren_levels[1] = 1;\n  for (size_t i = 2; i < paren_string.size();\
    \ ++i) {\n    if (paren_string[i] == '(') {\n      paren_levels[i] += 1;\n   \
    \ } else if (paren_string[i] == ')') {\n      paren_levels[i] -= 1;\n    }\n \
    \ }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_level++;\n        } else {\n            paren_level--;\n     \
    \   }\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp18b2e32y: /tmp/tmp18b2e32y.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   for (auto &c : paren_string) {\n        if (c == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpkl_q7cbu: /tmp/tmpkl_q7cbu.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long max_level = 0;\n    long level = 0;\n    bool is_open = false;\n   \
    \ bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren\
    \ = false;\n    for (auto c : paren_string) {\n        if (c == '(') {\n     \
    \       is_opening_paren = true;\n            level++;\n        } else if (c ==\
    \ ')') {\n            is_closing_paren = true;\n            level--;\n       \
    \ } else if (c == ' ') {\n            if (is_opening_paren) {\n              \
    \  is_opening_paren = false;\n                is_closed = true;\n            }\
    \ else if (is_closed) {\n                result.push_back(level);\n          \
    \      is_opening_paren = false;\n                is_closed = false;\n       \
    \     }\n        } else if (is_opening_paren) {\n            is_opening_paren\
    \ = false;\n            is_closed = false;\n        }\n    }\n    if (is_opening_paren)\
    \ {\n        result.push_back(level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpvjfr47ty: /tmp/tmpvjfr47ty.cpp:44: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ level) {\n            paren_levels.push(paren_level);\n        }\n        level++;\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpzbjsb7cn.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzbjsb7cn.cpp:19:26: error: \u2018class std::vector<long int>\u2019\
    \ has no member named \u2018push\u2019\n   19 |             paren_levels.push(paren_level);\n\
    \      |                          ^~~~\n"
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    long paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   is_open = true;\n            paren_level_count++;\n        } else if (c ==\
    \ ')') {\n            is_open = false;\n            paren_level_count--;\n   \
    \     }\n        if (is_open) {\n            paren_level++;\n        }\n     \
    \   if (paren_level_count == 0) {\n            paren_level_count = paren_level;\n\
    \        }\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmphc1b7o8j: /tmp/tmphc1b7o8j.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  long paren_level = 0;\n  for (auto c : paren_string) {\n\
    \    if (c == '(') {\n      paren_level++;\n    } else if (c == ')') {\n     \
    \ paren_level--;\n    }\n    if (paren_level == level) {\n      result.push_back(level);\n\
    \    }\n    level++;\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp9nz3053t: /tmp/tmp9nz3053t.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min =\
    \ 0;\n    long paren_level_count_sum = 0;\n    long paren_level_count_sum_max\
    \ = 0;\n    long paren_level_count_sum_min = 0;\n    long paren_level_count_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_max = 0;\n    long paren_level_count_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n\
    \    long paren_level_count_sum_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpu33saqkw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpu33saqkw.cpp:41:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   41 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu33saqkw.cpp:38:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \ previously declared here\n   38 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpu33saqkw.cpp:42:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \n   42 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu33saqkw.cpp:39:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \ previously declared here\n   39 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpu33saqkw.cpp:43:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \n   43 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max =\
    \ 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpu33saqkw.cpp:40:10: note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \ previously declared here\n   40 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpu33saqkw.cpp:44:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   44 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpu33saqkw.cpp:38:10:\
    \ not"
  stdout: ''
  timestamp: 1660113044
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    long level_count = 0;\n    bool is_open = false;\n \
    \   bool is_closed = false;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            is_open = true;\n            level_count++;\n       \
    \ } else if (c == ')') {\n            is_closed = true;\n            level_count--;\n\
    \        } else if (c == ' ') {\n            if (is_open && is_closed) {\n   \
    \             levels[level_count] = level;\n                is_open = false;\n\
    \                is_closed = false;\n                level_count = 0;\n      \
    \          level++;\n            }\n        } else {\n            is_open = false;\n\
    \            is_closed = false;\n        }\n    }\n    if (is_open || is_closed)\
    \ {\n        levels[level_count] = level;\n    }\n    return levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long current_paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpggqwdhpa: /tmp/tmpggqwdhpa.cpp:70: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        result.push_back(level);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp0wy84oqu: /tmp/tmp0wy84oqu.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113044
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long max_level = 0;\n    long current_paren_level\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_counter = 0;\n    long\
    \ paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n    long paren_level_counter4\
    \ = 0;\n    long paren_level_counter5 = 0;\n    long paren_level_counter6 = 0;\n\
    \    long paren_level_counter7 = 0;\n    long paren_level_counter8 = 0;\n    long\
    \ paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n    long paren_level_counter11\
    \ = 0;\n    long paren_level_counter12 = 0;\n    long paren_level_counter13 =\
    \ 0;\n    long paren_level_counter14 = 0;\n    long paren_level_counter15 = 0;\n\
    \    long paren_level_counter16 = 0;\n    long paren_level_counter17 = 0;\n  \
    \  long paren_level_counter18 = 0;\n    long paren_level_counter19 = 0;\n    long\
    \ paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n    long paren_level_counter22\
    \ = 0;\n    long paren_level_counter23 = 0;\n    long paren_level_counter24 =\
    \ 0;\n    long paren_level_counter25 = 0;\n    long paren_level_counter26 = 0;\n\
    \    long paren_level_counter27 = 0;\n    long paren_level_counter28 = 0;\n  \
    \  long paren_level_counter29 = 0;\n    long paren_level_counter30 = 0;\n    long\
    \ paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n    long paren_level_counter33\
    \ = 0;\n    long paren_level_counter34 = 0;\n    long paren_level_counter35 =\
    \ 0;\n    long paren_level_counter36 = 0;\n    long paren_level_counter37 = 0;\n\
    \    long paren_level_counter38 = 0;\n    long paren_level_counter39 = 0;\n  \
    \  long paren_level_counter40 = 0;\n    long paren_level_counter41 = 0;\n    long\
    \ paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n    long paren_level_counter44\
    \ = 0;\n    long paren_level_counter45 = 0;\n    long paren_level_counter46 =\
    \ 0;\n    long paren_level_counter47 = 0;\n    long paren_level_counter48 = 0;\n\
    \    long paren_level_counter49 = 0;\n    long paren_level_counter50 = 0;\n  \
    \  long paren_level_counter51 = 0;\n    long paren_level_counter52 = 0;\n    long\
    \ paren_level_counter53 = 0;\n    long paren_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpebjjvbbe.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpebjjvbbe.cpp:68:1: error: expected initializer before \u2018}\u2019\
    \ token\n   68 | }\n      | ^\n/tmp/tmpebjjvbbe.cpp:68:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpkpisermk: /tmp/tmpkpisermk.cpp:71: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpoyrfgxvi: /tmp/tmpoyrfgxvi.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level += c;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level_size = std::min(current_level_size, levels.size());\n   \
    \         levels.push_back(current_level_size);\n            current_level.clear();\n\
    \        } else {\n            current_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphcgk_pye.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmphcgk_pye.cpp:17:76: error: no matching function for call to \u2018\
    min(long int&, std::vector<long int>::size_type)\u2019\n   17 |             current_level_size\
    \ = std::min(current_level_size, levels.size());\n      |                    \
    \                                                        ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmphcgk_pye.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmphcgk_pye.cpp:17:76: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    })\n   17 |             current_level_size = std::min(current_level_size, levels.size());\n\
    \      |                                                                     \
    \       ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n     \
    \            from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmphcgk_pye.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmphcgk_pye.cpp:17:76:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long\
    \ unsigned"
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \  std::vector<long> paren_levels_temp;\n  paren_levels_temp.reserve(paren_levels);\n\
    \  for (long i = 0; i < paren_levels; i++) {\n    paren_levels_temp.push_back(0);\n\
    \  }\n  long paren_levels_index = 0;\n  long paren_levels_index_temp = 0;\n  long\
    \ paren_levels_index_temp2 = 0;\n  long paren_levels_index_temp3 = 0;\n  long\
    \ paren_levels_index_temp4 = 0;\n  long paren_levels_index_temp5 = 0;\n  long\
    \ paren_levels_index_temp6 = 0;\n  long paren_levels_index_temp7 = 0;\n  long\
    \ paren_levels_index_temp8 = 0;\n  long paren_levels_index_temp9 = 0;\n  long\
    \ paren_levels_index_temp10 = 0;\n  long paren_levels_index_temp11 = 0;\n  long\
    \ paren_levels_index_temp12 = 0;\n  long paren_levels_index_temp13 = 0;\n  long\
    \ paren_levels_index_temp14 = 0;\n  long paren_levels_index_temp15 = 0;\n  long\
    \ paren_levels_index_temp16 = 0;\n  long paren_levels_index_temp17 = 0;\n  long\
    \ paren_levels_index_temp18 = 0;\n  long paren_levels_index_temp19 = 0;\n  long\
    \ paren_levels_index_temp20 = 0;\n  long paren_levels_index_temp21 = 0;\n  long\
    \ paren_levels_index_temp22 = 0;\n  long paren_levels_index_temp23 = 0;\n  long\
    \ paren_levels_index_temp24 = 0;\n  long paren_levels_index_temp25 = 0;\n  long\
    \ paren_levels_index_temp26 = 0;\n  long paren_levels_index_temp27 = 0;\n  long\
    \ paren_levels_index_temp28 = 0;\n  long paren_levels_index_temp29 = 0;\n  long\
    \ paren_levels_index_temp30 = 0;\n  long paren_levels_index_temp31 = 0;\n  long\
    \ paren_levels_index_temp32 = 0;\n  long paren_levels_index_temp33 = 0;\n  long\
    \ paren_levels_index_temp34 = 0;\n  long paren_levels_index_temp35 = 0;\n  long\
    \ paren_levels_index_temp36 = 0;\n  long paren_levels_index_temp37 = 0;\n  long\
    \ paren_levels_index_temp38 = 0;\n  long paren_levels_index_temp39 = 0;\n  long\
    \ paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n  \
    \  assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpv6uss9pi.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpv6uss9pi.cpp:10:65: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                         ^~~~~\n/tmp/tmpv6uss9pi.cpp:12:29: error:\
    \ cannot convert \u2018std::vector<long int>\u2019 to \u2018std::vector<long int>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   12 |   paren_levels_temp.reserve(paren_levels);\n\
    \      |                             ^~~~~~~~~~~~\n      |                   \
    \          |\n      |                             std::vector<long int>\nIn file\
    \ included from /usr/include/c++/9/vector:72,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv6uss9pi.cpp:2:\n/usr/include/c++/9/bits/vector.tcc:67:23:\
    \ note:   initializing argument 1 of \u2018void std::vector<_Tp, _Alloc>::reserve(std::vector<_Tp,\
    \ _Alloc>::size_type) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n   67 |    \
    \ reserve(size_type __n)\n      |             ~~~~~~~~~~^~~\n/tmp/tmpv6uss9pi.cpp:13:22:\
    \ error: no match for \u2018operator<\u2019 (operand types are \u2018long int\u2019\
    \ and \u2018std::vector<long int>\u2019)\n   13 |   for (long i = 0; i < paren_levels;\
    \ i++) {\n      |                    ~ ^ ~~~~~~~~~~~~\n      |               \
    \     |   |\n      |                    |   std::vector<long int>\n      |   \
    \                 long int\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpv6uss9pi.cpp:2:\n/usr/include/c++/9/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::"
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_level = paren_string.substr(0, i);\n            level++;\n       \
    \ } else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpvkfrha3l: /tmp/tmpvkfrha3l.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    std::string paren_char;\n\
    \    std::string paren_string_reversed;\n    std::string paren_string_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed;\n    std::string paren_string_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0t8wa1qd.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp0t8wa1qd.cpp:27:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   27 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0t8wa1qd.cpp:26:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   26 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0t8wa1qd.cpp:29:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   29 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0t8wa1qd.cpp:28:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_rever"
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   level++;\n    } else if (c == ')') {\n      level--;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmppl61v35_: /tmp/tmppl61v35_.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long level = 0;\n  long paren_level = 0;\n  long paren_level_counter = 0;\n\
    \  for (size_t i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      paren_level++;\n      paren_level_counter++;\n    } else if\
    \ (paren_string[i] == ')') {\n      paren_level--;\n      paren_level_counter--;\n\
    \      if (paren_level == 0 && paren_level_counter == 0) {\n        paren_levels[paren_levels.size()\
    \ - 1] = level;\n      }\n    }\n    level++;\n  }\n  return paren_levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_prev = 0;\n\
    \    long paren_level_next = 0;\n    long paren_level_next_prev = 0;\n    long\
    \ paren_level_next_next_prev = 0;\n    long paren_level_next_next_next_prev =\
    \ 0;\n    long paren_level_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf8ohmobq.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpf8ohmobq.cpp:24:10: error: redeclaration of \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \n   24 |     long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpf8ohmobq.cpp:23:10: note: \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \ previously declared here\n   23 |     long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpf8ohmobq.cpp:27:10: error: redeclaration of \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \n   27 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpf8ohmobq.cpp:26:10: note: \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \ previously declared here\n   26 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpf8ohmobq.cpp:29:10: error: redeclaration of \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \n   29 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpf8ohmobq.cpp:28:10: note: \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \ previously declared here\n   28 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string paren_level_string;\n    std::string\
    \ paren_level_char;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        paren_level_char = paren_string[i];\n        paren_level_string = paren_string.substr(0,\
    \ i);\n        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmparh5ljn6.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmparh5ljn6.cpp:32:41: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   32 |         paren_level_string = paren_level\n      |           \
    \                              ^\n      |                                    \
    \     ;\n   33 | }\n      | ~                                        \n/tmp/tmparh5ljn6.cpp:34:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   34 | int main() {\n      |            ^\n/tmp/tmparh5ljn6.cpp:39:1: error:\
    \ expected \u2018}\u2019 at end of input\n   39 | }\n      | ^\n/tmp/tmparh5ljn6.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmparh5ljn6.cpp:39:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   39 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    long levels_size\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   current_level += c;\n            current_level_size += 1;\n        } else\
    \ if (c == ')') {\n            current_level_size = std::min(current_level_size,\
    \ levels_size);\n            levels.push_back(current_level_size);\n         \
    \   current_level.clear();\n            levels_size -= 1;\n        } else {\n\
    \            current_level += c;\n        }\n    }\n    levels.push_back(levels_size);\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpmtdhhzmh: /tmp/tmpmtdhhzmh.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113046
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    long level_count = 0;\n    long level_count_prev = 0;\n\
    \    long level_count_next = 0;\n    long level_count_next2 = 0;\n    long level_count_next3\
    \ = 0;\n    long level_count_next4 = 0;\n    long level_count_next5 = 0;\n   \
    \ long level_count_next6 = 0;\n    long level_count_next7 = 0;\n    long level_count_next8\
    \ = 0;\n    long level_count_next9 = 0;\n    long level_count_next10 = 0;\n  \
    \  long level_count_next11 = 0;\n    long level_count_next12 = 0;\n    long level_count_next13\
    \ = 0;\n    long level_count_next14 = 0;\n    long level_count_next15 = 0;\n \
    \   long level_count_next16 = 0;\n    long level_count_next17 = 0;\n    long level_count_next18\
    \ = 0;\n    long level_count_next19 = 0;\n    long level_count_next20 = 0;\n \
    \   long level_count_next21 = 0;\n    long level_count_next22 = 0;\n    long level_count_next23\
    \ = 0;\n    long level_count_next24 = 0;\n    long level_count_next25 = 0;\n \
    \   long level_count_next26 = 0;\n    long level_count_next27 = 0;\n    long level_count_next28\
    \ = 0;\n    long level_count_next29 = 0;\n    long level_count_next30 = 0;\n \
    \   long level_count_next31 = 0;\n    long level_count_next32 = 0;\n    long level_count_next33\
    \ = 0;\n    long level_count_next34 = 0;\n    long level_count_next35 = 0;\n \
    \   long level_count_next36 = 0;\n    long level_count_next37 = 0;\n    long level_count_next38\
    \ = 0;\n    long level_count_next39 = 0;\n    long level_count_next40 = 0;\n \
    \   long level_count_next41 = 0;\n    long level_count_next42 = 0;\n    long level_count_next43\
    \ = 0;\n    long level_count_next44 = 0;\n    long level_count_next45 = 0;\n \
    \   long level_count_next46 = 0;\n    long level_count_next47 = 0;\n    long level_count_next48\
    \ = 0;\n    long level_count_next49 = 0;\n    long level_count_next50 = 0;\n \
    \   long level_count_next51 = 0;\n    long level_count_next52 = 0;\n    long level_count_next53\
    \ = 0;\n    long level_count_next54 = 0;\n    long level_count_next55 = 0;\n \
    \   long level_count_next56 = 0;\n    long level_count_next57 = 0;\n    long level_count_next58\
    \ = 0;\n    long level_count_next59 = 0;\n    long level_count_next60 = 0;\n \
    \   long level_count_next61 = 0;\n    long level_count_next\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pmu18z7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp6pmu18z7.cpp:75:1: error: expected initializer before \u2018}\u2019\
    \ token\n   75 | }\n      | ^\n/tmp/tmp6pmu18z7.cpp:75:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_index2 = 0;\n    long paren_level_max_index3 =\
    \ 0;\n    long paren_level_max_index4 = 0;\n    long paren_level_max_index5 =\
    \ 0;\n    long paren_level_max_index6 = 0;\n    long paren_level_max_index7 =\
    \ 0;\n    long paren_level_max_index8 = 0;\n    long paren_level_max_index9 =\
    \ 0;\n    long paren_level_max_index10 = 0;\n    long paren_level_max_index11\
    \ = 0;\n    long paren_level_max_index12 = 0;\n    long paren_level_max_index13\
    \ = 0;\n    long paren_level_max_index14 = 0;\n    long paren_level_max_index15\
    \ = 0;\n    long paren_level_max_index16 = 0;\n    long paren_level_max_index17\
    \ = 0;\n    long paren_level_max_index18 = 0;\n    long paren_level_max_index19\
    \ = 0;\n    long paren_level_max_index20 = 0;\n    long paren_level_max_index21\
    \ = 0;\n    long paren_level_max_index22 = 0;\n    long paren_level_max_index23\
    \ = 0;\n    long paren_level_max_index24 = 0;\n    long paren_level_max_index25\
    \ = 0;\n    long paren_level_max_index26 = 0;\n    long paren_level_max_index27\
    \ = 0;\n    long paren_level_max_index28 = 0;\n    long paren_level_max_index29\
    \ = 0;\n    long paren_level_max_index30 = 0;\n    long paren_level_max_index31\
    \ = 0;\n    long paren_level_max_index32 = 0;\n    long paren_level_max_index33\
    \ = 0;\n    long paren_level_max_index34 = 0;\n    long paren_level_max_index35\
    \ = 0;\n    long paren_level_max_index36 = 0;\n    long paren_level_max_index37\
    \ = 0;\n    long paren_level_max_index38 = 0;\n    long paren_level_max_index39\
    \ = 0;\n    long paren_level_max_index40 = 0;\n    long paren_level_max_index41\
    \ = 0;\n    long paren_level_max_index42 = 0;\n    long paren_level_max_index43\
    \ = 0;\n    long paren_level_max_index44 = 0;\n    long paren_level_max_index45\
    \ = 0;\n    long paren_level_max_index46 = 0;\n    long paren_level_max_index47\
    \ = 0;\n    long paren_level_max_index\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzhu4bh80.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpzhu4bh80.cpp:62:1: error: expected initializer before \u2018}\u2019\
    \ token\n   62 | }\n      | ^\n/tmp/tmpzhu4bh80.cpp:62:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpkpisermk: /tmp/tmpkpisermk.cpp:71: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long level = 0;\n  for (char\
    \ c : paren_string) {\n    if (c == '(') {\n      paren_levels.push_back(level);\n\
    \      level++;\n    } else if (c == ')') {\n      level--;\n    }\n  }\n  assert(paren_levels.size()\
    \ == paren_string.size());\n  return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpk1a28_ht: /tmp/tmpk1a28_ht.cpp:20: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels.size() == paren_string.size()'' failed.

    '
  stdout: ''
  timestamp: 1660113046
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level = current_level\
    \ + c;\n            current_level_size++;\n        } else if (c == ')') {\n  \
    \          current_level = current_level.substr(0, current_level.size() - 1);\n\
    \            current_level_size--;\n        } else {\n            current_level\
    \ = current_level + c;\n        }\n        if (current_level_size > 0) {\n   \
    \         levels.push_back(current_level_size);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpk2t5tnxn: /tmp/tmpk2t5tnxn.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         level++;\n        } else {\n            level--;\n        }\n      \
    \  levels.push_back(level);\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp_0zoo6hp: /tmp/tmp_0zoo6hp.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ level) {\n            paren_level++;\n        }\n        level = paren_level;\n\
    \        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpxo6au15j: /tmp/tmpxo6au15j.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            is_open = true;\n            paren_level = c;\n     \
    \   } else if (c == ')') {\n            is_closed = true;\n            levels[level]\
    \ = std::max(levels[level], level);\n            is_open = false;\n        } else\
    \ if (is_open && is_closed) {\n            levels[level] = std::max(levels[level],\
    \ level);\n            level++;\n        }\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113047
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    long level_count = 0;\n    long level_count_max = 0;\n\
    \    std::string current_paren_string = paren_string;\n    std::string next_paren_string;\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    while (!current_paren_string.empty())\
    \ {\n        if (current_paren_string[0] == '(') {\n            is_open = true;\n\
    \            next_paren_string = current_paren_string;\n        } else if (current_paren_string[0]\
    \ == ')') {\n            is_closed = true;\n            next_paren_string = current_paren_string;\n\
    \        } else if (is_open) {\n            next_paren_string = current_paren_string;\n\
    \            level_count_max++;\n            level_count = level_count_max;\n\
    \            level++;\n            current_paren_string = next_paren_string;\n\
    \            is_open = false;\n        } else if (is_closed) {\n            level_count--;\n\
    \            current_paren_string = next_paren_string;\n            is_closed\
    \ = false;\n        } else {\n            current_paren_string = next_paren_string;\n\
    \        }\n    }\n    result.push_back(level_count);\n    return result;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113052
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp92nkt53u: /tmp/tmp92nkt53u.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto &c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.length()\
    \ - 1) + \")\";\n        } else if (c == ' ') {\n            curr_level = curr_level\
    \ + \" \";\n        } else {\n            curr_level = curr_level + c;\n     \
    \   }\n        if (curr_level.find(\"(\") == std::string::npos) {\n          \
    \  levels.push_back(std::stoi(curr_level));\n        }\n    }\n    return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpin228pov: /tmp/tmpin228pov.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long opening_paren_level = 0;\n    long closing_paren_level = 0;\n    for\
    \ (auto c : paren_string) {\n        if (c == '(') {\n            is_open = true;\n\
    \            opening_paren_level = paren_level;\n        } else if (c == ')')\
    \ {\n            is_closed = true;\n            closing_paren_level = paren_level;\n\
    \        } else if (is_open && is_closed) {\n            paren_level++;\n    \
    \    } else if (is_open) {\n            paren_level++;\n        } else if (is_closed)\
    \ {\n            paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpo2fba55o: /tmp/tmpo2fba55o.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.length()\
    \ - 1) + \")\";\n        } else if (c == ' ') {\n            curr_level = curr_level.substr(0,\
    \ curr_level.length() - 1);\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n        if (curr_level.length() == 0) {\n            levels.push_back(levels.size());\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpzpamw31r: /tmp/tmpzpamw31r.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   ++level;\n    } else if (c == ')') {\n      --level;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpsocu2a1j: /tmp/tmpsocu2a1j.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        result.push_back(level);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp0wy84oqu: /tmp/tmp0wy84oqu.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long level = 0;\n  for (auto\
    \ c : paren_string) {\n    if (c == '(') {\n      paren_levels.push_back(level);\n\
    \      level++;\n    } else if (c == ')') {\n      level--;\n    }\n  }\n  assert(paren_levels.size()\
    \ == paren_string.size());\n  return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpc1ay61pe: /tmp/tmpc1ay61pe.cpp:20: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels.size() == paren_string.size()'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long max_level = 0;\n  long level = 0;\n  long level_count = 0;\n  for (char\
    \ c : paren_string) {\n    if (c == '(') {\n      level++;\n      level_count++;\n\
    \    } else if (c == ')') {\n      level--;\n      level_count--;\n      if (level\
    \ == 0 && level_count == 0) {\n        result.push_back(max_level);\n        max_level\
    \ = 0;\n        level = 0;\n        level_count = 0;\n      }\n    }\n    max_level\
    \ = max(max_level, level);\n  }\n  result.push_back(max_level);\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_h9y9zzv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp_h9y9zzv.cpp:27:17: error: \u2018max\u2019 was not declared in this\
    \ scope; did you mean \u2018std::max\u2019?\n   27 |     max_level = max(max_level,\
    \ level);\n      |                 ^~~\n      |                 std::max\nIn file\
    \ included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_h9y9zzv.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_level = paren_string.substr(i, 1);\n            level++;\n       \
    \ } else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp2odlmrnj: /tmp/tmp2odlmrnj.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels[0] = 1;\n  long paren_level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_levels[paren_level] =\
    \ paren_levels[paren_level] + 1;\n    } else if (paren_string[i] == ')') {\n \
    \     paren_levels[paren_level] = paren_levels[paren_level] - 1;\n      if (paren_levels[paren_level]\
    \ == 0) {\n        paren_level++;\n      }\n    }\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113047
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  std::string paren_level;\n  long level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_level = paren_string.substr(0,\
    \ i);\n      level++;\n    }\n    if (paren_string[i] == ')') {\n      level--;\n\
    \    }\n    levels[level] = levels[level] + 1;\n  }\n  return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113048
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.split(\" \");\n  long max_level = 0;\n  for (long\
    \ i = 0; i < paren_levels.size(); i++) {\n    if (paren_levels[i] > max_level)\
    \ {\n      max_level = paren_levels[i];\n    }\n  }\n  std::vector<long> deepest_levels;\n\
    \  deepest_levels.push_back(max_level);\n  for (long i = 1; i < paren_levels.size();\
    \ i++) {\n    if (paren_levels[i] > deepest_levels[i - 1]) {\n      deepest_levels.push_back(i);\n\
    \    }\n  }\n  return deepest_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpp_1_iaw1.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpp_1_iaw1.cpp:10:31: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |   paren_levels = paren_string.split(\" \");\n      |               \
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long level = 0;\n    long\
    \ paren_level = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n        paren_levels.push_back(paren_level);\n        level++;\n \
    \   }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp86xkphzu: /tmp/tmp86xkphzu.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            ++level;\n        } else if (c == ')') {\n            --level;\n\
    \        }\n        if (level == 0) {\n            result.push_back(level);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp70nhza7u: /tmp/tmp70nhza7u.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(max_level);\n            max_level++;\n\
    \        } else if (c == ')') {\n            max_level = std::max(max_level, paren_levels[paren_levels.size()\
    \ - 1]);\n            paren_levels.pop_back();\n        } else {\n           \
    \ max_level = std::max(max_level, paren_levels[paren_levels.size() - 1] + 1);\n\
    \        }\n    }\n    paren_levels.push_back(max_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp9etvjwa0: /tmp/tmp9etvjwa0.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_level = paren_string.substr(0,\
    \ i);\n            levels.push_back(1);\n        } else if (paren_string[i] ==\
    \ ')') {\n            long level_of_paren = levels[levels.size() - 1];\n     \
    \       levels[levels.size() - 1] += 1;\n            if (levels[levels.size()\
    \ - 1] > level_of_paren) {\n                levels.push_back(level_of_paren);\n\
    \            }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp8i9zd7v4: /tmp/tmp8i9zd7v4.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   ++level;\n    } else if (c == ')') {\n      --level;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpsocu2a1j: /tmp/tmpsocu2a1j.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  std::string paren_level;\n  long level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_level = paren_string.substr(i,\
    \ 1);\n      level++;\n    } else if (paren_string[i] == ')') {\n      level--;\n\
    \      if (level == 0) {\n        levels.push_back(level);\n      }\n    }\n \
    \ }\n  return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpvh17wpu7: /tmp/tmpvh17wpu7.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   level++;\n    } else if (c == ')') {\n      level--;\n    }\n    levels.push_back(level);\n\
    \  }\n  return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp_i6s46et: /tmp/tmp_i6s46et.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level = current_level\
    \ + c;\n            current_level_size++;\n        } else if (c == ')') {\n  \
    \          current_level = current_level.substr(0, current_level.size() - 1);\n\
    \            current_level_size--;\n        } else {\n            current_level\
    \ = current_level + c;\n            current_level_size++;\n        }\n       \
    \ if (current_level_size == 0) {\n            levels.push_back(levels.size());\n\
    \            current_level_size = 0;\n        }\n    }\n    return levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp9_ggcx1e: /tmp/tmp9_ggcx1e.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string paren_char;\n    std::string paren_string_reversed;\n\
    \    std::string paren_string_reversed_reversed;\n    std::string paren_string_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed;\n    std::string\
    \ paren_string_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ paren_string_reversed_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfo_n4gn1.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpfo_n4gn1.cpp:22:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   22 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfo_n4gn1.cpp:21:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   21 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfo_n4gn1.cpp:25:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   25 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfo_n4gn1.cpp:24:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   24 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpfo_n4gn1.cpp:27:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_re"
  stdout: ''
  timestamp: 1660113047
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level += c;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level_size = std::min(current_level_size, levels.size());\n   \
    \         levels.push_back(current_level_size);\n            current_level.clear();\n\
    \        } else {\n            current_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphcgk_pye.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmphcgk_pye.cpp:17:76: error: no matching function for call to \u2018\
    min(long int&, std::vector<long int>::size_type)\u2019\n   17 |             current_level_size\
    \ = std::min(current_level_size, levels.size());\n      |                    \
    \                                                        ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmphcgk_pye.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmphcgk_pye.cpp:17:76: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    })\n   17 |             current_level_size = std::min(current_level_size, levels.size());\n\
    \      |                                                                     \
    \       ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n     \
    \            from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmphcgk_pye.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmphcgk_pye.cpp:17:76:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long\
    \ unsigned"
  stdout: ''
  timestamp: 1660113045
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n       \
    \     curr_level = paren_string.substr(0, i);\n            level = 0;\n      \
    \  } else if (paren_string[i] == ')') {\n            curr_level = paren_string.substr(0,\
    \ i);\n            level = 0;\n        } else if (paren_string[i] == ' ') {\n\
    \            curr_level = paren_string.substr(0, i);\n            level = 0;\n\
    \        } else {\n            curr_level += paren_string[i];\n            level++;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp269jcjdg: /tmp/tmp269jcjdg.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            paren_level++;\n     \
    \       paren_level_count++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            paren_level_count--;\n        }\n        if (paren_level == 0 &&\
    \ paren_level_count == 0) {\n            paren_level_count++;\n            paren_level++;\n\
    \        }\n    }\n    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpgwdgkk4v: /tmp/tmpgwdgkk4v.cpp:87: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpvzv2cvwf: /tmp/tmpvzv2cvwf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     curr_level = paren_string.substr(0, i);\n            level++;\n        }\
    \ else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp2u4b5xgt: /tmp/tmp2u4b5xgt.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_length = 0;\n    long\
    \ current_level_nesting = 1;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level = current_level + c;\n            current_level_length++;\n\
    \            current_level_nesting++;\n        } else if (c == ')') {\n      \
    \      current_level = current_level.substr(0, current_level_length-1);\n    \
    \        current_level_length--;\n            current_level_nesting--;\n     \
    \   } else if (c == ' ') {\n            if (current_level_nesting == 0) {\n  \
    \              levels.push_back(current_level_length);\n            }\n      \
    \      current_level = \"\";\n        } else {\n            current_level = current_level\
    \ + c;\n        }\n    }\n    if (current_level_nesting == 0) {\n        levels.push_back(current_level_length);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpf3nvyxdu: /tmp/tmpf3nvyxdu.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpvzv2cvwf: /tmp/tmpvzv2cvwf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        paren_char = paren_string[i];\n       \
    \ if (paren_char == '(') {\n            level++;\n        } else if (paren_char\
    \ == ')') {\n            level--;\n        }\n        levels.push_back(level);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpybyqwb4l.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpybyqwb4l.cpp:14:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   14 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpybyqwb4l.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpybyqwb4l.cpp:14:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   14\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpybyqwb4l.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpybyqwb4l.cpp:14:27: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ "
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            current_level = current_level + \"(\";\n        }\
    \ else if (c == ')') {\n            current_level = current_level.substr(0, current_level.length()\
    \ - 1) + \")\";\n        } else {\n            current_level = current_level +\
    \ c;\n        }\n        if (current_level.length() > levels.size()) {\n     \
    \       levels.resize(current_level.length());\n        }\n        levels[current_level.length()\
    \ - 1]++;\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpl6q681c0: /tmp/tmpl6q681c0.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113047
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n \
    \   bool is_closed = false;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            is_open = true;\n            paren_level++;\n       \
    \ } else if (c == ')') {\n            is_closed = true;\n            paren_level--;\n\
    \        } else if (is_open && is_closed) {\n            paren_levels[paren_level]\
    \ = level;\n            paren_level++;\n            is_open = false;\n       \
    \     is_closed = false;\n        } else if (is_open) {\n            paren_level++;\n\
    \        } else if (is_closed) {\n            paren_level--;\n        }\n    \
    \    level++;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    long max_level = 0;\n    bool is_open = false;\n   \
    \ for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            level++;\n        } else if (c == ')') {\n            is_open\
    \ = false;\n            level--;\n        } else if (is_open) {\n            level++;\n\
    \        } else {\n            level--;\n        }\n        if (level > max_level)\
    \ {\n            max_level = level;\n        }\n        result.push_back(level);\n\
    \    }\n    if (max_level > 0) {\n        result.push_back(max_level);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpgee_ybrd: /tmp/tmpgee_ybrd.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    std::string paren_char;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        paren_char =\
    \ paren_string[i];\n        if (paren_char == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (paren_char == ')') {\n       \
    \     paren_level_count--;\n            paren_level--;\n            if (paren_level_count\
    \ == 0) {\n                paren_level_count = paren_level;\n                paren_levels.push_back(paren_level);\n\
    \            }\n        }\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpji6zhla0.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpji6zhla0.cpp:15:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   15 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpji6zhla0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpji6zhla0.cpp:15:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   15\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpji6zhla0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpji6zhla0.cpp:15:27: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ "
  stdout: ''
  timestamp: 1660113047
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.size() -\
    \ 1);\n            curr_level = curr_level + \")\";\n            levels.push_back(std::stoi(curr_level));\n\
    \            curr_level.clear();\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long current_level = 0;\n  long\
    \ paren_level = 0;\n  long paren_level_count = 0;\n  for (char c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_level_count++;\n      paren_level++;\n \
    \   } else if (c == ')') {\n      paren_level_count--;\n      paren_level--;\n\
    \      if (paren_level_count == 0) {\n        paren_levels.push_back(paren_level);\n\
    \      }\n    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpcvub3sqb: /tmp/tmpcvub3sqb.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ 0 && paren_levels.size() <= level) {\n            paren_levels.push_back(level);\n\
    \        }\n        level++;\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp5rmow9jq: /tmp/tmp5rmow9jq.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpkpisermk: /tmp/tmpkpisermk.cpp:71: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            curr_level = curr_level + c;\n     \
    \       level++;\n        } else if (c == ')') {\n            curr_level = curr_level.substr(0,\
    \ curr_level.size() - 1);\n            level--;\n            levels[level] = levels[level]\
    \ + 1;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_stack;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_stack.push_back(paren_string[i]);\n        } else if (paren_string[i]\
    \ == ')') {\n            long level_of_nesting = level;\n            while (level_of_nesting\
    \ > 0) {\n                level_of_nesting -= 1;\n                level += 1;\n\
    \            }\n            level -= 1;\n            levels.push_back(level);\n\
    \            paren_stack.pop_back();\n        } else {\n            assert(paren_string[i]\
    \ == ' ');\n        }\n    }\n    assert(paren_stack.size() == 0);\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpnvlyy3y3: /tmp/tmpnvlyy3y3.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ level) {\n            paren_levels[paren_levels.size() - 1]++;\n        } else\
    \ {\n            paren_levels.push_back(1);\n        }\n        level++;\n   \
    \ }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpvlpusn9h: /tmp/tmpvlpusn9h.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_level;\n\
    \    long current_level = 0;\n    long paren_level_count = 0;\n    for (auto c\
    \ : paren_string) {\n        if (c == '(') {\n            current_level++;\n \
    \           paren_level_count++;\n        } else if (c == ')') {\n           \
    \ current_level--;\n            paren_level_count--;\n        }\n        if (current_level\
    \ == 0 && paren_level_count == 0) {\n            paren_level.push_back(current_level);\n\
    \        }\n    }\n    return paren_level;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpxe6i9kqn: /tmp/tmpxe6i9kqn.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113044
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        } else {\n            paren_levels[paren_level]\
    \ = current_level;\n        }\n    }\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpvzv2cvwf: /tmp/tmpvzv2cvwf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ 0 && paren_levels.size() <= level) {\n            paren_levels.push_back(level);\n\
    \        }\n        level++;\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp5jfcgcbl: /tmp/tmp5jfcgcbl.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string current_paren_string = \"\";\n   \
    \ for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level++;\n\
    \            current_paren_string = current_paren_string + c;\n        } else\
    \ if (c == ')') {\n            paren_level--;\n            current_paren_string\
    \ = current_paren_string + c;\n        } else {\n            current_paren_string\
    \ = current_paren_string + c;\n        }\n        if (paren_level == 0 && current_paren_string\
    \ == \"\") {\n            paren_level = 1;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpuvmcf_ck: /tmp/tmpuvmcf_ck.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  long level = 0;\n  for (size_t i = 0; i < paren_string.size(); ++i) {\n   \
    \ if (paren_string[i] == '(') {\n      ++level;\n    } else if (paren_string[i]\
    \ == ')') {\n      --level;\n    }\n    if (level == 0) levels.push_back(level);\n\
    \  }\n  return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp7dvoak1f: /tmp/tmp7dvoak1f.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    long level_size\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   level_size++;\n            current_level = current_level + c;\n          \
    \  current_level_size = std::max(current_level_size, level_size);\n        } else\
    \ if (c == ')') {\n            level_size--;\n            current_level = current_level.substr(0,\
    \ current_level.size() - 1);\n            current_level_size = std::max(current_level_size,\
    \ level_size);\n        } else {\n            current_level = current_level +\
    \ c;\n        }\n    }\n    levels.push_back(current_level_size);\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpbcft41tl: /tmp/tmpbcft41tl.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        char c = paren_string[i];\n        if (c\
    \ == '(') {\n            curr_level = curr_level + c;\n        } else if (c ==\
    \ ')') {\n            levels[level++] = std::stoi(curr_level);\n            curr_level.clear();\n\
    \        } else {\n            curr_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpwf_zy8xf: /tmp/tmpwf_zy8xf.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    std::string token;\n    std::string temp_token;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            temp_token\
    \ = \"\";\n        } else if (c == ')') {\n            is_open = false;\n    \
    \        temp_token = temp_token.substr(0, temp_token.size() - 1);\n         \
    \   result.push_back(level);\n        } else if (is_open) {\n            temp_token\
    \ += c;\n        } else if (temp_token.size() > 0) {\n            temp_token +=\
    \ c;\n        } else {\n            temp_token = \"\";\n        }\n    }\n   \
    \ if (temp_token.size() > 0) {\n        result.push_back(level);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp8cx90o9f: /tmp/tmp8cx90o9f.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter_max = 0;\n    long paren_level_counter_max_index\
    \ = 0;\n    long paren_level_counter_max_index2 = 0;\n    long paren_level_counter_max_index3\
    \ = 0;\n    long paren_level_counter_max_index4 = 0;\n    long paren_level_counter_max_index5\
    \ = 0;\n    long paren_level_counter_max_index6 = 0;\n    long paren_level_counter_max_index7\
    \ = 0;\n    long paren_level_counter_max_index8 = 0;\n    long paren_level_counter_max_index9\
    \ = 0;\n    long paren_level_counter_max_index10 = 0;\n    long paren_level_counter_max_index11\
    \ = 0;\n    long paren_level_counter_max_index12 = 0;\n    long paren_level_counter_max_index13\
    \ = 0;\n    long paren_level_counter_max_index14 = 0;\n    long paren_level_counter_max_index15\
    \ = 0;\n    long paren_level_counter_max_index16 = 0;\n    long paren_level_counter_max_index17\
    \ = 0;\n    long paren_level_counter_max_index18 = 0;\n    long paren_level_counter_max_index19\
    \ = 0;\n    long paren_level_counter_max_index20 = 0;\n    long paren_level_counter_max_index21\
    \ = 0;\n    long paren_level_counter_max_index22 = 0;\n    long paren_level_counter_max_index23\
    \ = 0;\n    long paren_level_counter_max_index24 = 0;\n    long paren_level_counter_max_index25\
    \ = 0;\n    long paren_level_counter_max_index26 = 0;\n    long paren_level_counter_max_index27\
    \ = 0;\n    long paren_level_counter_max_index28 = 0;\n    long paren_level_counter_max_index29\
    \ = 0;\n    long paren_level_counter_max_index30 = 0;\n    long paren_level_counter_max_index31\
    \ = 0;\n    long paren_level_counter_max_index32 = 0;\n    long paren_level_counter_max_index33\
    \ = 0;\n    long paren_level_counter_max_index34 = 0;\n    long paren_level_counter_max_index35\
    \ = 0;\n    long paren_level_counter_max_index36 = 0;\n    long paren_level_counter_max_index37\
    \ = 0;\n    long paren_level_counter_max_index38 = 0;\n    long paren_level_counter_max_index39\
    \ = 0;\n    long paren_level_counter_max_index40 = 0;\n    long paren_level_counter_max_index41\
    \ = 0;\n    long paren_level_counter_max_index42 = 0;\n    long paren_level_counter_max_index43\
    \ = 0;\n    long paren_level_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpasnxp22p.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpasnxp22p.cpp:58:1: error: expected initializer before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmpasnxp22p.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113048
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     level++;\n            paren_level = paren_level + paren_string[i];\n   \
    \     } else if (paren_string[i] == ')') {\n            level--;\n           \
    \ paren_level = paren_level.substr(0, paren_level.size()-1);\n            levels[level]\
    \ = levels[level] + 1;\n        }\n    }\n    return levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ 0 && paren_levels.size() <= level) {\n            paren_levels.push_back(level);\n\
    \        }\n        level++;\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp5jfcgcbl: /tmp/tmp5jfcgcbl.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113048
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp30l_2ezh: /tmp/tmp30l_2ezh.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   bool is_open = false;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_levels.pop_back();\n\
    \        } else if (is_open) {\n            paren_level++;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpw88e_imy: /tmp/tmpw88e_imy.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 1;\n    long paren_level = 0;\n    for (size_t i = 0; i\
    \ < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       paren_level++;\n        } else if (paren_string[i] == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels[paren_level] = paren_levels[paren_level]\
    \ + 1;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_level;\n\
    \    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count_index\
    \ = 0;\n    long paren_level_max_count_index2 = 0;\n    long paren_level_max_count_index3\
    \ = 0;\n    long paren_level_max_count_index4 = 0;\n    long paren_level_max_count_index5\
    \ = 0;\n    long paren_level_max_count_index6 = 0;\n    long paren_level_max_count_index7\
    \ = 0;\n    long paren_level_max_count_index8 = 0;\n    long paren_level_max_count_index9\
    \ = 0;\n    long paren_level_max_count_index10 = 0;\n    long paren_level_max_count_index11\
    \ = 0;\n    long paren_level_max_count_index12 = 0;\n    long paren_level_max_count_index13\
    \ = 0;\n    long paren_level_max_count_index14 = 0;\n    long paren_level_max_count_index15\
    \ = 0;\n    long paren_level_max_count_index16 = 0;\n    long paren_level_max_count_index17\
    \ = 0;\n    long paren_level_max_count_index18 = 0;\n    long paren_level_max_count_index19\
    \ = 0;\n    long paren_level_max_count_index20 = 0;\n    long paren_level_max_count_index21\
    \ = 0;\n    long paren_level_max_count_index22 = 0;\n    long paren_level_max_count_index23\
    \ = 0;\n    long paren_level_max_count_index24 = 0;\n    long paren_level_max_count_index25\
    \ = 0;\n    long paren_level_max_count_index26 = 0;\n    long paren_level_max_count_index27\
    \ = 0;\n    long paren_level_max_count_index28 = 0;\n    long paren_level_max_count_index29\
    \ = 0;\n    long paren_level_max_count_index30 = 0;\n    long paren_level_max_count_index31\
    \ = 0;\n    long paren_level_max_count_index32 = 0;\n    long paren_level_max_count_index33\
    \ = 0;\n    long paren_level_max_count_index34 = 0;\n    long paren_level_max_count_index35\
    \ = 0;\n    long paren_level_max_count_index36 = 0;\n    long paren_level_max_count_index37\
    \ = 0;\n    long paren_level_max_count_index38 = 0;\n    long paren_level_max_count_index39\
    \ = 0;\n    long paren_level_max_count_index40 = 0;\n    long paren_level_max_count_index41\
    \ = 0;\n    long paren_level_max_count_index42 = 0;\n    long paren_level_max_count_index43\
    \ = 0;\n    long \n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpu__1a0sv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpu__1a0sv.cpp:58:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmpu__1a0sv.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   for (char c : paren_string) {\n        if (c == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpwq25xta0: /tmp/tmpwq25xta0.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels);\n\
    \    long paren_levels_sum = 0;\n    long paren_levels_sum2 = 0;\n    long paren_levels_sum3\
    \ = 0;\n    long paren_levels_sum4 = 0;\n    long paren_levels_sum5 = 0;\n   \
    \ long paren_levels_sum6 = 0;\n    long paren_levels_sum7 = 0;\n    long paren_levels_sum8\
    \ = 0;\n    long paren_levels_sum9 = 0;\n    long paren_levels_sum10 = 0;\n  \
    \  long paren_levels_sum11 = 0;\n    long paren_levels_sum12 = 0;\n    long paren_levels_sum13\
    \ = 0;\n    long paren_levels_sum14 = 0;\n    long paren_levels_sum15 = 0;\n \
    \   long paren_levels_sum16 = 0;\n    long paren_levels_sum17 = 0;\n    long paren_levels_sum18\
    \ = 0;\n    long paren_levels_sum19 = 0;\n    long paren_levels_sum20 = 0;\n \
    \   long paren_levels_sum21 = 0;\n    long paren_levels_sum22 = 0;\n    long paren_levels_sum23\
    \ = 0;\n    long paren_levels_sum24 = 0;\n    long paren_levels_sum25 = 0;\n \
    \   long paren_levels_sum26 = 0;\n    long paren_levels_sum27 = 0;\n    long paren_levels_sum28\
    \ = 0;\n    long paren_levels_sum29 = 0;\n    long paren_levels_sum30 = 0;\n \
    \   long paren_levels_sum31 = 0;\n    long paren_levels_sum32 = 0;\n    long paren_levels_sum33\
    \ = 0;\n    long paren_levels_sum34 = 0;\n    long paren_levels_sum35 = 0;\n \
    \   long paren_levels_sum36 = 0;\n    long paren_levels_sum37 = 0;\n    long paren_levels_sum38\
    \ = 0;\n    long paren_levels_sum39 = 0;\n    long paren_levels_sum40 = 0;\n \
    \   long paren_levels_sum41 = 0;\n    long paren_levels_sum42 = 0;\n    long paren_levels_sum43\
    \ = 0;\n    long paren_levels_sum44 = 0;\n    long paren_levels_sum45 = 0;\n \
    \   long paren_levels_sum46 = 0;\n    long paren\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi6dg28rz.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpi6dg28rz.cpp:10:67: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                           ^~~~~\n/tmp/tmpi6dg28rz.cpp:12:45:\
    \ error: no matching function for call to \u2018std::vector<long int>::push_back(std::vector<long\
    \ int>&)\u2019\n   12 |     paren_levels_temp.push_back(paren_levels);\n     \
    \ |                                             ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi6dg28rz.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35: note:   no known\
    \ conversion for argument 1 from \u2018std::vector<long int>\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018std::vector<long int>::value_type&&\u2019 {aka "
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long current_level = 0;\n  for\
    \ (size_t i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i] == '(')\
    \ {\n      current_level++;\n    } else if (paren_string[i] == ')') {\n      current_level--;\n\
    \    }\n    paren_levels.push_back(current_level);\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpr6rz9w3b: /tmp/tmpr6rz9w3b.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 1;\n    long current_level_nesting\
    \ = 1;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   current_level = current_level + c;\n            current_level_nesting++;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level = current_level.substr(0, current_level.size() - 1);\n  \
    \          current_level_nesting--;\n            current_level_size -= 1;\n  \
    \      } else {\n            current_level = current_level + c;\n        }\n \
    \       if (current_level_nesting == 0) {\n            levels.push_back(current_level_size);\n\
    \            current_level_size = 1;\n            current_level_nesting = 1;\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpffi5_r_k: /tmp/tmpffi5_r_k.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level;\n            }\n        }\n        if (paren_level_count > paren_level_max_count)\
    \ {\n            paren_level_max_count = paren_level_count;\n            paren_level_max_count\
    \ = paren_level_max;\n        }\n    }\n    paren_level_count = paren_level_max_count;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level;\n            }\n        }\n        if (paren_level_count > paren_level_max_count)\
    \ {\n            paren_level_max_count = paren_level_count;\n            paren_level_max_count\
    \ = paren_level_max;\n        }\n    }\n    paren_level_count = paren_level_max_count;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level;\n            }\n        }\n        if (paren_level_count > paren_level_max_count)\
    \ {\n            paren_level_max_count = paren_level_count;\n            paren_level_max_count\
    \ = paren_level_max;\n        }\n    }\n    paren_level_count = paren_level_max_count;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp0vqg9xfp.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp0vqg9xfp.cpp:78:46: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   78 |                 paren_level_max = paren_level\n      |      \
    \                                        ^\n      |                          \
    \                    ;\n   79 | }\n      | ~                                 \
    \            \n/tmp/tmp0vqg9xfp.cpp:80:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n   80 | int main() {\n      |     \
    \       ^\n/tmp/tmp0vqg9xfp.cpp:85:1: error: expected \u2018}\u2019 at end of\
    \ input\n   85 | }\n      | ^\n/tmp/tmp0vqg9xfp.cpp:73:30: note: to match this\
    \ \u2018{\u2019\n   73 |         } else if (c == ')') {\n      |             \
    \                 ^\n/tmp/tmp0vqg9xfp.cpp:85:1: error: expected \u2018}\u2019\
    \ at end of input\n   85 | }\n      | ^\n/tmp/tmp0vqg9xfp.cpp:69:33: note: to\
    \ match this \u2018{\u2019\n   69 |     for (auto c : paren_string) {\n      |\
    \                                 ^\n/tmp/tmp0vqg9xfp.cpp:85:1: error: expected\
    \ \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmp0vqg9xfp.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp0vqg9xfp.cpp:85:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   85 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long paren_level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpdrj67dh7: /tmp/tmpdrj67dh7.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_count = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_count++;\n            current_level++;\n\
    \        } else if (c == ')') {\n            paren_count--;\n            current_level--;\n\
    \        }\n        if (current_level > paren_levels.size()) {\n            paren_levels.resize(current_level);\n\
    \        }\n        paren_levels[current_level] = std::max(paren_levels[current_level],\
    \ paren_count);\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpzuqjx0cp: /tmp/tmpzuqjx0cp.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels = paren_string.split(\" \");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(1);\n    long max_level = 1;\n    for (long i\
    \ = 0; i < paren_levels.size(); i++) {\n        long current_level = paren_levels[i];\n\
    \        if (current_level > max_level) {\n            max_level = current_level;\n\
    \        }\n    }\n    for (long i = 0; i < paren_levels.size(); i++) {\n    \
    \    long current_level = paren_levels[i];\n        if (current_level > max_level)\
    \ {\n            paren_levels[i] = max_level;\n        }\n    }\n    return paren_levels_temp;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmv2f50z2.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpmv2f50z2.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (char c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmp_xx2q9hm: /tmp/tmp_xx2q9hm.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpoyrfgxvi: /tmp/tmpoyrfgxvi.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113045
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_count =\
    \ 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min = 0;\n\
    \    long paren_level_count_sum = 0;\n    long paren_level_count_sum_max = 0;\n\
    \    long paren_level_count_sum_min = 0;\n    long paren_level_count_sum_sum =\
    \ 0;\n    long paren_level_count_sum_sum_max = 0;\n    long paren_level_count_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n   \
    \ long paren_level_count_sum_sum_sum_sum_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoqca0ypt.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpoqca0ypt.cpp:41:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   41 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoqca0ypt.cpp:38:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \ previously declared here\n   38 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpoqca0ypt.cpp:42:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \n   42 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoqca0ypt.cpp:39:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \ previously declared here\n   39 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpoqca0ypt.cpp:43:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \n   43 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max =\
    \ 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpoqca0ypt.cpp:40:10: note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \ previously declared here\n   40 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpoqca0ypt.cpp:44:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   44 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoqca0ypt.cpp:38:10:\
    \ not"
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpldh6rrcu: /tmp/tmpldh6rrcu.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113042
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   bool is_open = false;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            is_open = true;\n        } else if (c == ')') {\n      \
    \      is_open = false;\n        } else if (is_open) {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        }\n    }\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmph2uqnl0z: /tmp/tmph2uqnl0z.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long paren_level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpdrj67dh7: /tmp/tmpdrj67dh7.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113049
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplcx_b7h7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplcx_b7h7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplcx_b7h7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplcx_b7h7.cpp:14:1"
  stdout: ''
  timestamp: 1660113044
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  for (auto &c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_levels.push_back(0);\n    } else if (c ==\
    \ ')') {\n      assert(paren_levels.back() > 0);\n      paren_levels.back()--;\n\
    \    } else {\n      assert(paren_levels.back() == 0);\n      paren_levels.back()++;\n\
    \    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpshvf225_: /tmp/tmpshvf225_.cpp:15: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels.back() > 0'' failed.

    '
  stdout: ''
  timestamp: 1660113050
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_size = 1;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            curr_level.push_back(c);\n\
    \            curr_level_size += 1;\n        } else if (c == ')') {\n         \
    \   curr_level.pop_back();\n            curr_level_size -= 1;\n            if\
    \ (curr_level_size == 0) {\n                levels.push_back(curr_level.size());\n\
    \                curr_level_size = 1;\n            }\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: 'tmpv2lsflst: /tmp/tmpv2lsflst.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113050
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  std::string paren_level;\n  long level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_level = paren_string.substr(0,\
    \ i);\n      level++;\n    } else if (paren_string[i] == ')') {\n      level--;\n\
    \      levels[level] = levels[level] + 1;\n    }\n  }\n  return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113049
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            level--;\n\
    \        } else if (is_open) {\n            level++;\n        }\n        levels.push_back(level);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  status: Exception
  stderr: 'tmppgpw9fa1: /tmp/tmppgpw9fa1.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({2, 3, 1, 3}))'' failed.

    '
  stdout: ''
  timestamp: 1660113050
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string curr_paren_string = paren_string;\n\
    \    std::string curr_paren_level = \"\";\n    long paren_level_count = 0;\n \
    \   long paren_level_count_max = 0;\n    long paren_level_count_max_index = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_min_index = 0;\n\
    \    long paren_level_count_sum = 0;\n    long paren_level_count_sum_index = 0;\n\
    \    long paren_level_count_sum2 = 0;\n    long paren_level_count_sum2_index =\
    \ 0;\n    long paren_level_count_sum3 = 0;\n    long paren_level_count_sum3_index\
    \ = 0;\n    long paren_level_count_sum4 = 0;\n    long paren_level_count_sum4_index\
    \ = 0;\n    long paren_level_count_sum5 = 0;\n    long paren_level_count_sum5_index\
    \ = 0;\n    long paren_level_count_sum6 = 0;\n    long paren_level_count_sum6_index\
    \ = 0;\n    long paren_level_count_sum7 = 0;\n    long paren_level_count_sum7_index\
    \ = 0;\n    long paren_level_count_sum8 = 0;\n    long paren_level_count_sum8_index\
    \ = 0;\n    long paren_level_count_sum9 = 0;\n    long paren_level_count_sum9_index\
    \ = 0;\n    long paren_level_count_sum10 = 0;\n    long paren_level_count_sum10_index\
    \ = 0;\n    long paren_level_count_sum11 = 0;\n    long paren_level_count_sum11_index\
    \ = 0;\n    long paren_level_count_sum12 = 0;\n    long paren_level_count_sum12_index\
    \ = 0;\n    long paren_level_count_sum13 = 0;\n    long paren_level_count_sum13_index\
    \ = 0;\n    long paren_level_count_sum14 = 0;\n    long paren_level_count_sum14_index\
    \ = 0;\n    long paren_level_count_sum15 = 0;\n    long paren_level_count_sum15_index\
    \ = 0;\n    long paren_level_count_sum16 = 0;\n    long paren_level_count_sum16_index\
    \ = 0;\n    long paren_level_count_sum17 = 0;\n    long paren_level_count_sum17_index\
    \ = 0;\n    long paren_level_count_sum18 = 0;\n    long paren_level_count_sum18_index\
    \ = 0;\n    long paren_level_count_sum19 = 0;\n    long paren_level_count_sum19_index\
    \ = 0;\n    long paren_level_count_sum20 = 0;\n    long paren_level_count_sum20_index\
    \ = 0;\n    long paren_level_count_sum21 = 0;\n    long paren_level_count_sum21\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr62_8h1i.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpr62_8h1i.cpp:60:1: error: expected initializer before \u2018}\u2019\
    \ token\n   60 | }\n      | ^\n/tmp/tmpr62_8h1i.cpp:60:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660113049
