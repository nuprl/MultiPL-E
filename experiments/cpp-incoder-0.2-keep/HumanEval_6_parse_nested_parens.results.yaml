name: HumanEval_6_parse_nested_parens
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto &c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmph2mko2je: /tmp/tmph2mko2je.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpm6gbg7_0: /tmp/tmpm6gbg7_0.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level += c;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level_size = std::max(current_level_size, levels.size());\n   \
    \         levels.push_back(current_level_size);\n            current_level.clear();\n\
    \        } else {\n            current_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp81dr8gz.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpp81dr8gz.cpp:17:76: error: no matching function for call to \u2018\
    max(long int&, std::vector<long int>::size_type)\u2019\n   17 |             current_level_size\
    \ = std::max(current_level_size, levels.size());\n      |                    \
    \                                                        ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpp81dr8gz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpp81dr8gz.cpp:17:76:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   17 |             current_level_size = std::max(current_level_size,\
    \ levels.size());\n      |                                                   \
    \                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \          "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_parens = \"\";\n    for (auto c : paren_string) {\n    \
    \    if (c == '(') {\n            curr_parens += c;\n        } else if (c == ')')\
    \ {\n            curr_parens = curr_parens.substr(0, curr_parens.size() - 1);\n\
    \            long curr_level = levels.size();\n            long curr_level_parens\
    \ = curr_parens.size();\n            long curr_level_open = levels.size();\n \
    \           long curr_level_closed = levels.size();\n            long curr_level_open_p\
    \ = levels.size();\n            long curr_level_closed_p = levels.size();\n  \
    \          long curr_level_open_c = levels.size();\n            long curr_level_closed_c\
    \ = levels.size();\n            long curr_level_open_p_c = levels.size();\n  \
    \          long curr_level_closed_p_c = levels.size();\n            long curr_level_open_c_p\
    \ = levels.size();\n            long curr_level_closed_c_p = levels.size();\n\
    \            long curr_level_open_p_c_p = levels.size();\n            long curr_level_closed_p_c_p\
    \ = levels.size();\n            long curr_level_open_c_c_p = levels.size();\n\
    \            long curr_level_closed_c_c_p = levels.size();\n            long curr_level_open_p_c_c_p\
    \ = levels.size();\n            long curr_level_closed_p_c_c_p = levels.size();\n\
    \            long curr_level_open_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_p = levels.size();\n            long\
    \ curr_level_open_c_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_c_p = levels.size();\n           \
    \ long curr_level_open_c_c_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_c_c_p = levels.size();\n         \
    \   long curr_level_open_c_c_c_c_c_c_p = levels.size();\n            long curr_level_closed_c_c_c_c_c_c_p\
    \ = levels.size();\n            long curr_level_open_p_c_c_c_c_c_c_p = levels.size();\n\
    \            long curr_level_closed_p_c_c_c_c_c_c_p = levels.size();\n       \
    \     long curr_level_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp1ume7a4q.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp1ume7a4q.cpp:51:1: error: expected initializer before \u2018}\u2019\
    \ token\n   51 | }\n      | ^\n/tmp/tmp1ume7a4q.cpp:52:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   52 | int main() {\n     \
    \ |            ^\n/tmp/tmp1ume7a4q.cpp:57:1: error: expected \u2018}\u2019 at\
    \ end of input\n   57 | }\n      | ^\n/tmp/tmp1ume7a4q.cpp:11:33: note: to match\
    \ this \u2018{\u2019\n   11 |     for (auto c : paren_string) {\n      |     \
    \                            ^\n/tmp/tmp1ume7a4q.cpp:57:1: error: expected \u2018\
    }\u2019 at end of input\n   57 | }\n      | ^\n/tmp/tmp1ume7a4q.cpp:8:65: note:\
    \ to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp1ume7a4q.cpp:57:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   57 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        }\n        paren_levels[paren_level]\
    \ = current_level;\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_level = paren_string.substr(0, i);\n            level++;\n       \
    \ } else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpjoviqr5v: /tmp/tmpjoviqr5v.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_first_paren =\
    \ true;\n    for (auto c : paren_string) {\n        if (c == '(') {\n        \
    \    if (is_first_paren) {\n                is_first_paren = false;\n        \
    \        level++;\n                paren_level = std::to_string(level);\n    \
    \        } else {\n                levels[level - 1]++;\n            }\n     \
    \   } else if (c == ')') {\n            if (is_first_paren) {\n              \
    \  is_first_paren = false;\n                level--;\n                paren_level\
    \ = std::to_string(level);\n            } else {\n                levels[level\
    \ - 1]--;\n            }\n        } else {\n            levels[level - 1]++;\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long paren_level = 0;\n  long\
    \ paren_level_count = 0;\n  long paren_level_max_count = 0;\n  for (size_t i =\
    \ 0; i < paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n    \
    \  paren_level_count++;\n      if (paren_level_count > paren_level_max_count)\
    \ {\n        paren_level_max_count = paren_level_count;\n      }\n      paren_levels.push_back(paren_level);\n\
    \      paren_level_count = 0;\n    } else if (paren_string[i] == ')') {\n    \
    \  paren_level_count--;\n      if (paren_level_count < 0) {\n        throw std::runtime_error(\"\
    Invalid input\");\n      }\n      paren_levels.push_back(paren_level);\n     \
    \ paren_level_count = 0;\n    } else {\n      paren_level_count = 0;\n    }\n\
    \  }\n  paren_levels.push_back(paren_level);\n  return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::runtime_error'\n \
    \ what():  Invalid input\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  if (paren_level_count == 0) {\n                paren_levels.push_back(paren_level);\n\
    \                paren_level_count = 0;\n            }\n        }\n        paren_level++;\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp7e47lt7s: /tmp/tmp7e47lt7s.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp1hs2hypt: /tmp/tmp1hs2hypt.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpu29_39yw: /tmp/tmpu29_39yw.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.substr(1, paren_string.length() - 2).split(' ');\n\
    \  long max_level = 0;\n  for (long i = 0; i < paren_levels.size(); i++) {\n \
    \   if (paren_levels[i] > max_level) {\n      max_level = paren_levels[i];\n \
    \   }\n  }\n  std::vector<long> nested_paren_levels;\n  for (long i = 0; i < paren_levels.size();\
    \ i++) {\n    nested_paren_levels.push_back(max_level);\n  }\n  return nested_paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjyvrbnna.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpjyvrbnna.cpp:10:68: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(1,\
    \ paren_string.length() - 2).split(' ');\n      |                            \
    \                                        ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n        } else if (c == ')') {\n            is_closed = true;\n   \
    \     } else if (is_open && is_closed) {\n            result.push_back(level);\n\
    \            is_open = false;\n            is_closed = false;\n        } else\
    \ if (is_open) {\n            level++;\n        } else if (is_closed) {\n    \
    \        level--;\n        }\n    }\n    if (is_open || is_closed) {\n       \
    \ result.push_back(level);\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp3zklxstr: /tmp/tmp3zklxstr.cpp:35: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level = 1;\n    long paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_count = 1;\n    long paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_count = 1;\n    long\
    \ paren_level_max_paren_level_max_paren_level_max_count = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_max_paren_level_count\
    \ = 1;\n    long paren_level_max_paren_level_max_paren_\n}\nint main() {\n   \
    \ auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp739sky5r.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp739sky5r.cpp:34:1: error: expected initializer before \u2018}\u2019\
    \ token\n   34 | }\n      | ^\n/tmp/tmp739sky5r.cpp:34:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_start =\
    \ 0;\n    long paren_level_end = 0;\n    long paren_level_end_index = 0;\n   \
    \ long paren_level_end_index2 = 0;\n    long paren_level_end_index3 = 0;\n   \
    \ long paren_level_end_index4 = 0;\n    long paren_level_end_index5 = 0;\n   \
    \ long paren_level_end_index6 = 0;\n    long paren_level_end_index7 = 0;\n   \
    \ long paren_level_end_index8 = 0;\n    long paren_level_end_index9 = 0;\n   \
    \ long paren_level_end_index10 = 0;\n    long paren_level_end_index11 = 0;\n \
    \   long paren_level_end_index12 = 0;\n    long paren_level_end_index13 = 0;\n\
    \    long paren_level_end_index14 = 0;\n    long paren_level_end_index15 = 0;\n\
    \    long paren_level_end_index16 = 0;\n    long paren_level_end_index17 = 0;\n\
    \    long paren_level_end_index18 = 0;\n    long paren_level_end_index19 = 0;\n\
    \    long paren_level_end_index20 = 0;\n    long paren_level_end_index21 = 0;\n\
    \    long paren_level_end_index22 = 0;\n    long paren_level_end_index23 = 0;\n\
    \    long paren_level_end_index24 = 0;\n    long paren_level_end_index25 = 0;\n\
    \    long paren_level_end_index26 = 0;\n    long paren_level_end_index27 = 0;\n\
    \    long paren_level_end_index28 = 0;\n    long paren_level_end_index29 = 0;\n\
    \    long paren_level_end_index30 = 0;\n    long paren_level_end_index31 = 0;\n\
    \    long paren_level_end_index32 = 0;\n    long paren_level_end_index33 = 0;\n\
    \    long paren_level_end_index34 = 0;\n    long paren_level_end_index35 = 0;\n\
    \    long paren_level_end_index36 = 0;\n    long paren_level_end_index37 = 0;\n\
    \    long paren_level_end_index38 = 0;\n    long paren_level_end_index39 = 0;\n\
    \    long paren_level_end_index40 = 0;\n    long paren_level_end_index41 = 0;\n\
    \    long paren_level_end_index42 = 0;\n    long paren_level_end_index43 = 0;\n\
    \    long paren_level_end_index44 = 0;\n    long paren_level_end_index45 = 0;\n\
    \    long paren_level_end_index46 = 0;\n    long paren_level_end_index47 = 0;\n\
    \    long paren_level_end_index48 = 0;\n\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpkvoq0icf: /tmp/tmpkvoq0icf.cpp:66: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 1;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_max_index\
    \ = 0;\n    long paren_level_count_min = 0;\n    long paren_level_count_min_index\
    \ = 0;\n    long paren_level_count_max_paren = 0;\n    long paren_level_count_min_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren = 0;\n    long paren_level_count_min_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren = 0;\n    long paren_level_count_min_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren = 0;\n    long\
    \ paren_level_count_min_paren_paren_paren_paren = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren = 0;\n  \
    \  long paren_level_count_max_paren_paren_paren_paren_paren_paren = 0;\n    long\
    \ paren_level_count_min_paren_paren_paren_paren_paren_paren = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n    long paren_level_count_max_paren_paren_\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp746fhmtc.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp746fhmtc.cpp:35:10: error: redeclaration of \u2018long int paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \n   35 |     long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp746fhmtc.cpp:33:10: note: \u2018long int paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \ previously declared here\n   33 |     long paren_level_count_max_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp746fhmtc.cpp:36:10: error: redeclaration of \u2018long int paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \n   36 |     long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp746fhmtc.cpp:34:10: note: \u2018long int paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\u2019\
    \ previously declared here\n   34 |     long paren_level_count_min_paren_paren_paren_paren_paren_paren_paren_paren_paren\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp746fhmtc.cpp:40:1: error: expected initializer before \u2018}\u2019 token\n\
    \   40 | }\n      | ^\n/tmp/tmp746fhmtc.cpp:40:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   ++level;\n    } else if (c == ')') {\n      --level;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpnou49zuo: /tmp/tmpnou49zuo.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(max_level);\n            max_level++;\n\
    \        } else if (c == ')') {\n            max_level = std::max(max_level, paren_levels.back());\n\
    \            paren_levels.pop_back();\n        } else {\n            max_level\
    \ = std::max(max_level, paren_levels.back());\n        }\n    }\n    paren_levels.push_back(max_level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpf571ejjx: /tmp/tmpf571ejjx.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            level++;\n            paren_char = \"\
    (\";\n        } else if (c == ')') {\n            level--;\n            paren_char\
    \ = \")\";\n        } else {\n            paren_char += c;\n        }\n      \
    \  if (level == 0 && paren_char != \"()\") {\n            levels.push_back(level);\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpnyp4ep4g: /tmp/tmpnyp4ep4g.cpp:30: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpvsgmmt9k: /tmp/tmpvsgmmt9k.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long max_level = 0;\n    long level = 0;\n    long index = 0;\n    bool is_open\
    \ = false;\n    bool is_closed = false;\n    for (auto c : paren_string) {\n \
    \       if (c == '(') {\n            is_open = true;\n            level++;\n \
    \       }\n        else if (c == ')') {\n            is_closed = true;\n     \
    \       level--;\n        }\n        else if (c == ' ') {\n            if (is_open)\
    \ {\n                result.push_back(level);\n                is_open = false;\n\
    \            }\n        }\n        else if (is_open) {\n            is_closed\
    \ = false;\n        }\n    }\n    if (is_open) {\n        result.push_back(level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpmvctzp01: /tmp/tmpmvctzp01.cpp:41: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_count =\
    \ 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n   \
    \ long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpalhwj9sw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpalhwj9sw.cpp:16:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   16 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpalhwj9sw.cpp:14:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   14 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpalhwj9sw.cpp:17:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   17 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpalhwj9sw.cpp:15:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   15 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpalhwj9sw.cpp:18:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   18 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpalhwj9sw.cpp:14:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   14 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpalhwj9sw.cpp:19:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   19 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpalhwj9sw.cpp:15:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   15 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpalhwj9sw.cpp:20:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   20 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpalhwj9sw.cpp:14:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   14 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpalhwj9sw.cpp:21:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   21 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpalhwj9sw.cpp:15:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_length = 0;\n    bool is_first_level\
    \ = true;\n    for (auto c : paren_string) {\n        if (c == '(') {\n      \
    \      curr_level = curr_level + c;\n            curr_level_length++;\n      \
    \  } else if (c == ')') {\n            curr_level = curr_level.substr(0, curr_level_length);\n\
    \            curr_level_length--;\n            if (curr_level_length == 0) {\n\
    \                levels.push_back(curr_level.length());\n                is_first_level\
    \ = false;\n            }\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpqcdrszos: /tmp/tmpqcdrszos.cpp:32: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long max_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            current_level++;\n            if (current_level\
    \ > max_level) {\n                max_level = current_level;\n            }\n\
    \        } else if (c == ')') {\n            current_level--;\n        }\n   \
    \     paren_levels.push_back(current_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpvf3opplb: /tmp/tmpvf3opplb.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 0;\n    long paren_level = 0;\n    for (size_t i = 0; i\
    \ < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       paren_levels[paren_level] = paren_level + 1;\n        } else if (paren_string[i]\
    \ == ')') {\n            paren_levels[paren_level] = paren_levels[paren_level\
    \ - 1];\n        }\n    }\n    return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   paren_level++;\n            paren_level_counter++;\n        } else if (c ==\
    \ ')') {\n            paren_level--;\n            paren_level_counter--;\n   \
    \         if (paren_level == 0 && paren_level_counter == 0) {\n              \
    \  paren_levels[paren_levels.size() - 1] = current_level;\n                current_level++;\n\
    \            }\n        }\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min =\
    \ 0;\n    long paren_level_count_sum = 0;\n    long paren_level_count_sum2 = 0;\n\
    \    long paren_level_count_sum3 = 0;\n    long paren_level_count_sum4 = 0;\n\
    \    long paren_level_count_sum5 = 0;\n    long paren_level_count_sum6 = 0;\n\
    \    long paren_level_count_sum7 = 0;\n    long paren_level_count_sum8 = 0;\n\
    \    long paren_level_count_sum9 = 0;\n    long paren_level_count_sum10 = 0;\n\
    \    long paren_level_count_sum11 = 0;\n    long paren_level_count_sum12 = 0;\n\
    \    long paren_level_count_sum13 = 0;\n    long paren_level_count_sum14 = 0;\n\
    \    long paren_level_count_sum15 = 0;\n    long paren_level_count_sum16 = 0;\n\
    \    long paren_level_count_sum17 = 0;\n    long paren_level_count_sum18 = 0;\n\
    \    long paren_level_count_sum19 = 0;\n    long paren_level_count_sum20 = 0;\n\
    \    long paren_level_count_sum21 = 0;\n    long paren_level_count_sum22 = 0;\n\
    \    long paren_level_count_sum23 = 0;\n    long paren_level_count_sum24 = 0;\n\
    \    long paren_level_count_sum25 = 0;\n    long paren_level_count_sum26 = 0;\n\
    \    long paren_level_count_sum27 = 0;\n    long paren_level_count_sum28 = 0;\n\
    \    long paren_level_count_sum29 = 0;\n    long paren_level_count_sum30 = 0;\n\
    \    long paren_level_count_sum31 = 0;\n    long paren_level_count_sum32 = 0;\n\
    \    long paren_level_count_sum33 = 0;\n    long paren_level_count_sum34 = 0;\n\
    \    long paren_level_count_sum35 = 0;\n    long paren_level_count_sum36 = 0;\n\
    \    long paren_level_count_sum37 = 0;\n    long paren_level_count_sum38 = 0;\n\
    \    long paren_level_count_sum39 = 0;\n    long paren_level_count_sum40 = 0;\n\
    \    long paren_level_count_sum41 = 0;\n    long paren_level_count_sum42 = 0;\n\
    \    long paren_level_count_sum43 = 0;\n    long paren_level_count_sum44 = 0;\n\
    \    long paren_level_count_sum45 = 0;\n    long paren_level_count_sum46 = 0;\n\
    \    long paren_level_count_sum47 = 0;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp3_l5vfur: /tmp/tmp3_l5vfur.cpp:65: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            current_level = current_level + \"(\";\n        }\
    \ else if (c == ')') {\n            current_level = current_level.substr(0, current_level.size()-1);\n\
    \            levels.push_back(std::stoi(current_level));\n            current_level.clear();\n\
    \        } else {\n            current_level = current_level + c;\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_parens = \"\";\n    std::string curr_level = \"\";\n   \
    \ for (auto c : paren_string) {\n        if (c == '(') {\n            curr_parens\
    \ += c;\n        } else if (c == ')') {\n            curr_parens = curr_parens.substr(0,\
    \ curr_parens.size() - 1);\n            long curr_level = std::count(curr_parens.begin(),\
    \ curr_parens.end(), '(');\n            curr_level = std::max(curr_level, std::count(curr_parens.begin(),\
    \ curr_parens.end(), ')'));\n            curr_level++;\n            curr_parens\
    \ = \"\";\n            levels.push_back(curr_level);\n        } else {\n     \
    \       curr_parens += c;\n        }\n    }\n    return levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpxeb05iwv: /tmp/tmpxeb05iwv.cpp:30: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpvs3ix2rx: /tmp/tmpvs3ix2rx.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmptf7qg7o6: /tmp/tmptf7qg7o6.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_stack;\n    long level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_stack += c;\n        } else if\
    \ (c == ')') {\n            long new_level = level;\n            while (paren_stack.size()\
    \ > 0) {\n                if (paren_stack.back() == '(') {\n                 \
    \   new_level++;\n                    paren_stack.pop_back();\n              \
    \  } else if (paren_stack.back() == ')') {\n                    new_level--;\n\
    \                    paren_stack.pop_back();\n                }\n            }\n\
    \            levels[level++] = new_level;\n            paren_stack = \"\";\n \
    \       } else {\n            paren_stack += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \  std::vector<long> paren_levels_temp;\n  paren_levels_temp.push_back(paren_levels);\n\
    \  long paren_levels_sum = 0;\n  while (paren_levels_sum < paren_levels) {\n \
    \   paren_levels_sum += paren_levels_temp[paren_levels_sum];\n    paren_levels_temp.push_back(paren_levels_sum);\n\
    \  }\n  return paren_levels_temp;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp317phnkt.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp317phnkt.cpp:10:65: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                         ^~~~~\n/tmp/tmp317phnkt.cpp:12:43: error:\
    \ no matching function for call to \u2018std::vector<long int>::push_back(std::vector<long\
    \ int>&)\u2019\n   12 |   paren_levels_temp.push_back(paren_levels);\n      |\
    \                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp317phnkt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018const value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |\
    \       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.size() -\
    \ 1) + \")\";\n        } else {\n            curr_level = curr_level + c;\n  \
    \      }\n        if (curr_level.find(\"(\") == std::string::npos) {\n       \
    \     levels.push_back(std::stoi(curr_level));\n        }\n    }\n    return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpcmnkkwya: /tmp/tmpcmnkkwya.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp_bhh5lqu: /tmp/tmp_bhh5lqu.cpp:25: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels.push_back(std::stoi(paren_level));\n            paren_level.clear();\n\
    \        } else {\n            paren_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \    std::vector<long> paren_levels_temp;\n    paren_levels_temp.reserve(paren_levels);\n\
    \    long paren_level = 0;\n    long paren_levels_temp_index = 0;\n    long paren_levels_temp_size\
    \ = 0;\n    for (long i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == ')') {\n            paren_levels_temp[paren_levels_temp_index] = paren_level;\n\
    \            paren_levels_temp_index++;\n            paren_levels_temp_size++;\n\
    \            if (paren_levels_temp_index == paren_levels_temp.size()) {\n    \
    \            paren_levels_temp.push_back(paren_level);\n            }\n      \
    \      paren_level++;\n        }\n        else if (paren_string[i] == '(') {\n\
    \            paren_level++;\n        }\n    }\n    std::vector<long> paren_levels_temp_reversed;\n\
    \    paren_levels_temp_reversed.reserve(paren_levels_temp.size());\n    for (long\
    \ i = 0; i < paren_levels_temp.size(); i++) {\n        paren_levels_temp_reversed.push_back(paren_levels_temp[paren_levels_temp_reversed.size()\
    \ - 1 - i]);\n    }\n    return paren_levels_temp_reversed;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphwoai_as.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmphwoai_as.cpp:10:67: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                           ^~~~~\n/tmp/tmphwoai_as.cpp:12:31:\
    \ error: cannot convert \u2018std::vector<long int>\u2019 to \u2018std::vector<long\
    \ int>::size_type\u2019 {aka \u2018long unsigned int\u2019}\n   12 |     paren_levels_temp.reserve(paren_levels);\n\
    \      |                               ^~~~~~~~~~~~\n      |                 \
    \              |\n      |                               std::vector<long int>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:72,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmphwoai_as.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:67:23:\
    \ note:   initializing argument 1 of \u2018void std::vector<_Tp, _Alloc>::reserve(std::vector<_Tp,\
    \ _Alloc>::size_type) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n   67 |    \
    \ reserve(size_type __n)\n      |             ~~~~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        } else {\n            assert(current_level\
    \ == paren_level);\n            paren_levels[paren_level] = current_level;\n \
    \       }\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long level = 0;\n  for (char\
    \ c : paren_string) {\n    if (c == '(') {\n      ++level;\n    } else if (c ==\
    \ ')') {\n      --level;\n    }\n    paren_levels.push_back(level);\n  }\n  return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpch30k6bv: /tmp/tmpch30k6bv.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n          \
    \  if (paren_level_count == 0) {\n                paren_level++;\n           \
    \ }\n        }\n        paren_levels[paren_level_count] = paren_level;\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long paren_level = 0;\n  for\
    \ (auto c : paren_string) {\n    if (c == '(') {\n      paren_level++;\n    }\
    \ else if (c == ')') {\n      paren_level--;\n    }\n    paren_levels.push_back(paren_level);\n\
    \  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp5g024zh6: /tmp/tmp5g024zh6.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_open = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level = \"\";\n        } else if (c == ')') {\n \
    \           is_open = false;\n            level++;\n            paren_level +=\
    \ c;\n        } else if (is_open) {\n            level++;\n            paren_level\
    \ += c;\n        } else {\n            levels[level - 1]++;\n            paren_level\
    \ += c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n            if (paren_level == 0) {\n\
    \                paren_levels.push(paren_level);\n            }\n        }\n \
    \       level++;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa497cn22.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpa497cn22.cpp:18:30: error: \u2018class std::vector<long int>\u2019\
    \ has no member named \u2018push\u2019\n   18 |                 paren_levels.push(paren_level);\n\
    \      |                              ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        paren_char = paren_string[i];\n       \
    \ if (paren_char == '(') {\n            level++;\n        } else if (paren_char\
    \ == ')') {\n            level--;\n        }\n        if (level == 0) {\n    \
    \        levels.push_back(level);\n        }\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyt2nqcad.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpyt2nqcad.cpp:14:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   14 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpyt2nqcad.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpyt2nqcad.cpp:14:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   14\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpyt2nqcad.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    long paren_level = 0;\n\
    \    for (auto &c : paren_string) {\n        if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level == 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level > 0 && c == '(')\
    \ {\n            paren_level++;\n        } else if (paren_level > 0 && c == ')')\
    \ {\n            paren_level--;\n        } else if (paren_level == 0 && c == '(')\
    \ {\n            paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp38h9e3kg.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp38h9e3kg.cpp:71:24: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   71 |             paren_level\n      |                        ^\n \
    \     |                        ;\n   72 | }\n      | ~                       \n\
    /tmp/tmp38h9e3kg.cpp:73:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n/tmp/tmp38h9e3kg.cpp:78:1:\
    \ error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmp38h9e3kg.cpp:13:34:\
    \ note: to match this \u2018{\u2019\n   13 |     for (auto &c : paren_string)\
    \ {\n      |                                  ^\n/tmp/tmp38h9e3kg.cpp:78:1: error:\
    \ expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmp38h9e3kg.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp38h9e3kg.cpp:78:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   78 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp28vjcvhx: /tmp/tmp28vjcvhx.cpp:71: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_counter = 0;\n    bool is_first_paren\
    \ = true;\n    bool is_last_paren = true;\n    bool is_last_paren_level = true;\n\
    \    bool is_last_paren_level_counter = true;\n    long paren_level_counter_inner\
    \ = 1;\n    long paren_level_counter_outer = 1;\n    long paren_level_counter_outer_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner = 1;\n    long paren_level_counter_outer_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner = 1;\n    long\
    \ paren_level_counter_outer_inner_inner_inner_inner_inner = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n    long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbxl3envs.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpbxl3envs.cpp:30:10: error: redeclaration of \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \n   30 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbxl3envs.cpp:29:10: note: \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \ previously declared here\n   29 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbxl3envs.cpp:31:10: error: redeclaration of \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \n   31 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbxl3envs.cpp:29:10: note: \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \ previously declared here\n   29 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbxl3envs.cpp:34:10: error: redeclaration of \u2018long int paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\u2019\
    \n   34 |     long paren_level_counter_outer_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner_inner\
    \ = 1;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_parens = \"\";\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            curr_parens += c;\n        } else if\
    \ (c == ')') {\n            curr_parens = curr_parens.substr(0, curr_parens.size()\
    \ - 1);\n            level += 1;\n            levels[level - 1] += 1;\n      \
    \  } else if (c == ' ') {\n            levels[level - 1] += 1;\n        }\n  \
    \  }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp44cb11nf: /tmp/tmp44cb11nf.cpp:61: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpwgh5u6y5: /tmp/tmpwgh5u6y5.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_open = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level = c;\n        } else if (c == ')') {\n    \
    \        is_open = false;\n            levels[level] = std::max(levels[level],\
    \ level);\n            level++;\n        } else if (is_open) {\n            levels[level]\
    \ = std::max(levels[level], level);\n            level++;\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpdur4t2zf: /tmp/tmpdur4t2zf.cpp:61: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long max_level = 0;\n    long paren_level =\
    \ 0;\n    for (char c : paren_string) {\n        if (c == '(') {\n           \
    \ paren_level++;\n            if (paren_level > max_level) {\n               \
    \ max_level = paren_level;\n            }\n        } else if (c == ')') {\n  \
    \          paren_level--;\n            if (paren_level < current_level) {\n  \
    \              current_level = paren_level;\n            }\n        }\n    }\n\
    \    paren_levels.push_back(current_level);\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpk6wugv1x: /tmp/tmpk6wugv1x.cpp:31: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_level;\n\
    \    paren_level.reserve(paren_string.size());\n    long paren_level_count = 0;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \        } else if (c == ')') {\n            paren_level_count--;\n        }\n\
    \        paren_level.push_back(paren_level_count);\n    }\n    return paren_level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpe_kvgqkk: /tmp/tmpe_kvgqkk.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = \"(\";\n        } else if (c == ')') {\n\
    \            curr_level = \")\";\n        } else {\n            curr_level +=\
    \ c;\n        }\n        if (curr_level.length() == 0) {\n            levels.push_back(levels.size());\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp7pm_o55s: /tmp/tmp7pm_o55s.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpxnmchxcr: /tmp/tmpxnmchxcr.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto &c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_stack;\n    long level = 0;\n    bool is_open = false;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_stack += c;\n        } else if (c == ')') {\n   \
    \         is_open = false;\n            level++;\n            paren_stack += c;\n\
    \        } else if (is_open) {\n            level++;\n            paren_stack\
    \ += c;\n        } else {\n            levels[level - 1]++;\n        }\n    }\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp1kk64yca: /tmp/tmp1kk64yca.cpp:61: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max_count\
    \ = 1;\n    long paren_level_max_count_index = 0;\n    long paren_level_max_count_index2\
    \ = 0;\n    long paren_level_max_count_index3 = 0;\n    long paren_level_max_count_index4\
    \ = 0;\n    long paren_level_max_count_index5 = 0;\n    long paren_level_max_count_index6\
    \ = 0;\n    long paren_level_max_count_index7 = 0;\n    long paren_level_max_count_index8\
    \ = 0;\n    long paren_level_max_count_index9 = 0;\n    long paren_level_max_count_index10\
    \ = 0;\n    long paren_level_max_count_index11 = 0;\n    long paren_level_max_count_index12\
    \ = 0;\n    long paren_level_max_count_index13 = 0;\n    long paren_level_max_count_index14\
    \ = 0;\n    long paren_level_max_count_index15 = 0;\n    long paren_level_max_count_index16\
    \ = 0;\n    long paren_level_max_count_index17 = 0;\n    long paren_level_max_count_index18\
    \ = 0;\n    long paren_level_max_count_index19 = 0;\n    long paren_level_max_count_index20\
    \ = 0;\n    long paren_level_max_count_index21 = 0;\n    long paren_level_max_count_index22\
    \ = 0;\n    long paren_level_max_count_index23 = 0;\n    long paren_level_max_count_index24\
    \ = 0;\n    long paren_level_max_count_index25 = 0;\n    long paren_level_max_count_index26\
    \ = 0;\n    long paren_level_max_count_index27 = 0;\n    long paren_level_max_count_index28\
    \ = 0;\n    long paren_level_max_count_index29 = 0;\n    long paren_level_max_count_index30\
    \ = 0;\n    long paren_level_max_count_index31 = 0;\n    long paren_level_max_count_index32\
    \ = 0;\n    long paren_level_max_count_index33 = 0;\n    long paren_level_max_count_index34\
    \ = 0;\n    long paren_level_max_count_index35 = 0;\n    long paren_level_max_count_index36\
    \ = 0;\n    long paren_level_max_count_index37 = 0;\n    long paren_level_max_count_index38\
    \ = 0;\n    long paren_level_max_count_index39 = 0;\n    long paren_level_max_count_index40\
    \ = 0;\n    long paren_level_max_count_index41 = 0;\n    long paren_level_max_count_index42\
    \ = 0;\n    long paren_level_max_count_index43 = 0;\n    long paren_level_max_count_index44\
    \ = 0;\n\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpcm4d9g48: /tmp/tmpcm4d9g48.cpp:61: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        } else if (c == ' ') {\n  \
    \          paren_levels[current_level] = paren_level;\n        }\n    }\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter_max = 0;\n    long paren_level_counter_max_index\
    \ = 0;\n    long paren_level_counter_max_index2 = 0;\n    long paren_level_counter_max_index3\
    \ = 0;\n    long paren_level_counter_max_index4 = 0;\n    long paren_level_counter_max_index5\
    \ = 0;\n    long paren_level_counter_max_index6 = 0;\n    long paren_level_counter_max_index7\
    \ = 0;\n    long paren_level_counter_max_index8 = 0;\n    long paren_level_counter_max_index9\
    \ = 0;\n    long paren_level_counter_max_index10 = 0;\n    long paren_level_counter_max_index11\
    \ = 0;\n    long paren_level_counter_max_index12 = 0;\n    long paren_level_counter_max_index13\
    \ = 0;\n    long paren_level_counter_max_index14 = 0;\n    long paren_level_counter_max_index15\
    \ = 0;\n    long paren_level_counter_max_index16 = 0;\n    long paren_level_counter_max_index17\
    \ = 0;\n    long paren_level_counter_max_index18 = 0;\n    long paren_level_counter_max_index19\
    \ = 0;\n    long paren_level_counter_max_index20 = 0;\n    long paren_level_counter_max_index21\
    \ = 0;\n    long paren_level_counter_max_index22 = 0;\n    long paren_level_counter_max_index23\
    \ = 0;\n    long paren_level_counter_max_index24 = 0;\n    long paren_level_counter_max_index25\
    \ = 0;\n    long paren_level_counter_max_index26 = 0;\n    long paren_level_counter_max_index27\
    \ = 0;\n    long paren_level_counter_max_index28 = 0;\n    long paren_level_counter_max_index29\
    \ = 0;\n    long paren_level_counter_max_index30 = 0;\n    long paren_level_counter_max_index31\
    \ = 0;\n    long paren_level_counter_max_index32 = 0;\n    long paren_level_counter_max_index33\
    \ = 0;\n    long paren_level_counter_max_index34 = 0;\n    long paren_level_counter_max_index35\
    \ = 0;\n    long paren_level_counter_max_index36 = 0;\n    long paren_level_counter_max_index37\
    \ = 0;\n    long paren_level_counter_max_index38 = 0;\n    long paren_level_counter_max_index39\
    \ = 0;\n    long paren_level_counter_max_index40 = 0;\n    long paren_level_counter_max_index41\
    \ = 0;\n    long paren_level_counter_max_index42 = 0;\n    long paren_level_counter_max_index43\
    \ = 0;\n    long paren_level_counter_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmputx4lsrb.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmputx4lsrb.cpp:58:1: error: expected initializer before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmputx4lsrb.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(max_level);\n            max_level++;\n\
    \        } else if (c == ')') {\n            max_level = std::max(max_level, paren_levels[paren_levels.size()\
    \ - 1]);\n            paren_levels.erase(paren_levels.begin() + paren_levels.size()\
    \ - 1);\n        } else {\n            max_level = std::max(max_level, paren_levels[paren_levels.size()\
    \ - 1] + 1);\n        }\n    }\n    paren_levels.push_back(max_level);\n    return\
    \ paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpon2szt4b: /tmp/tmpon2szt4b.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            paren_level++;\n        } else if (c == ')') {\n      \
    \      is_open = false;\n            paren_level--;\n        } else if (is_open)\
    \ {\n            paren_level++;\n        } else {\n            paren_level--;\n\
    \        }\n        if (paren_level == level) {\n            paren_levels[paren_level\
    \ - 1]++;\n        }\n        level++;\n    }\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpzdotqpn2: /tmp/tmpzdotqpn2.cpp:34: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long level = 0;\n    long paren_level = 0;\n\
    \    long paren_level_counter = 0;\n    long paren_level_counter2 = 0;\n    long\
    \ paren_level_counter3 = 0;\n    long paren_level_counter4 = 0;\n    long paren_level_counter5\
    \ = 0;\n    long paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n\
    \    long paren_level_counter8 = 0;\n    long paren_level_counter9 = 0;\n    long\
    \ paren_level_counter10 = 0;\n    long paren_level_counter11 = 0;\n    long paren_level_counter12\
    \ = 0;\n    long paren_level_counter13 = 0;\n    long paren_level_counter14 =\
    \ 0;\n    long paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n\
    \    long paren_level_counter17 = 0;\n    long paren_level_counter18 = 0;\n  \
    \  long paren_level_counter19 = 0;\n    long paren_level_counter20 = 0;\n    long\
    \ paren_level_counter21 = 0;\n    long paren_level_counter22 = 0;\n    long paren_level_counter23\
    \ = 0;\n    long paren_level_counter24 = 0;\n    long paren_level_counter25 =\
    \ 0;\n    long paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n\
    \    long paren_level_counter28 = 0;\n    long paren_level_counter29 = 0;\n  \
    \  long paren_level_counter30 = 0;\n    long paren_level_counter31 = 0;\n    long\
    \ paren_level_counter32 = 0;\n    long paren_level_counter33 = 0;\n    long paren_level_counter34\
    \ = 0;\n    long paren_level_counter35 = 0;\n    long paren_level_counter36 =\
    \ 0;\n    long paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n\
    \    long paren_level_counter39 = 0;\n    long paren_level_counter40 = 0;\n  \
    \  long paren_level_counter41 = 0;\n    long paren_level_counter42 = 0;\n    long\
    \ paren_level_counter43 = 0;\n    long paren_level_counter44 = 0;\n    long paren_level_counter45\
    \ = 0;\n    long paren_level_counter46 = 0;\n    long paren_level_counter47 =\
    \ 0;\n    long paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n\
    \    long paren_level_counter50 = 0;\n    long paren_level_counter51 = 0;\n  \
    \  long paren_level_counter52 = 0;\n    long paren_level_counter53 = 0;\n    long\
    \ paren_level_counter54 = 0;\n    long paren_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_nfvdp17.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp_nfvdp17.cpp:68:1: error: expected initializer before \u2018}\u2019\
    \ token\n   68 | }\n      | ^\n/tmp/tmp_nfvdp17.cpp:68:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp5m2a75ws: /tmp/tmp5m2a75ws.cpp:71: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_size = 0;\n    for (size_t i\
    \ = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n\
    \            curr_level = paren_string.substr(0, i);\n            curr_level_size\
    \ = levels.size();\n            levels.push_back(curr_level_size);\n        }\
    \ else if (paren_string[i] == ')') {\n            long level_size = levels[curr_level_size];\n\
    \            long level_index = curr_level_size;\n            while (level_index\
    \ > 0) {\n                level_index--;\n                if (levels[level_index]\
    \ == level_size) {\n                    levels[level_index] = level_index + 1;\n\
    \                    break;\n                }\n            }\n            curr_level_size\
    \ = level_index;\n        } else {\n            curr_level += paren_string[i];\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp4zjqcacv: /tmp/tmp4zjqcacv.cpp:36: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    std::string paren_char;\n    std::string paren_char2;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        paren_char =\
    \ paren_string[i];\n        paren_char2 = paren_string[paren_string.size() - 1\
    \ - i];\n        if (paren_char == '(' && paren_char2 == ')') {\n            level++;\n\
    \        } else if (paren_char == '(' && paren_char2 != ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeyzivpap.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpeyzivpap.cpp:16:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   16 |         if (paren_char == '(' && paren_char2\
    \ == ')') {\n      |             ~~~~~~~~~~ ^~ ~~~\n      |             |    \
    \         |\n      |             |             char\n      |             std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpeyzivpap.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpeyzivpap.cpp:16:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   16\
    \ |         if (paren_char == '(' && paren_char2 == ')') {\n      |          \
    \                 ^~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpeyzivpap.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_tr"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    long paren_level = 0;\n\
    \    long paren_level_max = 0;\n    long paren_level_cur = 0;\n    long paren_level_cur_index\
    \ = 0;\n    long paren_level_cur_max = 0;\n    long paren_level_cur_cur = 0;\n\
    \    long paren_level_cur_cur_index = 0;\n    long paren_level_cur_cur_max = 0;\n\
    \    long paren_level_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_index = 0;\n    long paren_level_cur_cur_cur_cur_max\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_index = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_max\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_index = 0;\n    long\
    \ paren_level_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_index = 0;\n\
    \    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index = 0;\n\
    \    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_max = 0;\n    long\
    \ paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\
    \ = 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_max =\
    \ 0;\n    long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur = 0;\n\
    \    long paren_level_cur_cur_cur_cur_\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn9p3u4fc.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpn9p3u4fc.cpp:45:10: error: redeclaration of \u2018long int paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\u2019\
    \n   45 |     long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index =\
    \ 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpn9p3u4fc.cpp:42:10: note: \u2018long int paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\u2019\
    \ previously declared here\n   42 |     long paren_level_cur_cur_cur_cur_cur_cur_cur_cur_cur_cur_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpn9p3u4fc.cpp:49:1: error: expected initializer before \u2018}\u2019 token\n\
    \   49 | }\n      | ^\n/tmp/tmpn9p3u4fc.cpp:49:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + c;\n        } else if (c ==\
    \ ')') {\n            curr_level = curr_level.substr(0, curr_level.length() -\
    \ 1);\n            long level_of_nesting = curr_level.length();\n            levels.push_back(level_of_nesting);\n\
    \            curr_level = \"\";\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpfkd_tugn: /tmp/tmpfkd_tugn.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        paren_char = paren_string[i];\n       \
    \ if (paren_char == '(') {\n            level++;\n        } else if (paren_char\
    \ == ')') {\n            level--;\n        }\n        levels.push_back(level);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmphhjhu7b5.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmphhjhu7b5.cpp:14:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   14 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphhjhu7b5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmphhjhu7b5.cpp:14:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   14\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphhjhu7b5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   paren_levels.push_back(level);\n      level++;\n    } else if (c == ')') {\n\
    \      level--;\n    }\n  }\n  assert(level == 0);\n  paren_levels.push_back(level);\n\
    \  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp23hkc44m: /tmp/tmp23hkc44m.cpp:25: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter_max = 0;\n    long paren_level_counter_max_index\
    \ = 0;\n    long paren_level_counter_max_index2 = 0;\n    long paren_level_counter_max_index3\
    \ = 0;\n    long paren_level_counter_max_index4 = 0;\n    long paren_level_counter_max_index5\
    \ = 0;\n    long paren_level_counter_max_index6 = 0;\n    long paren_level_counter_max_index7\
    \ = 0;\n    long paren_level_counter_max_index8 = 0;\n    long paren_level_counter_max_index9\
    \ = 0;\n    long paren_level_counter_max_index10 = 0;\n    long paren_level_counter_max_index11\
    \ = 0;\n    long paren_level_counter_max_index12 = 0;\n    long paren_level_counter_max_index13\
    \ = 0;\n    long paren_level_counter_max_index14 = 0;\n    long paren_level_counter_max_index15\
    \ = 0;\n    long paren_level_counter_max_index16 = 0;\n    long paren_level_counter_max_index17\
    \ = 0;\n    long paren_level_counter_max_index18 = 0;\n    long paren_level_counter_max_index19\
    \ = 0;\n    long paren_level_counter_max_index20 = 0;\n    long paren_level_counter_max_index21\
    \ = 0;\n    long paren_level_counter_max_index22 = 0;\n    long paren_level_counter_max_index23\
    \ = 0;\n    long paren_level_counter_max_index24 = 0;\n    long paren_level_counter_max_index25\
    \ = 0;\n    long paren_level_counter_max_index26 = 0;\n    long paren_level_counter_max_index27\
    \ = 0;\n    long paren_level_counter_max_index28 = 0;\n    long paren_level_counter_max_index29\
    \ = 0;\n    long paren_level_counter_max_index30 = 0;\n    long paren_level_counter_max_index31\
    \ = 0;\n    long paren_level_counter_max_index32 = 0;\n    long paren_level_counter_max_index33\
    \ = 0;\n    long paren_level_counter_max_index34 = 0;\n    long paren_level_counter_max_index35\
    \ = 0;\n    long paren_level_counter_max_index36 = 0;\n    long paren_level_counter_max_index37\
    \ = 0;\n    long paren_level_counter_max_index38 = 0;\n    long paren_level_counter_max_index39\
    \ = 0;\n    long paren_level_counter_max_index40 = 0;\n    long paren_level_counter_max_index41\
    \ = 0;\n    long paren_level_counter_max_index42 = 0;\n    long paren_level_counter_max_index43\
    \ = 0;\n    long paren_level_counter_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpna2iy0jz.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpna2iy0jz.cpp:58:1: error: expected initializer before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmpna2iy0jz.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp1vk45mxk: /tmp/tmp1vk45mxk.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_size = 0;\n    for (size_t i\
    \ = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n\
    \            curr_level_size = levels.size();\n            curr_level = paren_string.substr(0,\
    \ i);\n            levels.push_back(curr_level_size);\n        } else if (paren_string[i]\
    \ == ')') {\n            long level_size = levels[curr_level_size];\n        \
    \    long level_index = curr_level_size;\n            while (level_index < levels.size()\
    \ && levels[level_index] == level_size) {\n                level_index++;\n  \
    \          }\n            levels.erase(levels.begin() + level_index);\n      \
    \      curr_level_size = levels.size();\n            curr_level = paren_string.substr(0,\
    \ i);\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_index2 = 0;\n    long paren_level_max_index3 =\
    \ 0;\n    long paren_level_max_index4 = 0;\n    long paren_level_max_index5 =\
    \ 0;\n    long paren_level_max_index6 = 0;\n    long paren_level_max_index7 =\
    \ 0;\n    long paren_level_max_index8 = 0;\n    long paren_level_max_index9 =\
    \ 0;\n    long paren_level_max_index10 = 0;\n    long paren_level_max_index11\
    \ = 0;\n    long paren_level_max_index12 = 0;\n    long paren_level_max_index13\
    \ = 0;\n    long paren_level_max_index14 = 0;\n    long paren_level_max_index15\
    \ = 0;\n    long paren_level_max_index16 = 0;\n    long paren_level_max_index17\
    \ = 0;\n    long paren_level_max_index18 = 0;\n    long paren_level_max_index19\
    \ = 0;\n    long paren_level_max_index20 = 0;\n    long paren_level_max_index21\
    \ = 0;\n    long paren_level_max_index22 = 0;\n    long paren_level_max_index23\
    \ = 0;\n    long paren_level_max_index24 = 0;\n    long paren_level_max_index25\
    \ = 0;\n    long paren_level_max_index26 = 0;\n    long paren_level_max_index27\
    \ = 0;\n    long paren_level_max_index28 = 0;\n    long paren_level_max_index29\
    \ = 0;\n    long paren_level_max_index30 = 0;\n    long paren_level_max_index31\
    \ = 0;\n    long paren_level_max_index32 = 0;\n    long paren_level_max_index33\
    \ = 0;\n    long paren_level_max_index34 = 0;\n    long paren_level_max_index35\
    \ = 0;\n    long paren_level_max_index36 = 0;\n    long paren_level_max_index37\
    \ = 0;\n    long paren_level_max_index38 = 0;\n    long paren_level_max_index39\
    \ = 0;\n    long paren_level_max_index40 = 0;\n    long paren_level_max_index41\
    \ = 0;\n    long paren_level_max_index42 = 0;\n    long paren_level_max_index43\
    \ = 0;\n    long paren_level_max_index44 = 0;\n    long paren_level_max_index45\
    \ = 0;\n    long paren_level_max_index46 = 0;\n    long paren_level_max_index47\
    \ = 0;\n    long paren_level_max_index\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvw5wri90.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpvw5wri90.cpp:62:1: error: expected initializer before \u2018}\u2019\
    \ token\n   62 | }\n      | ^\n/tmp/tmpvw5wri90.cpp:62:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels[0] = 1;\n  paren_levels[1] = 1;\n  for (size_t i = 2; i < paren_string.size();\
    \ ++i) {\n    if (paren_string[i] == '(') {\n      paren_levels[i] += 1;\n   \
    \ } else if (paren_string[i] == ')') {\n      paren_levels[i] -= 1;\n    }\n \
    \ }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_level++;\n        } else {\n            paren_level--;\n     \
    \   }\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmptq8be6rm: /tmp/tmptq8be6rm.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   for (auto &c : paren_string) {\n        if (c == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpgu40l_jq: /tmp/tmpgu40l_jq.cpp:25: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long max_level = 0;\n    long level = 0;\n    bool is_open = false;\n   \
    \ bool is_closed = false;\n    bool is_opening_paren = false;\n    bool is_closing_paren\
    \ = false;\n    for (auto c : paren_string) {\n        if (c == '(') {\n     \
    \       is_opening_paren = true;\n            level++;\n        } else if (c ==\
    \ ')') {\n            is_closing_paren = true;\n            level--;\n       \
    \ } else if (c == ' ') {\n            if (is_opening_paren) {\n              \
    \  is_opening_paren = false;\n                is_closed = true;\n            }\
    \ else if (is_closed) {\n                result.push_back(level);\n          \
    \      is_opening_paren = false;\n                is_closed = false;\n       \
    \     }\n        } else if (is_opening_paren) {\n            is_opening_paren\
    \ = false;\n            is_closed = false;\n        }\n    }\n    if (is_opening_paren)\
    \ {\n        result.push_back(level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpytykc7xh: /tmp/tmpytykc7xh.cpp:44: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ level) {\n            paren_levels.push(paren_level);\n        }\n        level++;\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpyrv12iok.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpyrv12iok.cpp:19:26: error: \u2018class std::vector<long int>\u2019\
    \ has no member named \u2018push\u2019\n   19 |             paren_levels.push(paren_level);\n\
    \      |                          ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    long paren_level_count\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   is_open = true;\n            paren_level_count++;\n        } else if (c ==\
    \ ')') {\n            is_open = false;\n            paren_level_count--;\n   \
    \     }\n        if (is_open) {\n            paren_level++;\n        }\n     \
    \   if (paren_level_count == 0) {\n            paren_level_count = paren_level;\n\
    \        }\n        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpujyddf8j: /tmp/tmpujyddf8j.cpp:33: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  long paren_level = 0;\n  for (auto c : paren_string) {\n\
    \    if (c == '(') {\n      paren_level++;\n    } else if (c == ')') {\n     \
    \ paren_level--;\n    }\n    if (paren_level == level) {\n      result.push_back(level);\n\
    \    }\n    level++;\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp2nap0mhw: /tmp/tmp2nap0mhw.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min =\
    \ 0;\n    long paren_level_count_sum = 0;\n    long paren_level_count_sum_max\
    \ = 0;\n    long paren_level_count_sum_min = 0;\n    long paren_level_count_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_max = 0;\n    long paren_level_count_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n\
    \    long paren_level_count_sum_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpt2l1gkrb.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpt2l1gkrb.cpp:41:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   41 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt2l1gkrb.cpp:38:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \ previously declared here\n   38 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt2l1gkrb.cpp:42:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \n   42 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt2l1gkrb.cpp:39:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \ previously declared here\n   39 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt2l1gkrb.cpp:43:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \n   43 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max =\
    \ 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt2l1gkrb.cpp:40:10: note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \ previously declared here\n   40 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt2l1gkrb.cpp:44:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   44 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt2l1gkrb.cpp:38:10:\
    \ note: \u2018long int paren_level_count_s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpll5jzlh7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpll5jzlh7.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpll5jzlh7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpll5jzlh7.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpll5jzlh7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpll5jzlh7.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpll5jzlh7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpll5jzlh7.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpll5jzlh7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpll5jzlh7.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpll5jzlh7.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpll5jzlh7.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpll5jzlh7.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    long level_count = 0;\n    bool is_open = false;\n \
    \   bool is_closed = false;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            is_open = true;\n            level_count++;\n       \
    \ } else if (c == ')') {\n            is_closed = true;\n            level_count--;\n\
    \        } else if (c == ' ') {\n            if (is_open && is_closed) {\n   \
    \             levels[level_count] = level;\n                is_open = false;\n\
    \                is_closed = false;\n                level_count = 0;\n      \
    \          level++;\n            }\n        } else {\n            is_open = false;\n\
    \            is_closed = false;\n        }\n    }\n    if (is_open || is_closed)\
    \ {\n        levels[level_count] = level;\n    }\n    return levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long current_paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpn5h1h1y1: /tmp/tmpn5h1h1y1.cpp:70: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        result.push_back(level);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp1tt5g6ru: /tmp/tmp1tt5g6ru.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long max_level = 0;\n    long current_paren_level\
    \ = 0;\n    long paren_level = 0;\n    long paren_level_counter = 0;\n    long\
    \ paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n    long paren_level_counter4\
    \ = 0;\n    long paren_level_counter5 = 0;\n    long paren_level_counter6 = 0;\n\
    \    long paren_level_counter7 = 0;\n    long paren_level_counter8 = 0;\n    long\
    \ paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n    long paren_level_counter11\
    \ = 0;\n    long paren_level_counter12 = 0;\n    long paren_level_counter13 =\
    \ 0;\n    long paren_level_counter14 = 0;\n    long paren_level_counter15 = 0;\n\
    \    long paren_level_counter16 = 0;\n    long paren_level_counter17 = 0;\n  \
    \  long paren_level_counter18 = 0;\n    long paren_level_counter19 = 0;\n    long\
    \ paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n    long paren_level_counter22\
    \ = 0;\n    long paren_level_counter23 = 0;\n    long paren_level_counter24 =\
    \ 0;\n    long paren_level_counter25 = 0;\n    long paren_level_counter26 = 0;\n\
    \    long paren_level_counter27 = 0;\n    long paren_level_counter28 = 0;\n  \
    \  long paren_level_counter29 = 0;\n    long paren_level_counter30 = 0;\n    long\
    \ paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n    long paren_level_counter33\
    \ = 0;\n    long paren_level_counter34 = 0;\n    long paren_level_counter35 =\
    \ 0;\n    long paren_level_counter36 = 0;\n    long paren_level_counter37 = 0;\n\
    \    long paren_level_counter38 = 0;\n    long paren_level_counter39 = 0;\n  \
    \  long paren_level_counter40 = 0;\n    long paren_level_counter41 = 0;\n    long\
    \ paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n    long paren_level_counter44\
    \ = 0;\n    long paren_level_counter45 = 0;\n    long paren_level_counter46 =\
    \ 0;\n    long paren_level_counter47 = 0;\n    long paren_level_counter48 = 0;\n\
    \    long paren_level_counter49 = 0;\n    long paren_level_counter50 = 0;\n  \
    \  long paren_level_counter51 = 0;\n    long paren_level_counter52 = 0;\n    long\
    \ paren_level_counter53 = 0;\n    long paren_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgtcxex0x.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpgtcxex0x.cpp:68:1: error: expected initializer before \u2018}\u2019\
    \ token\n   68 | }\n      | ^\n/tmp/tmpgtcxex0x.cpp:68:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpc43tyb7q: /tmp/tmpc43tyb7q.cpp:71: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpnq4suurc: /tmp/tmpnq4suurc.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level += c;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level_size = std::min(current_level_size, levels.size());\n   \
    \         levels.push_back(current_level_size);\n            current_level.clear();\n\
    \        } else {\n            current_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsbdbhtg3.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpsbdbhtg3.cpp:17:76: error: no matching function for call to \u2018\
    min(long int&, std::vector<long int>::size_type)\u2019\n   17 |             current_level_size\
    \ = std::min(current_level_size, levels.size());\n      |                    \
    \                                                        ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsbdbhtg3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsbdbhtg3.cpp:17:76:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   17 |             current_level_size = std::min(current_level_size,\
    \ levels.size());\n      |                                                   \
    \                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \          "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \  std::vector<long> paren_levels_temp;\n  paren_levels_temp.reserve(paren_levels);\n\
    \  for (long i = 0; i < paren_levels; i++) {\n    paren_levels_temp.push_back(0);\n\
    \  }\n  long paren_levels_index = 0;\n  long paren_levels_index_temp = 0;\n  long\
    \ paren_levels_index_temp2 = 0;\n  long paren_levels_index_temp3 = 0;\n  long\
    \ paren_levels_index_temp4 = 0;\n  long paren_levels_index_temp5 = 0;\n  long\
    \ paren_levels_index_temp6 = 0;\n  long paren_levels_index_temp7 = 0;\n  long\
    \ paren_levels_index_temp8 = 0;\n  long paren_levels_index_temp9 = 0;\n  long\
    \ paren_levels_index_temp10 = 0;\n  long paren_levels_index_temp11 = 0;\n  long\
    \ paren_levels_index_temp12 = 0;\n  long paren_levels_index_temp13 = 0;\n  long\
    \ paren_levels_index_temp14 = 0;\n  long paren_levels_index_temp15 = 0;\n  long\
    \ paren_levels_index_temp16 = 0;\n  long paren_levels_index_temp17 = 0;\n  long\
    \ paren_levels_index_temp18 = 0;\n  long paren_levels_index_temp19 = 0;\n  long\
    \ paren_levels_index_temp20 = 0;\n  long paren_levels_index_temp21 = 0;\n  long\
    \ paren_levels_index_temp22 = 0;\n  long paren_levels_index_temp23 = 0;\n  long\
    \ paren_levels_index_temp24 = 0;\n  long paren_levels_index_temp25 = 0;\n  long\
    \ paren_levels_index_temp26 = 0;\n  long paren_levels_index_temp27 = 0;\n  long\
    \ paren_levels_index_temp28 = 0;\n  long paren_levels_index_temp29 = 0;\n  long\
    \ paren_levels_index_temp30 = 0;\n  long paren_levels_index_temp31 = 0;\n  long\
    \ paren_levels_index_temp32 = 0;\n  long paren_levels_index_temp33 = 0;\n  long\
    \ paren_levels_index_temp34 = 0;\n  long paren_levels_index_temp35 = 0;\n  long\
    \ paren_levels_index_temp36 = 0;\n  long paren_levels_index_temp37 = 0;\n  long\
    \ paren_levels_index_temp38 = 0;\n  long paren_levels_index_temp39 = 0;\n  long\
    \ paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n  \
    \  assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpaa3zhyft.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpaa3zhyft.cpp:10:65: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                         ^~~~~\n/tmp/tmpaa3zhyft.cpp:12:29: error:\
    \ cannot convert \u2018std::vector<long int>\u2019 to \u2018std::vector<long int>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   12 |   paren_levels_temp.reserve(paren_levels);\n\
    \      |                             ^~~~~~~~~~~~\n      |                   \
    \          |\n      |                             std::vector<long int>\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:72,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpaa3zhyft.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:67:23:\
    \ note:   initializing argument 1 of \u2018void std::vector<_Tp, _Alloc>::reserve(std::vector<_Tp,\
    \ _Alloc>::size_type) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n   67 |    \
    \ reserve(size_type __n)\n      |             ~~~~~~~~~~^~~\n/tmp/tmpaa3zhyft.cpp:13:22:\
    \ error: no match for \u2018operator<\u2019 (operand types are \u2018long int\u2019\
    \ and \u2018std::vector<long int>\u2019)\n   13 |   for (long i = 0; i < paren_levels;\
    \ i++) {\n      |                    ~ ^ ~~~~~~~~~~~~\n      |               \
    \     |   |\n      |                    |   std::vector<long int>\n      |   \
    \                 long int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpaa3zhyft.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1048:5"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_level = paren_string.substr(0, i);\n            level++;\n       \
    \ } else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpngbrnzwt: /tmp/tmpngbrnzwt.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    std::string paren_char;\n\
    \    std::string paren_string_reversed;\n    std::string paren_string_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed;\n    std::string paren_string_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpctfkkbh0.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpctfkkbh0.cpp:27:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   27 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpctfkkbh0.cpp:26:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   26 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpctfkkbh0.cpp:29:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   29 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpctfkkbh0.cpp:28:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ prev"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   level++;\n    } else if (c == ')') {\n      level--;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpv05kk8v1: /tmp/tmpv05kk8v1.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long level = 0;\n  long paren_level = 0;\n  long paren_level_counter = 0;\n\
    \  for (size_t i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      paren_level++;\n      paren_level_counter++;\n    } else if\
    \ (paren_string[i] == ')') {\n      paren_level--;\n      paren_level_counter--;\n\
    \      if (paren_level == 0 && paren_level_counter == 0) {\n        paren_levels[paren_levels.size()\
    \ - 1] = level;\n      }\n    }\n    level++;\n  }\n  return paren_levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_prev = 0;\n\
    \    long paren_level_next = 0;\n    long paren_level_next_prev = 0;\n    long\
    \ paren_level_next_next_prev = 0;\n    long paren_level_next_next_next_prev =\
    \ 0;\n    long paren_level_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_prev = 0;\n    long\
    \ paren_level_next_next_next_next_next_next_next_prev = 0;\n    long paren_level_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1g08il11.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp1g08il11.cpp:24:10: error: redeclaration of \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \n   24 |     long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1g08il11.cpp:23:10: note: \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \ previously declared here\n   23 |     long paren_level_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1g08il11.cpp:27:10: error: redeclaration of \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \n   27 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1g08il11.cpp:26:10: note: \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \ previously declared here\n   26 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1g08il11.cpp:29:10: error: redeclaration of \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \n   29 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1g08il11.cpp:28:10: note: \u2018long int paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\u2019\
    \ previously declared here\n   28 |     long paren_level_next_next_next_next_next_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpqksvivef: /tmp/tmpqksvivef.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string paren_level_string;\n    std::string\
    \ paren_level_char;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n\
    \        paren_level_char = paren_string[i];\n        paren_level_string = paren_string.substr(0,\
    \ i);\n        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_not_of(paren_level_char));\n\
    \        paren_level_string = paren_level_string.substr(0, paren_level_string.find_first_of(paren_level_char));\n\
    \        paren_level_string = paren_level\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxn1p6rih.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpxn1p6rih.cpp:32:41: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   32 |         paren_level_string = paren_level\n      |           \
    \                              ^\n      |                                    \
    \     ;\n   33 | }\n      | ~                                        \n/tmp/tmpxn1p6rih.cpp:34:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   34 | int main() {\n      |            ^\n/tmp/tmpxn1p6rih.cpp:39:1: error:\
    \ expected \u2018}\u2019 at end of input\n   39 | }\n      | ^\n/tmp/tmpxn1p6rih.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpxn1p6rih.cpp:39:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   39 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    long levels_size\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   current_level += c;\n            current_level_size += 1;\n        } else\
    \ if (c == ')') {\n            current_level_size = std::min(current_level_size,\
    \ levels_size);\n            levels.push_back(current_level_size);\n         \
    \   current_level.clear();\n            levels_size -= 1;\n        } else {\n\
    \            current_level += c;\n        }\n    }\n    levels.push_back(levels_size);\n\
    \    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpq172p59f: /tmp/tmpq172p59f.cpp:31: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz_49jqki.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpz_49jqki.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpz_49jqki.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz_49jqki.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz_49jqki.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpz_49jqki.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpz_49jqki.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz_49jqki.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz_49jqki.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpz_49jqki.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpz_49jqki.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz_49jqki.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpz_49jqki.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    long level_count = 0;\n    long level_count_prev = 0;\n\
    \    long level_count_next = 0;\n    long level_count_next2 = 0;\n    long level_count_next3\
    \ = 0;\n    long level_count_next4 = 0;\n    long level_count_next5 = 0;\n   \
    \ long level_count_next6 = 0;\n    long level_count_next7 = 0;\n    long level_count_next8\
    \ = 0;\n    long level_count_next9 = 0;\n    long level_count_next10 = 0;\n  \
    \  long level_count_next11 = 0;\n    long level_count_next12 = 0;\n    long level_count_next13\
    \ = 0;\n    long level_count_next14 = 0;\n    long level_count_next15 = 0;\n \
    \   long level_count_next16 = 0;\n    long level_count_next17 = 0;\n    long level_count_next18\
    \ = 0;\n    long level_count_next19 = 0;\n    long level_count_next20 = 0;\n \
    \   long level_count_next21 = 0;\n    long level_count_next22 = 0;\n    long level_count_next23\
    \ = 0;\n    long level_count_next24 = 0;\n    long level_count_next25 = 0;\n \
    \   long level_count_next26 = 0;\n    long level_count_next27 = 0;\n    long level_count_next28\
    \ = 0;\n    long level_count_next29 = 0;\n    long level_count_next30 = 0;\n \
    \   long level_count_next31 = 0;\n    long level_count_next32 = 0;\n    long level_count_next33\
    \ = 0;\n    long level_count_next34 = 0;\n    long level_count_next35 = 0;\n \
    \   long level_count_next36 = 0;\n    long level_count_next37 = 0;\n    long level_count_next38\
    \ = 0;\n    long level_count_next39 = 0;\n    long level_count_next40 = 0;\n \
    \   long level_count_next41 = 0;\n    long level_count_next42 = 0;\n    long level_count_next43\
    \ = 0;\n    long level_count_next44 = 0;\n    long level_count_next45 = 0;\n \
    \   long level_count_next46 = 0;\n    long level_count_next47 = 0;\n    long level_count_next48\
    \ = 0;\n    long level_count_next49 = 0;\n    long level_count_next50 = 0;\n \
    \   long level_count_next51 = 0;\n    long level_count_next52 = 0;\n    long level_count_next53\
    \ = 0;\n    long level_count_next54 = 0;\n    long level_count_next55 = 0;\n \
    \   long level_count_next56 = 0;\n    long level_count_next57 = 0;\n    long level_count_next58\
    \ = 0;\n    long level_count_next59 = 0;\n    long level_count_next60 = 0;\n \
    \   long level_count_next61 = 0;\n    long level_count_next\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp90f8vg1p.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp90f8vg1p.cpp:75:1: error: expected initializer before \u2018}\u2019\
    \ token\n   75 | }\n      | ^\n/tmp/tmp90f8vg1p.cpp:75:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_index2 = 0;\n    long paren_level_max_index3 =\
    \ 0;\n    long paren_level_max_index4 = 0;\n    long paren_level_max_index5 =\
    \ 0;\n    long paren_level_max_index6 = 0;\n    long paren_level_max_index7 =\
    \ 0;\n    long paren_level_max_index8 = 0;\n    long paren_level_max_index9 =\
    \ 0;\n    long paren_level_max_index10 = 0;\n    long paren_level_max_index11\
    \ = 0;\n    long paren_level_max_index12 = 0;\n    long paren_level_max_index13\
    \ = 0;\n    long paren_level_max_index14 = 0;\n    long paren_level_max_index15\
    \ = 0;\n    long paren_level_max_index16 = 0;\n    long paren_level_max_index17\
    \ = 0;\n    long paren_level_max_index18 = 0;\n    long paren_level_max_index19\
    \ = 0;\n    long paren_level_max_index20 = 0;\n    long paren_level_max_index21\
    \ = 0;\n    long paren_level_max_index22 = 0;\n    long paren_level_max_index23\
    \ = 0;\n    long paren_level_max_index24 = 0;\n    long paren_level_max_index25\
    \ = 0;\n    long paren_level_max_index26 = 0;\n    long paren_level_max_index27\
    \ = 0;\n    long paren_level_max_index28 = 0;\n    long paren_level_max_index29\
    \ = 0;\n    long paren_level_max_index30 = 0;\n    long paren_level_max_index31\
    \ = 0;\n    long paren_level_max_index32 = 0;\n    long paren_level_max_index33\
    \ = 0;\n    long paren_level_max_index34 = 0;\n    long paren_level_max_index35\
    \ = 0;\n    long paren_level_max_index36 = 0;\n    long paren_level_max_index37\
    \ = 0;\n    long paren_level_max_index38 = 0;\n    long paren_level_max_index39\
    \ = 0;\n    long paren_level_max_index40 = 0;\n    long paren_level_max_index41\
    \ = 0;\n    long paren_level_max_index42 = 0;\n    long paren_level_max_index43\
    \ = 0;\n    long paren_level_max_index44 = 0;\n    long paren_level_max_index45\
    \ = 0;\n    long paren_level_max_index46 = 0;\n    long paren_level_max_index47\
    \ = 0;\n    long paren_level_max_index\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeviipegp.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpeviipegp.cpp:62:1: error: expected initializer before \u2018}\u2019\
    \ token\n   62 | }\n      | ^\n/tmp/tmpeviipegp.cpp:62:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp2d866vn1: /tmp/tmp2d866vn1.cpp:71: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long level = 0;\n  for (char\
    \ c : paren_string) {\n    if (c == '(') {\n      paren_levels.push_back(level);\n\
    \      level++;\n    } else if (c == ')') {\n      level--;\n    }\n  }\n  assert(paren_levels.size()\
    \ == paren_string.size());\n  return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp1m68jskc: /tmp/tmp1m68jskc.cpp:20: std::vector<long int> parse_nested_parens(std::string):\
    \ Assertion `paren_levels.size() == paren_string.size()' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level = current_level\
    \ + c;\n            current_level_size++;\n        } else if (c == ')') {\n  \
    \          current_level = current_level.substr(0, current_level.size() - 1);\n\
    \            current_level_size--;\n        } else {\n            current_level\
    \ = current_level + c;\n        }\n        if (current_level_size > 0) {\n   \
    \         levels.push_back(current_level_size);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmplrxlavd7: /tmp/tmplrxlavd7.cpp:30: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         level++;\n        } else {\n            level--;\n        }\n      \
    \  levels.push_back(level);\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpgovbj0kz: /tmp/tmpgovbj0kz.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpcptjd8d5: /tmp/tmpcptjd8d5.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ level) {\n            paren_level++;\n        }\n        level = paren_level;\n\
    \        paren_levels.push_back(paren_level);\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpx8g5b928: /tmp/tmpx8g5b928.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    bool is_open = false;\n\
    \    bool is_closed = false;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            is_open = true;\n            paren_level = c;\n     \
    \   } else if (c == ')') {\n            is_closed = true;\n            levels[level]\
    \ = std::max(levels[level], level);\n            is_open = false;\n        } else\
    \ if (is_open && is_closed) {\n            levels[level] = std::max(levels[level],\
    \ level);\n            level++;\n        }\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    long level_count = 0;\n    long level_count_max = 0;\n\
    \    std::string current_paren_string = paren_string;\n    std::string next_paren_string;\n\
    \    bool is_open = false;\n    bool is_closed = false;\n    while (!current_paren_string.empty())\
    \ {\n        if (current_paren_string[0] == '(') {\n            is_open = true;\n\
    \            next_paren_string = current_paren_string;\n        } else if (current_paren_string[0]\
    \ == ')') {\n            is_closed = true;\n            next_paren_string = current_paren_string;\n\
    \        } else if (is_open) {\n            next_paren_string = current_paren_string;\n\
    \            level_count_max++;\n            level_count = level_count_max;\n\
    \            level++;\n            current_paren_string = next_paren_string;\n\
    \            is_open = false;\n        } else if (is_closed) {\n            level_count--;\n\
    \            current_paren_string = next_paren_string;\n            is_closed\
    \ = false;\n        } else {\n            current_paren_string = next_paren_string;\n\
    \        }\n    }\n    result.push_back(level_count);\n    return result;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpxc2o9u0b: /tmp/tmpxc2o9u0b.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto &c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.length()\
    \ - 1) + \")\";\n        } else if (c == ' ') {\n            curr_level = curr_level\
    \ + \" \";\n        } else {\n            curr_level = curr_level + c;\n     \
    \   }\n        if (curr_level.find(\"(\") == std::string::npos) {\n          \
    \  levels.push_back(std::stoi(curr_level));\n        }\n    }\n    return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpeqpqlz41: /tmp/tmpeqpqlz41.cpp:29: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    long opening_paren_level = 0;\n    long closing_paren_level = 0;\n    for\
    \ (auto c : paren_string) {\n        if (c == '(') {\n            is_open = true;\n\
    \            opening_paren_level = paren_level;\n        } else if (c == ')')\
    \ {\n            is_closed = true;\n            closing_paren_level = paren_level;\n\
    \        } else if (is_open && is_closed) {\n            paren_level++;\n    \
    \    } else if (is_open) {\n            paren_level++;\n        } else if (is_closed)\
    \ {\n            paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpsh45m0bn: /tmp/tmpsh45m0bn.cpp:35: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxwc3hxms.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpxwc3hxms.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxwc3hxms.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxwc3hxms.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxwc3hxms.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxwc3hxms.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxwc3hxms.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxwc3hxms.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxwc3hxms.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxwc3hxms.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpxwc3hxms.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxwc3hxms.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxwc3hxms.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.length()\
    \ - 1) + \")\";\n        } else if (c == ' ') {\n            curr_level = curr_level.substr(0,\
    \ curr_level.length() - 1);\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n        if (curr_level.length() == 0) {\n            levels.push_back(levels.size());\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpin3cqj29: /tmp/tmpin3cqj29.cpp:29: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   ++level;\n    } else if (c == ')') {\n      --level;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp061xehz5: /tmp/tmp061xehz5.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        result.push_back(level);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpp9ziz38v: /tmp/tmpp9ziz38v.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long level = 0;\n  for (auto\
    \ c : paren_string) {\n    if (c == '(') {\n      paren_levels.push_back(level);\n\
    \      level++;\n    } else if (c == ')') {\n      level--;\n    }\n  }\n  assert(paren_levels.size()\
    \ == paren_string.size());\n  return paren_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmppa7tpm8d: /tmp/tmppa7tpm8d.cpp:20: std::vector<long int> parse_nested_parens(std::string):\
    \ Assertion `paren_levels.size() == paren_string.size()' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long max_level = 0;\n  long level = 0;\n  long level_count = 0;\n  for (char\
    \ c : paren_string) {\n    if (c == '(') {\n      level++;\n      level_count++;\n\
    \    } else if (c == ')') {\n      level--;\n      level_count--;\n      if (level\
    \ == 0 && level_count == 0) {\n        result.push_back(max_level);\n        max_level\
    \ = 0;\n        level = 0;\n        level_count = 0;\n      }\n    }\n    max_level\
    \ = max(max_level, level);\n  }\n  result.push_back(max_level);\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq34y13qv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpq34y13qv.cpp:27:17: error: \u2018max\u2019 was not declared in this\
    \ scope; did you mean \u2018std::max\u2019?\n   27 |     max_level = max(max_level,\
    \ level);\n      |                 ^~~\n      |                 std::max\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq34y13qv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3462:5:\
    \ note: \u2018std::max\u2019 declared here\n 3462 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_level = paren_string.substr(i, 1);\n            level++;\n       \
    \ } else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpn7zma9wg: /tmp/tmpn7zma9wg.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplggvc76l.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmplggvc76l.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplggvc76l.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplggvc76l.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplggvc76l.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplggvc76l.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplggvc76l.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplggvc76l.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplggvc76l.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplggvc76l.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplggvc76l.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplggvc76l.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplggvc76l.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels[0] = 1;\n  long paren_level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_levels[paren_level] =\
    \ paren_levels[paren_level] + 1;\n    } else if (paren_string[i] == ')') {\n \
    \     paren_levels[paren_level] = paren_levels[paren_level] - 1;\n      if (paren_levels[paren_level]\
    \ == 0) {\n        paren_level++;\n      }\n    }\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  std::string paren_level;\n  long level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_level = paren_string.substr(0,\
    \ i);\n      level++;\n    }\n    if (paren_string[i] == ')') {\n      level--;\n\
    \    }\n    levels[level] = levels[level] + 1;\n  }\n  return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels = paren_string.split(\" \");\n  long max_level = 0;\n  for (long\
    \ i = 0; i < paren_levels.size(); i++) {\n    if (paren_levels[i] > max_level)\
    \ {\n      max_level = paren_levels[i];\n    }\n  }\n  std::vector<long> deepest_levels;\n\
    \  deepest_levels.push_back(max_level);\n  for (long i = 1; i < paren_levels.size();\
    \ i++) {\n    if (paren_levels[i] > deepest_levels[i - 1]) {\n      deepest_levels.push_back(i);\n\
    \    }\n  }\n  return deepest_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpo0h915d_.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpo0h915d_.cpp:10:31: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |   paren_levels = paren_string.split(\" \");\n      |               \
    \                ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long level = 0;\n    long\
    \ paren_level = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n        paren_levels.push_back(paren_level);\n        level++;\n \
    \   }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpsdim21gt: /tmp/tmpsdim21gt.cpp:26: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            ++level;\n        } else if (c == ')') {\n            --level;\n\
    \        }\n        if (level == 0) {\n            result.push_back(level);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpsq_yk1z2: /tmp/tmpsq_yk1z2.cpp:25: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_levels.push_back(max_level);\n            max_level++;\n\
    \        } else if (c == ')') {\n            max_level = std::max(max_level, paren_levels[paren_levels.size()\
    \ - 1]);\n            paren_levels.pop_back();\n        } else {\n           \
    \ max_level = std::max(max_level, paren_levels[paren_levels.size() - 1] + 1);\n\
    \        }\n    }\n    paren_levels.push_back(max_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpu_ifwryb: /tmp/tmpu_ifwryb.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            paren_level = paren_string.substr(0,\
    \ i);\n            levels.push_back(1);\n        } else if (paren_string[i] ==\
    \ ')') {\n            long level_of_paren = levels[levels.size() - 1];\n     \
    \       levels[levels.size() - 1] += 1;\n            if (levels[levels.size()\
    \ - 1] > level_of_paren) {\n                levels.push_back(level_of_paren);\n\
    \            }\n        }\n    }\n    return levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp5d_v0hdk: /tmp/tmp5d_v0hdk.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> result;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   ++level;\n    } else if (c == ')') {\n      --level;\n    }\n    result.push_back(level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpj0hwws0_: /tmp/tmpj0hwws0_.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  std::string paren_level;\n  long level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_level = paren_string.substr(i,\
    \ 1);\n      level++;\n    } else if (paren_string[i] == ')') {\n      level--;\n\
    \      if (level == 0) {\n        levels.push_back(level);\n      }\n    }\n \
    \ }\n  return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpgfbp2uzi: /tmp/tmpgfbp2uzi.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  long level = 0;\n  for (auto c : paren_string) {\n    if (c == '(') {\n   \
    \   level++;\n    } else if (c == ')') {\n      level--;\n    }\n    levels.push_back(level);\n\
    \  }\n  return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpe2yomd4g: /tmp/tmpe2yomd4g.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level = current_level\
    \ + c;\n            current_level_size++;\n        } else if (c == ')') {\n  \
    \          current_level = current_level.substr(0, current_level.size() - 1);\n\
    \            current_level_size--;\n        } else {\n            current_level\
    \ = current_level + c;\n            current_level_size++;\n        }\n       \
    \ if (current_level_size == 0) {\n            levels.push_back(levels.size());\n\
    \            current_level_size = 0;\n        }\n    }\n    return levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmplfl86if8: /tmp/tmplfl86if8.cpp:32: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string paren_char;\n    std::string paren_string_reversed;\n\
    \    std::string paren_string_reversed_reversed;\n    std::string paren_string_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed;\n    std::string\
    \ paren_string_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ paren_string_reversed_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy8n5j4vp.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpy8n5j4vp.cpp:22:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   22 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpy8n5j4vp.cpp:21:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   21 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpy8n5j4vp.cpp:25:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \n   25 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpy8n5j4vp.cpp:24:17: note: \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ previously declared here\n   24 |     std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpy8n5j4vp.cpp:27:17: error: redeclaration of \u2018std::string paren_string_reversed_reversed_reversed_reversed_reversed_reversed_revers"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            current_level += c;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level_size = std::min(current_level_size, levels.size());\n   \
    \         levels.push_back(current_level_size);\n            current_level.clear();\n\
    \        } else {\n            current_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7i97qqrg.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp7i97qqrg.cpp:17:76: error: no matching function for call to \u2018\
    min(long int&, std::vector<long int>::size_type)\u2019\n   17 |             current_level_size\
    \ = std::min(current_level_size, levels.size());\n      |                    \
    \                                                        ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp7i97qqrg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp7i97qqrg.cpp:17:76:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   17 |             current_level_size = std::min(current_level_size,\
    \ levels.size());\n      |                                                   \
    \                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \          "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n       \
    \     curr_level = paren_string.substr(0, i);\n            level = 0;\n      \
    \  } else if (paren_string[i] == ')') {\n            curr_level = paren_string.substr(0,\
    \ i);\n            level = 0;\n        } else if (paren_string[i] == ' ') {\n\
    \            curr_level = paren_string.substr(0, i);\n            level = 0;\n\
    \        } else {\n            curr_level += paren_string[i];\n            level++;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpe207x6sn: /tmp/tmpe207x6sn.cpp:32: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            paren_level++;\n     \
    \       paren_level_count++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            paren_level_count--;\n        }\n        if (paren_level == 0 &&\
    \ paren_level_count == 0) {\n            paren_level_count++;\n            paren_level++;\n\
    \        }\n    }\n    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n    paren_level_count++;\n\
    \    paren_level_count--;\n    paren_level_count++;\n    paren_level_count--;\n\
    \    paren_level_count++;\n    paren_level_count--;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp5dd0d913: /tmp/tmp5dd0d913.cpp:87: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm86lm1v2.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpm86lm1v2.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm86lm1v2.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm86lm1v2.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm86lm1v2.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm86lm1v2.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm86lm1v2.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm86lm1v2.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm86lm1v2.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm86lm1v2.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm86lm1v2.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm86lm1v2.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpm86lm1v2.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpum6xfo59: /tmp/tmpum6xfo59.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     curr_level = paren_string.substr(0, i);\n            level++;\n        }\
    \ else if (paren_string[i] == ')') {\n            level--;\n            if (level\
    \ == 0) {\n                levels.push_back(level);\n            }\n        }\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpq61xeb0a: /tmp/tmpq61xeb0a.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_length = 0;\n    long\
    \ current_level_nesting = 1;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level = current_level + c;\n            current_level_length++;\n\
    \            current_level_nesting++;\n        } else if (c == ')') {\n      \
    \      current_level = current_level.substr(0, current_level_length-1);\n    \
    \        current_level_length--;\n            current_level_nesting--;\n     \
    \   } else if (c == ' ') {\n            if (current_level_nesting == 0) {\n  \
    \              levels.push_back(current_level_length);\n            }\n      \
    \      current_level = \"\";\n        } else {\n            current_level = current_level\
    \ + c;\n        }\n    }\n    if (current_level_nesting == 0) {\n        levels.push_back(current_level_length);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpwrradk5_: /tmp/tmpwrradk5_.cpp:38: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpxjipl31g: /tmp/tmpxjipl31g.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_char;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        paren_char = paren_string[i];\n       \
    \ if (paren_char == '(') {\n            level++;\n        } else if (paren_char\
    \ == ')') {\n            level--;\n        }\n        levels.push_back(level);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpb87fzvlr.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpb87fzvlr.cpp:14:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   14 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpb87fzvlr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpb87fzvlr.cpp:14:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   14\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpb87fzvlr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    for (auto c : paren_string) {\n        if\
    \ (c == '(') {\n            current_level = current_level + \"(\";\n        }\
    \ else if (c == ')') {\n            current_level = current_level.substr(0, current_level.length()\
    \ - 1) + \")\";\n        } else {\n            current_level = current_level +\
    \ c;\n        }\n        if (current_level.length() > levels.size()) {\n     \
    \       levels.resize(current_level.length());\n        }\n        levels[current_level.length()\
    \ - 1]++;\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpn3nh6r6a: /tmp/tmpn3nh6r6a.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    bool is_open = false;\n \
    \   bool is_closed = false;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            is_open = true;\n            paren_level++;\n       \
    \ } else if (c == ')') {\n            is_closed = true;\n            paren_level--;\n\
    \        } else if (is_open && is_closed) {\n            paren_levels[paren_level]\
    \ = level;\n            paren_level++;\n            is_open = false;\n       \
    \     is_closed = false;\n        } else if (is_open) {\n            paren_level++;\n\
    \        } else if (is_closed) {\n            paren_level--;\n        }\n    \
    \    level++;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    long max_level = 0;\n    bool is_open = false;\n   \
    \ for (auto c : paren_string) {\n        if (c == '(') {\n            is_open\
    \ = true;\n            level++;\n        } else if (c == ')') {\n            is_open\
    \ = false;\n            level--;\n        } else if (is_open) {\n            level++;\n\
    \        } else {\n            level--;\n        }\n        if (level > max_level)\
    \ {\n            max_level = level;\n        }\n        result.push_back(level);\n\
    \    }\n    if (max_level > 0) {\n        result.push_back(max_level);\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp0acn_szi: /tmp/tmp0acn_szi.cpp:37: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt7cihndp.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpt7cihndp.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt7cihndp.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7cihndp.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7cihndp.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt7cihndp.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt7cihndp.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7cihndp.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7cihndp.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt7cihndp.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpt7cihndp.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7cihndp.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpt7cihndp.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    std::string paren_char;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        paren_char =\
    \ paren_string[i];\n        if (paren_char == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (paren_char == ')') {\n       \
    \     paren_level_count--;\n            paren_level--;\n            if (paren_level_count\
    \ == 0) {\n                paren_level_count = paren_level;\n                paren_levels.push_back(paren_level);\n\
    \            }\n        }\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9ro4_zkn.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp9ro4_zkn.cpp:15:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   15 |         if (paren_char == '(') {\n      |   \
    \          ~~~~~~~~~~ ^~ ~~~\n      |             |             |\n      |   \
    \          |             char\n      |             std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9ro4_zkn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9ro4_zkn.cpp:15:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   15\
    \ |         if (paren_char == '(') {\n      |                           ^~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9ro4_zkn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            curr_level = curr_level + \"(\";\n        } else if (c\
    \ == ')') {\n            curr_level = curr_level.substr(0, curr_level.size() -\
    \ 1);\n            curr_level = curr_level + \")\";\n            levels.push_back(std::stoi(curr_level));\n\
    \            curr_level.clear();\n        } else {\n            curr_level = curr_level\
    \ + c;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long current_level = 0;\n  long\
    \ paren_level = 0;\n  long paren_level_count = 0;\n  for (char c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_level_count++;\n      paren_level++;\n \
    \   } else if (c == ')') {\n      paren_level_count--;\n      paren_level--;\n\
    \      if (paren_level_count == 0) {\n        paren_levels.push_back(paren_level);\n\
    \      }\n    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpiyeubijb: /tmp/tmpiyeubijb.cpp:30: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ 0 && paren_levels.size() <= level) {\n            paren_levels.push_back(level);\n\
    \        }\n        level++;\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpksz21k5n: /tmp/tmpksz21k5n.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter2 = 0;\n    long paren_level_counter3 = 0;\n\
    \    long paren_level_counter4 = 0;\n    long paren_level_counter5 = 0;\n    long\
    \ paren_level_counter6 = 0;\n    long paren_level_counter7 = 0;\n    long paren_level_counter8\
    \ = 0;\n    long paren_level_counter9 = 0;\n    long paren_level_counter10 = 0;\n\
    \    long paren_level_counter11 = 0;\n    long paren_level_counter12 = 0;\n  \
    \  long paren_level_counter13 = 0;\n    long paren_level_counter14 = 0;\n    long\
    \ paren_level_counter15 = 0;\n    long paren_level_counter16 = 0;\n    long paren_level_counter17\
    \ = 0;\n    long paren_level_counter18 = 0;\n    long paren_level_counter19 =\
    \ 0;\n    long paren_level_counter20 = 0;\n    long paren_level_counter21 = 0;\n\
    \    long paren_level_counter22 = 0;\n    long paren_level_counter23 = 0;\n  \
    \  long paren_level_counter24 = 0;\n    long paren_level_counter25 = 0;\n    long\
    \ paren_level_counter26 = 0;\n    long paren_level_counter27 = 0;\n    long paren_level_counter28\
    \ = 0;\n    long paren_level_counter29 = 0;\n    long paren_level_counter30 =\
    \ 0;\n    long paren_level_counter31 = 0;\n    long paren_level_counter32 = 0;\n\
    \    long paren_level_counter33 = 0;\n    long paren_level_counter34 = 0;\n  \
    \  long paren_level_counter35 = 0;\n    long paren_level_counter36 = 0;\n    long\
    \ paren_level_counter37 = 0;\n    long paren_level_counter38 = 0;\n    long paren_level_counter39\
    \ = 0;\n    long paren_level_counter40 = 0;\n    long paren_level_counter41 =\
    \ 0;\n    long paren_level_counter42 = 0;\n    long paren_level_counter43 = 0;\n\
    \    long paren_level_counter44 = 0;\n    long paren_level_counter45 = 0;\n  \
    \  long paren_level_counter46 = 0;\n    long paren_level_counter47 = 0;\n    long\
    \ paren_level_counter48 = 0;\n    long paren_level_counter49 = 0;\n    long paren_level_counter50\
    \ = 0;\n    long paren_level_counter51 = 0;\n    long paren_level_counter52 =\
    \ 0;\n    long paren_level_counter53 = 0;\n    long paren_level_counter54 = 0;\n\
    \    long paren_level_counter55 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmprc4yian9: /tmp/tmprc4yian9.cpp:71: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            curr_level = curr_level + c;\n     \
    \       level++;\n        } else if (c == ')') {\n            curr_level = curr_level.substr(0,\
    \ curr_level.size() - 1);\n            level--;\n            levels[level] = levels[level]\
    \ + 1;\n        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_stack;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n       \
    \     paren_stack.push_back(paren_string[i]);\n        } else if (paren_string[i]\
    \ == ')') {\n            long level_of_nesting = level;\n            while (level_of_nesting\
    \ > 0) {\n                level_of_nesting -= 1;\n                level += 1;\n\
    \            }\n            level -= 1;\n            levels.push_back(level);\n\
    \            paren_stack.pop_back();\n        } else {\n            assert(paren_string[i]\
    \ == ' ');\n        }\n    }\n    assert(paren_stack.size() == 0);\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpuyonehol: /tmp/tmpuyonehol.cpp:33: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ level) {\n            paren_levels[paren_levels.size() - 1]++;\n        } else\
    \ {\n            paren_levels.push_back(1);\n        }\n        level++;\n   \
    \ }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpecxlrq7s: /tmp/tmpecxlrq7s.cpp:29: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_level;\n\
    \    long current_level = 0;\n    long paren_level_count = 0;\n    for (auto c\
    \ : paren_string) {\n        if (c == '(') {\n            current_level++;\n \
    \           paren_level_count++;\n        } else if (c == ')') {\n           \
    \ current_level--;\n            paren_level_count--;\n        }\n        if (current_level\
    \ == 0 && paren_level_count == 0) {\n            paren_level.push_back(current_level);\n\
    \        }\n    }\n    return paren_level;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpz5m8uax3: /tmp/tmpz5m8uax3.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpl2r6g13b: /tmp/tmpl2r6g13b.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level = std::to_string(level);\n\
    \            level++;\n        } else if (c == ')') {\n            level--;\n\
    \            levels[level] = std::stoi(paren_level);\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n            current_level\
    \ = paren_level;\n        } else if (c == ')') {\n            paren_level--;\n\
    \            current_level = paren_level;\n        } else {\n            paren_levels[paren_level]\
    \ = current_level;\n        }\n    }\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpvg9k686z: /tmp/tmpvg9k686z.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpg2efclk0: /tmp/tmpg2efclk0.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ 0 && paren_levels.size() <= level) {\n            paren_levels.push_back(level);\n\
    \        }\n        level++;\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp8wxkcg6p: /tmp/tmp8wxkcg6p.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string current_paren_string = \"\";\n   \
    \ for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level++;\n\
    \            current_paren_string = current_paren_string + c;\n        } else\
    \ if (c == ')') {\n            paren_level--;\n            current_paren_string\
    \ = current_paren_string + c;\n        } else {\n            current_paren_string\
    \ = current_paren_string + c;\n        }\n        if (paren_level == 0 && current_paren_string\
    \ == \"\") {\n            paren_level = 1;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpmeoi7hb3: /tmp/tmpmeoi7hb3.cpp:31: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  long level = 0;\n  for (size_t i = 0; i < paren_string.size(); ++i) {\n   \
    \ if (paren_string[i] == '(') {\n      ++level;\n    } else if (paren_string[i]\
    \ == ')') {\n      --level;\n    }\n    if (level == 0) levels.push_back(level);\n\
    \  }\n  return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpahx4ultx: /tmp/tmpahx4ultx.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 0;\n    long level_size\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   level_size++;\n            current_level = current_level + c;\n          \
    \  current_level_size = std::max(current_level_size, level_size);\n        } else\
    \ if (c == ')') {\n            level_size--;\n            current_level = current_level.substr(0,\
    \ current_level.size() - 1);\n            current_level_size = std::max(current_level_size,\
    \ level_size);\n        } else {\n            current_level = current_level +\
    \ c;\n        }\n    }\n    levels.push_back(current_level_size);\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpf851ggts: /tmp/tmpf851ggts.cpp:31: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        char c = paren_string[i];\n        if (c\
    \ == '(') {\n            curr_level = curr_level + c;\n        } else if (c ==\
    \ ')') {\n            levels[level++] = std::stoi(curr_level);\n            curr_level.clear();\n\
    \        } else {\n            curr_level += c;\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            current_level++;\n        } else if (c == ')') {\n  \
    \          current_level--;\n        }\n        paren_levels.push_back(current_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpylzuctf7: /tmp/tmpylzuctf7.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n\
    \    long level = 0;\n    bool is_open = false;\n    bool is_closed = false;\n\
    \    std::string token;\n    std::string temp_token;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            temp_token\
    \ = \"\";\n        } else if (c == ')') {\n            is_open = false;\n    \
    \        temp_token = temp_token.substr(0, temp_token.size() - 1);\n         \
    \   result.push_back(level);\n        } else if (is_open) {\n            temp_token\
    \ += c;\n        } else if (temp_token.size() > 0) {\n            temp_token +=\
    \ c;\n        } else {\n            temp_token = \"\";\n        }\n    }\n   \
    \ if (temp_token.size() > 0) {\n        result.push_back(level);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmplig5no2t: /tmp/tmplig5no2t.cpp:38: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_level = 0;\n    long paren_level_counter\
    \ = 0;\n    long paren_level_counter_max = 0;\n    long paren_level_counter_max_index\
    \ = 0;\n    long paren_level_counter_max_index2 = 0;\n    long paren_level_counter_max_index3\
    \ = 0;\n    long paren_level_counter_max_index4 = 0;\n    long paren_level_counter_max_index5\
    \ = 0;\n    long paren_level_counter_max_index6 = 0;\n    long paren_level_counter_max_index7\
    \ = 0;\n    long paren_level_counter_max_index8 = 0;\n    long paren_level_counter_max_index9\
    \ = 0;\n    long paren_level_counter_max_index10 = 0;\n    long paren_level_counter_max_index11\
    \ = 0;\n    long paren_level_counter_max_index12 = 0;\n    long paren_level_counter_max_index13\
    \ = 0;\n    long paren_level_counter_max_index14 = 0;\n    long paren_level_counter_max_index15\
    \ = 0;\n    long paren_level_counter_max_index16 = 0;\n    long paren_level_counter_max_index17\
    \ = 0;\n    long paren_level_counter_max_index18 = 0;\n    long paren_level_counter_max_index19\
    \ = 0;\n    long paren_level_counter_max_index20 = 0;\n    long paren_level_counter_max_index21\
    \ = 0;\n    long paren_level_counter_max_index22 = 0;\n    long paren_level_counter_max_index23\
    \ = 0;\n    long paren_level_counter_max_index24 = 0;\n    long paren_level_counter_max_index25\
    \ = 0;\n    long paren_level_counter_max_index26 = 0;\n    long paren_level_counter_max_index27\
    \ = 0;\n    long paren_level_counter_max_index28 = 0;\n    long paren_level_counter_max_index29\
    \ = 0;\n    long paren_level_counter_max_index30 = 0;\n    long paren_level_counter_max_index31\
    \ = 0;\n    long paren_level_counter_max_index32 = 0;\n    long paren_level_counter_max_index33\
    \ = 0;\n    long paren_level_counter_max_index34 = 0;\n    long paren_level_counter_max_index35\
    \ = 0;\n    long paren_level_counter_max_index36 = 0;\n    long paren_level_counter_max_index37\
    \ = 0;\n    long paren_level_counter_max_index38 = 0;\n    long paren_level_counter_max_index39\
    \ = 0;\n    long paren_level_counter_max_index40 = 0;\n    long paren_level_counter_max_index41\
    \ = 0;\n    long paren_level_counter_max_index42 = 0;\n    long paren_level_counter_max_index43\
    \ = 0;\n    long paren_level_\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppzii5nyg.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmppzii5nyg.cpp:58:1: error: expected initializer before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmppzii5nyg.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string paren_level;\n    long level = 0;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     level++;\n            paren_level = paren_level + paren_string[i];\n   \
    \     } else if (paren_string[i] == ')') {\n            level--;\n           \
    \ paren_level = paren_level.substr(0, paren_level.size()-1);\n            levels[level]\
    \ = levels[level] + 1;\n        }\n    }\n    return levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_level++;\n        } else if (c\
    \ == ')') {\n            paren_level--;\n        }\n        if (paren_level ==\
    \ 0 && paren_levels.size() <= level) {\n            paren_levels.push_back(level);\n\
    \        }\n        level++;\n    }\n    return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpruvis382: /tmp/tmpruvis382.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n        } else if (c\
    \ == ')') {\n            is_open = false;\n        } else if (is_open) {\n   \
    \         paren_levels.push_back(level);\n            level++;\n        }\n  \
    \  }\n    paren_levels.push_back(level);\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmphpf0nml1: /tmp/tmphpf0nml1.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   bool is_open = false;\n    for (char c : paren_string) {\n        if (c ==\
    \ '(') {\n            is_open = true;\n            paren_levels.push_back(paren_level);\n\
    \        } else if (c == ')') {\n            is_open = false;\n            paren_levels.pop_back();\n\
    \        } else if (is_open) {\n            paren_level++;\n        }\n    }\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpn8lp5e2z: /tmp/tmpn8lp5e2z.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5ed9fo2g.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp5ed9fo2g.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5ed9fo2g.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ed9fo2g.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ed9fo2g.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5ed9fo2g.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5ed9fo2g.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ed9fo2g.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ed9fo2g.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5ed9fo2g.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5ed9fo2g.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ed9fo2g.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5ed9fo2g.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 1;\n    long paren_level = 0;\n    for (size_t i = 0; i\
    \ < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       paren_level++;\n        } else if (paren_string[i] == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels[paren_level] = paren_levels[paren_level]\
    \ + 1;\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_level;\n\
    \    long paren_level_count = 0;\n    long paren_level_max = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_count_index\
    \ = 0;\n    long paren_level_max_count_index2 = 0;\n    long paren_level_max_count_index3\
    \ = 0;\n    long paren_level_max_count_index4 = 0;\n    long paren_level_max_count_index5\
    \ = 0;\n    long paren_level_max_count_index6 = 0;\n    long paren_level_max_count_index7\
    \ = 0;\n    long paren_level_max_count_index8 = 0;\n    long paren_level_max_count_index9\
    \ = 0;\n    long paren_level_max_count_index10 = 0;\n    long paren_level_max_count_index11\
    \ = 0;\n    long paren_level_max_count_index12 = 0;\n    long paren_level_max_count_index13\
    \ = 0;\n    long paren_level_max_count_index14 = 0;\n    long paren_level_max_count_index15\
    \ = 0;\n    long paren_level_max_count_index16 = 0;\n    long paren_level_max_count_index17\
    \ = 0;\n    long paren_level_max_count_index18 = 0;\n    long paren_level_max_count_index19\
    \ = 0;\n    long paren_level_max_count_index20 = 0;\n    long paren_level_max_count_index21\
    \ = 0;\n    long paren_level_max_count_index22 = 0;\n    long paren_level_max_count_index23\
    \ = 0;\n    long paren_level_max_count_index24 = 0;\n    long paren_level_max_count_index25\
    \ = 0;\n    long paren_level_max_count_index26 = 0;\n    long paren_level_max_count_index27\
    \ = 0;\n    long paren_level_max_count_index28 = 0;\n    long paren_level_max_count_index29\
    \ = 0;\n    long paren_level_max_count_index30 = 0;\n    long paren_level_max_count_index31\
    \ = 0;\n    long paren_level_max_count_index32 = 0;\n    long paren_level_max_count_index33\
    \ = 0;\n    long paren_level_max_count_index34 = 0;\n    long paren_level_max_count_index35\
    \ = 0;\n    long paren_level_max_count_index36 = 0;\n    long paren_level_max_count_index37\
    \ = 0;\n    long paren_level_max_count_index38 = 0;\n    long paren_level_max_count_index39\
    \ = 0;\n    long paren_level_max_count_index40 = 0;\n    long paren_level_max_count_index41\
    \ = 0;\n    long paren_level_max_count_index42 = 0;\n    long paren_level_max_count_index43\
    \ = 0;\n    long \n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp12n2ey34.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp12n2ey34.cpp:58:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   58 | }\n      | ^\n/tmp/tmp12n2ey34.cpp:58:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   for (char c : paren_string) {\n        if (c == '(') {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level--;\n\
    \        }\n    }\n    paren_levels.push_back(paren_level);\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp4x785dtb: /tmp/tmp4x785dtb.cpp:25: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels = paren_string.substr(0, paren_string.find('(')).split(' ').size();\n\
    \    std::vector<long> paren_levels_temp;\n    paren_levels_temp.push_back(paren_levels);\n\
    \    long paren_levels_sum = 0;\n    long paren_levels_sum2 = 0;\n    long paren_levels_sum3\
    \ = 0;\n    long paren_levels_sum4 = 0;\n    long paren_levels_sum5 = 0;\n   \
    \ long paren_levels_sum6 = 0;\n    long paren_levels_sum7 = 0;\n    long paren_levels_sum8\
    \ = 0;\n    long paren_levels_sum9 = 0;\n    long paren_levels_sum10 = 0;\n  \
    \  long paren_levels_sum11 = 0;\n    long paren_levels_sum12 = 0;\n    long paren_levels_sum13\
    \ = 0;\n    long paren_levels_sum14 = 0;\n    long paren_levels_sum15 = 0;\n \
    \   long paren_levels_sum16 = 0;\n    long paren_levels_sum17 = 0;\n    long paren_levels_sum18\
    \ = 0;\n    long paren_levels_sum19 = 0;\n    long paren_levels_sum20 = 0;\n \
    \   long paren_levels_sum21 = 0;\n    long paren_levels_sum22 = 0;\n    long paren_levels_sum23\
    \ = 0;\n    long paren_levels_sum24 = 0;\n    long paren_levels_sum25 = 0;\n \
    \   long paren_levels_sum26 = 0;\n    long paren_levels_sum27 = 0;\n    long paren_levels_sum28\
    \ = 0;\n    long paren_levels_sum29 = 0;\n    long paren_levels_sum30 = 0;\n \
    \   long paren_levels_sum31 = 0;\n    long paren_levels_sum32 = 0;\n    long paren_levels_sum33\
    \ = 0;\n    long paren_levels_sum34 = 0;\n    long paren_levels_sum35 = 0;\n \
    \   long paren_levels_sum36 = 0;\n    long paren_levels_sum37 = 0;\n    long paren_levels_sum38\
    \ = 0;\n    long paren_levels_sum39 = 0;\n    long paren_levels_sum40 = 0;\n \
    \   long paren_levels_sum41 = 0;\n    long paren_levels_sum42 = 0;\n    long paren_levels_sum43\
    \ = 0;\n    long paren_levels_sum44 = 0;\n    long paren_levels_sum45 = 0;\n \
    \   long paren_levels_sum46 = 0;\n    long paren\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpscikaafv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpscikaafv.cpp:10:67: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |     paren_levels = paren_string.substr(0,\
    \ paren_string.find('(')).split(' ').size();\n      |                        \
    \                                           ^~~~~\n/tmp/tmpscikaafv.cpp:12:45:\
    \ error: no matching function for call to \u2018std::vector<long int>::push_back(std::vector<long\
    \ int>&)\u2019\n   12 |     paren_levels_temp.push_back(paren_levels);\n     \
    \ |                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpscikaafv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018const value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |\
    \       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<l"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp1hl9e2s_: /tmp/tmp1hl9e2s_.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  long current_level = 0;\n  for\
    \ (size_t i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i] == '(')\
    \ {\n      current_level++;\n    } else if (paren_string[i] == ')') {\n      current_level--;\n\
    \    }\n    paren_levels.push_back(current_level);\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmppkeamcke: /tmp/tmppkeamcke.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string current_level;\n    long current_level_size = 1;\n    long current_level_nesting\
    \ = 1;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   current_level = current_level + c;\n            current_level_nesting++;\n\
    \            current_level_size += 1;\n        } else if (c == ')') {\n      \
    \      current_level = current_level.substr(0, current_level.size() - 1);\n  \
    \          current_level_nesting--;\n            current_level_size -= 1;\n  \
    \      } else {\n            current_level = current_level + c;\n        }\n \
    \       if (current_level_nesting == 0) {\n            levels.push_back(current_level_size);\n\
    \            current_level_size = 1;\n            current_level_nesting = 1;\n\
    \        }\n    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpc81q8z7s: /tmp/tmpc81q8z7s.cpp:35: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels[0] = 0;\n    long paren_level = 0;\n    long paren_level_count\
    \ = 0;\n    long paren_level_max = 0;\n    long paren_level_max_count = 0;\n \
    \   for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level;\n            }\n        }\n        if (paren_level_count > paren_level_max_count)\
    \ {\n            paren_level_max_count = paren_level_count;\n            paren_level_max_count\
    \ = paren_level_max;\n        }\n    }\n    paren_level_count = paren_level_max_count;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level;\n            }\n        }\n        if (paren_level_count > paren_level_max_count)\
    \ {\n            paren_level_max_count = paren_level_count;\n            paren_level_max_count\
    \ = paren_level_max;\n        }\n    }\n    paren_level_count = paren_level_max_count;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level;\n            }\n        }\n        if (paren_level_count > paren_level_max_count)\
    \ {\n            paren_level_max_count = paren_level_count;\n            paren_level_max_count\
    \ = paren_level_max;\n        }\n    }\n    paren_level_count = paren_level_max_count;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            paren_level_count++;\n\
    \            paren_level++;\n        } else if (c == ')') {\n            paren_level_count--;\n\
    \            paren_level--;\n            if (paren_level_count == 0) {\n     \
    \           paren_level_count = paren_level_max;\n                paren_level_max\
    \ = paren_level\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp1vk5p_a7.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp1vk5p_a7.cpp:78:46: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   78 |                 paren_level_max = paren_level\n      |      \
    \                                        ^\n      |                          \
    \                    ;\n   79 | }\n      | ~                                 \
    \            \n/tmp/tmp1vk5p_a7.cpp:80:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n   80 | int main() {\n      |     \
    \       ^\n/tmp/tmp1vk5p_a7.cpp:85:1: error: expected \u2018}\u2019 at end of\
    \ input\n   85 | }\n      | ^\n/tmp/tmp1vk5p_a7.cpp:73:30: note: to match this\
    \ \u2018{\u2019\n   73 |         } else if (c == ')') {\n      |             \
    \                 ^\n/tmp/tmp1vk5p_a7.cpp:85:1: error: expected \u2018}\u2019\
    \ at end of input\n   85 | }\n      | ^\n/tmp/tmp1vk5p_a7.cpp:69:33: note: to\
    \ match this \u2018{\u2019\n   69 |     for (auto c : paren_string) {\n      |\
    \                                 ^\n/tmp/tmp1vk5p_a7.cpp:85:1: error: expected\
    \ \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmp1vk5p_a7.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp1vk5p_a7.cpp:85:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   85 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long paren_level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpa_8z0pwr: /tmp/tmpa_8z0pwr.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long current_level = 0;\n    long paren_count = 0;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_count++;\n            current_level++;\n\
    \        } else if (c == ')') {\n            paren_count--;\n            current_level--;\n\
    \        }\n        if (current_level > paren_levels.size()) {\n            paren_levels.resize(current_level);\n\
    \        }\n        paren_levels[current_level] = std::max(paren_levels[current_level],\
    \ paren_count);\n    }\n    return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp8x35bnly: /tmp/tmp8x35bnly.cpp:29: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels = paren_string.split(\" \");\n    std::vector<long> paren_levels_temp;\n\
    \    paren_levels_temp.push_back(1);\n    long max_level = 1;\n    for (long i\
    \ = 0; i < paren_levels.size(); i++) {\n        long current_level = paren_levels[i];\n\
    \        if (current_level > max_level) {\n            max_level = current_level;\n\
    \        }\n    }\n    for (long i = 0; i < paren_levels.size(); i++) {\n    \
    \    long current_level = paren_levels[i];\n        if (current_level > max_level)\
    \ {\n            paren_levels[i] = max_level;\n        }\n    }\n    return paren_levels_temp;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0euzeoxm.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp0euzeoxm.cpp:10:33: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018split\u2019\
    \n   10 |     paren_levels = paren_string.split(\" \");\n      |             \
    \                    ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    for (char c : paren_string) {\n        if (c == '(')\
    \ {\n            level++;\n        } else if (c == ')') {\n            level--;\n\
    \        }\n        levels.push_back(level);\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmpr7415cor: /tmp/tmpr7415cor.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            paren_level++;\n        } else if (c == ')') {\n       \
    \     paren_level--;\n        }\n        paren_levels.push_back(paren_level);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpcp5d1lve: /tmp/tmpcp5d1lve.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    long paren_level = 0;\n    long paren_level_count =\
    \ 0;\n    long paren_level_count_max = 0;\n    long paren_level_count_min = 0;\n\
    \    long paren_level_count_sum = 0;\n    long paren_level_count_sum_max = 0;\n\
    \    long paren_level_count_sum_min = 0;\n    long paren_level_count_sum_sum =\
    \ 0;\n    long paren_level_count_sum_sum_max = 0;\n    long paren_level_count_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n    long\
    \ paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \    long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max = 0;\n   \
    \ long paren_level_count_sum_sum_sum_sum_\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"() (()) ((()))\
    \ (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp12rgugx3.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp12rgugx3.cpp:41:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   41 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp12rgugx3.cpp:38:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \ previously declared here\n   38 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp12rgugx3.cpp:42:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \n   42 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp12rgugx3.cpp:39:10:\
    \ note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\u2019\
    \ previously declared here\n   39 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp12rgugx3.cpp:43:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \n   43 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max =\
    \ 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp12rgugx3.cpp:40:10: note: \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\u2019\
    \ previously declared here\n   40 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_sum_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp12rgugx3.cpp:44:10: error: redeclaration of \u2018long int paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min\u2019\
    \n   44 |     long paren_level_count_sum_sum_sum_sum_sum_sum_sum_sum_min = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp12rgugx3.cpp:38:10:\
    \ note: \u2018long int paren_level_count_s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long level = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            paren_levels.push_back(level);\n            level++;\n      \
    \  } else if (c == ')') {\n            level--;\n        }\n    }\n    paren_levels.push_back(level);\n\
    \    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpbm8evysy: /tmp/tmpbm8evysy.cpp:24: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    paren_levels.reserve(paren_string.size());\n    long paren_level = 0;\n \
    \   bool is_open = false;\n    for (auto c : paren_string) {\n        if (c ==\
    \ '(') {\n            is_open = true;\n        } else if (c == ')') {\n      \
    \      is_open = false;\n        } else if (is_open) {\n            paren_levels.push_back(paren_level);\n\
    \            paren_level++;\n        }\n    }\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmp7iiufose: /tmp/tmp7iiufose.cpp:27: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  long paren_level = 0;\n  for (char c : paren_string) {\n    if (c == '(') {\n\
    \      paren_level++;\n    } else if (c == ')') {\n      paren_level--;\n    }\n\
    \    paren_levels.push_back(paren_level);\n  }\n  return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmps8etooko: /tmp/tmps8etooko.cpp:23: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    long paren_level_count = 0;\n    long paren_level_max\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count =\
    \ 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n\
    \    long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n  \
    \  long paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long\
    \ paren_level_max_index = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index\
    \ = 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index =\
    \ 0;\n    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n\
    \    long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n  \
    \  long paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long\
    \ paren_level_max_count = 0;\n    long paren_level_max_index = 0;\n    long paren_level_max_count\
    \ = 0;\n    long paren_level_max_index = 0;\n    long paren_\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1zpiurhw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp1zpiurhw.cpp:15:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   15 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1zpiurhw.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1zpiurhw.cpp:16:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   16 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1zpiurhw.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1zpiurhw.cpp:17:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   17 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1zpiurhw.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1zpiurhw.cpp:18:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   18 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1zpiurhw.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previously declared here\n   14 |\
    \     long paren_level_max_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1zpiurhw.cpp:19:10: error: redeclaration of \u2018long int paren_level_max_count\u2019\
    \n   19 |     long paren_level_max_count = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp1zpiurhw.cpp:13:10: note: \u2018long int paren_level_max_count\u2019 previously\
    \ declared here\n   13 |     long paren_level_max_count = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1zpiurhw.cpp:20:10: error: redeclaration of\
    \ \u2018long int paren_level_max_index\u2019\n   20 |     long paren_level_max_index\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp1zpiurhw.cpp:14:10: note:\
    \ \u2018long int paren_level_max_index\u2019 previo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> paren_levels;\n\
    \  paren_levels.reserve(paren_string.size());\n  for (auto &c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_levels.push_back(0);\n    } else if (c ==\
    \ ')') {\n      assert(paren_levels.back() > 0);\n      paren_levels.back()--;\n\
    \    } else {\n      assert(paren_levels.back() == 0);\n      paren_levels.back()++;\n\
    \    }\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmpk0wu8r9x: /tmp/tmpk0wu8r9x.cpp:15: std::vector<long int> parse_nested_parens(std::string):\
    \ Assertion `paren_levels.back() > 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    std::string curr_level;\n    long curr_level_size = 1;\n    for (auto c :\
    \ paren_string) {\n        if (c == '(') {\n            curr_level.push_back(c);\n\
    \            curr_level_size += 1;\n        } else if (c == ')') {\n         \
    \   curr_level.pop_back();\n            curr_level_size -= 1;\n            if\
    \ (curr_level_size == 0) {\n                levels.push_back(curr_level.size());\n\
    \                curr_level_size = 1;\n            }\n        }\n    }\n    return\
    \ levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "tmppui5sts2: /tmp/tmppui5sts2.cpp:29: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n  std::vector<long> levels;\n\
    \  std::string paren_level;\n  long level = 0;\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      paren_level = paren_string.substr(0,\
    \ i);\n      level++;\n    } else if (paren_string[i] == ')') {\n      level--;\n\
    \      levels[level] = levels[level] + 1;\n    }\n  }\n  return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> levels;\n\
    \    long level = 0;\n    bool is_open = false;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            is_open = true;\n            level++;\n\
    \        } else if (c == ')') {\n            is_open = false;\n            level--;\n\
    \        } else if (is_open) {\n            level++;\n        }\n        levels.push_back(level);\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({2,\
    \ 3, 1, 3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({1,\
    \ 2, 3, 4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({4})));\n\
    }\n"
  stdout: ''
  stderr: "tmp1ba_ui53: /tmp/tmp1ba_ui53.cpp:28: int main(): Assertion `candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long>\
    \ parse_nested_parens(std::string paren_string) {\n    std::vector<long> paren_levels;\n\
    \    long paren_level = 0;\n    std::string curr_paren_string = paren_string;\n\
    \    std::string curr_paren_level = \"\";\n    long paren_level_count = 0;\n \
    \   long paren_level_count_max = 0;\n    long paren_level_count_max_index = 0;\n\
    \    long paren_level_count_min = 0;\n    long paren_level_count_min_index = 0;\n\
    \    long paren_level_count_sum = 0;\n    long paren_level_count_sum_index = 0;\n\
    \    long paren_level_count_sum2 = 0;\n    long paren_level_count_sum2_index =\
    \ 0;\n    long paren_level_count_sum3 = 0;\n    long paren_level_count_sum3_index\
    \ = 0;\n    long paren_level_count_sum4 = 0;\n    long paren_level_count_sum4_index\
    \ = 0;\n    long paren_level_count_sum5 = 0;\n    long paren_level_count_sum5_index\
    \ = 0;\n    long paren_level_count_sum6 = 0;\n    long paren_level_count_sum6_index\
    \ = 0;\n    long paren_level_count_sum7 = 0;\n    long paren_level_count_sum7_index\
    \ = 0;\n    long paren_level_count_sum8 = 0;\n    long paren_level_count_sum8_index\
    \ = 0;\n    long paren_level_count_sum9 = 0;\n    long paren_level_count_sum9_index\
    \ = 0;\n    long paren_level_count_sum10 = 0;\n    long paren_level_count_sum10_index\
    \ = 0;\n    long paren_level_count_sum11 = 0;\n    long paren_level_count_sum11_index\
    \ = 0;\n    long paren_level_count_sum12 = 0;\n    long paren_level_count_sum12_index\
    \ = 0;\n    long paren_level_count_sum13 = 0;\n    long paren_level_count_sum13_index\
    \ = 0;\n    long paren_level_count_sum14 = 0;\n    long paren_level_count_sum14_index\
    \ = 0;\n    long paren_level_count_sum15 = 0;\n    long paren_level_count_sum15_index\
    \ = 0;\n    long paren_level_count_sum16 = 0;\n    long paren_level_count_sum16_index\
    \ = 0;\n    long paren_level_count_sum17 = 0;\n    long paren_level_count_sum17_index\
    \ = 0;\n    long paren_level_count_sum18 = 0;\n    long paren_level_count_sum18_index\
    \ = 0;\n    long paren_level_count_sum19 = 0;\n    long paren_level_count_sum19_index\
    \ = 0;\n    long paren_level_count_sum20 = 0;\n    long paren_level_count_sum20_index\
    \ = 0;\n    long paren_level_count_sum21 = 0;\n    long paren_level_count_sum21\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({2, 3, 1, 3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({4})));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx2_928zv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpx2_928zv.cpp:60:1: error: expected initializer before \u2018}\u2019\
    \ token\n   60 | }\n      | ^\n/tmp/tmpx2_928zv.cpp:60:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
