language: cpp
name: HumanEval_132_is_nested
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(flag && string[i] == ']') {\n            flag =\
    \ false;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpazyc7xgz: /tmp/tmpazyc7xgz.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int i = 0;\n    int j = 0;\n    int k =\
    \ 0;\n    int l = 0;\n    int count = 0;\n    int flag = 0;\n    while(i < string.length()){\n\
    \        if(string[i] == '['){\n            count++;\n        }\n        else\
    \ if(string[i] == ']'){\n            count--;\n        }\n        i++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(j < string.length()){\n\
    \        if(string[j] == '['){\n            count++;\n        }\n        else\
    \ if(string[j] == ']'){\n            count--;\n        }\n        j++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp6037iefs.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp6037iefs.cpp:130:18: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n  130 |             count\n      |                  ^\n      |      \
    \            ;\n  131 | }\n      | ~                 \n/tmp/tmp6037iefs.cpp:132:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  132 | int main() {\n      |            ^\n/tmp/tmp6037iefs.cpp:148:1: error:\
    \ expected \u2018}\u2019 at end of input\n  148 | }\n      | ^\n/tmp/tmp6037iefs.cpp:128:31:\
    \ note: to match this \u2018{\u2019\n  128 |     while(k < string.length()){\n\
    \      |                               ^\n/tmp/tmp6037iefs.cpp:148:1: error: expected\
    \ \u2018}\u2019 at end of input\n  148 | }\n      | ^\n/tmp/tmp6037iefs.cpp:12:36:\
    \ note: to match this \u2018{\u2019\n   12 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmp6037iefs.cpp:148:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n  148 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            open++;\n        } else\
    \ if (string[i] == ']') {\n            close++;\n        }\n        if (open >\
    \ close) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp8d3gog7l: /tmp/tmp8d3gog7l.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n\
    \            count++;\n        }\n        if(string[i] == ']') {\n           \
    \ count--;\n        }\n        if(count == 0) {\n            flag = true;\n  \
    \          break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5sosl3wm: /tmp/tmp5sosl3wm.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size())\
    \ {\n        if (string[i] == '[') {\n            count++;\n        }\n      \
    \  if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            if (j == i) {\n                return true;\n         \
    \   }\n            j++;\n        }\n        i++;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp78ia3bm2: /tmp/tmp78ia3bm2.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        }\n        if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpba4g_4j4: /tmp/tmpba4g_4j4.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0yfmg53u: /tmp/tmp0yfmg53u.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool found = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            found\
    \ = true;\n        }\n    }\n    return found;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5v8rtqk4: /tmp/tmp5v8rtqk4.cpp:25: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n           \
    \ flag = true;\n        }\n        if(string[i] == ']') {\n            flag =\
    \ false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9d1hxcbu: /tmp/tmp9d1hxcbu.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    int i = 0;\n    while(i < string.size())\
    \ {\n        if(string[i] == '[') {\n            open++;\n        }\n        if(string[i]\
    \ == ']') {\n            close++;\n        }\n        i++;\n    }\n    if(open\
    \ > close) {\n        return true;\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9o9yfy29: /tmp/tmp9o9yfy29.cpp:32: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool result = true;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']')\
    \ {\n            result = false;\n            break;\n        } else if (string[i]\
    \ == ']' && string[i + 1] != ']') {\n            result = false;\n           \
    \ break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpp7o2h6nm: /tmp/tmpp7o2h6nm.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool found = false;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[') {\n            found = true;\n\
    \        }\n        if (string[i] == ']') {\n            found = false;\n    \
    \    }\n    }\n    return found;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpp4r4qfvt: /tmp/tmpp4r4qfvt.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n           \
    \ flag = true;\n        }\n        if(string[i] == ']') {\n            flag =\
    \ false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9d1hxcbu: /tmp/tmp9d1hxcbu.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpds_dw27w: /tmp/tmpds_dw27w.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n\
    \        if (string[i] == ']') {\n            count--;\n        }\n        if\
    \ (count == 0) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1ggdrm8g: /tmp/tmp1ggdrm8g.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    bool flag = false;\n    int count\
    \ = 0;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] ==\
    \ '[') {\n            count++;\n        }\n        if(string[i] == ']') {\n  \
    \          count--;\n        }\n        if(count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpu6tspe1s: /tmp/tmpu6tspe1s.cpp:34: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.length(); i++){\n        if(string[i] == '['){\n           \
    \ flag = true;\n        }\n        else if(string[i] == ']'){\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr14fsohs: /tmp/tmpr14fsohs.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i=0;i<string.length();i++){\n  \
    \      if(string[i]=='['){\n            for(int j=i;j<string.length();j++){\n\
    \                if(string[j]==']'){\n                    if(string[j-1]=='['){\n\
    \                        if(string[j-2]==']'){\n                            if(string[j-3]==']'){\n\
    \                                if(string[j-4]==']'){\n                     \
    \               if(string[j-5]==']'){\n                                      \
    \  if(string[j-6]==']'){\n                                            if(string[j-7]==']'){\n\
    \                                                if(string[j-8]==']'){\n     \
    \                                               if(string[j-9]==']'){\n      \
    \                                                  if(string[j-10]==']'){\n  \
    \                                                          if(string[j-11]==']'){\n\
    \                                                                if(string[j-12]==']'){\n\
    \                                                                    if(string[j-13]==']'){\n\
    \                                                                        if(string[j-14]==']'){\n\
    \                                                                            if(string[j-15]==']'){\n\
    \                                                                            \
    \    if(string[j-16]==']'){\n                                                \
    \                                    return true;\n                          \
    \                                                      }\n                   \
    \                                                         }\n                \
    \                                                        }\n                 \
    \                                                   }\n                      \
    \                                          }\n                               \
    \                             }\n                                            \
    \            }\n                                                    }\n      \
    \                                          }\n                               \
    \             }\n                                        }\n                 \
    \                   }\n                                }\n                   \
    \         }\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp_ykasgwm: /tmp/tmp_ykasgwm.cpp:60: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(s[i] == '[') {\n            s.push(s[i]);\n        } else\
    \ if(s[i] == ']') {\n            if(s.empty()) {\n                flag = false;\n\
    \                break;\n            } else {\n                s.pop();\n    \
    \        }\n        } else {\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpg1u36ogy.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpg1u36ogy.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpg1u36ogy.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpg1u36ogy.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpg1u36ogy.cpp:16:12: error: \u2018s\u2019 was not declared in this scope\n\
    \   16 |         if(s[i] == '[') {\n      |            ^\n"
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            flag = true;\n        }\n       \
    \ if(string[i] == ']') {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpl78hirvl: /tmp/tmpl78hirvl.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpxz7tfgyj: /tmp/tmpxz7tfgyj.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxq1m9966: /tmp/tmpxq1m9966.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int open = 0;\n    int close = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     open++;\n        }\n        if(string[i] == ']') {\n            close++;\n\
    \        }\n        if(open > close) {\n            return true;\n        }\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpw814szoz: /tmp/tmpw814szoz.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0 && flag == false) {\n            flag = true;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpn65qm_ab: /tmp/tmpn65qm_ab.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121254
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> brackets;\n    bool found = false;\n    \n    for (char c\
    \ : string) {\n        if (c == '[') {\n            brackets.push(c);\n      \
    \  } else if (c == ']') {\n            if (brackets.empty()) {\n             \
    \   return false;\n            }\n            char top = brackets.top();\n   \
    \         brackets.pop();\n            if (top == '[') {\n                brackets.push(top);\n\
    \            } else if (top == ']') {\n                brackets.pop();\n     \
    \       }\n        }\n    }\n    return found;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmphmyt71ij.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmphmyt71ij.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmphmyt71ij.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmphmyt71ij.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmphmyt71ij.cpp:18:13: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   18 |             brackets.push(c);\n      |             ^~~~~~~~\n\
    /tmp/tmphmyt71ij.cpp:20:17: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   20 |             if (brackets.empty()) {\n      |                \
    \ ^~~~~~~~\n/tmp/tmphmyt71ij.cpp:23:24: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   23 |             char top = brackets.top();\n      |     \
    \                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660121252
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0 && flag == false) {\n            flag = true;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpn65qm_ab: /tmp/tmpn65qm_ab.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121254
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            flag = true;\n        }\n       \
    \ if(string[i] == ']') {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpl78hirvl: /tmp/tmpl78hirvl.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0mtcwrzl: /tmp/tmp0mtcwrzl.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121254
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr6azjx43: /tmp/tmpr6azjx43.cpp:18: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            flag = true;\n        }\n        if(flag){\n\
    \            if(string[i]==']'){\n                flag = false;\n            }\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp_djun25k: /tmp/tmp_djun25k.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        else if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpg8vklou4: /tmp/tmpg8vklou4.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') {\n            open++;\n        } else\
    \ if (string[i] == ']') {\n            close++;\n        }\n        if (open >\
    \ close) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpncws8n60: /tmp/tmpncws8n60.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0mtcwrzl: /tmp/tmp0mtcwrzl.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121254
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            flag = true;\n        }\n        if(string[i]==']'){\n\
    \            flag = false;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpfmpn656i: /tmp/tmpfmpn656i.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0yfmg53u: /tmp/tmp0yfmg53u.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool first = true;\n    bool last = false;\n\
    \    bool foundFirst = false;\n    bool foundLast = false;\n    bool foundFirstLast\
    \ = false;\n    bool foundLastFirst = false;\n    bool foundFirstLastFirst = false;\n\
    \    bool foundLastFirstFirst = false;\n    bool foundFirstLastLast = false;\n\
    \    bool foundLastFirstLast = false;\n    bool foundFirstLastLastFirst = false;\n\
    \    bool foundLastFirstLastFirst = false;\n    bool foundFirstLastLastLast =\
    \ false;\n    bool foundLastFirstLastLast = false;\n    bool foundFirstLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastFirst = false;\n    bool foundFirstLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLast = false;\n    bool foundFirstLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastFirst = false;\n    bool\
    \ foundFirstLastLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastFirst = false;\n    bool\
    \ foundLastFirstLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLast = false;\n    bool\
    \ foundFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLast = false;\n   \
    \ bool foundLastFirstLastLastLastLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLastFirst = false;\n  \
    \  bool foundFirstLastLastLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLastFirst = false;\n\
    \    bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLast\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_9_j85jd.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp_9_j85jd.cpp:43:10: error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLast\u2019\
    \n   43 |     bool foundLastFirstLastLastLastLastLast = false;\n      |      \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9_j85jd.cpp:39:10: note: \u2018\
    bool foundLastFirstLastLastLastLastLast\u2019 previously declared here\n   39\
    \ |     bool foundLastFirstLastLastLastLastLast = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_9_j85jd.cpp:44:10: error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastFirst\u2019\
    \n   44 |     bool foundFirstLastLastLastLastLastLastFirst = false;\n      | \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9_j85jd.cpp:40:10:\
    \ note: \u2018bool foundFirstLastLastLastLastLastLastFirst\u2019 previously declared\
    \ here\n   40 |     bool foundFirstLastLastLastLastLastLastFirst = false;\n  \
    \    |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9_j85jd.cpp:45:10:\
    \ error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLastFirst\u2019\
    \n   45 |     bool foundLastFirstLastLastLastLastLastFirst = false;\n      | \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9_j85jd.cpp:41:10:\
    \ note: \u2018bool foundLastFirstLastLastLastLastLastFirst\u2019 previously declared\
    \ here\n   41 |     bool foundLastFirstLastLastLastLastLastFirst = false;\n  \
    \    |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9_j85jd.cpp:46:10:\
    \ error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLast\u2019\
    \n   46 |     bool foundFirstLastLastLastLastLastLastLast = false;\n      |  \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9_j85jd.cpp:42:10: note:\
    \ \u2018bool foundFirstLastLastLastLastLastLastLast\u2019 previously declared\
    \ here\n   42 |     bool foundFirstLastLastLastLastLastLastLast = false;\n   \
    \   |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp_9_j85jd.cpp:52:10:\
    \ error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLastFirst\u2019\
    \n   52 |     bool foundFirstLastLastLastLastLastLastLastFirst = false;\n  "
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0yfmg53u: /tmp/tmp0yfmg53u.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int counter = 0;\n    int index = 0;\n    bool\
    \ found = false;\n    while(index < string.length()){\n        if(string[index]\
    \ == '[' && string[index+1] == '['){\n            counter++;\n        }\n    \
    \    if(string[index] == '[' && string[index+1] == ']'){\n            counter--;\n\
    \        }\n        if(string[index] == ']' && string[index+1] == ']'){\n    \
    \        found = true;\n        }\n        index++;\n    }\n    return found;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpmymycj5d: /tmp/tmpmymycj5d.cpp:34: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool result = true;\n    for(int i = 0;\
    \ i < n; i++) {\n        if(string[i] == '[') {\n            int j = i;\n    \
    \        while(j < n && string[j] != ']') {\n                j++;\n          \
    \  }\n            if(j == n) {\n                result = false;\n            \
    \    break;\n            }\n            for(int k = i; k < j; k++) {\n       \
    \         string[k] = '\\0';\n            }\n            i = j;\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpx6_lqxee: /tmp/tmpx6_lqxee.cpp:36: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open_brackets = 0;\n    int close_brackets = 0;\n    for (int i =\
    \ 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n          \
    \  open_brackets++;\n        } else if (string[i] == ']') {\n            close_brackets++;\n\
    \        }\n    }\n    return open_brackets == close_brackets;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpeq8zqbgq: /tmp/tmpeq8zqbgq.cpp:28: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpayn598du: /tmp/tmpayn598du.cpp:19: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int open_brackets = 0;\n    int close_brackets\
    \ = 0;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] ==\
    \ '[') {\n            open_brackets++;\n        }\n        if(string[i] == ']')\
    \ {\n            close_brackets++;\n        }\n        if(open_brackets > close_brackets)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpzhes0gvy: /tmp/tmpzhes0gvy.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.length(); i++) {\n        if(string[i] == '[')\
    \ {\n            count++;\n        }\n        if(string[i] == ']') {\n       \
    \     count--;\n        }\n        if(count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp4fiu_xhj: /tmp/tmp4fiu_xhj.cpp:34: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121252
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxq1m9966: /tmp/tmpxq1m9966.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr6azjx43: /tmp/tmpr6azjx43.cpp:18: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmptkfjzwnl: /tmp/tmptkfjzwnl.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n\
    \        if (string[i] == ']') {\n            count--;\n        }\n        if\
    \ (count == 0) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1ggdrm8g: /tmp/tmp1ggdrm8g.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxq1m9966: /tmp/tmpxq1m9966.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++){\n        if(string[i] == '[' && string[i+1] ==\
    \ '[' && string[i+2] == '[' && string[i+3] == '['){\n            flag = true;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpbbj_l_ei: /tmp/tmpbbj_l_ei.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp963l3e12: /tmp/tmp963l3e12.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpds_dw27w: /tmp/tmpds_dw27w.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n \
    \           count++;\n        }\n        if (string[i] == ']') {\n           \
    \ count--;\n        }\n        if (count == 0) {\n            flag = true;\n \
    \           break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpoycns7zt: /tmp/tmpoycns7zt.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    bool flag = false;\n    for(int i\
    \ = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n         \
    \   flag = true;\n        }\n        if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3uzopfid: /tmp/tmp3uzopfid.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121254
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = false;\n    int i = 0;\n    int j = 0;\n    while (i <\
    \ string.length()) {\n        if (string[i] == '[') {\n            i++;\n    \
    \        while (i < string.length() && string[i] != ']') {\n                i++;\n\
    \            }\n            if (i < string.length() && string[i] == ']') {\n \
    \               i++;\n                while (i < string.length() && string[i]\
    \ != ']') {\n                    i++;\n                }\n                if (i\
    \ < string.length() && string[i] == ']') {\n                    i++;\n       \
    \             while (i < string.length() && string[i] != ']') {\n            \
    \            i++;\n                    }\n                    if (i < string.length()\
    \ && string[i] == ']') {\n                        i++;\n                     \
    \   while (i < string.length() && string[i] != ']') {\n                      \
    \      i++;\n                        }\n                        if (i < string.length()\
    \ && string[i] == ']') {\n                            i++;\n                 \
    \           while (i < string.length() && string[i] != ']') {\n              \
    \                  i++;\n                            }\n                     \
    \       if (i < string.length() && string[i] == ']') {\n                     \
    \           i++;\n                                while (i < string.length() &&\
    \ string[i] != ']') {\n                                    i++;\n            \
    \                    }\n                                if (i < string.length()\
    \ && string[i] == ']') {\n                                    i++;\n         \
    \                           while (i < string.length() && string[i] != ']') {\n\
    \                                        i++;\n                              \
    \      }\n                                    if (i < string.length() && string[i]\
    \ == ']') {\n                                        i++;\n                  \
    \                      while (i < string.length() && string[i] != ']') {\n   \
    \                                         i++;\n                             \
    \           }\n                                        if (i < string.length()\
    \ && string[i] == ']') {\n                                            i++;\n \
    \                                           while (i < string.length() && string[i]\
    \ != ']') {\n                                                i++;\n          \
    \                                  }\n                                       \
    \     if (i < string.length() && string[i] == ']') {\n                       \
    \                         i++;\n                                             \
    \   while (i < string.length() && string[i] != ']') {\n                      \
    \                              i++;\n                                        \
    \        }\n                                                if (i < string.length()\
    \ && string[i] == ']') {\n                                                   \
    \ i++;\n                                                    while (i < string.length()\
    \ && string[i] != ']') {\n                                                   \
    \     i++;\n                                                    }\n          \
    \                                          if (i < string.length() && string[i]\
    \ == ']') {\n                                                        i++;\n  \
    \                                                      while (i < string.length()\
    \ && string[i] != ']') {\n                                                   \
    \         i++;\n                                                        }\n  \
    \                                                      if (i < string.length()\
    \ && string[i] == ']') {\n                                                   \
    \         i++;\n                                                            while\
    \ (i < string.length() && string[i] != ']') {\n                              \
    \                                  i++;\n                                    \
    \                        }\n                                                 \
    \           if (i < string.length() && string[i] == ']') {\n                 \
    \                                               i++;\n                       \
    \                                         while (i < string.length() && string[i]\
    \ != ']') {\n                                                                \
    \    i++;\n                                                                }\n\
    \                                                                if (i < string.length()\
    \ && string[i] == ']') {\n                                                   \
    \                 i++;\n                                                     \
    \               while (i < string.length() && string[i] != ']') {\n          \
    \                      \n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpc26f2lpc.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpc26f2lpc.cpp:92:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   92 | int main() {\n      |            ^\n/tmp/tmpc26f2lpc.cpp:108:1:\
    \ error: expected \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmpc26f2lpc.cpp:87:110:\
    \ note: to match this \u2018{\u2019\n   87 |                                 \
    \                                if (i < string.length() && string[i] == ']')\
    \ {\n      |                                                                 \
    \                                             ^\n/tmp/tmpc26f2lpc.cpp:108:1: error:\
    \ expected \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmpc26f2lpc.cpp:82:106:\
    \ note: to match this \u2018{\u2019\n   82 |                                 \
    \                            if (i < string.length() && string[i] == ']') {\n\
    \      |                                                                     \
    \                                     ^\n/tmp/tmpc26f2lpc.cpp:108:1: error: expected\
    \ \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmpc26f2lpc.cpp:77:102:\
    \ note: to match this \u2018{\u2019\n   77 |                                 \
    \                        if (i < string.length() && string[i] == ']') {\n    \
    \  |                                                                         \
    \                             ^\n/tmp/tmpc26f2lpc.cpp:108:1: error: expected \u2018\
    }\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmpc26f2lpc.cpp:72:98: note:\
    \ to match this \u2018{\u2019\n   72 |                                       \
    \              if (i < string.length() && string[i] == ']') {\n      |       \
    \                                                                            \
    \               ^\n/tmp/tmpc26f2lpc.cpp:108:1: error: expected \u2018}\u2019 at\
    \ end of input\n  108 | }\n      | ^\n/tmp/tmpc26f2lpc.cpp:67:94: note: to match\
    \ this \u2018{\u2019\n   67 |                                                \
    \ if (i < string.length() && string[i] == ']') {\n      |                    \
    \                                                                          ^\n\
    /tmp/t"
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n\
    \            count++;\n        }\n        if(string[i] == ']') {\n           \
    \ count--;\n        }\n        if(count == 0) {\n            flag = true;\n  \
    \          break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpeq4xw7kv: /tmp/tmpeq4xw7kv.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121255
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        else if (string[i] == ']') {\n \
    \           count--;\n        }\n        if (count == 0) {\n            flag =\
    \ true;\n            break;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9njga6wg: /tmp/tmp9njga6wg.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121255
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool result = true;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']')\
    \ {\n            result = false;\n            break;\n        } else if (string[i]\
    \ == ']' && string[i + 1] != ']') {\n            result = false;\n           \
    \ break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpp7o2h6nm: /tmp/tmpp7o2h6nm.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpe54arycq: /tmp/tmpe54arycq.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i=0;i<string.length();i++){\n  \
    \      if(string[i]=='['){\n            for(int j=i+1;j<string.length();j++){\n\
    \                if(string[j]=='['){\n                    for(int k=j+1;k<string.length();k++){\n\
    \                        if(string[k]==']'){\n                            for(int\
    \ l=k+1;l<string.length();l++){\n                                if(string[l]==']'){\n\
    \                                    return true;\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660121255
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool result = true;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']')\
    \ {\n            result = false;\n            break;\n        } else if (string[i]\
    \ == '[' && string[i + 1] == ']') {\n            i += 2;\n        } else if (string[i]\
    \ == ']' && string[i + 1] == ']') {\n            i += 2;\n        } else if (string[i]\
    \ == ']' && string[i + 1] != '[') {\n            result = false;\n           \
    \ break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpgx754sfg: /tmp/tmpgx754sfg.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpds_dw27w: /tmp/tmpds_dw27w.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int count = 0;\n    for (int i = 0; i <\
    \ string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n\
    \        }\n        if (string[i] == ']') {\n            count--;\n        }\n\
    \        if (count == 0) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp1cyzshhf: /tmp/tmp1cyzshhf.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        }\n        if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpba4g_4j4: /tmp/tmpba4g_4j4.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int n = string.length();\n    bool flag = false;\n\
    \    for (int i = 0; i < n; i++) {\n        if (string[i] == '[') {\n        \
    \    flag = true;\n        } else if (string[i] == ']') {\n            flag =\
    \ false;\n        } else {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp8sq00jmp: /tmp/tmp8sq00jmp.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpds_dw27w: /tmp/tmpds_dw27w.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    for(int i = 0; i < string.size(); i++) {\n \
    \       if(string[i] == '[') {\n            found = true;\n        }\n       \
    \ if(string[i] == ']') {\n            found = false;\n        }\n    }\n    return\
    \ found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpe8381ihp: /tmp/tmpe8381ihp.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3kujw4ok: /tmp/tmp3kujw4ok.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int i = 0;\n   \
    \ int j = 0;\n    int k = 0;\n    int count = 0;\n    while(i < string.size())\
    \ {\n        if(string[i] == '[') {\n            count++;\n        }\n       \
    \ if(string[i] == ']') {\n            count--;\n        }\n        if(count ==\
    \ 0) {\n            flag = true;\n        }\n        i++;\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpds19hq3t: /tmp/tmpds19hq3t.cpp:36: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            flag = true;\n        }\n        if(string[i]==']'){\n\
    \            flag = false;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpr8m_leko: /tmp/tmpr8m_leko.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        }\n        if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpba4g_4j4: /tmp/tmpba4g_4j4.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr6azjx43: /tmp/tmpr6azjx43.cpp:18: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        else if(string[i] == ']') {\n            flag = false;\n        }\n \
    \   }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5h2chhmz: /tmp/tmp5h2chhmz.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    for (int i = 0; i < n; ++i) {\n       \
    \ if (string[i] == '[' && string[i + 1] == '[') {\n            i += 2;\n     \
    \   } else if (string[i] == '[' && string[i + 1] != ']') {\n            return\
    \ false;\n        } else if (string[i] == '[' && string[i + 1] == ']') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']'\
    \ && string[i + 1] != ']') {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpzbyzbyfm: /tmp/tmpzbyzbyfm.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    int count = 0;\n    for (int i = 0; i < n;\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpop802gr7: /tmp/tmpop802gr7.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm7fvl4xc: /tmp/tmpm7fvl4xc.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='[' && string[i+1]=='['){\n            flag = true;\n \
    \       }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpgt9jjjqx: /tmp/tmpgt9jjjqx.cpp:25: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpmoddtccl: /tmp/tmpmoddtccl.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.size(); i++) {\n  \
    \      if(string[i] == '[') {\n            flag = true;\n        }\n        if(string[i]\
    \ == ']') {\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwbooqn1g: /tmp/tmpwbooqn1g.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpds_dw27w: /tmp/tmpds_dw27w.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int counter = 0;\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            opening_brackets++;\n  \
    \      }\n        if(string[i] == ']') {\n            closing_brackets++;\n  \
    \      }\n        if(opening_brackets == closing_brackets) {\n            counter++;\n\
    \        }\n    }\n    return counter == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp_bqiqzo2: /tmp/tmp_bqiqzo2.cpp:32: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp74e_od9n: /tmp/tmp74e_od9n.cpp:34: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0yfmg53u: /tmp/tmp0yfmg53u.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.size(); i++){\n        if(string[i] == '['){\n\
    \            count++;\n        }\n        if(string[i] == ']'){\n            count--;\n\
    \        }\n        if(count == 0){\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3ayha70p: /tmp/tmp3ayha70p.cpp:34: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool found = false;\n    bool first = true;\n\
    \    bool last = false;\n    bool foundFirst = false;\n    bool foundLast = false;\n\
    \    bool foundFirstLast = false;\n    bool foundLastFirst = false;\n    bool\
    \ foundFirstLastFirst = false;\n    bool foundLastFirstFirst = false;\n    bool\
    \ foundFirstLastLast = false;\n    bool foundLastFirstLast = false;\n    bool\
    \ foundFirstLastLastFirst = false;\n    bool foundLastFirstLastFirst = false;\n\
    \    bool foundFirstLastLastLast = false;\n    bool foundLastFirstLastLast = false;\n\
    \    bool foundFirstLastLastLastFirst = false;\n    bool foundLastFirstLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLast = false;\n    bool foundLastFirstLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastFirst = false;\n    bool\
    \ foundLastFirstLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLast = false;\n    bool\
    \ foundFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLast = false;\n   \
    \ bool foundLastFirstLastLastLastLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n\
    \    bool foundFirstLastLastLastLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLastFirst = false;\n\
    \    bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLastLastLast = false;\n\
    \    bool foundFirstLastLastLastLastLastLastLastLastLastFirst = false;\n    bool\
    \ foundLastFirstLastLastLastLastLastLastLastLastLastFirst = false;\n    bool foundFirstLastLast\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjqoi3ouo.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpjqoi3ouo.cpp:52:10: error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLastLastLast\u2019\
    \n   52 |     bool foundLastFirstLastLastLastLastLastLastLast = false;\n     \
    \ |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjqoi3ouo.cpp:48:10:\
    \ note: \u2018bool foundLastFirstLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   48 |     bool foundLastFirstLastLastLastLastLastLastLast =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjqoi3ouo.cpp:53:10:\
    \ error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLastLastFirst\u2019\
    \n   53 |     bool foundFirstLastLastLastLastLastLastLastLastFirst = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjqoi3ouo.cpp:49:10:\
    \ note: \u2018bool foundFirstLastLastLastLastLastLastLastLastFirst\u2019 previously\
    \ declared here\n   49 |     bool foundFirstLastLastLastLastLastLastLastLastFirst\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjqoi3ouo.cpp:54:10: error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLastLastLastFirst\u2019\
    \n   54 |     bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjqoi3ouo.cpp:50:10:\
    \ note: \u2018bool foundLastFirstLastLastLastLastLastLastLastFirst\u2019 previously\
    \ declared here\n   50 |     bool foundLastFirstLastLastLastLastLastLastLastFirst\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpjqoi3ouo.cpp:55:10: error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLastLastLast\u2019\
    \n   55 |     bool foundFirstLastLastLastLastLastLastLastLastLast = false;\n \
    \     |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjqoi3ouo.cpp:51:10:\
    \ note: \u2018bool foundFirstLastLastLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   51 |     bool foundFirstLastLastLastLastLastLastLastLastLast\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660121255
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    // Your code here\n    \n    return\
    \ true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphuwvgzzd: /tmp/tmphuwvgzzd.cpp:22: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open_brackets = 0;\n    int close_brackets = 0;\n    for(int i =\
    \ 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n           \
    \ open_brackets++;\n        }\n        else if(string[i] == ']') {\n         \
    \   close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpsv5rkbxm: /tmp/tmpsv5rkbxm.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr6azjx43: /tmp/tmpr6azjx43.cpp:18: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp963l3e12: /tmp/tmp963l3e12.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool found = false;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[') {\n            found = true;\n\
    \        }\n        if (string[i] == ']') {\n            if (found) {\n      \
    \          return true;\n            }\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa6vt2fp3: /tmp/tmpa6vt2fp3.cpp:30: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    int counter = 0;\n    for (int i = 0; i <\
    \ string.size(); i++) {\n        if (string[i] == '[') {\n            counter++;\n\
    \        }\n        if (string[i] == ']') {\n            counter--;\n        }\n\
    \        if (counter < 0) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphxbe3h6t: /tmp/tmphxbe3h6t.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool open = false;\n    bool close = false;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            open = true;\n        } else if (string[i] == ']') {\n      \
    \      close = true;\n        } else if (open) {\n            open = false;\n\
    \        } else if (close) {\n            close = false;\n        } else {\n \
    \           found = true;\n        }\n    }\n    return found;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1q7674cg: /tmp/tmp1q7674cg.cpp:33: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaz90575u: /tmp/tmpaz90575u.cpp:25: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    for (int i = 0; i < n; i++) {\n       \
    \ if (string[i] == '[' && string[i + 1] == '[') {\n            i += 2;\n     \
    \       while (i < n && string[i] != ']') {\n                i++;\n          \
    \  }\n            if (i == n) {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp3py4dusr: /tmp/tmp3py4dusr.cpp:29: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0mtcwrzl: /tmp/tmp0mtcwrzl.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121254
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp963l3e12: /tmp/tmp963l3e12.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9qg82vvc: /tmp/tmp9qg82vvc.cpp:271: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphlne22xx: /tmp/tmphlne22xx.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121255
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int open_brackets = 0;\n    int close_brackets\
    \ = 0;\n    int i = 0;\n    while(i < string.length()) {\n        if(string[i]\
    \ == '[') {\n            open_brackets++;\n        }\n        else if(string[i]\
    \ == ']') {\n            close_brackets++;\n        }\n        i++;\n    }\n \
    \   if(open_brackets == close_brackets) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpn8migsld: /tmp/tmpn8migsld.cpp:35: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i = 0; i < string.size(); i++) {\n\
    \        if(string[i] == '[') {\n            int count = 0;\n            for(int\
    \ j = i; j < string.size(); j++) {\n                if(string[j] == ']') {\n \
    \                   count++;\n                }\n            }\n            if(count\
    \ == 0) {\n                return false;\n            }\n        }\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpf282jpwz: /tmp/tmpf282jpwz.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpayn598du: /tmp/tmpayn598du.cpp:19: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaz90575u: /tmp/tmpaz90575u.cpp:25: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxq1m9966: /tmp/tmpxq1m9966.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxq1m9966: /tmp/tmpxq1m9966.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool found = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            found = true;\n        }\n\
    \        if(string[i] == ']') {\n            found = false;\n        }\n    }\n\
    \    return found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpswook9xz: /tmp/tmpswook9xz.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            open++;\n        } else\
    \ if (string[i] == ']') {\n            close++;\n        }\n    }\n    if (open\
    \ != close) {\n        return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp5acsi1ze: /tmp/tmp5acsi1ze.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        else if (string[i] == ']') {\n \
    \           count--;\n        }\n        if (count == 0) {\n            flag =\
    \ true;\n            break;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpegafh7z7: /tmp/tmpegafh7z7.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; ++i) {\n        if (string[i] == '[') {\n            ++count;\n        }\
    \ else if (string[i] == ']') {\n            --count;\n        }\n        if (count\
    \ < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp3kbbnunf: /tmp/tmp3kbbnunf.cpp:31: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        } else\
    \ if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpeqaad9_n: /tmp/tmpeqaad9_n.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpds_dw27w: /tmp/tmpds_dw27w.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9qg82vvc: /tmp/tmp9qg82vvc.cpp:271: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n\
    \        if (string[i] == ']') {\n            count--;\n        }\n        if\
    \ (count == 0) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1ggdrm8g: /tmp/tmp1ggdrm8g.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool flag = false;\n    for (int i = 0; i\
    \ < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n     \
    \       flag = true;\n        }\n        if (string[i] == '[' && string[i + 1]\
    \ != ']') {\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpf2cetmgw: /tmp/tmpf2cetmgw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int i = 0;\n    int j\
    \ = string.size() - 1;\n    while (i < j) {\n        if (string[i] == '[' && string[j]\
    \ == '[') {\n            flag = true;\n            i++;\n            j--;\n  \
    \      } else if (string[i] == '[' && string[j] == ']') {\n            i++;\n\
    \            j--;\n        } else if (string[i] == ']' && string[j] == ']') {\n\
    \            i++;\n            j--;\n        } else if (string[i] == ']' && string[j]\
    \ == '[') {\n            i++;\n            j--;\n        } else {\n          \
    \  i++;\n            j--;\n        }\n    }\n    return flag;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpaytv5isi: /tmp/tmpaytv5isi.cpp:40: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaz90575u: /tmp/tmpaz90575u.cpp:25: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++){\n        if(string[i] == '[' && string[i+1] == '['){\n\
    \            flag = true;\n        }\n        if(string[i] == '[' && string[i+1]\
    \ != ']'){\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpi4ycs5jz: /tmp/tmpi4ycs5jz.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9qg82vvc: /tmp/tmp9qg82vvc.cpp:271: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = false;\n    \n    // Iterate through each character in\
    \ the string\n    for(int i = 0; i < string.size(); i++) {\n        // If the\
    \ character is a left bracket, increment the count of left brackets\n        if(string[i]\
    \ == '[') {\n            ++left_brackets;\n        }\n        // If the character\
    \ is a right bracket, decrement the count of left brackets\n        else if(string[i]\
    \ == ']') {\n            --left_brackets;\n        }\n        // If the count\
    \ of left brackets is equal to zero, return true\n        if(left_brackets ==\
    \ 0) {\n            result = true;\n            break;\n        }\n    }\n   \
    \ \n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpkg6638bg.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpkg6638bg.cpp:19:15: error: \u2018left_brackets\u2019 was not declared\
    \ in this scope\n   19 |             ++left_brackets;\n      |               ^~~~~~~~~~~~~\n\
    /tmp/tmpkg6638bg.cpp:23:15: error: \u2018left_brackets\u2019 was not declared\
    \ in this scope\n   23 |             --left_brackets;\n      |               ^~~~~~~~~~~~~\n\
    /tmp/tmpkg6638bg.cpp:26:12: error: \u2018left_brackets\u2019 was not declared\
    \ in this scope\n   26 |         if(left_brackets == 0) {\n      |           \
    \ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpihzni4ae: /tmp/tmpihzni4ae.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9qg82vvc: /tmp/tmp9qg82vvc.cpp:271: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool res = false;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[') {\n            if (string[i + 1]\
    \ == '[') {\n                if (string[i + 2] == '[') {\n                   \
    \ if (string[i + 3] == '[') {\n                        if (string[i + 4] == '[')\
    \ {\n                            if (string[i + 5] == '[') {\n               \
    \                 if (string[i + 6] == '[') {\n                              \
    \      if (string[i + 7] == '[') {\n                                        if\
    \ (string[i + 8] == '[') {\n                                            if (string[i\
    \ + 9] == '[') {\n                                                if (string[i\
    \ + 10] == '[') {\n                                                    if (string[i\
    \ + 11] == '[') {\n                                                        res\
    \ = true;\n                                                    }\n           \
    \                                     }\n                                    \
    \        }\n                                        }\n                      \
    \              }\n                                }\n                        \
    \    }\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmplbcbb4j_: /tmp/tmplbcbb4j_.cpp:46: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int counter = 0;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            counter++;\n        }\n\
    \        if(string[i] == ']') {\n            counter--;\n        }\n        if(counter\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpht4aozlf: /tmp/tmpht4aozlf.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int len = string.length();\n    int count = 0;\n    for(int i = 0; i\
    \ < len; i++){\n        if(string[i] == '['){\n            count++;\n        }\n\
    \        else if(string[i] == ']'){\n            count--;\n        }\n       \
    \ if(count < 0){\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6y4q6n9g: /tmp/tmp6y4q6n9g.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    \n    for(int i = 0; i < string.size(); i++)\
    \ {\n        if(string[i] == '[' && string[i+1] == '[') {\n            i += 2;\n\
    \            while(i < string.size() && string[i] != ']') {\n                i++;\n\
    \            }\n            if(i == string.size()) {\n                return true;\n\
    \            }\n            i += 1;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp8knw4pmi: /tmp/tmp8knw4pmi.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jpii96_: /tmp/tmp0jpii96_.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr6azjx43: /tmp/tmpr6azjx43.cpp:18: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool open = false;\n    bool close = false;\n\
    \    bool open2 = false;\n    bool close2 = false;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            open = true;\n        \
    \    open2 = false;\n            close = false;\n            close2 = false;\n\
    \        }\n        if (string[i] == ']') {\n            close = true;\n     \
    \       close2 = false;\n            open = false;\n            open2 = false;\n\
    \        }\n        if (string[i] == '[' && open) {\n            open2 = true;\n\
    \        }\n        if (string[i] == ']' && close) {\n            close2 = true;\n\
    \        }\n        if (open2 && close2) {\n            found = true;\n      \
    \  }\n    }\n    return found;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpw_hvr34x: /tmp/tmpw_hvr34x.cpp:45: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = true;\n    int index = 0;\n    while(index < string.length())\
    \ {\n        if(string[index] == '[') {\n            bool found = false;\n   \
    \         for(int i = index + 1; i < string.length(); i++) {\n               \
    \ if(string[i] == '[') {\n                    found = true;\n                \
    \    break;\n                }\n            }\n            if(!found) {\n    \
    \            result = false;\n                break;\n            }\n        }\n\
    \        index++;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpwxraskqd: /tmp/tmpwxraskqd.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp963l3e12: /tmp/tmp963l3e12.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpe54arycq: /tmp/tmpe54arycq.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int n = string.size();\n    int count = 0;\n \
    \   for (int i = 0; i < n; i++) {\n        if (string[i] == '[') {\n         \
    \   count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            return true;\n        }\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5kcmhz76: /tmp/tmp5kcmhz76.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jpii96_: /tmp/tmp0jpii96_.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0yfmg53u: /tmp/tmp0yfmg53u.cpp:28: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp9qg82vvc: /tmp/tmp9qg82vvc.cpp:271: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        } else if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpyoaxjcjy: /tmp/tmpyoaxjcjy.cpp:29: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp2lnd_t69: /tmp/tmp2lnd_t69.cpp:31: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpr6azjx43: /tmp/tmpr6azjx43.cpp:18: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = true;\n    int i = 0;\n    int j = string.size() - 1;\n\
    \    while (i < j) {\n        if (string[i] == '[' && string[j] == '[') {\n  \
    \          i++;\n            j--;\n        } else if (string[i] == '[' && string[j]\
    \ != ']') {\n            i++;\n        } else if (string[i] == '[' && string[j]\
    \ == ']') {\n            i++;\n            j++;\n        } else if (string[i]\
    \ == '[' && string[j] != ']' && string[j] != ']') {\n            result = false;\n\
    \            break;\n        } else if (string[i] == '[' && string[j] == ']')\
    \ {\n            i++;\n            j++;\n        } else {\n            i++;\n\
    \            j--;\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpy53mer4u: /tmp/tmpy53mer4u.cpp:41: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int start = 0;\n    int end = 0;\n    bool\
    \ flag = false;\n    while(end < string.length()){\n        if(string[end] ==\
    \ '[' && string[end+1] == ']'){\n            flag = true;\n            end = end\
    \ + 2;\n        }\n        else if(string[end] == '[' && string[end+1] != ']'){\n\
    \            flag = false;\n            end = end + 1;\n        }\n        else\
    \ if(string[end] == '[' && string[end+1] == ']'){\n            flag = true;\n\
    \            end = end + 2;\n        }\n        else if(string[end] == '[' &&\
    \ string[end+1] != ']'){\n            flag = false;\n            end = end + 1;\n\
    \        }\n        else if(string[end] == '[' && string[end+1] == ']'){\n   \
    \         flag = true;\n            end = end + 2;\n        }\n        else if(string[end]\
    \ == '[' && string[end+1] != ']'){\n            flag = false;\n            end\
    \ = end + 1;\n        }\n        else if(string[end] == '[' && string[end+1] ==\
    \ ']'){\n            flag = true;\n            end = end + 2;\n        }\n   \
    \     else if(string[end] == '[' && string[end+1] != ']'){\n            flag =\
    \ false;\n            end = end + 1;\n        }\n        else if(string[end] ==\
    \ '[' && string[end+1] == ']'){\n            flag = true;\n            end = end\
    \ + 2;\n        }\n        else if(string[end] == '[' && string[end+1] != ']'){\n\
    \            flag = false;\n            end = end + 1;\n        }\n        else\
    \ if(string[end] == '[' && string[end+1] == ']'){\n            flag = true;\n\
    \            end = end + 2;\n        }\n        else if(string[end] == '[' &&\
    \ string[end+1] != ']'){\n            flag = false;\n            end = end + 1;\n\
    \        }\n        else if(string[end] == '[' && string[end+1] == ']'){\n   \
    \         flag = true;\n            end = end + 2;\n        }\n        else if(string[end]\
    \ == '[' && string[end+1] != ']'){\n            flag = false;\n            end\
    \ = end + 1;\n        }\n        else if(string[end] == '[' && string[end+1] ==\
    \ ']'){\n            flag = true;\n            end = end + 2;\n        }\n   \
    \     else if(string[end] == '[' && string[end+1] != ']'){\n            flag =\
    \ false;\n            end = end + 1;\n        }\n        else if(string[end] ==\
    \ '[' && string[end+1] == ']'){\n            flag = true;\n            \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbqa38t34.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpbqa38t34.cpp:86:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   86 | int main() {\n      |            ^\n/tmp/tmpbqa38t34.cpp:102:1:\
    \ error: expected \u2018}\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmpbqa38t34.cpp:17:33:\
    \ note: to match this \u2018{\u2019\n   17 |     while(end < string.length()){\n\
    \      |                                 ^\n/tmp/tmpbqa38t34.cpp:102:1: error:\
    \ expected \u2018}\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmpbqa38t34.cpp:12:36:\
    \ note: to match this \u2018{\u2019\n   12 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmpbqa38t34.cpp:102:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  102 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    // Write your code here\n    \n  \
    \  // Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp8vjvsa_e: /tmp/tmp8vjvsa_e.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpaz90575u: /tmp/tmpaz90575u.cpp:25: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxq1m9966: /tmp/tmpxq1m9966.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        } else\
    \ if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp1im6smx9: /tmp/tmp1im6smx9.cpp:31: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool is_nested = false;\n    int open = 0;\n\
    \    int close = 0;\n    for (int i = 0; i < string.length(); i++) {\n       \
    \ if (string[i] == '[') {\n            open++;\n        } else if (string[i] ==\
    \ ']') {\n            close++;\n        }\n        if (open > close) {\n     \
    \       is_nested = true;\n            found = true;\n        }\n    }\n    return\
    \ found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxpfs_7fb: /tmp/tmpxpfs_7fb.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++){\n        if(string[i] == '['){\n           \
    \ count++;\n        }\n        if(string[i] == ']'){\n            count--;\n \
    \       }\n        if(count < 0){\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpqyml5k76: /tmp/tmpqyml5k76.cpp:32: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    bool flag = false;\n    for (char c : string) {\n\
    \        if (c == '[') {\n            s.push(c);\n        } else if (c == ']')\
    \ {\n            if (s.empty()) {\n                flag = false;\n           \
    \     break;\n            } else {\n                flag = true;\n           \
    \     s.pop();\n            }\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6gbf2ohm.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp6gbf2ohm.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp6gbf2ohm.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp6gbf2ohm.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmp6gbf2ohm.cpp:17:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   17 |             s.push(c);\n      |             ^\n/tmp/tmp6gbf2ohm.cpp:19:17:\
    \ error: \u2018s\u2019 was not declared in this scope\n   19 |             if\
    \ (s.empty()) {\n      |                 ^\n"
  stdout: ''
  timestamp: 1660121257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i=0;i<string.length();i++){\n  \
    \      if(string[i]=='['){\n            for(int j=i;j<string.length();j++){\n\
    \                if(string[j]=='['){\n                    for(int k=j+1;k<string.length();k++){\n\
    \                        if(string[k]==']'){\n                            for(int\
    \ l=k+1;l<string.length();l++){\n                                if(string[l]==']'){\n\
    \                                    return true;\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5qkk6tzs: /tmp/tmp5qkk6tzs.cpp:37: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int counter = 0;\n    for (int i = 0; i\
    \ < string.size(); i++) {\n        if (string[i] == '[') {\n            counter++;\n\
    \        }\n        if (string[i] == ']') {\n            counter--;\n        }\n\
    \        if (counter < 0) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpkgp6_rfk: /tmp/tmpkgp6_rfk.cpp:32: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            flag = true;\n        }\n       \
    \ if(string[i] == ']') {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpl78hirvl: /tmp/tmpl78hirvl.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open_brackets = 0;\n    int close_brackets = 0;\n    for(int i =\
    \ 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n           \
    \ open_brackets++;\n        }\n        else if(string[i] == ']') {\n         \
    \   close_brackets++;\n        }\n    }\n    return open_brackets > 0 && close_brackets\
    \ > 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6qtq06xg: /tmp/tmp6qtq06xg.cpp:28: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        else if (string[i] == ']') {\n        \
    \    count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp_4pmucun: /tmp/tmp_4pmucun.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool found2 = false;\n    bool found3 = false;\n\
    \    bool found4 = false;\n    bool found5 = false;\n    bool found6 = false;\n\
    \    bool found7 = false;\n    bool found8 = false;\n    bool found9 = false;\n\
    \    bool found10 = false;\n    bool found11 = false;\n    bool found12 = false;\n\
    \    bool found13 = false;\n    bool found14 = false;\n    bool found15 = false;\n\
    \    bool found16 = false;\n    bool found17 = false;\n    bool found18 = false;\n\
    \    bool found19 = false;\n    bool found20 = false;\n    bool found21 = false;\n\
    \    bool found22 = false;\n    bool found23 = false;\n    bool found24 = false;\n\
    \    bool found25 = false;\n    bool found26 = false;\n    bool found27 = false;\n\
    \    bool found28 = false;\n    bool found29 = false;\n    bool found30 = false;\n\
    \    bool found31 = false;\n    bool found32 = false;\n    bool found33 = false;\n\
    \    bool found34 = false;\n    bool found35 = false;\n    bool found36 = false;\n\
    \    bool found37 = false;\n    bool found38 = false;\n    bool found39 = false;\n\
    \    bool found40 = false;\n    bool found41 = false;\n    bool found42 = false;\n\
    \    bool found43 = false;\n    bool found44 = false;\n    bool found45 = false;\n\
    \    bool found46 = false;\n    bool found47 = false;\n    bool found48 = false;\n\
    \    bool found49 = false;\n    bool found50 = false;\n    bool found51 = false;\n\
    \    bool found52 = false;\n    bool found53 = false;\n    bool found54 = false;\n\
    \    bool found55 = false;\n    bool found56 = false;\n    bool found57 = false;\n\
    \    bool found58 = false;\n    bool found59 = false;\n    bool found60 = false;\n\
    \    bool found61 = false;\n    bool found62 = false;\n    bool found63 = false;\n\
    \    bool found64 = false;\n    bool found65 = false;\n    bool found66 = false;\n\
    \    bool found67 = false;\n    bool found68 = false;\n    bool found69 = false;\n\
    \    bool found70 = false;\n    bool found71 = false;\n    bool found72 = false;\n\
    \    bool found73 = false;\n    bool found74 = false;\n    bool found75 = false;\n\
    \    bool found76 = false;\n    bool found77 = false;\n    bool found78 = false;\n\
    \    bool found79 = false;\n    bool found80 = false;\n    bool found81 = false;\n\
    \    bool found82 = false;\n    bool \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpljs7nwvv.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpljs7nwvv.cpp:96:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   96 | }\n      | ^\n/tmp/tmpljs7nwvv.cpp:96:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; ++i) {\n        if (string[i] == '[') {\n            ++count;\n        }\n\
    \        else if (string[i] == ']') {\n            --count;\n        }\n    }\n\
    \    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpuk_x137l: /tmp/tmpuk_x137l.cpp:29: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            count++;\n        }\n  \
    \      else if(string[i] == ']') {\n            count--;\n        }\n        if(count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpt_6_v6m3: /tmp/tmpt_6_v6m3.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    int i = 0;\n    bool result =\
    \ false;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n\
    \            open++;\n        } else if (string[i] == ']') {\n            close++;\n\
    \        }\n        i++;\n    }\n    if (open > close) {\n        result = true;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0q10on44: /tmp/tmp0q10on44.cpp:32: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int i = 0;\n    int j = 0;\n    int k = 0;\n \
    \   int count = 0;\n    bool flag = false;\n    while (i < string.size()) {\n\
    \        if (string[i] == '[') {\n            count++;\n        }\n        if\
    \ (string[i] == ']') {\n            count--;\n        }\n        if (count ==\
    \ 0) {\n            flag = true;\n        }\n        i++;\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpzmfgmv06: /tmp/tmpzmfgmv06.cpp:36: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0p1rk77r: /tmp/tmp0p1rk77r.cpp:163: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxq1m9966: /tmp/tmpxq1m9966.cpp:33: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpnyxlftbw: /tmp/tmpnyxlftbw.cpp:27: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121253
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n         \
    \   flag = true;\n        }\n        if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp_aabvcvn: /tmp/tmp_aabvcvn.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.size(); i++) {\n  \
    \      if(string[i] == '[') {\n            flag = true;\n        }\n        if(string[i]\
    \ == ']') {\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpwbooqn1g: /tmp/tmpwbooqn1g.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121256
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool first = true;\n    bool last = false;\n\
    \    bool inside = false;\n    bool firstInside = false;\n    bool lastInside\
    \ = false;\n    bool firstLast = false;\n    bool lastFirst = false;\n    bool\
    \ firstLastInside = false;\n    bool lastFirstInside = false;\n    bool firstLastLast\
    \ = false;\n    bool lastFirstLast = false;\n    bool firstLastLastInside = false;\n\
    \    bool lastFirstLastInside = false;\n    bool firstLastLastLast = false;\n\
    \    bool lastFirstLastLast = false;\n    bool firstLastLastLastInside = false;\n\
    \    bool lastFirstLastLastInside = false;\n    bool firstLastLastLastLast = false;\n\
    \    bool lastFirstLastLastLast = false;\n    bool firstLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastInside = false;\n    bool firstLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLast = false;\n    bool firstLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastInside = false;\n    bool firstLastLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLastLast = false;\n    bool firstLastLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastLastInside = false;\n    bool firstLastLastLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLastLastLast = false;\n    bool firstLastLastLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastLastLastInside = false;\n    bool\
    \ firstLastLastLastLastLastLastLastLast = false;\n    bool lastFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool firstLastLastLastLastLastLastLastLastInside = false;\n  \
    \  bool lastFirstLastLastLastLastLastLastLastLastInside = false;\n    bool firstLastLastLastLastLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLastLastLastLastLast = false;\n    bool\
    \ firstLastLastLastLastLastLastLastLastLastInside = false;\n    bool lastFirstLastLastLastLastLastLastLastLastInside\
    \ = false;\n    bool firstLastLastLastLastLastLastLastLastLast = false;\n    bool\
    \ lastFirstLastLastLastLastLastLastLastLast = false;\n    bool firstLastLastLastLastLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastLastLastLastLastInside = false;\n\
    \    bool firstLastLastLastLastLastLastLastLastLastLast = false;\n    bool lastFirstLastLast\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkxqn86va.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpkxqn86va.cpp:54:10: error: redeclaration of \u2018bool lastFirstLastLastLastLastLastLastLastLastInside\u2019\
    \n   54 |     bool lastFirstLastLastLastLastLastLastLastLastInside = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkxqn86va.cpp:50:10:\
    \ note: \u2018bool lastFirstLastLastLastLastLastLastLastLastInside\u2019 previously\
    \ declared here\n   50 |     bool lastFirstLastLastLastLastLastLastLastLastInside\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkxqn86va.cpp:55:10: error: redeclaration of \u2018bool firstLastLastLastLastLastLastLastLastLast\u2019\
    \n   55 |     bool firstLastLastLastLastLastLastLastLastLast = false;\n      |\
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkxqn86va.cpp:51:10:\
    \ note: \u2018bool firstLastLastLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   51 |     bool firstLastLastLastLastLastLastLastLastLast =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkxqn86va.cpp:56:10:\
    \ error: redeclaration of \u2018bool lastFirstLastLastLastLastLastLastLastLast\u2019\
    \n   56 |     bool lastFirstLastLastLastLastLastLastLastLast = false;\n      |\
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkxqn86va.cpp:52:10:\
    \ note: \u2018bool lastFirstLastLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   52 |     bool lastFirstLastLastLastLastLastLastLastLast =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkxqn86va.cpp:57:10:\
    \ error: redeclaration of \u2018bool firstLastLastLastLastLastLastLastLastLastInside\u2019\
    \n   57 |     bool firstLastLastLastLastLastLastLastLastLastInside = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpkxqn86va.cpp:53:10:\
    \ note: \u2018bool firstLastLastLastLastLastLastLastLastLastInside\u2019 previously\
    \ declared here\n   53 |     bool firstLastLastLastLastLastLastLastLastLastInside\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkxqn86va.cpp:58"
  stdout: ''
  timestamp: 1660121258
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool res = true;\n    for(int i = 0; i\
    \ < n; i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n        \
    \    i += 2;\n            while(i < n && string[i] != ']') {\n               \
    \ i++;\n            }\n            if(i == n) return false;\n            i +=\
    \ 1;\n            while(i < n && string[i] != ']') {\n                i++;\n \
    \           }\n            if(i == n) return false;\n            i += 1;\n   \
    \         while(i < n && string[i] != ']') {\n                i++;\n         \
    \   }\n            if(i == n) return false;\n            i += 1;\n           \
    \ while(i < n && string[i] != ']') {\n                i++;\n            }\n  \
    \          if(i == n) return false;\n            i += 1;\n            while(i\
    \ < n && string[i] != ']') {\n                i++;\n            }\n          \
    \  if(i == n) return false;\n            i += 1;\n            while(i < n && string[i]\
    \ != ']') {\n                i++;\n            }\n            if(i == n) return\
    \ false;\n            i += 1;\n            while(i < n && string[i] != ']') {\n\
    \                i++;\n            }\n            if(i == n) return false;\n \
    \           i += 1;\n            while(i < n && string[i] != ']') {\n        \
    \        i++;\n            }\n            if(i == n) return false;\n         \
    \   i += 1;\n            while(i < n && string[i] != ']') {\n                i++;\n\
    \            }\n            if(i == n) return false;\n            i += 1;\n  \
    \          while(i < n && string[i] != ']') {\n                i++;\n        \
    \    }\n            if(i == n) return false;\n            i += 1;\n          \
    \  while(i < n && string[i] != ']') {\n                i++;\n            }\n \
    \           if(i == n) return false;\n            i += 1;\n            while(i\
    \ < n && string[i] != ']') {\n                i++;\n            }\n          \
    \  if(i == n) return false;\n            i += 1;\n            while(i < n && string[i]\
    \ != ']') {\n                i++;\n            }\n            if(i == n) return\
    \ false;\n            i += 1;\n            while(i < n && string[i] != ']') {\n\
    \                i++;\n            }\n            if(i == n) return false;\n \
    \           i += 1;\n            while(i < n && string[i] != ']') {\n        \
    \        i++;\n            }\n            if(i == n) return false;\n         \
    \   i += 1;\n            while(i < n && string[i] != ']') {\n                i++;\n\
    \            }\n            if(i == n) return false;\n            i += 1;\n  \
    \          while(i < n && string[i] != ']') {\n                i++;\n        \
    \    }\n            if(i == n) return false;\n            i += 1;\n          \
    \  while(i < \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmph6pr4b8g.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmph6pr4b8g.cpp:104:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  104 | }\n      | ^\n/tmp/tmph6pr4b8g.cpp:103:22: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n  103 |             while(i <\n  \
    \    |                  ~   ^\n      |                      )\n  104 | }\n   \
    \   | ~                     \n/tmp/tmph6pr4b8g.cpp:104:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  104 | }\n      | ^\n/tmp/tmph6pr4b8g.cpp:105:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  105 | int main() {\n      |            ^\n/tmp/tmph6pr4b8g.cpp:121:1: error:\
    \ expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmph6pr4b8g.cpp:15:32:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i = 0; i < n; i++) {\n\
    \      |                                ^\n/tmp/tmph6pr4b8g.cpp:121:1: error:\
    \ expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmph6pr4b8g.cpp:12:36:\
    \ note: to match this \u2018{\u2019\n   12 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmph6pr4b8g.cpp:121:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n  121 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660121257
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int n = string.length();\n    int count = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        if (string[i] == '[') {\n        \
    \    count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            return true;\n        }\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp1ykstwtd: /tmp/tmp1ykstwtd.cpp:32: int main(): Assertion `candidate(("[]]]]]]][[[[[]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            found = true;\n        }\n      \
    \  if(string[i] == ']') {\n            found = false;\n        }\n    }\n    return\
    \ found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9yi9lvq9: /tmp/tmp9yi9lvq9.cpp:26: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n           \
    \ flag = true;\n        }\n        else if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpc2ff95aq: /tmp/tmpc2ff95aq.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    bool flag = false;\n    \n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     flag = true;\n        }\n        if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpup3rpn8k: /tmp/tmpup3rpn8k.cpp:30: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660121258
