name: HumanEval_132_is_nested
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp4_yox540: /tmp/tmp4_yox540.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(flag && string[i] == ']') {\n            flag =\
    \ false;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp29xfd21c: /tmp/tmp29xfd21c.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp5b751xmi: /tmp/tmp5b751xmi.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpgw5lucqi: /tmp/tmpgw5lucqi.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int i = 0;\n    int j = 0;\n    int k =\
    \ 0;\n    int l = 0;\n    int count = 0;\n    int flag = 0;\n    while(i < string.length()){\n\
    \        if(string[i] == '['){\n            count++;\n        }\n        else\
    \ if(string[i] == ']'){\n            count--;\n        }\n        i++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(j < string.length()){\n\
    \        if(string[j] == '['){\n            count++;\n        }\n        else\
    \ if(string[j] == ']'){\n            count--;\n        }\n        j++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count++;\n        }\n        else\
    \ if(string[k] == ']'){\n            count--;\n        }\n        k++;\n    }\n\
    \    if(count == 0){\n        return true;\n    }\n    while(k < string.length()){\n\
    \        if(string[k] == '['){\n            count\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7vxapimw.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp7vxapimw.cpp:130:18: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n  130 |             count\n      |                  ^\n      |      \
    \            ;\n  131 | }\n      | ~                 \n/tmp/tmp7vxapimw.cpp:132:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  132 | int main() {\n      |            ^\n/tmp/tmp7vxapimw.cpp:148:1: error:\
    \ expected \u2018}\u2019 at end of input\n  148 | }\n      | ^\n/tmp/tmp7vxapimw.cpp:128:31:\
    \ note: to match this \u2018{\u2019\n  128 |     while(k < string.length()){\n\
    \      |                               ^\n/tmp/tmp7vxapimw.cpp:148:1: error: expected\
    \ \u2018}\u2019 at end of input\n  148 | }\n      | ^\n/tmp/tmp7vxapimw.cpp:12:36:\
    \ note: to match this \u2018{\u2019\n   12 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmp7vxapimw.cpp:148:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n  148 | }\n\
    \      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            open++;\n        } else\
    \ if (string[i] == ']') {\n            close++;\n        }\n        if (open >\
    \ close) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpb0ss30g7: /tmp/tmpb0ss30g7.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n\
    \            count++;\n        }\n        if(string[i] == ']') {\n           \
    \ count--;\n        }\n        if(count == 0) {\n            flag = true;\n  \
    \          break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp78issmih: /tmp/tmp78issmih.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < string.size())\
    \ {\n        if (string[i] == '[') {\n            count++;\n        }\n      \
    \  if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            if (j == i) {\n                return true;\n         \
    \   }\n            j++;\n        }\n        i++;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp4yu5uyfw: /tmp/tmp4yu5uyfw.cpp:35: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        }\n        if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpynyh7kjk: /tmp/tmpynyh7kjk.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpyrpvfztv: /tmp/tmpyrpvfztv.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpxmv6ewej: /tmp/tmpxmv6ewej.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool found = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            found\
    \ = true;\n        }\n    }\n    return found;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpqoud74np: /tmp/tmpqoud74np.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n           \
    \ flag = true;\n        }\n        if(string[i] == ']') {\n            flag =\
    \ false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpuyw7xxkz: /tmp/tmpuyw7xxkz.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    int i = 0;\n    while(i < string.size())\
    \ {\n        if(string[i] == '[') {\n            open++;\n        }\n        if(string[i]\
    \ == ']') {\n            close++;\n        }\n        i++;\n    }\n    if(open\
    \ > close) {\n        return true;\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpgspmcezp: /tmp/tmpgspmcezp.cpp:32: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool result = true;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']')\
    \ {\n            result = false;\n            break;\n        } else if (string[i]\
    \ == ']' && string[i + 1] != ']') {\n            result = false;\n           \
    \ break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpiea3t4zh: /tmp/tmpiea3t4zh.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool found = false;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[') {\n            found = true;\n\
    \        }\n        if (string[i] == ']') {\n            found = false;\n    \
    \    }\n    }\n    return found;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp5qn1htr5: /tmp/tmp5qn1htr5.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n           \
    \ flag = true;\n        }\n        if(string[i] == ']') {\n            flag =\
    \ false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp_mhhrmoc: /tmp/tmp_mhhrmoc.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpf054pan_: /tmp/tmpf054pan_.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n\
    \        if (string[i] == ']') {\n            count--;\n        }\n        if\
    \ (count == 0) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp392az21g: /tmp/tmp392az21g.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    bool flag = false;\n    int count\
    \ = 0;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] ==\
    \ '[') {\n            count++;\n        }\n        if(string[i] == ']') {\n  \
    \          count--;\n        }\n        if(count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp09gw96gu: /tmp/tmp09gw96gu.cpp:34: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.length(); i++){\n        if(string[i] == '['){\n           \
    \ flag = true;\n        }\n        else if(string[i] == ']'){\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmphmumx1fh: /tmp/tmphmumx1fh.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i=0;i<string.length();i++){\n  \
    \      if(string[i]=='['){\n            for(int j=i;j<string.length();j++){\n\
    \                if(string[j]==']'){\n                    if(string[j-1]=='['){\n\
    \                        if(string[j-2]==']'){\n                            if(string[j-3]==']'){\n\
    \                                if(string[j-4]==']'){\n                     \
    \               if(string[j-5]==']'){\n                                      \
    \  if(string[j-6]==']'){\n                                            if(string[j-7]==']'){\n\
    \                                                if(string[j-8]==']'){\n     \
    \                                               if(string[j-9]==']'){\n      \
    \                                                  if(string[j-10]==']'){\n  \
    \                                                          if(string[j-11]==']'){\n\
    \                                                                if(string[j-12]==']'){\n\
    \                                                                    if(string[j-13]==']'){\n\
    \                                                                        if(string[j-14]==']'){\n\
    \                                                                            if(string[j-15]==']'){\n\
    \                                                                            \
    \    if(string[j-16]==']'){\n                                                \
    \                                    return true;\n                          \
    \                                                      }\n                   \
    \                                                         }\n                \
    \                                                        }\n                 \
    \                                                   }\n                      \
    \                                          }\n                               \
    \                             }\n                                            \
    \            }\n                                                    }\n      \
    \                                          }\n                               \
    \             }\n                                        }\n                 \
    \                   }\n                                }\n                   \
    \         }\n                        }\n                    }\n              \
    \  }\n            }\n        }\n    }\n    return false;\n}\nint main() {\n  \
    \  auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp3ot2xwq8: /tmp/tmp3ot2xwq8.cpp:60: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(s[i] == '[') {\n            s.push(s[i]);\n        } else\
    \ if(s[i] == ']') {\n            if(s.empty()) {\n                flag = false;\n\
    \                break;\n            } else {\n                s.pop();\n    \
    \        }\n        } else {\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpit2e4d1n.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpit2e4d1n.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpit2e4d1n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpit2e4d1n.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpit2e4d1n.cpp:16:12: error: \u2018s\u2019 was not declared in this scope\n\
    \   16 |         if(s[i] == '[') {\n      |            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            flag = true;\n        }\n       \
    \ if(string[i] == ']') {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmplio3u5k2: /tmp/tmplio3u5k2.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpep3ptznh: /tmp/tmpep3ptznh.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpt8jt3jg5: /tmp/tmpt8jt3jg5.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpt8huy_6t: /tmp/tmpt8huy_6t.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int open = 0;\n    int close = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     open++;\n        }\n        if(string[i] == ']') {\n            close++;\n\
    \        }\n        if(open > close) {\n            return true;\n        }\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp8o2k16f0: /tmp/tmp8o2k16f0.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0 && flag == false) {\n            flag = true;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmptr6_4t93: /tmp/tmptr6_4t93.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpcwifm2fr: /tmp/tmpcwifm2fr.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> brackets;\n    bool found = false;\n    \n    for (char c\
    \ : string) {\n        if (c == '[') {\n            brackets.push(c);\n      \
    \  } else if (c == ']') {\n            if (brackets.empty()) {\n             \
    \   return false;\n            }\n            char top = brackets.top();\n   \
    \         brackets.pop();\n            if (top == '[') {\n                brackets.push(top);\n\
    \            } else if (top == ']') {\n                brackets.pop();\n     \
    \       }\n        }\n    }\n    return found;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpl3a73cla.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpl3a73cla.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> brackets;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpl3a73cla.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpl3a73cla.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> brackets;\n      |        \
    \   ^~~~\n/tmp/tmpl3a73cla.cpp:18:13: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   18 |             brackets.push(c);\n      |             ^~~~~~~~\n\
    /tmp/tmpl3a73cla.cpp:20:17: error: \u2018brackets\u2019 was not declared in this\
    \ scope\n   20 |             if (brackets.empty()) {\n      |                \
    \ ^~~~~~~~\n/tmp/tmpl3a73cla.cpp:23:24: error: \u2018brackets\u2019 was not declared\
    \ in this scope\n   23 |             char top = brackets.top();\n      |     \
    \                   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0 && flag == false) {\n            flag = true;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp1r4_7qp7: /tmp/tmp1r4_7qp7.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            flag = true;\n        }\n       \
    \ if(string[i] == ']') {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmptsixsua_: /tmp/tmptsixsua_.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp3nvh0jol: /tmp/tmp3nvh0jol.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpi5jhbzz1: /tmp/tmpi5jhbzz1.cpp:18: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            flag = true;\n        }\n        if(flag){\n\
    \            if(string[i]==']'){\n                flag = false;\n            }\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpyhe0ehyv: /tmp/tmpyhe0ehyv.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        else if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmppd6iw28p: /tmp/tmppd6iw28p.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') {\n            open++;\n        } else\
    \ if (string[i] == ']') {\n            close++;\n        }\n        if (open >\
    \ close) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp51rnwl2m: /tmp/tmp51rnwl2m.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpfv6qcsmq: /tmp/tmpfv6qcsmq.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            flag = true;\n        }\n        if(string[i]==']'){\n\
    \            flag = false;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpxs0hhtw4: /tmp/tmpxs0hhtw4.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp29qgyki3: /tmp/tmp29qgyki3.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpu1b5mw5n: /tmp/tmpu1b5mw5n.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool first = true;\n    bool last = false;\n\
    \    bool foundFirst = false;\n    bool foundLast = false;\n    bool foundFirstLast\
    \ = false;\n    bool foundLastFirst = false;\n    bool foundFirstLastFirst = false;\n\
    \    bool foundLastFirstFirst = false;\n    bool foundFirstLastLast = false;\n\
    \    bool foundLastFirstLast = false;\n    bool foundFirstLastLastFirst = false;\n\
    \    bool foundLastFirstLastFirst = false;\n    bool foundFirstLastLastLast =\
    \ false;\n    bool foundLastFirstLastLast = false;\n    bool foundFirstLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastFirst = false;\n    bool foundFirstLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLast = false;\n    bool foundFirstLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastFirst = false;\n    bool\
    \ foundFirstLastLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastFirst = false;\n    bool\
    \ foundLastFirstLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLast = false;\n    bool\
    \ foundFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLast = false;\n   \
    \ bool foundLastFirstLastLastLastLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLastFirst = false;\n  \
    \  bool foundFirstLastLastLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLastFirst = false;\n\
    \    bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLast\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpketn45z5.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpketn45z5.cpp:43:10: error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLast\u2019\
    \n   43 |     bool foundLastFirstLastLastLastLastLast = false;\n      |      \
    \    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpketn45z5.cpp:39:10: note: \u2018\
    bool foundLastFirstLastLastLastLastLast\u2019 previously declared here\n   39\
    \ |     bool foundLastFirstLastLastLastLastLast = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpketn45z5.cpp:44:10: error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastFirst\u2019\
    \n   44 |     bool foundFirstLastLastLastLastLastLastFirst = false;\n      | \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpketn45z5.cpp:40:10:\
    \ note: \u2018bool foundFirstLastLastLastLastLastLastFirst\u2019 previously declared\
    \ here\n   40 |     bool foundFirstLastLastLastLastLastLastFirst = false;\n  \
    \    |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpketn45z5.cpp:45:10:\
    \ error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLastFirst\u2019\
    \n   45 |     bool foundLastFirstLastLastLastLastLastFirst = false;\n      | \
    \         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpketn45z5.cpp:41:10:\
    \ note: \u2018bool foundLastFirstLastLastLastLastLastFirst\u2019 previously declared\
    \ here\n   41 |     bool foundLastFirstLastLastLastLastLastFirst = false;\n  \
    \    |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpketn45z5.cpp:46:10:\
    \ error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLast\u2019\
    \n   46 |     bool foundFirstLastLastLastLastLastLastLast = false;\n      |  \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpketn45z5.cpp:42:10: note:\
    \ \u2018bool foundFirstLastLastLastLastLastLastLast\u2019 previously declared\
    \ here\n   42 |     bool foundFirstLastLastLastLastLastLastLast = false;\n   \
    \   |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpketn45z5.cpp:52:10:\
    \ error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLastFirst\u2019\
    \n   52 |     bool foundFirstLastLastLastLastLastLastLastFirst = false;\n    \
    \  |          ^~~~~~~~~~~~~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp1vy5008x: /tmp/tmp1vy5008x.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpx_6mskzs: /tmp/tmpx_6mskzs.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int counter = 0;\n    int index = 0;\n    bool\
    \ found = false;\n    while(index < string.length()){\n        if(string[index]\
    \ == '[' && string[index+1] == '['){\n            counter++;\n        }\n    \
    \    if(string[index] == '[' && string[index+1] == ']'){\n            counter--;\n\
    \        }\n        if(string[index] == ']' && string[index+1] == ']'){\n    \
    \        found = true;\n        }\n        index++;\n    }\n    return found;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9dc22d9l: /tmp/tmp9dc22d9l.cpp:34: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool result = true;\n    for(int i = 0;\
    \ i < n; i++) {\n        if(string[i] == '[') {\n            int j = i;\n    \
    \        while(j < n && string[j] != ']') {\n                j++;\n          \
    \  }\n            if(j == n) {\n                result = false;\n            \
    \    break;\n            }\n            for(int k = i; k < j; k++) {\n       \
    \         string[k] = '\\0';\n            }\n            i = j;\n        }\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpahhz1psm: /tmp/tmpahhz1psm.cpp:36: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open_brackets = 0;\n    int close_brackets = 0;\n    for (int i =\
    \ 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n          \
    \  open_brackets++;\n        } else if (string[i] == ']') {\n            close_brackets++;\n\
    \        }\n    }\n    return open_brackets == close_brackets;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpa51dckja: /tmp/tmpa51dckja.cpp:28: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp0j0i6364: /tmp/tmp0j0i6364.cpp:19: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpi2kwo51e: /tmp/tmpi2kwo51e.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int open_brackets = 0;\n    int close_brackets\
    \ = 0;\n    for(int i = 0; i < string.size(); i++) {\n        if(string[i] ==\
    \ '[') {\n            open_brackets++;\n        }\n        if(string[i] == ']')\
    \ {\n            close_brackets++;\n        }\n        if(open_brackets > close_brackets)\
    \ {\n            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpeiz13f4s: /tmp/tmpeiz13f4s.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpll4m5zmt: /tmp/tmpll4m5zmt.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpassy4oto: /tmp/tmpassy4oto.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.length(); i++) {\n        if(string[i] == '[')\
    \ {\n            count++;\n        }\n        if(string[i] == ']') {\n       \
    \     count--;\n        }\n        if(count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmptxgvu0lv: /tmp/tmptxgvu0lv.cpp:34: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp9mhumzur: /tmp/tmp9mhumzur.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpxz7fbsy9: /tmp/tmpxz7fbsy9.cpp:18: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpv846egts: /tmp/tmpv846egts.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n\
    \        if (string[i] == ']') {\n            count--;\n        }\n        if\
    \ (count == 0) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmphtriho75: /tmp/tmphtriho75.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpoh0edtkm: /tmp/tmpoh0edtkm.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++){\n        if(string[i] == '[' && string[i+1] ==\
    \ '[' && string[i+2] == '[' && string[i+3] == '['){\n            flag = true;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpl7ga76oq: /tmp/tmpl7ga76oq.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmppbw1phvj: /tmp/tmppbw1phvj.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpchh60mzf: /tmp/tmpchh60mzf.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n \
    \           count++;\n        }\n        if (string[i] == ']') {\n           \
    \ count--;\n        }\n        if (count == 0) {\n            flag = true;\n \
    \           break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp9v8ie9do: /tmp/tmp9v8ie9do.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    bool flag = false;\n    for(int i\
    \ = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n         \
    \   flag = true;\n        }\n        if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp50lu6prt: /tmp/tmp50lu6prt.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = false;\n    int i = 0;\n    int j = 0;\n    while (i <\
    \ string.length()) {\n        if (string[i] == '[') {\n            i++;\n    \
    \        while (i < string.length() && string[i] != ']') {\n                i++;\n\
    \            }\n            if (i < string.length() && string[i] == ']') {\n \
    \               i++;\n                while (i < string.length() && string[i]\
    \ != ']') {\n                    i++;\n                }\n                if (i\
    \ < string.length() && string[i] == ']') {\n                    i++;\n       \
    \             while (i < string.length() && string[i] != ']') {\n            \
    \            i++;\n                    }\n                    if (i < string.length()\
    \ && string[i] == ']') {\n                        i++;\n                     \
    \   while (i < string.length() && string[i] != ']') {\n                      \
    \      i++;\n                        }\n                        if (i < string.length()\
    \ && string[i] == ']') {\n                            i++;\n                 \
    \           while (i < string.length() && string[i] != ']') {\n              \
    \                  i++;\n                            }\n                     \
    \       if (i < string.length() && string[i] == ']') {\n                     \
    \           i++;\n                                while (i < string.length() &&\
    \ string[i] != ']') {\n                                    i++;\n            \
    \                    }\n                                if (i < string.length()\
    \ && string[i] == ']') {\n                                    i++;\n         \
    \                           while (i < string.length() && string[i] != ']') {\n\
    \                                        i++;\n                              \
    \      }\n                                    if (i < string.length() && string[i]\
    \ == ']') {\n                                        i++;\n                  \
    \                      while (i < string.length() && string[i] != ']') {\n   \
    \                                         i++;\n                             \
    \           }\n                                        if (i < string.length()\
    \ && string[i] == ']') {\n                                            i++;\n \
    \                                           while (i < string.length() && string[i]\
    \ != ']') {\n                                                i++;\n          \
    \                                  }\n                                       \
    \     if (i < string.length() && string[i] == ']') {\n                       \
    \                         i++;\n                                             \
    \   while (i < string.length() && string[i] != ']') {\n                      \
    \                              i++;\n                                        \
    \        }\n                                                if (i < string.length()\
    \ && string[i] == ']') {\n                                                   \
    \ i++;\n                                                    while (i < string.length()\
    \ && string[i] != ']') {\n                                                   \
    \     i++;\n                                                    }\n          \
    \                                          if (i < string.length() && string[i]\
    \ == ']') {\n                                                        i++;\n  \
    \                                                      while (i < string.length()\
    \ && string[i] != ']') {\n                                                   \
    \         i++;\n                                                        }\n  \
    \                                                      if (i < string.length()\
    \ && string[i] == ']') {\n                                                   \
    \         i++;\n                                                            while\
    \ (i < string.length() && string[i] != ']') {\n                              \
    \                                  i++;\n                                    \
    \                        }\n                                                 \
    \           if (i < string.length() && string[i] == ']') {\n                 \
    \                                               i++;\n                       \
    \                                         while (i < string.length() && string[i]\
    \ != ']') {\n                                                                \
    \    i++;\n                                                                }\n\
    \                                                                if (i < string.length()\
    \ && string[i] == ']') {\n                                                   \
    \                 i++;\n                                                     \
    \               while (i < string.length() && string[i] != ']') {\n          \
    \                      \n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmphqy0o_ri.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmphqy0o_ri.cpp:92:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   92 | int main() {\n      |            ^\n/tmp/tmphqy0o_ri.cpp:108:1:\
    \ error: expected \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmphqy0o_ri.cpp:87:110:\
    \ note: to match this \u2018{\u2019\n   87 |                                 \
    \                                if (i < string.length() && string[i] == ']')\
    \ {\n      |                                                                 \
    \                                             ^\n/tmp/tmphqy0o_ri.cpp:108:1: error:\
    \ expected \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmphqy0o_ri.cpp:82:106:\
    \ note: to match this \u2018{\u2019\n   82 |                                 \
    \                            if (i < string.length() && string[i] == ']') {\n\
    \      |                                                                     \
    \                                     ^\n/tmp/tmphqy0o_ri.cpp:108:1: error: expected\
    \ \u2018}\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmphqy0o_ri.cpp:77:102:\
    \ note: to match this \u2018{\u2019\n   77 |                                 \
    \                        if (i < string.length() && string[i] == ']') {\n    \
    \  |                                                                         \
    \                             ^\n/tmp/tmphqy0o_ri.cpp:108:1: error: expected \u2018\
    }\u2019 at end of input\n  108 | }\n      | ^\n/tmp/tmphqy0o_ri.cpp:72:98: note:\
    \ to match this \u2018{\u2019\n   72 |                                       \
    \              if (i < string.length() && string[i] == ']') {\n      |       \
    \                                                                            \
    \               ^\n/tmp/tmphqy0o_ri.cpp:108:1: error: expected \u2018}\u2019 at\
    \ end of input\n  108 | }\n      | ^\n/tmp/tmphqy0o_ri.cpp:67:94: note: to match\
    \ this \u2018{\u2019\n   67 |                                                \
    \ if (i < string.length() && string[i] == ']') {\n      |                    \
    \                                                                          ^\n\
    /tmp/tmphqy0o_ri.cpp:108:1: error: expected \u2018}\u2019 at end"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n\
    \            count++;\n        }\n        if(string[i] == ']') {\n           \
    \ count--;\n        }\n        if(count == 0) {\n            flag = true;\n  \
    \          break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpgv2kohzn: /tmp/tmpgv2kohzn.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        else if (string[i] == ']') {\n \
    \           count--;\n        }\n        if (count == 0) {\n            flag =\
    \ true;\n            break;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmplwlo6c1n: /tmp/tmplwlo6c1n.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool result = true;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']')\
    \ {\n            result = false;\n            break;\n        } else if (string[i]\
    \ == ']' && string[i + 1] != ']') {\n            result = false;\n           \
    \ break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpspbym45t: /tmp/tmpspbym45t.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpsdxtreh2: /tmp/tmpsdxtreh2.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i=0;i<string.length();i++){\n  \
    \      if(string[i]=='['){\n            for(int j=i+1;j<string.length();j++){\n\
    \                if(string[j]=='['){\n                    for(int k=j+1;k<string.length();k++){\n\
    \                        if(string[k]==']'){\n                            for(int\
    \ l=k+1;l<string.length();l++){\n                                if(string[l]==']'){\n\
    \                                    return true;\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool result = true;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']')\
    \ {\n            result = false;\n            break;\n        } else if (string[i]\
    \ == '[' && string[i + 1] == ']') {\n            i += 2;\n        } else if (string[i]\
    \ == ']' && string[i + 1] == ']') {\n            i += 2;\n        } else if (string[i]\
    \ == ']' && string[i + 1] != '[') {\n            result = false;\n           \
    \ break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp47m782nd: /tmp/tmp47m782nd.cpp:34: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmppj_pxy1p: /tmp/tmppj_pxy1p.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp5ihtogii: /tmp/tmp5ihtogii.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int count = 0;\n    for (int i = 0; i <\
    \ string.size(); i++) {\n        if (string[i] == '[') {\n            count++;\n\
    \        }\n        if (string[i] == ']') {\n            count--;\n        }\n\
    \        if (count == 0) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpgo70w1gq: /tmp/tmpgo70w1gq.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpst76mwvp: /tmp/tmpst76mwvp.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        }\n        if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9d6idbb5: /tmp/tmp9d6idbb5.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int n = string.length();\n    bool flag = false;\n\
    \    for (int i = 0; i < n; i++) {\n        if (string[i] == '[') {\n        \
    \    flag = true;\n        } else if (string[i] == ']') {\n            flag =\
    \ false;\n        } else {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpnl_aop5r: /tmp/tmpnl_aop5r.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpxyh_343c: /tmp/tmpxyh_343c.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    for(int i = 0; i < string.size(); i++) {\n \
    \       if(string[i] == '[') {\n            found = true;\n        }\n       \
    \ if(string[i] == ']') {\n            found = false;\n        }\n    }\n    return\
    \ found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp4z3niebw: /tmp/tmp4z3niebw.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpy4dbjzi6: /tmp/tmpy4dbjzi6.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int i = 0;\n   \
    \ int j = 0;\n    int k = 0;\n    int count = 0;\n    while(i < string.size())\
    \ {\n        if(string[i] == '[') {\n            count++;\n        }\n       \
    \ if(string[i] == ']') {\n            count--;\n        }\n        if(count ==\
    \ 0) {\n            flag = true;\n        }\n        i++;\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp35sq_zsf: /tmp/tmp35sq_zsf.cpp:36: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmppvsa4gmx: /tmp/tmppvsa4gmx.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpvcvou05h: /tmp/tmpvcvou05h.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='['){\n            flag = true;\n        }\n        if(string[i]==']'){\n\
    \            flag = false;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp3hjy2knz: /tmp/tmp3hjy2knz.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        }\n        if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp43v2fxbp: /tmp/tmp43v2fxbp.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp80yjejsr: /tmp/tmp80yjejsr.cpp:18: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        else if(string[i] == ']') {\n            flag = false;\n        }\n \
    \   }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpl812yduq: /tmp/tmpl812yduq.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    for (int i = 0; i < n; ++i) {\n       \
    \ if (string[i] == '[' && string[i + 1] == '[') {\n            i += 2;\n     \
    \   } else if (string[i] == '[' && string[i + 1] != ']') {\n            return\
    \ false;\n        } else if (string[i] == '[' && string[i + 1] == ']') {\n   \
    \         i += 2;\n        } else if (string[i] == '[' && string[i + 1] != ']'\
    \ && string[i + 1] != ']') {\n            return false;\n        }\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpeeg9cm7v: /tmp/tmpeeg9cm7v.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    int count = 0;\n    for (int i = 0; i < n;\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpdznjyio8: /tmp/tmpdznjyio8.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpk6kt2aup: /tmp/tmpk6kt2aup.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp4nput35z: /tmp/tmp4nput35z.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i=0;i<string.length();i++){\n\
    \        if(string[i]=='[' && string[i+1]=='['){\n            flag = true;\n \
    \       }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpmjapbjea: /tmp/tmpmjapbjea.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpyte5n7dy: /tmp/tmpyte5n7dy.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.size(); i++) {\n  \
    \      if(string[i] == '[') {\n            flag = true;\n        }\n        if(string[i]\
    \ == ']') {\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpt70iglcz: /tmp/tmpt70iglcz.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp3qxsfrpn: /tmp/tmp3qxsfrpn.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp1uffzwke: /tmp/tmp1uffzwke.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpnmthbla2: /tmp/tmpnmthbla2.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int counter = 0;\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            opening_brackets++;\n  \
    \      }\n        if(string[i] == ']') {\n            closing_brackets++;\n  \
    \      }\n        if(opening_brackets == closing_brackets) {\n            counter++;\n\
    \        }\n    }\n    return counter == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpnmrjqly4: /tmp/tmpnmrjqly4.cpp:32: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp4oybgrsa: /tmp/tmp4oybgrsa.cpp:34: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpz3juoiut: /tmp/tmpz3juoiut.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    int count = 0;\n\
    \    for(int i = 0; i < string.size(); i++){\n        if(string[i] == '['){\n\
    \            count++;\n        }\n        if(string[i] == ']'){\n            count--;\n\
    \        }\n        if(count == 0){\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpfxx47rr8: /tmp/tmpfxx47rr8.cpp:34: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool found = false;\n    bool first = true;\n\
    \    bool last = false;\n    bool foundFirst = false;\n    bool foundLast = false;\n\
    \    bool foundFirstLast = false;\n    bool foundLastFirst = false;\n    bool\
    \ foundFirstLastFirst = false;\n    bool foundLastFirstFirst = false;\n    bool\
    \ foundFirstLastLast = false;\n    bool foundLastFirstLast = false;\n    bool\
    \ foundFirstLastLastFirst = false;\n    bool foundLastFirstLastFirst = false;\n\
    \    bool foundFirstLastLastLast = false;\n    bool foundLastFirstLastLast = false;\n\
    \    bool foundFirstLastLastLastFirst = false;\n    bool foundLastFirstLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLast = false;\n    bool foundLastFirstLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastFirst = false;\n    bool\
    \ foundLastFirstLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLast = false;\n    bool\
    \ foundFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundLastFirstLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLast = false;\n   \
    \ bool foundLastFirstLastLastLastLastLastLastLast = false;\n    bool foundFirstLastLastLastLastLastLastLastLastFirst\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n\
    \    bool foundFirstLastLastLastLastLastLastLastLastLast = false;\n    bool foundLastFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool foundFirstLastLastLastLastLastLastLastLastFirst = false;\n\
    \    bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n    bool foundFirstLastLastLastLastLastLastLastLastLast\
    \ = false;\n    bool foundLastFirstLastLastLastLastLastLastLastLast = false;\n\
    \    bool foundFirstLastLastLastLastLastLastLastLastLastFirst = false;\n    bool\
    \ foundLastFirstLastLastLastLastLastLastLastLastLastFirst = false;\n    bool foundFirstLastLast\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp18imh5t0.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp18imh5t0.cpp:52:10: error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLastLastLast\u2019\
    \n   52 |     bool foundLastFirstLastLastLastLastLastLastLast = false;\n     \
    \ |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp18imh5t0.cpp:48:10:\
    \ note: \u2018bool foundLastFirstLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   48 |     bool foundLastFirstLastLastLastLastLastLastLast =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp18imh5t0.cpp:53:10:\
    \ error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLastLastFirst\u2019\
    \n   53 |     bool foundFirstLastLastLastLastLastLastLastLastFirst = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp18imh5t0.cpp:49:10:\
    \ note: \u2018bool foundFirstLastLastLastLastLastLastLastLastFirst\u2019 previously\
    \ declared here\n   49 |     bool foundFirstLastLastLastLastLastLastLastLastFirst\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp18imh5t0.cpp:54:10: error: redeclaration of \u2018bool foundLastFirstLastLastLastLastLastLastLastFirst\u2019\
    \n   54 |     bool foundLastFirstLastLastLastLastLastLastLastFirst = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp18imh5t0.cpp:50:10:\
    \ note: \u2018bool foundLastFirstLastLastLastLastLastLastLastFirst\u2019 previously\
    \ declared here\n   50 |     bool foundLastFirstLastLastLastLastLastLastLastFirst\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp18imh5t0.cpp:55:10: error: redeclaration of \u2018bool foundFirstLastLastLastLastLastLastLastLastLast\u2019\
    \n   55 |     bool foundFirstLastLastLastLastLastLastLastLastLast = false;\n \
    \     |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp18imh5t0.cpp:51:10:\
    \ note: \u2018bool foundFirstLastLastLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   51 |     bool foundFirstLastLastLastLastLastLastLastLastLast\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp18imh5t0.cpp:60"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    // Your code here\n    \n    return\
    \ true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpv6bwrejn: /tmp/tmpv6bwrejn.cpp:22: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open_brackets = 0;\n    int close_brackets = 0;\n    for(int i =\
    \ 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n           \
    \ open_brackets++;\n        }\n        else if(string[i] == ']') {\n         \
    \   close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpp6ddln8n: /tmp/tmpp6ddln8n.cpp:29: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp2vebz_g7: /tmp/tmp2vebz_g7.cpp:18: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpvupvn6f8: /tmp/tmpvupvn6f8.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool found = false;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[') {\n            found = true;\n\
    \        }\n        if (string[i] == ']') {\n            if (found) {\n      \
    \          return true;\n            }\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpojrkrrz9: /tmp/tmpojrkrrz9.cpp:30: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    int counter = 0;\n    for (int i = 0; i <\
    \ string.size(); i++) {\n        if (string[i] == '[') {\n            counter++;\n\
    \        }\n        if (string[i] == ']') {\n            counter--;\n        }\n\
    \        if (counter < 0) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp1vwvdejl: /tmp/tmp1vwvdejl.cpp:32: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpuqmpwqbi: /tmp/tmpuqmpwqbi.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool open = false;\n    bool close = false;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            open = true;\n        } else if (string[i] == ']') {\n      \
    \      close = true;\n        } else if (open) {\n            open = false;\n\
    \        } else if (close) {\n            close = false;\n        } else {\n \
    \           found = true;\n        }\n    }\n    return found;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmprj1e1xl3: /tmp/tmprj1e1xl3.cpp:33: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpr6kkgapz: /tmp/tmpr6kkgapz.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    for (int i = 0; i < n; i++) {\n       \
    \ if (string[i] == '[' && string[i + 1] == '[') {\n            i += 2;\n     \
    \       while (i < n && string[i] != ']') {\n                i++;\n          \
    \  }\n            if (i == n) {\n                return true;\n            }\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpj_u4dv6t: /tmp/tmpj_u4dv6t.cpp:29: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        if(string[i] == '[') {\n            flag\
    \ = true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp18zpmk93: /tmp/tmp18zpmk93.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpbhvqjsgv: /tmp/tmpbhvqjsgv.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpebjlmh7o: /tmp/tmpebjlmh7o.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp0b69s8iv: /tmp/tmp0b69s8iv.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp25fe_tc0: /tmp/tmp25fe_tc0.cpp:271: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpc6u8z1kw: /tmp/tmpc6u8z1kw.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int open_brackets = 0;\n    int close_brackets\
    \ = 0;\n    int i = 0;\n    while(i < string.length()) {\n        if(string[i]\
    \ == '[') {\n            open_brackets++;\n        }\n        else if(string[i]\
    \ == ']') {\n            close_brackets++;\n        }\n        i++;\n    }\n \
    \   if(open_brackets == close_brackets) {\n        return true;\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpjzuawjkt: /tmp/tmpjzuawjkt.cpp:35: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i = 0; i < string.size(); i++) {\n\
    \        if(string[i] == '[') {\n            int count = 0;\n            for(int\
    \ j = i; j < string.size(); j++) {\n                if(string[j] == ']') {\n \
    \                   count++;\n                }\n            }\n            if(count\
    \ == 0) {\n                return false;\n            }\n        }\n    }\n  \
    \  return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpudrywhrx: /tmp/tmpudrywhrx.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // return true;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp0n5996ly: /tmp/tmp0n5996ly.cpp:19: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpprwuavna: /tmp/tmpprwuavna.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp80nm6p5r: /tmp/tmp80nm6p5r.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmphxn3hw3p: /tmp/tmphxn3hw3p.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp1xyz0jw_: /tmp/tmp1xyz0jw_.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp_k99s356: /tmp/tmp_k99s356.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool found = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            found = true;\n        }\n\
    \        if(string[i] == ']') {\n            found = false;\n        }\n    }\n\
    \    return found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpxgavimv6: /tmp/tmpxgavimv6.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            open++;\n        } else\
    \ if (string[i] == ']') {\n            close++;\n        }\n    }\n    if (open\
    \ != close) {\n        return false;\n    }\n    return true;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmppbyejavn: /tmp/tmppbyejavn.cpp:31: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        else if (string[i] == ']') {\n \
    \           count--;\n        }\n        if (count == 0) {\n            flag =\
    \ true;\n            break;\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp4mkzdsq2: /tmp/tmp4mkzdsq2.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; ++i) {\n        if (string[i] == '[') {\n            ++count;\n        }\
    \ else if (string[i] == ']') {\n            --count;\n        }\n        if (count\
    \ < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp5mygwvf4: /tmp/tmp5mygwvf4.cpp:31: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        } else\
    \ if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp3kgg9f3u: /tmp/tmp3kgg9f3u.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpofeg3a28: /tmp/tmpofeg3a28.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpu33g55ln: /tmp/tmpu33g55ln.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpac3_e7ye: /tmp/tmpac3_e7ye.cpp:271: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n\
    \        if (string[i] == ']') {\n            count--;\n        }\n        if\
    \ (count == 0) {\n            return true;\n        }\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmprckkmx8o: /tmp/tmprckkmx8o.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.size();\n    bool flag = false;\n    for (int i = 0; i\
    \ < n; i++) {\n        if (string[i] == '[' && string[i + 1] == '[') {\n     \
    \       flag = true;\n        }\n        if (string[i] == '[' && string[i + 1]\
    \ != ']') {\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp779kxn7p: /tmp/tmp779kxn7p.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp9wbl8zfc: /tmp/tmp9wbl8zfc.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int i = 0;\n    int j\
    \ = string.size() - 1;\n    while (i < j) {\n        if (string[i] == '[' && string[j]\
    \ == '[') {\n            flag = true;\n            i++;\n            j--;\n  \
    \      } else if (string[i] == '[' && string[j] == ']') {\n            i++;\n\
    \            j--;\n        } else if (string[i] == ']' && string[j] == ']') {\n\
    \            i++;\n            j--;\n        } else if (string[i] == ']' && string[j]\
    \ == '[') {\n            i++;\n            j--;\n        } else {\n          \
    \  i++;\n            j--;\n        }\n    }\n    return flag;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpc0pk9usj: /tmp/tmpc0pk9usj.cpp:40: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpm2q4mcb0: /tmp/tmpm2q4mcb0.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++){\n        if(string[i] == '[' && string[i+1] == '['){\n\
    \            flag = true;\n        }\n        if(string[i] == '[' && string[i+1]\
    \ != ']'){\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpra4n2zoe: /tmp/tmpra4n2zoe.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpk3kegfk8: /tmp/tmpk3kegfk8.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp25gde_c_: /tmp/tmp25gde_c_.cpp:271: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpc3ptm2ey: /tmp/tmpc3ptm2ey.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = false;\n    \n    // Iterate through each character in\
    \ the string\n    for(int i = 0; i < string.size(); i++) {\n        // If the\
    \ character is a left bracket, increment the count of left brackets\n        if(string[i]\
    \ == '[') {\n            ++left_brackets;\n        }\n        // If the character\
    \ is a right bracket, decrement the count of left brackets\n        else if(string[i]\
    \ == ']') {\n            --left_brackets;\n        }\n        // If the count\
    \ of left brackets is equal to zero, return true\n        if(left_brackets ==\
    \ 0) {\n            result = true;\n            break;\n        }\n    }\n   \
    \ \n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n   \
    \ assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpf7k8xk8x.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpf7k8xk8x.cpp:19:15: error: \u2018left_brackets\u2019 was not declared\
    \ in this scope\n   19 |             ++left_brackets;\n      |               ^~~~~~~~~~~~~\n\
    /tmp/tmpf7k8xk8x.cpp:23:15: error: \u2018left_brackets\u2019 was not declared\
    \ in this scope\n   23 |             --left_brackets;\n      |               ^~~~~~~~~~~~~\n\
    /tmp/tmpf7k8xk8x.cpp:26:12: error: \u2018left_brackets\u2019 was not declared\
    \ in this scope\n   26 |         if(left_brackets == 0) {\n      |           \
    \ ^~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.length();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpfqr5df92: /tmp/tmpfqr5df92.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9jzwfx8n: /tmp/tmp9jzwfx8n.cpp:271: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool res = false;\n    for (int i = 0;\
    \ i < n; i++) {\n        if (string[i] == '[') {\n            if (string[i + 1]\
    \ == '[') {\n                if (string[i + 2] == '[') {\n                   \
    \ if (string[i + 3] == '[') {\n                        if (string[i + 4] == '[')\
    \ {\n                            if (string[i + 5] == '[') {\n               \
    \                 if (string[i + 6] == '[') {\n                              \
    \      if (string[i + 7] == '[') {\n                                        if\
    \ (string[i + 8] == '[') {\n                                            if (string[i\
    \ + 9] == '[') {\n                                                if (string[i\
    \ + 10] == '[') {\n                                                    if (string[i\
    \ + 11] == '[') {\n                                                        res\
    \ = true;\n                                                    }\n           \
    \                                     }\n                                    \
    \        }\n                                        }\n                      \
    \              }\n                                }\n                        \
    \    }\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpemm1j1qj: /tmp/tmpemm1j1qj.cpp:46: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int counter = 0;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            counter++;\n        }\n\
    \        if(string[i] == ']') {\n            counter--;\n        }\n        if(counter\
    \ == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpiqi2jlii: /tmp/tmpiqi2jlii.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp2xt9okty: /tmp/tmp2xt9okty.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int len = string.length();\n    int count = 0;\n    for(int i = 0; i\
    \ < len; i++){\n        if(string[i] == '['){\n            count++;\n        }\n\
    \        else if(string[i] == ']'){\n            count--;\n        }\n       \
    \ if(count < 0){\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpwyt5cu_2: /tmp/tmpwyt5cu_2.cpp:32: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code goes here\n    \n    for(int i = 0; i < string.size(); i++)\
    \ {\n        if(string[i] == '[' && string[i+1] == '[') {\n            i += 2;\n\
    \            while(i < string.size() && string[i] != ']') {\n                i++;\n\
    \            }\n            if(i == string.size()) {\n                return true;\n\
    \            }\n            i += 1;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpakd1d2oe: /tmp/tmpakd1d2oe.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpiy2gq35s: /tmp/tmpiy2gq35s.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpw3v3j8o9: /tmp/tmpw3v3j8o9.cpp:18: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool open = false;\n    bool close = false;\n\
    \    bool open2 = false;\n    bool close2 = false;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            open = true;\n        \
    \    open2 = false;\n            close = false;\n            close2 = false;\n\
    \        }\n        if (string[i] == ']') {\n            close = true;\n     \
    \       close2 = false;\n            open = false;\n            open2 = false;\n\
    \        }\n        if (string[i] == '[' && open) {\n            open2 = true;\n\
    \        }\n        if (string[i] == ']' && close) {\n            close2 = true;\n\
    \        }\n        if (open2 && close2) {\n            found = true;\n      \
    \  }\n    }\n    return found;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpklgcuizq: /tmp/tmpklgcuizq.cpp:45: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = true;\n    int index = 0;\n    while(index < string.length())\
    \ {\n        if(string[index] == '[') {\n            bool found = false;\n   \
    \         for(int i = index + 1; i < string.length(); i++) {\n               \
    \ if(string[i] == '[') {\n                    found = true;\n                \
    \    break;\n                }\n            }\n            if(!found) {\n    \
    \            result = false;\n                break;\n            }\n        }\n\
    \        index++;\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp2gesmp_h: /tmp/tmp2gesmp_h.cpp:35: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmphgcp280y: /tmp/tmphgcp280y.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    bool flag = false;\n    int count = 0;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[')\
    \ {\n            count++;\n        }\n        if (string[i] == ']') {\n      \
    \      count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpe5ivedfa: /tmp/tmpe5ivedfa.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n         \
    \   count++;\n        }\n        else if(string[i] == ']') {\n            count--;\n\
    \        }\n        if(count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp2who39hp: /tmp/tmp2who39hp.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int n = string.size();\n    int count = 0;\n \
    \   for (int i = 0; i < n; i++) {\n        if (string[i] == '[') {\n         \
    \   count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            return true;\n        }\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpyqkfjdpo: /tmp/tmpyqkfjdpo.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpnat0t147: /tmp/tmpnat0t147.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        }\n \
    \       if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmptth44w2m: /tmp/tmptth44w2m.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    for(int i = 0; i\
    \ < string.size(); i++) {\n        if(string[i] == '[') {\n            flag =\
    \ true;\n        }\n        if(string[i] == ']') {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp8h0eh9tv: /tmp/tmp8h0eh9tv.cpp:28: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpy0xzew20: /tmp/tmpy0xzew20.cpp:271: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp_29d6i9c: /tmp/tmp_29d6i9c.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n     \
    \   if (string[i] == '[') {\n            count++;\n        } else if (string[i]\
    \ == ']') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        return true;\n        }\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpilnzh3fr: /tmp/tmpilnzh3fr.cpp:29: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpclm3pz3f: /tmp/tmpclm3pz3f.cpp:31: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpx21rzi2j: /tmp/tmpx21rzi2j.cpp:18: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool result = true;\n    int i = 0;\n    int j = string.size() - 1;\n\
    \    while (i < j) {\n        if (string[i] == '[' && string[j] == '[') {\n  \
    \          i++;\n            j--;\n        } else if (string[i] == '[' && string[j]\
    \ != ']') {\n            i++;\n        } else if (string[i] == '[' && string[j]\
    \ == ']') {\n            i++;\n            j++;\n        } else if (string[i]\
    \ == '[' && string[j] != ']' && string[j] != ']') {\n            result = false;\n\
    \            break;\n        } else if (string[i] == '[' && string[j] == ']')\
    \ {\n            i++;\n            j++;\n        } else {\n            i++;\n\
    \            j--;\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpvbdl5xv_: /tmp/tmpvbdl5xv_.cpp:41: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp8eyxy9kz: /tmp/tmp8eyxy9kz.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int start = 0;\n    int end = 0;\n    bool\
    \ flag = false;\n    while(end < string.length()){\n        if(string[end] ==\
    \ '[' && string[end+1] == ']'){\n            flag = true;\n            end = end\
    \ + 2;\n        }\n        else if(string[end] == '[' && string[end+1] != ']'){\n\
    \            flag = false;\n            end = end + 1;\n        }\n        else\
    \ if(string[end] == '[' && string[end+1] == ']'){\n            flag = true;\n\
    \            end = end + 2;\n        }\n        else if(string[end] == '[' &&\
    \ string[end+1] != ']'){\n            flag = false;\n            end = end + 1;\n\
    \        }\n        else if(string[end] == '[' && string[end+1] == ']'){\n   \
    \         flag = true;\n            end = end + 2;\n        }\n        else if(string[end]\
    \ == '[' && string[end+1] != ']'){\n            flag = false;\n            end\
    \ = end + 1;\n        }\n        else if(string[end] == '[' && string[end+1] ==\
    \ ']'){\n            flag = true;\n            end = end + 2;\n        }\n   \
    \     else if(string[end] == '[' && string[end+1] != ']'){\n            flag =\
    \ false;\n            end = end + 1;\n        }\n        else if(string[end] ==\
    \ '[' && string[end+1] == ']'){\n            flag = true;\n            end = end\
    \ + 2;\n        }\n        else if(string[end] == '[' && string[end+1] != ']'){\n\
    \            flag = false;\n            end = end + 1;\n        }\n        else\
    \ if(string[end] == '[' && string[end+1] == ']'){\n            flag = true;\n\
    \            end = end + 2;\n        }\n        else if(string[end] == '[' &&\
    \ string[end+1] != ']'){\n            flag = false;\n            end = end + 1;\n\
    \        }\n        else if(string[end] == '[' && string[end+1] == ']'){\n   \
    \         flag = true;\n            end = end + 2;\n        }\n        else if(string[end]\
    \ == '[' && string[end+1] != ']'){\n            flag = false;\n            end\
    \ = end + 1;\n        }\n        else if(string[end] == '[' && string[end+1] ==\
    \ ']'){\n            flag = true;\n            end = end + 2;\n        }\n   \
    \     else if(string[end] == '[' && string[end+1] != ']'){\n            flag =\
    \ false;\n            end = end + 1;\n        }\n        else if(string[end] ==\
    \ '[' && string[end+1] == ']'){\n            flag = true;\n            \n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj8m1lfcc.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpj8m1lfcc.cpp:86:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   86 | int main() {\n      |            ^\n/tmp/tmpj8m1lfcc.cpp:102:1:\
    \ error: expected \u2018}\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmpj8m1lfcc.cpp:17:33:\
    \ note: to match this \u2018{\u2019\n   17 |     while(end < string.length()){\n\
    \      |                                 ^\n/tmp/tmpj8m1lfcc.cpp:102:1: error:\
    \ expected \u2018}\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmpj8m1lfcc.cpp:12:36:\
    \ note: to match this \u2018{\u2019\n   12 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmpj8m1lfcc.cpp:102:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  102 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    // Write your code here\n    \n  \
    \  // Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp9nkhwkbs: /tmp/tmp9nkhwkbs.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpm5e5en5r: /tmp/tmpm5e5en5r.cpp:25: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp49jxy6mk: /tmp/tmp49jxy6mk.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == '[') {\n            count++;\n        } else\
    \ if (string[i] == ']') {\n            count--;\n        }\n        if (count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpg4b0rqhi: /tmp/tmpg4b0rqhi.cpp:31: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool is_nested = false;\n    int open = 0;\n\
    \    int close = 0;\n    for (int i = 0; i < string.length(); i++) {\n       \
    \ if (string[i] == '[') {\n            open++;\n        } else if (string[i] ==\
    \ ']') {\n            close++;\n        }\n        if (open > close) {\n     \
    \       is_nested = true;\n            found = true;\n        }\n    }\n    return\
    \ found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp6c78qjop: /tmp/tmp6c78qjop.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for(int\
    \ i = 0; i < string.size(); i++){\n        if(string[i] == '['){\n           \
    \ count++;\n        }\n        if(string[i] == ']'){\n            count--;\n \
    \       }\n        if(count < 0){\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpx5at4n6t: /tmp/tmpx5at4n6t.cpp:32: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    stack<char> s;\n    bool flag = false;\n    for (char c : string) {\n\
    \        if (c == '[') {\n            s.push(c);\n        } else if (c == ']')\
    \ {\n            if (s.empty()) {\n                flag = false;\n           \
    \     break;\n            } else {\n                flag = true;\n           \
    \     s.pop();\n            }\n        }\n    }\n    return flag;\n}\nint main()\
    \ {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm7rx66i1.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpm7rx66i1.cpp:13:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   13 |     stack<char> s;\n  \
    \    |     ^~~~~\n      |     std::stack\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpm7rx66i1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpm7rx66i1.cpp:13:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   13 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpm7rx66i1.cpp:17:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   17 |             s.push(c);\n      |             ^\n/tmp/tmpm7rx66i1.cpp:19:17:\
    \ error: \u2018s\u2019 was not declared in this scope\n   19 |             if\
    \ (s.empty()) {\n      |                 ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    for(int i=0;i<string.length();i++){\n  \
    \      if(string[i]=='['){\n            for(int j=i;j<string.length();j++){\n\
    \                if(string[j]=='['){\n                    for(int k=j+1;k<string.length();k++){\n\
    \                        if(string[k]==']'){\n                            for(int\
    \ l=k+1;l<string.length();l++){\n                                if(string[l]==']'){\n\
    \                                    return true;\n                          \
    \      }\n                            }\n                        }\n         \
    \           }\n                }\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpsa3825rx: /tmp/tmpsa3825rx.cpp:37: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    int counter = 0;\n    for (int i = 0; i\
    \ < string.size(); i++) {\n        if (string[i] == '[') {\n            counter++;\n\
    \        }\n        if (string[i] == ']') {\n            counter--;\n        }\n\
    \        if (counter < 0) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpcsivu95h: /tmp/tmpcsivu95h.cpp:32: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            flag = true;\n        }\n       \
    \ if(string[i] == ']') {\n            flag = false;\n        }\n    }\n    return\
    \ flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpa6hd_pp7: /tmp/tmpa6hd_pp7.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpd5pklb8r: /tmp/tmpd5pklb8r.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open_brackets = 0;\n    int close_brackets = 0;\n    for(int i =\
    \ 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n           \
    \ open_brackets++;\n        }\n        else if(string[i] == ']') {\n         \
    \   close_brackets++;\n        }\n    }\n    return open_brackets > 0 && close_brackets\
    \ > 0;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp2yq1mnvh: /tmp/tmp2yq1mnvh.cpp:28: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        else if (string[i] == ']') {\n        \
    \    count--;\n        }\n        if (count == 0) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    return flag;\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp17mw0p9s: /tmp/tmp17mw0p9s.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool found2 = false;\n    bool found3 = false;\n\
    \    bool found4 = false;\n    bool found5 = false;\n    bool found6 = false;\n\
    \    bool found7 = false;\n    bool found8 = false;\n    bool found9 = false;\n\
    \    bool found10 = false;\n    bool found11 = false;\n    bool found12 = false;\n\
    \    bool found13 = false;\n    bool found14 = false;\n    bool found15 = false;\n\
    \    bool found16 = false;\n    bool found17 = false;\n    bool found18 = false;\n\
    \    bool found19 = false;\n    bool found20 = false;\n    bool found21 = false;\n\
    \    bool found22 = false;\n    bool found23 = false;\n    bool found24 = false;\n\
    \    bool found25 = false;\n    bool found26 = false;\n    bool found27 = false;\n\
    \    bool found28 = false;\n    bool found29 = false;\n    bool found30 = false;\n\
    \    bool found31 = false;\n    bool found32 = false;\n    bool found33 = false;\n\
    \    bool found34 = false;\n    bool found35 = false;\n    bool found36 = false;\n\
    \    bool found37 = false;\n    bool found38 = false;\n    bool found39 = false;\n\
    \    bool found40 = false;\n    bool found41 = false;\n    bool found42 = false;\n\
    \    bool found43 = false;\n    bool found44 = false;\n    bool found45 = false;\n\
    \    bool found46 = false;\n    bool found47 = false;\n    bool found48 = false;\n\
    \    bool found49 = false;\n    bool found50 = false;\n    bool found51 = false;\n\
    \    bool found52 = false;\n    bool found53 = false;\n    bool found54 = false;\n\
    \    bool found55 = false;\n    bool found56 = false;\n    bool found57 = false;\n\
    \    bool found58 = false;\n    bool found59 = false;\n    bool found60 = false;\n\
    \    bool found61 = false;\n    bool found62 = false;\n    bool found63 = false;\n\
    \    bool found64 = false;\n    bool found65 = false;\n    bool found66 = false;\n\
    \    bool found67 = false;\n    bool found68 = false;\n    bool found69 = false;\n\
    \    bool found70 = false;\n    bool found71 = false;\n    bool found72 = false;\n\
    \    bool found73 = false;\n    bool found74 = false;\n    bool found75 = false;\n\
    \    bool found76 = false;\n    bool found77 = false;\n    bool found78 = false;\n\
    \    bool found79 = false;\n    bool found80 = false;\n    bool found81 = false;\n\
    \    bool found82 = false;\n    bool \n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxtgp5xnb.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpxtgp5xnb.cpp:96:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   96 | }\n      | ^\n/tmp/tmpxtgp5xnb.cpp:96:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    int count = 0;\n    for (int i = 0; i <\
    \ n; ++i) {\n        if (string[i] == '[') {\n            ++count;\n        }\n\
    \        else if (string[i] == ']') {\n            --count;\n        }\n    }\n\
    \    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n  \
    \  assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmptl2ocxkb: /tmp/tmptl2ocxkb.cpp:29: int main(): Assertion `candidate((\"\
    [][]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    int count = 0;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            count++;\n        }\n  \
    \      else if(string[i] == ']') {\n            count--;\n        }\n        if(count\
    \ == 0) {\n            flag = true;\n            break;\n        }\n    }\n  \
    \  return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpdn5xeeim: /tmp/tmpdn5xeeim.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int open = 0;\n    int close = 0;\n    int i = 0;\n    bool result =\
    \ false;\n    while (i < string.length()) {\n        if (string[i] == '[') {\n\
    \            open++;\n        } else if (string[i] == ']') {\n            close++;\n\
    \        }\n        i++;\n    }\n    if (open > close) {\n        result = true;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp02dry6nk: /tmp/tmp02dry6nk.cpp:32: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int i = 0;\n    int j = 0;\n    int k = 0;\n \
    \   int count = 0;\n    bool flag = false;\n    while (i < string.size()) {\n\
    \        if (string[i] == '[') {\n            count++;\n        }\n        if\
    \ (string[i] == ']') {\n            count--;\n        }\n        if (count ==\
    \ 0) {\n            flag = true;\n        }\n        i++;\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpdm908jz1: /tmp/tmpdm908jz1.cpp:36: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpqeei7pe1: /tmp/tmpqeei7pe1.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // Your code here\n    \n    // Your code\
    \ here\n    \n    // Your code here\n    \n    // Your code here\n    \n    //\
    \ Your code here\n    \n    // Your code here\n    \n    // Your code here\n \
    \   \n    // Your code here\n    \n    // \n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpf5ycx903: /tmp/tmpf5ycx903.cpp:163: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < string.size(); i++) {\n        if (string[i] == '[') {\n   \
    \         count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            flag = true;\n            break;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp6bvtk3ht: /tmp/tmp6bvtk3ht.cpp:33: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    bool flag = false;\n    for(int i = 0; i < string.size();\
    \ i++) {\n        if(string[i] == '[') {\n            flag = true;\n        }\n\
    \        if(string[i] == ']') {\n            flag = false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmp10km1_5p: /tmp/tmp10km1_5p.cpp:27: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n         \
    \   flag = true;\n        }\n        if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpyab6grv5: /tmp/tmpyab6grv5.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool flag = false;\n    for(int i = 0; i < string.size(); i++) {\n  \
    \      if(string[i] == '[') {\n            flag = true;\n        }\n        if(string[i]\
    \ == ']') {\n            flag = false;\n        }\n    }\n    return flag;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpa8kq_9zl: /tmp/tmpa8kq_9zl.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    bool first = true;\n    bool last = false;\n\
    \    bool inside = false;\n    bool firstInside = false;\n    bool lastInside\
    \ = false;\n    bool firstLast = false;\n    bool lastFirst = false;\n    bool\
    \ firstLastInside = false;\n    bool lastFirstInside = false;\n    bool firstLastLast\
    \ = false;\n    bool lastFirstLast = false;\n    bool firstLastLastInside = false;\n\
    \    bool lastFirstLastInside = false;\n    bool firstLastLastLast = false;\n\
    \    bool lastFirstLastLast = false;\n    bool firstLastLastLastInside = false;\n\
    \    bool lastFirstLastLastInside = false;\n    bool firstLastLastLastLast = false;\n\
    \    bool lastFirstLastLastLast = false;\n    bool firstLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastInside = false;\n    bool firstLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLast = false;\n    bool firstLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastInside = false;\n    bool firstLastLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLastLast = false;\n    bool firstLastLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastLastInside = false;\n    bool firstLastLastLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLastLastLast = false;\n    bool firstLastLastLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastLastLastInside = false;\n    bool\
    \ firstLastLastLastLastLastLastLastLast = false;\n    bool lastFirstLastLastLastLastLastLastLast\
    \ = false;\n    bool firstLastLastLastLastLastLastLastLastInside = false;\n  \
    \  bool lastFirstLastLastLastLastLastLastLastLastInside = false;\n    bool firstLastLastLastLastLastLastLastLastLast\
    \ = false;\n    bool lastFirstLastLastLastLastLastLastLastLast = false;\n    bool\
    \ firstLastLastLastLastLastLastLastLastLastInside = false;\n    bool lastFirstLastLastLastLastLastLastLastLastInside\
    \ = false;\n    bool firstLastLastLastLastLastLastLastLastLast = false;\n    bool\
    \ lastFirstLastLastLastLastLastLastLastLast = false;\n    bool firstLastLastLastLastLastLastLastLastLastInside\
    \ = false;\n    bool lastFirstLastLastLastLastLastLastLastLastInside = false;\n\
    \    bool firstLastLastLastLastLastLastLastLastLastLast = false;\n    bool lastFirstLastLast\n\
    }\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp475hy5y4.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmp475hy5y4.cpp:54:10: error: redeclaration of \u2018bool lastFirstLastLastLastLastLastLastLastLastInside\u2019\
    \n   54 |     bool lastFirstLastLastLastLastLastLastLastLastInside = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp475hy5y4.cpp:50:10:\
    \ note: \u2018bool lastFirstLastLastLastLastLastLastLastLastInside\u2019 previously\
    \ declared here\n   50 |     bool lastFirstLastLastLastLastLastLastLastLastInside\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp475hy5y4.cpp:55:10: error: redeclaration of \u2018bool firstLastLastLastLastLastLastLastLastLast\u2019\
    \n   55 |     bool firstLastLastLastLastLastLastLastLastLast = false;\n      |\
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp475hy5y4.cpp:51:10:\
    \ note: \u2018bool firstLastLastLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   51 |     bool firstLastLastLastLastLastLastLastLastLast =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp475hy5y4.cpp:56:10:\
    \ error: redeclaration of \u2018bool lastFirstLastLastLastLastLastLastLastLast\u2019\
    \n   56 |     bool lastFirstLastLastLastLastLastLastLastLast = false;\n      |\
    \          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp475hy5y4.cpp:52:10:\
    \ note: \u2018bool lastFirstLastLastLastLastLastLastLastLast\u2019 previously\
    \ declared here\n   52 |     bool lastFirstLastLastLastLastLastLastLastLast =\
    \ false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp475hy5y4.cpp:57:10:\
    \ error: redeclaration of \u2018bool firstLastLastLastLastLastLastLastLastLastInside\u2019\
    \n   57 |     bool firstLastLastLastLastLastLastLastLastLastInside = false;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp475hy5y4.cpp:53:10:\
    \ note: \u2018bool firstLastLastLastLastLastLastLastLastLastInside\u2019 previously\
    \ declared here\n   53 |     bool firstLastLastLastLastLastLastLastLastLastInside\
    \ = false;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp475hy5y4.cpp:58:10: error: redeclaration of \u2018bool l"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    int n = string.length();\n    bool res = true;\n    for(int i = 0; i\
    \ < n; i++) {\n        if(string[i] == '[' && string[i+1] == '[') {\n        \
    \    i += 2;\n            while(i < n && string[i] != ']') {\n               \
    \ i++;\n            }\n            if(i == n) return false;\n            i +=\
    \ 1;\n            while(i < n && string[i] != ']') {\n                i++;\n \
    \           }\n            if(i == n) return false;\n            i += 1;\n   \
    \         while(i < n && string[i] != ']') {\n                i++;\n         \
    \   }\n            if(i == n) return false;\n            i += 1;\n           \
    \ while(i < n && string[i] != ']') {\n                i++;\n            }\n  \
    \          if(i == n) return false;\n            i += 1;\n            while(i\
    \ < n && string[i] != ']') {\n                i++;\n            }\n          \
    \  if(i == n) return false;\n            i += 1;\n            while(i < n && string[i]\
    \ != ']') {\n                i++;\n            }\n            if(i == n) return\
    \ false;\n            i += 1;\n            while(i < n && string[i] != ']') {\n\
    \                i++;\n            }\n            if(i == n) return false;\n \
    \           i += 1;\n            while(i < n && string[i] != ']') {\n        \
    \        i++;\n            }\n            if(i == n) return false;\n         \
    \   i += 1;\n            while(i < n && string[i] != ']') {\n                i++;\n\
    \            }\n            if(i == n) return false;\n            i += 1;\n  \
    \          while(i < n && string[i] != ']') {\n                i++;\n        \
    \    }\n            if(i == n) return false;\n            i += 1;\n          \
    \  while(i < n && string[i] != ']') {\n                i++;\n            }\n \
    \           if(i == n) return false;\n            i += 1;\n            while(i\
    \ < n && string[i] != ']') {\n                i++;\n            }\n          \
    \  if(i == n) return false;\n            i += 1;\n            while(i < n && string[i]\
    \ != ']') {\n                i++;\n            }\n            if(i == n) return\
    \ false;\n            i += 1;\n            while(i < n && string[i] != ']') {\n\
    \                i++;\n            }\n            if(i == n) return false;\n \
    \           i += 1;\n            while(i < n && string[i] != ']') {\n        \
    \        i++;\n            }\n            if(i == n) return false;\n         \
    \   i += 1;\n            while(i < n && string[i] != ']') {\n                i++;\n\
    \            }\n            if(i == n) return false;\n            i += 1;\n  \
    \          while(i < n && string[i] != ']') {\n                i++;\n        \
    \    }\n            if(i == n) return false;\n            i += 1;\n          \
    \  while(i < \n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpnyny59p0.cpp: In function \u2018bool is_nested(std::string)\u2019\
    :\n/tmp/tmpnyny59p0.cpp:104:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  104 | }\n      | ^\n/tmp/tmpnyny59p0.cpp:103:22: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n  103 |             while(i <\n  \
    \    |                  ~   ^\n      |                      )\n  104 | }\n   \
    \   | ~                     \n/tmp/tmpnyny59p0.cpp:104:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  104 | }\n      | ^\n/tmp/tmpnyny59p0.cpp:105:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  105 | int main() {\n      |            ^\n/tmp/tmpnyny59p0.cpp:121:1: error:\
    \ expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmpnyny59p0.cpp:15:32:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i = 0; i < n; i++) {\n\
    \      |                                ^\n/tmp/tmpnyny59p0.cpp:121:1: error:\
    \ expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmpnyny59p0.cpp:12:36:\
    \ note: to match this \u2018{\u2019\n   12 | bool is_nested(std::string string)\
    \ {\n      |                                    ^\n/tmp/tmpnyny59p0.cpp:121:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n  121 | }\n\
    \      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    int n = string.length();\n    int count = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        if (string[i] == '[') {\n        \
    \    count++;\n        }\n        if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count == 0) {\n            return true;\n        }\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n \
    \   assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpasz47as4: /tmp/tmpasz47as4.cpp:32: int main(): Assertion `candidate((\"\
    []]]]]]][[[[[]\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    bool found = false;\n    for(int i = 0; i < string.length(); i++) {\n\
    \        if(string[i] == '[') {\n            found = true;\n        }\n      \
    \  if(string[i] == ']') {\n            found = false;\n        }\n    }\n    return\
    \ found;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpo99tif6r: /tmp/tmpo99tif6r.cpp:26: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Your code here\n    \n    bool flag = false;\n    \n    for(int i\
    \ = 0; i < string.size(); i++) {\n        if(string[i] == '[') {\n           \
    \ flag = true;\n        }\n        else if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpvgt9a0dn: /tmp/tmpvgt9a0dn.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// is_nested('[[]]')\
    \ \u279E True\n// is_nested('[]]]]]]][[[[[]') \u279E False\n// is_nested('[][]')\
    \ \u279E False\n// is_nested('[]') \u279E False\n// is_nested('[[][]]') \u279E\
    \ True\n// is_nested('[[]][[') \u279E True\nbool is_nested(std::string string)\
    \ {\n    // Write your code here\n    \n    bool flag = false;\n    \n    for(int\
    \ i = 0; i < string.length(); i++) {\n        if(string[i] == '[') {\n       \
    \     flag = true;\n        }\n        if(string[i] == ']') {\n            flag\
    \ = false;\n        }\n    }\n    \n    return flag;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  stdout: ''
  stderr: "tmpyu_ly139: /tmp/tmpyu_ly139.cpp:30: int main(): Assertion `candidate((\"\
    [[]]\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
