name: HumanEval_148_bf
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpk0w3oct0.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpk0w3oct0.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpk0w3oct0.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk0w3oct0.cpp:2:\n/tmp/tmpk0w3oct0.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpk0w3oct0.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpk0w3oct0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_velocity, planet2_orbital_velocity;\n    double planet1_eccentricity,\
    \ planet2_eccentricity;\n    double planet1_semi_major_axis, planet2_semi_major_axis;\n\
    \    double planet1_longitude, planet2_longitude;\n    double planet1_latitude,\
    \ planet2_latitude;\n    double planet1_orbital_period, planet2_orbital_period;\n\
    \    double planet1_eccentric_anomaly, planet2_eccentric_anomaly;\n    double\
    \ planet1_longitude_deg, planet2_longitude_deg;\n    double planet1_latitude_deg,\
    \ planet2_latitude_deg;\n    double planet1_orbital_period_deg, planet2_orbital_period_deg;\n\
    \    double planet1_eccentric_anomaly_deg, planet2_eccentric_anomaly_deg;\n  \
    \  double planet1_semi_major_axis_deg, planet2_semi_major_axis_deg;\n    double\
    \ planet1_longitude_deg_deg, planet2_longitude_deg_deg;\n    double planet1_latitude_deg_deg,\
    \ planet2_latitude_deg_deg;\n    double planet1_orbital_velocity_deg, planet2_orbital_velocity_deg;\n\
    \    double planet1_eccentricity_deg, planet2_eccentricity_deg;\n    double planet1_semi_major_axis_deg,\
    \ planet2_semi_major_axis_deg;\n    double planet1_longitude_deg_deg, planet2_longitude_deg_deg;\n\
    \    double planet1_latitude_deg_deg, planet2_latitude_deg_deg;\n    double planet1_orbital_distance_deg,\
    \ planet2_orbital_distance_deg;\n    double planet1_eccentric_anomaly_deg, planet2_eccentric_anomaly_deg;\n\
    \    double planet1_semi_major_axis_deg, planet2_semi_major_axis_deg;\n    double\
    \ planet1_longitude_deg_deg, planet2_longitude_deg_deg;\n    double planet1_latitude_deg_deg,\
    \ planet2_latitude_deg_deg;\n    double planet1_orbital_velocity_deg, planet2_orbital_velocity_deg;\n\
    \    double planet1_eccentricity_deg, planet2_eccentri\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpimwt3rjg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpimwt3rjg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpimwt3rjg.cpp:36:12: error: redeclaration\
    \ of \u2018double planet1_semi_major_axis_deg\u2019\n   36 |     double planet1_semi_major_axis_deg,\
    \ planet2_semi_major_axis_deg;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpimwt3rjg.cpp:31:12: note: \u2018double planet1_semi_major_axis_deg\u2019\
    \ previously declared here\n   31 |     double planet1_semi_major_axis_deg, planet2_semi_major_axis_deg;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpimwt3rjg.cpp:36:41: error:\
    \ redeclaration of \u2018double planet2_semi_major_axis_deg\u2019\n   36 |   \
    \  double planet1_semi_major_axis_deg, planet2_semi_major_axis_deg;\n      | \
    \                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpimwt3rjg.cpp:31:41:\
    \ note: \u2018double planet2_semi_major_axis_deg\u2019 previously declared here\n\
    \   31 |     double planet1_semi_major_axis_deg, planet2_semi_major_axis_deg;\n\
    \      |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpimwt3rjg.cpp:37:12: error: redeclaration of \u2018double planet1_longitude_deg_deg\u2019\
    \n   37 |     double planet1_longitude_deg_deg, planet2_longitude_deg_deg;\n \
    \     |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpimwt3rjg.cpp:32:12: note:\
    \ \u2018double planet1_longitude_deg_deg\u2019 previously declared here\n   32\
    \ |     double planet1_longitude_deg_deg, planet2_longitude_deg_deg;\n      |\
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpimwt3rjg.cpp:37:39: error: redeclaration\
    \ of \u2018double planet2_longitude_deg_deg\u2019\n   37 |     double planet1_longitude_deg_deg,\
    \ planet2_longitude_deg_deg;\n      |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpimwt3rjg.cpp:32:39: note: \u2018double planet2_longitude_deg_deg\u2019\
    \ previously declared here\n   32 |     double planet1_longitude_deg_deg, planet2_longitude_deg_deg;\n\
    \      |                                       ^~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1SunOrbitDistance,\
    \ planet2SunOrbitDistance;\n    double planet1SunOrbit, planet2SunOrbit;\n   \
    \ double planet1SunOrbitDistanceSquared = planet1SunOrbitDistance * planet1SunOrbitDistance;\n\
    \    double planet2SunOrbitDistanceSquared = planet2SunOrbitDistance * planet2SunOrbitDistance;\n\
    \    double planet1SunOrbitDistanceSquared = planet1SunOrbitDistance * planet1SunOrbitDistance;\n\
    \    double planet2SunOrbitDistanceSquared = planet2SunOrbitDistance * planet2SunOrbitDistance;\n\
    \    double planet1SunOrbitDistance = sqrt(planet1SunOrbitDistanceSquared);\n\
    \    double planet2SunOrbitDistance = sqrt(planet2SunOrbitDistanceSquared);\n\
    \    double planet1OrbitDistance = planet1OrbitDistance * planet1OrbitDistance;\n\
    \    double planet2OrbitDistance = planet2OrbitDistance * planet2OrbitDistance;\n\
    \    double planet1OrbitDistanceSquared = planet1OrbitDistance * planet1OrbitDistance;\n\
    \    double planet2OrbitDistanceSquared = planet2OrbitDistance * planet2OrbitDistance;\n\
    \    double planet1OrbitDistanceSquared = planet1OrbitDistance * planet1OrbitDistance;\n\
    \    double planet2OrbitDistanceSquared = planet2OrbitDistance * planet2OrbitDistance;\n\
    \    double planet1OrbitDistance = sqrt(planet1OrbitDistanceSquared);\n    double\
    \ planet2OrbitDistance = sqrt(planet2OrbitDistanceSquared);\n    double planet1OrbitDistanceSquared\
    \ = planet1OrbitDistance * planet1OrbitDistance;\n    double planet2OrbitDistanceSquared\
    \ = planet2OrbitDistance * planet2OrbitDistance;\n    double planet1OrbitDistance\
    \ = sqrt(planet1OrbitDistanceSquared);\n    double planet2OrbitDistance = sqrt(planet2OrbitDistanceSquared);\n\
    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa6429fer.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpa6429fer.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpa6429fer.cpp:23:12: error: redeclaration\
    \ of \u2018double planet1SunOrbitDistanceSquared\u2019\n   23 |     double planet1SunOrbitDistanceSquared\
    \ = planet1SunOrbitDistance * planet1SunOrbitDistance;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa6429fer.cpp:21:12: note: \u2018double planet1SunOrbitDistanceSquared\u2019\
    \ previously declared here\n   21 |     double planet1SunOrbitDistanceSquared\
    \ = planet1SunOrbitDistance * planet1SunOrbitDistance;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa6429fer.cpp:24:12: error: redeclaration of \u2018double planet2SunOrbitDistanceSquared\u2019\
    \n   24 |     double planet2SunOrbitDistanceSquared = planet2SunOrbitDistance\
    \ * planet2SunOrbitDistance;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa6429fer.cpp:22:12: note: \u2018double planet2SunOrbitDistanceSquared\u2019\
    \ previously declared here\n   22 |     double planet2SunOrbitDistanceSquared\
    \ = planet2SunOrbitDistance * planet2SunOrbitDistance;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa6429fer.cpp:25:12: error: redeclaration of \u2018double planet1SunOrbitDistance\u2019\
    \n   25 |     double planet1SunOrbitDistance = sqrt(planet1SunOrbitDistanceSquared);\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpa6429fer.cpp:19:12: note:\
    \ \u2018double planet1SunOrbitDistance\u2019 previously declared here\n   19 |\
    \     double planet1SunOrbitDistance, planet2SunOrbitDistance;\n      |      \
    \      ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpa6429fer.cpp:26:12: error: redeclaration\
    \ of \u2018double planet2SunOrbitDistance\u2019\n   26 |     double planet2SunOrbitDistance\
    \ = sqrt(planet2SunOrbitDistanceSquared);\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpa6429fer.cpp:19:37: note: \u2018double planet2SunOrbitDistance\u2019 previously\
    \ declared here\n   19 |     double planet1SunOrbitDistance, planet2SunOrbitDistance;\n\
    \      |         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1orb = planet1 + \"orbit\";\n\
    \    std::string planet2orb = planet2 + \"orbit\";\n    std::string planet1sun\
    \ = planet1 + \"sun\";\n    std::string planet2sun = planet2 + \"sun\";\n    std::string\
    \ planet1orbitorbit = planet1orb + planet2orbit;\n    std::string planet2orbitorbit\
    \ = planet2orb + planet1orbit;\n    std::string planet1orbitsun = planet1orb +\
    \ planet2sun;\n    std::string planet2orbitsun = planet2orb + planet1sun;\n  \
    \  std::string planet1orbitorbitorbitorbit = planet1orbitorbit + planet2orbitorbit;\n\
    \    std::string planet2orbitorbitorbit = planet2orbitorbit + planet1orbitorbit;\n\
    \    std::string planet1orbitorbitsun = planet1orbitorbit + planet2orbitsun;\n\
    \    std::string planet2orbitorbitsun = planet2orbitorbit + planet1orbitsun;\n\
    \    std::string planet1orbitorbitorbitorbitorbit = planet1orbitorbitorbit + planet2orbitorbitorbit;\n\
    \    std::string planet2orbitorbitorbit = planet2orbitorbit + planet1orbitorbit;\n\
    \    std::string planet1orbitorbitsun = planet1orbitorbit + planet2orbitsun;\n\
    \    std::string planet2orbitorbitsun = planet2orbitorbit + planet1orbitsun;\n\
    \    std::string planet1orbitorbitorbitorbitorbit = planet1orbitorbitorbit + planet2orbitorbitorbit;\n\
    \    std::string planet2orbitorbitorbit = planet2orbitorbit + planet1orbitorbit;\n\
    \    std::string planet1orbitorbitsun = planet1orbitorbit + planet2orbitsun;\n\
    \    std::string planet2orbitorbitsun = planet2orbitorbit + planet1orbitsun;\n\
    \    std::string planet1orbitorbitorbitorbit = planet1orbitorbitorbit + planet2orbitorbitorbit;\n\
    \    std::string planet2orbitorbitorbit = planet2orbitorbit + planet1orbitorbit;\n\
    \    std::string planet1orbitorbitsun = planet1orbitorbit + planet2orbitsun;\n\
    \    std::string planet2orbitorbitsun = planet2orbitorbit + planet1\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpawqze56b.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpawqze56b.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpawqze56b.cpp:21:50: error: \u2018\
    planet2orbit\u2019 was not declared in this scope; did you mean \u2018planet2orb\u2019\
    ?\n   21 |     std::string planet1orbitorbit = planet1orb + planet2orbit;\n  \
    \    |                                                  ^~~~~~~~~~~~\n      |\
    \                                                  planet2orb\n/tmp/tmpawqze56b.cpp:22:50:\
    \ error: \u2018planet1orbit\u2019 was not declared in this scope; did you mean\
    \ \u2018planet1orb\u2019?\n   22 |     std::string planet2orbitorbit = planet2orb\
    \ + planet1orbit;\n      |                                                  ^~~~~~~~~~~~\n\
    \      |                                                  planet1orb\n/tmp/tmpawqze56b.cpp:29:52:\
    \ error: \u2018planet1orbitorbitorbit\u2019 was not declared in this scope; did\
    \ you mean \u2018planet2orbitorbitorbit\u2019?\n   29 |     std::string planet1orbitorbitorbitorbitorbit\
    \ = planet1orbitorbitorbit + planet2orbitorbitorbit;\n      |                \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~\n      |         \
    \                                           planet2orbitorbitorbit\n/tmp/tmpawqze56b.cpp:30:17:\
    \ error: redeclaration of \u2018std::string planet2orbitorbitorbit\u2019\n   30\
    \ |     std::string planet2orbitorbitorbit = planet2orbitorbit + planet1orbitorbit;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpawqze56b.cpp:26:17: note:\
    \ \u2018std::string planet2orbitorbitorbit\u2019 previously declared here\n  \
    \ 26 |     std::string planet2orbitorbitorbit = planet2orbitorbit + planet1orbitorbit;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpawqze56b.cpp:31:17: error:\
    \ redeclaration of \u2018std::string planet1orbitorbitsun\u2019\n   31 |     std::string\
    \ planet1orbitorbitsun = planet1orbitorbit + planet2orbitsun;\n      |       \
    \          ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpawqze56b.cpp:27:17: note: \u2018std::string\
    \ planet1orbitorbitsun\u2019 previously declare"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1;\n    double distance2;\n    double distance3;\n\
    \    double distance4;\n    double distance5;\n    double distance6;\n    double\
    \ distance7;\n    double distance8;\n    double distance9;\n    double distance10;\n\
    \    double distance11;\n    double distance12;\n    double distance13;\n    double\
    \ distance14;\n    double distance15;\n    double distance16;\n    double distance17;\n\
    \    double distance18;\n    double distance19;\n    double distance20;\n    double\
    \ distance21;\n    double distance22;\n    double distance23;\n    double distance24;\n\
    \    double distance25;\n    double distance26;\n    double distance27;\n    double\
    \ distance28;\n    double distance29;\n    double distance30;\n    double distance31;\n\
    \    double distance32;\n    double distance33;\n    double distance34;\n    double\
    \ distance35;\n    double distance36;\n    double distance37;\n    double distance38;\n\
    \    double distance39;\n    double distance40;\n    double distance41;\n    double\
    \ distance42;\n    double distance43;\n    double distance44;\n    double distance45;\n\
    \    double distance46;\n    double distance47;\n    double distance48;\n    double\
    \ distance49;\n    double distance50;\n    double distance51;\n    double distance52;\n\
    \    double distance53;\n    double distance54;\n    double distance55;\n    double\
    \ distance56;\n    double distance57;\n    double distance58;\n    double distance59;\n\
    \    double distance60;\n    double distance61;\n    double distance62;\n    double\
    \ distance63;\n    double distance64;\n    double distance65;\n    double distance66;\n\
    \    double distance67;\n    double distance68;\n    double distance69;\n    double\
    \ distance70;\n    double distance71;\n    double distance72;\n    double distance73;\n\
    \    double distance74;\n    double distance75;\n    double distance76;\n    double\
    \ distance77;\n    double distance78;\n    double distance79;\n    double distance80;\n\
    \    double distance81;\n    double distance82;\n    double distance83;\n    double\
    \ distance84;\n    double distance85;\n    double \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpi1l67y0d.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpi1l67y0d.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpi1l67y0d.cpp:105:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmpi1l67y0d.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi1l67y0d.cpp:2:\n/tmp/tmpi1l67y0d.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpi1l67y0d.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpi1l67y0d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != planet2);\n    std::tuple<std::string,\
    \ > result;\n    std::string planet1_orbit, planet2_orbit;\n    double distance;\n\
    \    double sun_distance;\n    double sun_distance2;\n    double sun_distance3;\n\
    \    double sun_distance4;\n    double sun_distance5;\n    double sun_distance6;\n\
    \    double sun_distance7;\n    double sun_distance8;\n    double sun_distance9;\n\
    \    double sun_distance10;\n    double sun_distance11;\n    double sun_distance12;\n\
    \    double sun_distance13;\n    double sun_distance14;\n    double sun_distance15;\n\
    \    double sun_distance16;\n    double sun_distance17;\n    double sun_distance18;\n\
    \    double sun_distance19;\n    double sun_distance20;\n    double sun_distance21;\n\
    \    double sun_distance22;\n    double sun_distance23;\n    double sun_distance24;\n\
    \    double sun_distance25;\n    double sun_distance26;\n    double sun_distance27;\n\
    \    double sun_distance28;\n    double sun_distance29;\n    double sun_distance30;\n\
    \    double sun_distance31;\n    double sun_distance32;\n    double sun_distance33;\n\
    \    double sun_distance34;\n    double sun_distance35;\n    double sun_distance36;\n\
    \    double sun_distance37;\n    double sun_distance38;\n    double sun_distance39;\n\
    \    double sun_distance40;\n    double sun_distance41;\n    double sun_distance42;\n\
    \    double sun_distance43;\n    double sun_distance44;\n    double sun_distance45;\n\
    \    double sun_distance46;\n    double sun_distance47;\n    double sun_distance48;\n\
    \    double sun_distance49;\n    double sun_distance50;\n    double sun_distance51;\n\
    \    double sun_distance52;\n    double sun_distance53;\n    double sun_distance54;\n\
    \    double sun_distance55;\n    double sun_distance56;\n    double sun_distance57;\n\
    \    double sun_distance58;\n    double sun_distance59;\n    double sun_distance60;\n\
    \    double sun_distance61;\n    double sun_distance62;\n    double sun\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg_mfjv9y.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpg_mfjv9y.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpg_mfjv9y.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpg_mfjv9y.cpp:84:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   84 | }\n      | ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg_mfjv9y.cpp:2:\n/tmp/tmpg_mfjv9y.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpg_mfjv9y.cpp:87:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   87 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpg_mfjv9y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpks861ikz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpks861ikz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpks861ikz.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpks861ikz.cpp:2:\n/tmp/tmpks861ikz.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpks861ikz.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpks861ikz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.1;\n    double sun_mass\
    \ = 5.972e24;\n    double sun_eccentricity = 0.9157;\n    double sun_longitude\
    \ = 88.15; // degrees\n    double sun_latitude = 49.0; // degrees\n    double\
    \ planet_radius = 6378.1;\n    double planet_mass = 5.972e24;\n    double planet_eccentricity\
    \ = 0.9157;\n    double planet_longitude = 88.15; // degrees\n    double planet_latitude\
    \ = 49.0; // degrees\n    double planet_orbital_radius = planet_radius * cos(planet_latitude);\n\
    \    double planet_orbital_mass = planet_mass * cos(planet_latitude);\n    double\
    \ planet_orbital_eccentricity = planet_eccentricity * cos(planet_latitude);\n\
    \    double planet_orbital_longitude = planet_longitude * cos(planet_latitude);\n\
    \    double planet_orbital_latitude = planet_latitude * cos(planet_latitude);\n\
    \    double planet_orbital_distance = planet_orbital_radius * cos(planet_orbital_latitude);\n\
    \    double planet_orbital_velocity = planet_orbital_distance / planet_orbital_mass;\n\
    \    double planet_orbital_period = planet_orbital_velocity / planet_orbital_radius;\n\
    \    double planet_orbital_time = planet_orbital_period / 365.25;\n    double\
    \ planet_orbital_period2 = planet_orbital_time * planet_orbital_radius;\n    double\
    \ planet_orbital_period3 = planet_orbital_time * planet_orbital_radius * planet_orbital_radius;\n\
    \    double planet_orbital_period4 = planet_orbital_time * planet_orbital_radius\
    \ * planet_orbital_radius * planet_orbital_radius;\n    double planet_orbital_period5\
    \ = planet_orbital_time * planet_orbital_radius * planet_orbital_radius * planet_orbital_radius\
    \ * planet_orbital_radius * planet_orbital_radius;\n    double planet_orbital_period6\
    \ = planet_orbital_time * planet_orbital_radius * planet_orbital_radius * planet_orbital_radius\
    \ * planet_orbital_radius * planet_orbital_radius * planet_orbital_radius * planet_orbital_radius;\n\
    \    double planet_orbital_period7 = planet_orbital_time * planet_orbital_radius\
    \ * planet_orbital_radius * planet_orbital_radius * planet_\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe9vfo5qy.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpe9vfo5qy.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpe9vfo5qy.cpp:41:131: error: \u2018\
    planet_\u2019 was not declared in this scope; did you mean \u2018planet1\u2019\
    ?\n   41 |     double planet_orbital_period7 = planet_orbital_time * planet_orbital_radius\
    \ * planet_orbital_radius * planet_orbital_radius * planet_\n      |         \
    \                                                                            \
    \                                              ^~~~~~~\n      |              \
    \                                                                            \
    \                                         planet1\n/tmp/tmpe9vfo5qy.cpp:42:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   42 | }\n      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe9vfo5qy.cpp:2:\n/tmp/tmpe9vfo5qy.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpe9vfo5qy.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe9vfo5qy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018tem"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8zlf0psc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8zlf0psc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8zlf0psc.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8zlf0psc.cpp:2:\n/tmp/tmp8zlf0psc.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8zlf0psc.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8zlf0psc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_distance = 0;\n    double sun_radius\
    \ = 0.0;\n    double planet_distance = 0;\n    double planet_radius = 0.0;\n \
    \   double planet_orbit = 0.0;\n    double planet_orbit1 = 0.0;\n    double planet_orbit2\
    \ = 0.0;\n    double planet_orbit3 = 0.0;\n    double planet_orbit4 = 0.0;\n \
    \   double planet_orbit5 = 0.0;\n    double planet_orbit6 = 0.0;\n    double planet_orbit7\
    \ = 0.0;\n    double planet_orbit8 = 0.0;\n    double planet_orbit9 = 0.0;\n \
    \   double planet_orbit10 = 0.0;\n    double planet_orbit11 = 0.0;\n    double\
    \ planet_orbit12 = 0.0;\n    double planet_orbit13 = 0.0;\n    double planet_orbit14\
    \ = 0.0;\n    double planet_orbit15 = 0.0;\n    double planet_orbit16 = 0.0;\n\
    \    double planet_orbit17 = 0.0;\n    double planet_orbit18 = 0.0;\n    double\
    \ planet_orbit19 = 0.0;\n    double planet_orbit20 = 0.0;\n    double planet_orbit21\
    \ = 0.0;\n    double planet_orbit22 = 0.0;\n    double planet_orbit23 = 0.0;\n\
    \    double planet_orbit24 = 0.0;\n    double planet_orbit25 = 0.0;\n    double\
    \ planet_orbit26 = 0.0;\n    double planet_orbit27 = 0.0;\n    double planet_orbit28\
    \ = 0.0;\n    double planet_orbit29 = 0.0;\n    double planet_orbit30 = 0.0;\n\
    \    double planet_orbit31 = 0.0;\n    double planet_orbit32 = 0.0;\n    double\
    \ planet_orbit33 = 0.0;\n    double planet_orbit34 = 0.0;\n    double planet_orbit35\
    \ = 0.0;\n    double planet_orbit36 = 0.0;\n    double planet_orbit37 = 0.0;\n\
    \    double planet_orbit38 = 0.0;\n    double planet_orbit39 = 0.0;\n    double\
    \ planet_orbit40 = 0.0;\n    double planet_orbit41 = 0.0;\n    double planet_orbit42\
    \ = 0.0;\n    double planet_orbit43 = 0.0;\n    double planet_orbit44 = 0.0;\n\
    \    double planet_orbit45 = 0.0;\n    double planet_orbit46 = 0.0;\n    double\
    \ planet_orbit47 = 0.0;\n    double planet_orbit48 = 0.0;\n    double planet_orbit49\
    \ = 0.0;\n    double planet_orbit50 = 0.0;\n    double planet_orbit51 = 0.0;\n\
    \    double planet_orbit52 = 0.\n}\nint main() {\n    auto candidate = bf;\n \
    \   assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpze491ont.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpze491ont.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpze491ont.cpp:74:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   74 | }\n     \
    \ | ^\n/tmp/tmpze491ont.cpp:74:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpze491ont.cpp:2:\n/tmp/tmpze491ont.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpze491ont.cpp:77:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   77 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpze491ont.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_distance = std::abs(planet1.length()\
    \ - planet2.length());\n    double sun_radius = 6378.1;\n    double sun_angle\
    \ = std::atan2(planet1.length(), planet2.length());\n    double sun_x = sun_radius\
    \ * cos(sun_angle);\n    double sun_y = sun_radius * sin(sun_angle);\n    double\
    \ sun_distance = sqrt(sun_x * sun_x + sun_y * sun_y);\n    double sun_radius =\
    \ 6378.1;\n    double sun_angle = std::atan2(planet1.length(), planet2.length());\n\
    \    double sun_x = sun_radius * cos(sun_angle);\n    double sun_y = sun_radius\
    \ * sin(sun_angle);\n    double sun_distance = sqrt(sun_x * sun_x + sun_y * sun_y);\n\
    \    double sun_radius = 6378.1;\n    double sun_angle = std::atan2(planet1.length(),\
    \ planet2.length());\n    double sun_x = sun_radius * cos(sun_angle);\n    double\
    \ sun_y = sun_radius * sin(sun_angle);\n    double sun_distance = sqrt(sun_x *\
    \ sun_x + sun_y * sun_y);\n    double sun_radius = 6378.1;\n    double sun_angle\
    \ = std::atan2(planet1.length(), planet2.length());\n    double sun_x = sun_radius\
    \ * cos(sun_angle);\n    double sun_y = sun_radius * sin(sun_angle);\n    double\
    \ sun_distance = sqrt(sun_x * sun_x + sun_y * sun_y);\n    double sun_radius =\
    \ 6378.1;\n    double sun_angle = std::atan2(planet1.length(), planet2.length());\n\
    \    double sun_x = sun_radius * cos(sun_angle);\n    double sun_y = sun_radius\
    \ * sin(sun_angle);\n    double sun_distance = sqrt(sun_x * sun_x + sun_y * sun_y);\n\
    \    double sun_radius = 6378.1;\n    double sun_angle = std::atan2(planet1.length(),\
    \ planet2.length());\n    double sun_x = sun_radius * cos(sun_angle);\n    double\
    \ sun_y = sun_radius * sin(sun_angle);\n    double sun_distance = sqrt(sun_x *\
    \ sun_x + sun_y * sun_y);\n    double sun_radius = 6378.1;\n    double sun_angle\
    \ = std::atan2(planet1.length(), planet2.\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmporf0p59_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmporf0p59_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmporf0p59_.cpp:17:71: error: call\
    \ of overloaded \u2018abs(std::__cxx11::basic_string<char>::size_type)\u2019 is\
    \ ambiguous\n   17 |     double sun_distance = std::abs(planet1.length() - planet2.length());\n\
    \      |                                                                     \
    \  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmporf0p59_.cpp:2:\n/usr/include/stdlib.h:770:12:\
    \ note: candidate: \u2018int abs(int)\u2019\n  770 | extern int abs (int __x)\
    \ __THROW __attribute__ ((__const__)) __wur;\n      |            ^~~\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmporf0p59_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:56:3:\
    \ note: candidate: \u2018long int std::abs(long int)\u2019\n   56 |   abs(long\
    \ __i) { return __builtin_labs(__i); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:61:3:\
    \ note: candidate: \u2018long long int std::abs(long long int)\u2019\n   61 |\
    \   abs(long long __x) { return __builtin_llabs (__x); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:71:3:\
    \ note: candidate: \u2018constexpr double std::abs(double)\u2019\n   71 |   abs(double\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:75:3:\
    \ note: candidate: \u2018constexpr float std::abs(float)\u2019\n   75 |   abs(float\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance;\n    double distance2;\n    double\
    \ distance3;\n    double distance4;\n    double distance5;\n    double distance6;\n\
    \    double distance7;\n    double distance8;\n    double distance9;\n    double\
    \ distance10;\n    double distance11;\n    double distance12;\n    double distance13;\n\
    \    double distance14;\n    double distance15;\n    double distance16;\n    double\
    \ distance17;\n    double distance18;\n    double distance19;\n    double distance20;\n\
    \    double distance21;\n    double distance22;\n    double distance23;\n    double\
    \ distance24;\n    double distance25;\n    double distance26;\n    double distance27;\n\
    \    double distance28;\n    double distance29;\n    double distance30;\n    double\
    \ distance31;\n    double distance32;\n    double distance33;\n    double distance34;\n\
    \    double distance35;\n    double distance36;\n    double distance37;\n    double\
    \ distance38;\n    double distance39;\n    double distance40;\n    double distance41;\n\
    \    double distance42;\n    double distance43;\n    double distance44;\n    double\
    \ distance45;\n    double distance46;\n    double distance47;\n    double distance48;\n\
    \    double distance49;\n    double distance50;\n    double distance51;\n    double\
    \ distance52;\n    double distance53;\n    double distance54;\n    double distance55;\n\
    \    double distance56;\n    double distance57;\n    double distance58;\n    double\
    \ distance59;\n    double distance60;\n    double distance61;\n    double distance62;\n\
    \    double distance63;\n    double distance64;\n    double distance65;\n    double\
    \ distance66;\n    double distance67;\n    double distance68;\n    double distance69;\n\
    \    double distance70;\n    double distance71;\n    double distance72;\n    double\
    \ distance73;\n    double distance74;\n    double distance75;\n    double distance76;\n\
    \    double distance77;\n    double distance78;\n    double distance79;\n    double\
    \ distance80;\n    double distance81;\n    double distance82;\n    double distance83;\n\
    \    double distance84;\n    double distance85;\n    double distance86;\n    double\
    \ distance87;\n    double distance88;\n    double distance89\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe4vckn72.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpe4vckn72.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpe4vckn72.cpp:106:1: error: expected\
    \ initializer before \u2018}\u2019 token\n  106 | }\n      | ^\n/tmp/tmpe4vckn72.cpp:106:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe4vckn72.cpp:2:\n/tmp/tmpe4vckn72.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpe4vckn72.cpp:109:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  109 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpe4vckn72.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Write your code here\n    \n    return\
    \ std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpwwo_mtd6.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpwwo_mtd6.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpwwo_mtd6.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwwo_mtd6.cpp:2:\n/tmp/tmpwwo_mtd6.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpwwo_mtd6.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwwo_mtd6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6e12wo55.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp6e12wo55.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp6e12wo55.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6e12wo55.cpp:2:\n/tmp/tmp6e12wo55.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp6e12wo55.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6e12wo55.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // your code goes here\n    \n    \n    return\
    \ std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpolseursi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpolseursi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpolseursi.cpp:21:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   21 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpolseursi.cpp:2:\n/tmp/tmpolseursi.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpolseursi.cpp:25:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   25 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpolseursi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Write your code here\n    \n    return\
    \ std::tuple<std::string, >();\n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp28d7i243.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp28d7i243.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp28d7i243.cpp:20:36: error: template\
    \ argument 2 is invalid\n   20 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp28d7i243.cpp:2:\n/tmp/tmp28d7i243.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp28d7i243.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp28d7i243.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance2;\n    double distance3;\n    double distance4;\n\
    \    double distance5;\n    double distance6;\n    double distance7;\n    double\
    \ distance8;\n    double distance9;\n    double distance10;\n    double distance11;\n\
    \    double distance12;\n    double distance13;\n    double distance14;\n    double\
    \ distance15;\n    double distance16;\n    double distance17;\n    double distance18;\n\
    \    double distance19;\n    double distance20;\n    double distance21;\n    double\
    \ distance22;\n    double distance23;\n    double distance24;\n    double distance25;\n\
    \    double distance26;\n    double distance27;\n    double distance28;\n    double\
    \ distance29;\n    double distance30;\n    double distance31;\n    double distance32;\n\
    \    double distance33;\n    double distance34;\n    double distance35;\n    double\
    \ distance36;\n    double distance37;\n    double distance38;\n    double distance39;\n\
    \    double distance40;\n    double distance41;\n    double distance42;\n    double\
    \ distance43;\n    double distance44;\n    double distance45;\n    double distance46;\n\
    \    double distance47;\n    double distance48;\n    double distance49;\n    double\
    \ distance50;\n    double distance51;\n    double distance52;\n    double distance53;\n\
    \    double distance54;\n    double distance55;\n    double distance56;\n    double\
    \ distance57;\n    double distance58;\n    double distance59;\n    double distance60;\n\
    \    double distance61;\n    double distance62;\n    double distance63;\n    double\
    \ distance64;\n    double distance65;\n    double distance66;\n    double distance67;\n\
    \    double distance68;\n    double distance69;\n    double distance70;\n    double\
    \ distance71;\n    double distance72;\n    double distance73;\n    double distance74;\n\
    \    double distance75;\n    double distance76;\n    double distance77;\n    double\
    \ distance78;\n    double distance79;\n    double distance80;\n    double distance81;\n\
    \    double distance82;\n    double distance83;\n    double distance84;\n    double\
    \ distance85;\n    double distance86;\n    \n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpd5avubn9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpd5avubn9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpd5avubn9.cpp:105:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  105 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd5avubn9.cpp:2:\n/tmp/tmpd5avubn9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpd5avubn9.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpd5avubn9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceToSun,\
    \ planet2OrbitDistanceToSun;\n    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlan\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpds1cy8nt.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpds1cy8nt.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpds1cy8nt.cpp:26:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   26 | }\n      | ^\n/tmp/tmpds1cy8nt.cpp:26:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpds1cy8nt.cpp:2:\n/tmp/tmpds1cy8nt.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpds1cy8nt.cpp:29:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   29 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpds1cy8nt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy12cci0j.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpy12cci0j.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpy12cci0j.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy12cci0j.cpp:2:\n/tmp/tmpy12cci0j.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpy12cci0j.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy12cci0j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpv05wm8cn.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpv05wm8cn.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpv05wm8cn.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv05wm8cn.cpp:2:\n/tmp/tmpv05wm8cn.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpv05wm8cn.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpv05wm8cn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpabngnd8v.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpabngnd8v.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpabngnd8v.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpabngnd8v.cpp:2:\n/tmp/tmpabngnd8v.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpabngnd8v.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpabngnd8v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzky8pch2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzky8pch2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzky8pch2.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzky8pch2.cpp:2:\n/tmp/tmpzky8pch2.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzky8pch2.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzky8pch2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpub_7cb3p.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpub_7cb3p.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpub_7cb3p.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpub_7cb3p.cpp:2:\n/tmp/tmpub_7cb3p.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpub_7cb3p.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpub_7cb3p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Write your code here\n    \n    return\
    \ std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp48zpj33v.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp48zpj33v.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp48zpj33v.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp48zpj33v.cpp:2:\n/tmp/tmp48zpj33v.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp48zpj33v.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp48zpj33v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1orb = planet1 + \"Orbit\";\n\
    \    std::string planet2orb = planet2 + \"Orbit\";\n    std::string planet1sun\
    \ = planet1 + \"Sun\";\n    std::string planet2sun = planet2 + \"Sun\";\n    std::string\
    \ planet1orbsun = planet1orb + planet1sun;\n    std::string planet2orbsun = planet2orb\
    \ + planet2sun;\n    std::string planet1orbsunorb = planet1orbsun + planet2orbsun;\n\
    \    std::string planet2orbsunorb = planet2orbsun + planet1orbsun;\n    std::string\
    \ planet1orbsunorbsun = planet1orbsunorb + planet2orbsun;\n    std::string planet2orbsunorbsun\
    \ = planet2orbsunorb + planet1orbsun;\n    std::string planet1orbsunorbsunorbsun\
    \ = planet1orbsunorbsun + planet2orbsun;\n    std::string planet2orbsunorbsunorbsun\
    \ = planet2orbsunorbsun + planet1orbsun;\n    std::string planet1orbsunorbsunorbsunorbsun\
    \ = planet1orbsunorbsunorbsun + planet2orbsun;\n    std::string planet2orbsunorbsunorbsunorbsun\
    \ = planet2orbsunorbsunorbsun + planet1orbsun;\n    std::string planet1orbsunorbsunorbsunorbsunorbsun\
    \ = planet1orbsunorbsunorbsunorbsun + planet2orbsun;\n    std::string planet2orbsunorbsunorbsunorbsunorbsun\
    \ = planet2orbsunorbsunorbsunorbsun + planet1orbsun;\n    std::string planet1orbsunorbsunorbsunorbsunorbsunorbsun\
    \ = planet1orbsunorbsunorbsunorbsunorbsun + planet2orbsun;\n    std::string planet2orbsunorbsunorbsunorbsunorb\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbl3z2bls.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbl3z2bls.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbl3z2bls.cpp:35:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   35 | }\n      | ^\n/tmp/tmpbl3z2bls.cpp:35:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbl3z2bls.cpp:2:\n/tmp/tmpbl3z2bls.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbl3z2bls.cpp:38:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   38 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbl3z2bls.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    double a1 = 0.0;\n    double a2 = 0.0;\n \
    \   double b1 = 0.0;\n    double b2 = 0.0;\n    double c1 = 0.0;\n    double c2\
    \ = 0.0;\n    double d1 = 0.0;\n    double d2 = 0.0;\n    double e1 = 0.0;\n \
    \   double e2 = 0.0;\n    double f1 = 0.0;\n    double f2 = 0.0;\n    double g1\
    \ = 0.0;\n    double g2 = 0.0;\n    double h1 = 0.0;\n    double h2 = 0.0;\n \
    \   double i1 = 0.0;\n    double i2 = 0.0;\n    double j1 = 0.0;\n    double j2\
    \ = 0.0;\n    double k1 = 0.0;\n    double k2 = 0.0;\n    double l1 = 0.0;\n \
    \   double l2 = 0.0;\n    double m1 = 0.0;\n    double m2 = 0.0;\n    double n1\
    \ = 0.0;\n    double n2 = 0.0;\n    double o1 = 0.0;\n    double o2 = 0.0;\n \
    \   double p1 = 0.0;\n    double p2 = 0.0;\n    double q1 = 0.0;\n    double q2\
    \ = 0.0;\n    double r1 = 0.0;\n    double r2 = 0.0;\n    double s1 = 0.0;\n \
    \   double s2 = 0.0;\n    double t1 = 0.0;\n    double t2 = 0.0;\n    double u1\
    \ = 0.0;\n    double u2 = 0.0;\n    double v1 = 0.0;\n    double v2 = 0.0;\n \
    \   double w1 = 0.0;\n    double w2 = 0.0;\n    double x1 = 0.0;\n    double x2\
    \ = 0.0;\n    double y1 = 0.0;\n    double y2 = 0.0;\n    double z1 = 0.0;\n \
    \   double z2 = 0.0;\n    double a3 = 0.0;\n    double b3 = 0.0;\n    double c3\
    \ = 0.0;\n    double d3 = 0.0;\n    double e3 = 0.0;\n    double f3 = 0.0;\n \
    \   double g3 = 0.0;\n    double h3 = 0.0;\n    double i3 = 0.0;\n    double j3\
    \ = 0.0;\n    double k3 = 0.0;\n    double l3 = 0.0;\n    double m3 = 0.0;\n \
    \   double n3 = 0.0;\n    double o3 = 0.0;\n    double p3 = 0.0;\n    double q3\
    \ = 0.0;\n    double r3 = 0.0;\n    double s3 = 0.0;\n    double t3 = 0.0;\n \
    \   double u3 = 0.0;\n    double v3 = 0.0;\n    double \n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2t8chdo8.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp2t8chdo8.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp2t8chdo8.cpp:93:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n   93 | }\n      | ^\n/tmp/tmp2t8chdo8.cpp:93:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2t8chdo8.cpp:2:\n/tmp/tmp2t8chdo8.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp2t8chdo8.cpp:96:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   96 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2t8chdo8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptpsd72qu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptpsd72qu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptpsd72qu.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptpsd72qu.cpp:2:\n/tmp/tmptpsd72qu.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmptpsd72qu.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptpsd72qu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprfp22fws.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmprfp22fws.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmprfp22fws.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprfp22fws.cpp:2:\n/tmp/tmprfp22fws.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmprfp22fws.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprfp22fws.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpont4yvc_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpont4yvc_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpont4yvc_.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpont4yvc_.cpp:2:\n/tmp/tmpont4yvc_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpont4yvc_.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpont4yvc_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.137;\n    double planet_radius\
    \ = 6378.137;\n    double planet_separation = planet_radius - sun_radius;\n  \
    \  double planet_separation_sq = planet_separation * planet_separation;\n    double\
    \ planet_separation_sq2 = planet_separation_sq * planet_separation_sq;\n    double\
    \ planet_separation_sq3 = planet_separation_sq2 * planet_separation_sq;\n    double\
    \ planet_separation_sq4 = planet_separation_sq3 * planet_separation_sq;\n    double\
    \ planet_separation_sq5 = planet_separation_sq4 * planet_separation_sq;\n    double\
    \ planet_separation_sq6 = planet_separation_sq5 * planet_separation_sq;\n    double\
    \ planet_separation_sq7 = planet_separation_sq6 * planet_separation_sq;\n    double\
    \ planet_separation_sq8 = planet_separation_sq7 * planet_separation_sq;\n    double\
    \ planet_separation_sq9 = planet_separation_sq8 * planet_separation_sq;\n    double\
    \ planet_separation_sq10 = planet_separation_sq9 * planet_separation_sq;\n   \
    \ double planet_separation_sq11 = planet_separation_sq10 * planet_separation_sq;\n\
    \    double planet_separation_sq12 = planet_separation_sq11 * planet_separation_sq;\n\
    \    double planet_separation_sq13 = planet_separation_sq12 * planet_separation_sq;\n\
    \    double planet_separation_sq14 = planet_separation_sq13 * planet_separation_sq;\n\
    \    double planet_separation_sq15 = planet_separation_sq14 * planet_separation_sq;\n\
    \    double planet_separation_sq16 = planet_separation_sq15 * planet_separation_sq;\n\
    \    double planet_separation_sq17 = planet_separation_sq16 * planet_separation_sq;\n\
    \    double planet_separation_sq18 = planet_separation_sq17 * planet_separation_sq;\n\
    \    double planet_separation_sq19 = planet_separation_sq18 * planet_separation_sq;\n\
    \    double planet_separation_sq20 = planet_separation_sq19 * planet_separation_sq;\n\
    \    double planet_separation_sq21 = planet_separation_sq20 * planet_separation_sq;\n\
    \    double planet_separation_sq22 = planet_separation_sq\n}\nint main() {\n \
    \   auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfak__nt9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfak__nt9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfak__nt9.cpp:42:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   42 | }\n     \
    \ | ^\n/tmp/tmpfak__nt9.cpp:42:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfak__nt9.cpp:2:\n/tmp/tmpfak__nt9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfak__nt9.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfak__nt9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    std::tuple<std::string,\
    \ > result;\n    if (planet1 == planet2) {\n        result = std::make_tuple(planet1);\n\
    \        return result;\n    }\n    if (planet1 == \"Mercury\") {\n        if\
    \ (planet2 == \"Venus\") {\n            result = std::make_tuple(planet1, planet2);\n\
    \            return result;\n        }\n        if (planet2 == \"Earth\") {\n\
    \            result = std::make_tuple(planet1, planet2);\n            return result;\n\
    \        }\n        if (planet2 == \"Mars\") {\n            result = std::make_tuple(planet1,\
    \ planet2);\n            return result;\n        }\n        if (planet2 == \"\
    Jupiter\") {\n            result = std::make_tuple(planet1, planet2);\n      \
    \      return result;\n        }\n        if (planet2 == \"Saturn\") {\n     \
    \       result = std::make_tuple(planet1, planet2);\n            return result;\n\
    \        }\n        if (planet2 == \"Uranus\") {\n            result = std::make_tuple(planet1,\
    \ planet2);\n            return result;\n        }\n        if (planet2 == \"\
    Neptune\") {\n            result = std::make_tuple(planet1, planet2);\n      \
    \      return result;\n        }\n    }\n    if (planet1 == \"Venus\") {\n   \
    \     if (planet2 == \"Mercury\") {\n            result = std::make_tuple(planet1,\
    \ planet2);\n            return result;\n        }\n        if (planet2 == \"\
    Earth\") {\n            result = std::make_tuple(planet1, planet2);\n        \
    \    return result;\n        }\n        if (planet2 == \"Mars\") {\n         \
    \   result = std::make_tuple(planet1, planet2);\n            return result;\n\
    \        }\n        if (planet2 == \"Jupiter\") {\n            result = std::make_tuple(planet1,\
    \ planet2);\n            return result;\n        }\n        if (planet2 == \"\
    Saturn\") {\n            result = std::make_tuple(planet1, planet2);\n       \
    \     return result;\n        }\n        if (planet2 == \"Uranus\") {\n      \
    \      result = std::make_tuple(planet1, planet2);\n\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvoaql085.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpvoaql085.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpvoaql085.cpp:19:29: error: template\
    \ argument 2 is invalid\n   19 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpvoaql085.cpp:21:33: error: cannot convert\
    \ \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >\u2019 to \u2018int\u2019 in assignment\n   21 |         result = std::make_tuple(planet1);\n\
    \      |                  ~~~~~~~~~~~~~~~^~~~~~~~~\n      |                  \
    \               |\n      |                                 std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpvoaql085.cpp:26:37:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   26 |   \
    \          result = std::make_tuple(planet1, planet2);\n      |              \
    \        ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                          \
    \           |\n      |                                     std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\n/tmp/tmpvoaql085.cpp:30:37:\
    \ error: cannot convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in assignment\n   30 |   \
    \          result = std::make_tuple(planet1, planet2);\n      |              \
    \        ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n      |                          \
    \           |\n      |                                     std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxsipof8f.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpxsipof8f.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpxsipof8f.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxsipof8f.cpp:2:\n/tmp/tmpxsipof8f.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpxsipof8f.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpxsipof8f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7mq25cmf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp7mq25cmf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp7mq25cmf.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7mq25cmf.cpp:2:\n/tmp/tmp7mq25cmf.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp7mq25cmf.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7mq25cmf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, planet2_distance;\n\
    \    double planet1_distance, planet2_distance;\n    double planet1_distance,\
    \ planet2_distance;\n    double planet1_distance, planet2_distance;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_distance, plan\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_nam1gn6.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_nam1gn6.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_nam1gn6.cpp:19:12: error: redeclaration\
    \ of \u2018double planet1_distance\u2019\n   19 |     double planet1_distance,\
    \ planet2_distance;\n      |            ^~~~~~~~~~~~~~~~\n/tmp/tmp_nam1gn6.cpp:18:12:\
    \ note: \u2018double planet1_distance\u2019 previously declared here\n   18 |\
    \     double planet1_distance, planet2_distance;\n      |            ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp_nam1gn6.cpp:19:30: error: redeclaration of \u2018double planet2_distance\u2019\
    \n   19 |     double planet1_distance, planet2_distance;\n      |            \
    \                  ^~~~~~~~~~~~~~~~\n/tmp/tmp_nam1gn6.cpp:18:30: note: \u2018\
    double planet2_distance\u2019 previously declared here\n   18 |     double planet1_distance,\
    \ planet2_distance;\n      |                              ^~~~~~~~~~~~~~~~\n/tmp/tmp_nam1gn6.cpp:20:12:\
    \ error: redeclaration of \u2018double planet1_distance\u2019\n   20 |     double\
    \ planet1_distance, planet2_distance;\n      |            ^~~~~~~~~~~~~~~~\n/tmp/tmp_nam1gn6.cpp:18:12:\
    \ note: \u2018double planet1_distance\u2019 previously declared here\n   18 |\
    \     double planet1_distance, planet2_distance;\n      |            ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp_nam1gn6.cpp:20:30: error: redeclaration of \u2018double planet2_distance\u2019\
    \n   20 |     double planet1_distance, planet2_distance;\n      |            \
    \                  ^~~~~~~~~~~~~~~~\n/tmp/tmp_nam1gn6.cpp:18:30: note: \u2018\
    double planet2_distance\u2019 previously declared here\n   18 |     double planet1_distance,\
    \ planet2_distance;\n      |                              ^~~~~~~~~~~~~~~~\n/tmp/tmp_nam1gn6.cpp:21:12:\
    \ error: redeclaration of \u2018double planet1_distance\u2019\n   21 |     double\
    \ planet1_distance, planet2_distance;\n      |            ^~~~~~~~~~~~~~~~\n/tmp/tmp_nam1gn6.cpp:18:12:\
    \ note: \u2018double planet1_distance\u2019 previously declared here\n   18 |\
    \     double planet1_distance, planet2_distance;\n      |            ^~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuazhsmp3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpuazhsmp3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpuazhsmp3.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuazhsmp3.cpp:2:\n/tmp/tmpuazhsmp3.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpuazhsmp3.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuazhsmp3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit = planet1 + \"Orbit\";\n\
    \    std::string planet2Orbit = planet2 + \"Orbit\";\n    std::string planet1OrbitSun\
    \ = planet1 + \"OrbitSun\";\n    std::string planet2OrbitSun = planet2 + \"OrbitSun\"\
    ;\n    std::string planet1OrbitMercury = planet1 + \"OrbitMercury\";\n    std::string\
    \ planet2OrbitMercury = planet2 + \"OrbitMercury\";\n    std::string planet1OrbitVenus\
    \ = planet1 + \"OrbitVenus\";\n    std::string planet2OrbitVenus = planet2 + \"\
    OrbitVenus\";\n    std::string planet1OrbitEarth = planet1 + \"OrbitEarth\";\n\
    \    std::string planet2OrbitEarth = planet2 + \"OrbitEarth\";\n    std::string\
    \ planet1OrbitMars = planet1 + \"OrbitMars\";\n    std::string planet2OrbitMars\
    \ = planet2 + \"OrbitMars\";\n    std::string planet1OrbitJupiter = planet1 +\
    \ \"OrbitJupiter\";\n    std::string planet2OrbitJupiter = planet2 + \"OrbitJupiter\"\
    ;\n    std::string planet1OrbitSaturn = planet1 + \"OrbitSaturn\";\n    std::string\
    \ planet2OrbitSaturn = planet2 + \"OrbitSaturn\";\n    std::string planet1OrbitUranus\
    \ = planet1 + \"OrbitUranus\";\n    std::string planet2OrbitUranus = planet2 +\
    \ \"OrbitUranus\";\n    std::string planet1OrbitNeptune = planet1 + \"OrbitNeptune\"\
    ;\n    std::string planet2OrbitNeptune = planet2 + \"OrbitNeptune\";\n    std::string\
    \ planet1OrbitMercuryOrbitSun = planet1OrbitMercury + planet1OrbitSun;\n    std::string\
    \ planet2OrbitMercuryOrbitSun = planet2OrbitMercury + planet2OrbitSun;\n    std::string\
    \ planet1OrbitMercuryOrbitMercury = planet1OrbitMercury + planet1OrbitMercury;\n\
    \    std::string planet2OrbitMercuryOrbitMercury = planet2OrbitMercury + planet2\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk54csl30.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpk54csl30.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpk54csl30.cpp:41:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   41 | }\n     \
    \ | ^\n/tmp/tmpk54csl30.cpp:41:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk54csl30.cpp:2:\n/tmp/tmpk54csl30.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpk54csl30.cpp:44:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   44 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpk54csl30.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ distance;\n    double sun_distance;\n    double sun_radius;\n    double planet1_orbit_radius;\n\
    \    double planet2_orbit_radius;\n    double planet1_orbit_period;\n    double\
    \ planet2_orbit_period;\n    double planet1_orbit_eccentricity;\n    double planet2_orbit_eccentricity;\n\
    \    double planet1_orbit_inclination;\n    double planet2_orbit_inclination;\n\
    \    double planet1_orbit_longitude;\n    double planet2_orbit_longitude;\n  \
    \  double planet1_orbit_latitude;\n    double planet2_orbit_latitude;\n    double\
    \ planet1_orbit_height;\n    double planet2_orbit_height;\n    double planet1_orbit_semimajor_axis;\n\
    \    double planet2_orbit_semimajor_axis;\n    double planet1_orbit_inclination;\n\
    \    double planet2_orbit_inclination;\n    double planet1_orbit_longitude;\n\
    \    double planet2_orbit_longitude;\n    double planet1_orbit_latitude;\n   \
    \ double planet2_orbit_latitude;\n    double planet1_orbit_height;\n    double\
    \ planet2_orbit_height;\n    double planet1_orbit_semimajor_axis;\n    double\
    \ planet2_orbit_semimajor_axis;\n    double planet1_orbit_inclination;\n    double\
    \ planet2_orbit_inclination;\n    double planet1_orbit_longitude;\n    double\
    \ planet2_orbit_longitude;\n    double planet1_orbit_latitude;\n    double planet2_orbit_latitude;\n\
    \    double planet1_orbit_height;\n    double planet2_orbit_height;\n    double\
    \ planet1_orbit_semimajor_axis;\n    double planet2_orbit_semimajor_axis;\n  \
    \  double planet1_orbit_inclination;\n    double planet2_orbit_inclination;\n\
    \    double planet1_orbit_longitude;\n    double planet2_orbit_longitude;\n  \
    \  double planet1_orbit_latitude;\n    double planet2_orbit_latitude;\n    double\
    \ planet1_orbit_height;\n    double planet2_orbit_height;\n    double planet1_orbit_semimajor_axis;\n\
    \    double planet\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk1esgnj8.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpk1esgnj8.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpk1esgnj8.cpp:37:12: error: redeclaration\
    \ of \u2018double planet1_orbit_inclination\u2019\n   37 |     double planet1_orbit_inclination;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk1esgnj8.cpp:27:12: note:\
    \ \u2018double planet1_orbit_inclination\u2019 previously declared here\n   27\
    \ |     double planet1_orbit_inclination;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk1esgnj8.cpp:38:12: error: redeclaration of \u2018double planet2_orbit_inclination\u2019\
    \n   38 |     double planet2_orbit_inclination;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk1esgnj8.cpp:28:12: note: \u2018double planet2_orbit_inclination\u2019\
    \ previously declared here\n   28 |     double planet2_orbit_inclination;\n  \
    \    |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk1esgnj8.cpp:39:12: error:\
    \ redeclaration of \u2018double planet1_orbit_longitude\u2019\n   39 |     double\
    \ planet1_orbit_longitude;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk1esgnj8.cpp:29:12:\
    \ note: \u2018double planet1_orbit_longitude\u2019 previously declared here\n\
    \   29 |     double planet1_orbit_longitude;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk1esgnj8.cpp:40:12: error: redeclaration of \u2018double planet2_orbit_longitude\u2019\
    \n   40 |     double planet2_orbit_longitude;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk1esgnj8.cpp:30:12: note: \u2018double planet2_orbit_longitude\u2019 previously\
    \ declared here\n   30 |     double planet2_orbit_longitude;\n      |        \
    \    ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk1esgnj8.cpp:41:12: error: redeclaration\
    \ of \u2018double planet1_orbit_latitude\u2019\n   41 |     double planet1_orbit_latitude;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk1esgnj8.cpp:31:12: note:\
    \ \u2018double planet1_orbit_latitude\u2019 previously declared here\n   31 |\
    \     double planet1_orbit_latitude;\n      |            ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk1esgnj8.cpp:42:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpus5ohfag.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpus5ohfag.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpus5ohfag.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpus5ohfag.cpp:2:\n/tmp/tmpus5ohfag.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpus5ohfag.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpus5ohfag.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitRadius, planet2OrbitRadius;\n    double planet1OrbitDistance, planet2OrbitDistance;\n\
    \    double planet1OrbitDistanceRadians, planet2OrbitDistanceRadians;\n    double\
    \ planet1OrbitDistanceRadians2, planet2OrbitDistanceRadians2;\n    double planet1OrbitDistanceRadians3,\
    \ planet2OrbitDistanceRadians3;\n    double planet1OrbitDistanceRadians4, planet2OrbitDistanceRadians4;\n\
    \    double planet1OrbitDistanceRadians5, planet2OrbitDistanceRadians5;\n    double\
    \ planet1OrbitDistanceRadians6, planet2OrbitDistanceRadians6;\n    double planet1OrbitDistanceRadians7,\
    \ planet2OrbitDistanceRadians7;\n    double planet1OrbitDistanceRadians8, planet2OrbitDistanceRadians8;\n\
    \    double planet1OrbitDistanceRadians9, planet2OrbitDistanceRadians9;\n    double\
    \ planet1OrbitDistanceRadians10, planet2OrbitDistanceRadians10;\n    double planet1OrbitDistanceRadians11,\
    \ planet2OrbitDistanceRadians11;\n    double planet1OrbitDistanceRadians12, planet2OrbitDistanceRadians12;\n\
    \    double planet1OrbitDistanceRadians13, planet2OrbitDistanceRadians13;\n  \
    \  double planet1OrbitDistanceRadians14, planet2OrbitDistanceRadians14;\n    double\
    \ planet1OrbitDistanceRadians15, planet2OrbitDistanceRadians15;\n    double planet1OrbitDistanceRadians16,\
    \ planet2OrbitDistanceRadians16;\n    double planet1OrbitDistanceRadians17, planet2OrbitDistanceRadians17;\n\
    \    double planet1OrbitDistanceRadians18, planet2OrbitDistanceRadians18;\n  \
    \  double planet1OrbitDistanceRadians19, planet2OrbitDistanceRadians19;\n    double\
    \ planet1OrbitDistanceRadians20, planet2OrbitDistanceRadians20;\n    double planet1OrbitDistanceRadians21,\
    \ planet2OrbitDistanceRadians21;\n    double planet1OrbitDistanceRadians22, planet2Orbit\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_dt3dbkf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_dt3dbkf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_dt3dbkf.cpp:42:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   42 | }\n      | ^\n/tmp/tmp_dt3dbkf.cpp:42:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_dt3dbkf.cpp:2:\n/tmp/tmp_dt3dbkf.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_dt3dbkf.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_dt3dbkf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1Orbit, planet2Orbit;\n\
    \    \n    planet1Orbit = planet1 + \"Orbit\";\n    planet2Orbit = planet2 + \"\
    Orbit\";\n    \n    std::string planet1OrbitSun, planet2OrbitSun;\n    \n    planet1OrbitSun\
    \ = planet1 + \"OrbitSun\";\n    planet2OrbitSun = planet2 + \"OrbitSun\";\n \
    \   \n    std::string planet1OrbitMercury, planet2OrbitMercury;\n    \n    planet1OrbitMercury\
    \ = planet1 + \"OrbitMercury\";\n    planet2OrbitMercury = planet2 + \"OrbitMercury\"\
    ;\n    \n    std::string planet1OrbitVenus, planet2OrbitVenus;\n    \n    planet1OrbitVenus\
    \ = planet1 + \"OrbitVenus\";\n    planet2OrbitVenus = planet2 + \"OrbitVenus\"\
    ;\n    \n    std::string planet1OrbitEarth, planet2OrbitEarth;\n    \n    planet1OrbitEarth\
    \ = planet1 + \"OrbitEarth\";\n    planet2OrbitEarth = planet2 + \"OrbitEarth\"\
    ;\n    \n    std::string planet1OrbitMars, planet2OrbitMars;\n    \n    planet1OrbitMars\
    \ = planet1 + \"OrbitMars\";\n    planet2OrbitMars = planet2 + \"OrbitMars\";\n\
    \    \n    std::string planet1OrbitJupiter, planet2OrbitJupiter;\n    \n    planet1OrbitJupiter\
    \ = planet1 + \"OrbitJupiter\";\n    planet2OrbitJupiter = planet2 + \"OrbitJupiter\"\
    ;\n    \n    std::string planet1OrbitSaturn, planet2OrbitSaturn;\n    \n    planet1OrbitSaturn\
    \ = planet1 + \"OrbitSaturn\";\n    planet2OrbitSaturn = planet2 + \"OrbitSaturn\"\
    ;\n    \n    std::string planet1OrbitUranus, planet2OrbitUranus;\n    \n    planet1OrbitUranus\
    \ = planet1 + \"OrbitUranus\";\n    planet2Or\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppkmm1ytq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmppkmm1ytq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmppkmm1ytq.cpp:61:5: error: \u2018\
    planet2Or\u2019 was not declared in this scope; did you mean \u2018planet2\u2019\
    ?\n   61 |     planet2Or\n      |     ^~~~~~~~~\n      |     planet2\n/tmp/tmppkmm1ytq.cpp:62:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   62 | }\n      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppkmm1ytq.cpp:2:\n/tmp/tmppkmm1ytq.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmppkmm1ytq.cpp:65:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   65 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppkmm1ytq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance;\n    double angle;\n    double\
    \ distance1;\n    double angle1;\n    double distance2;\n    double angle2;\n\
    \    double distance3;\n    double angle3;\n    double distance4;\n    double\
    \ angle4;\n    double distance5;\n    double angle5;\n    double distance6;\n\
    \    double angle6;\n    double distance7;\n    double angle7;\n    double distance8;\n\
    \    double angle8;\n    double distance9;\n    double angle9;\n    double distance10;\n\
    \    double angle10;\n    double distance11;\n    double angle11;\n    double\
    \ distance12;\n    double angle12;\n    double distance13;\n    double angle13;\n\
    \    double distance14;\n    double angle14;\n    double distance15;\n    double\
    \ angle15;\n    double distance16;\n    double angle16;\n    double distance17;\n\
    \    double angle17;\n    double distance18;\n    double angle18;\n    double\
    \ distance19;\n    double angle19;\n    double distance20;\n    double angle20;\n\
    \    double distance21;\n    double angle21;\n    double distance22;\n    double\
    \ angle22;\n    double distance23;\n    double angle23;\n    double distance24;\n\
    \    double angle24;\n    double distance25;\n    double angle25;\n    double\
    \ distance26;\n    double angle26;\n    double distance27;\n    double angle27;\n\
    \    double distance28;\n    double angle28;\n    double distance29;\n    double\
    \ angle29;\n    double distance30;\n    double angle30;\n    double distance31;\n\
    \    double angle31;\n    double distance32;\n    double angle32;\n    double\
    \ distance33;\n    double angle33;\n    double distance34;\n    double angle34;\n\
    \    double distance35;\n    double angle35;\n    double distance36;\n    double\
    \ angle36;\n    double distance37;\n    double angle37;\n    double distance38;\n\
    \    double angle38;\n    double distance39;\n    double angle39;\n    double\
    \ distance40;\n    double angle40;\n    double distance41;\n    double angle41;\n\
    \    double distance42;\n    double angle42;\n    double distance43;\n    double\
    \ angle43;\n    double distance44;\n    double angle44;\n    double distance45;\n\
    \    double angle45;\n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn1olm330.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpn1olm330.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpn1olm330.cpp:110:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  110 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn1olm330.cpp:2:\n/tmp/tmpn1olm330.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpn1olm330.cpp:113:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  113 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpn1olm330.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1;\n    double distance2;\n    double distance3;\n\
    \    double distance4;\n    double distance5;\n    double distance6;\n    double\
    \ distance7;\n    double distance8;\n    double distance9;\n    double distance10;\n\
    \    double distance11;\n    double distance12;\n    double distance13;\n    double\
    \ distance14;\n    double distance15;\n    double distance16;\n    double distance17;\n\
    \    double distance18;\n    double distance19;\n    double distance20;\n    double\
    \ distance21;\n    double distance22;\n    double distance23;\n    double distance24;\n\
    \    double distance25;\n    double distance26;\n    double distance27;\n    double\
    \ distance28;\n    double distance29;\n    double distance30;\n    double distance31;\n\
    \    double distance32;\n    double distance33;\n    double distance34;\n    double\
    \ distance35;\n    double distance36;\n    double distance37;\n    double distance38;\n\
    \    double distance39;\n    double distance40;\n    double distance41;\n    double\
    \ distance42;\n    double distance43;\n    double distance44;\n    double distance45;\n\
    \    double distance46;\n    double distance47;\n    double distance48;\n    double\
    \ distance49;\n    double distance50;\n    double distance51;\n    double distance52;\n\
    \    double distance53;\n    double distance54;\n    double distance55;\n    double\
    \ distance56;\n    double distance57;\n    double distance58;\n    double distance59;\n\
    \    double distance60;\n    double distance61;\n    double distance62;\n    double\
    \ distance63;\n    double distance64;\n    double distance65;\n    double distance66;\n\
    \    double distance67;\n    double distance68;\n    double distance69;\n    double\
    \ distance70;\n    double distance71;\n    double distance72;\n    double distance73;\n\
    \    double distance74;\n    double distance75;\n    double distance76;\n    double\
    \ distance77;\n    double distance78;\n    double distance79;\n    double distance80;\n\
    \    double distance81;\n    double distance82;\n    double distance83;\n    double\
    \ distance84;\n    double distance85;\n    double \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp97699glm.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp97699glm.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp97699glm.cpp:105:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmp97699glm.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp97699glm.cpp:2:\n/tmp/tmp97699glm.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp97699glm.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp97699glm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance;\n    double distance2;\n    double\
    \ distance3;\n    double distance4;\n    double distance5;\n    double distance6;\n\
    \    double distance7;\n    double distance8;\n    double distance9;\n    double\
    \ distance10;\n    double distance11;\n    double distance12;\n    double distance13;\n\
    \    double distance14;\n    double distance15;\n    double distance16;\n    double\
    \ distance17;\n    double distance18;\n    double distance19;\n    double distance20;\n\
    \    double distance21;\n    double distance22;\n    double distance23;\n    double\
    \ distance24;\n    double distance25;\n    double distance26;\n    double distance27;\n\
    \    double distance28;\n    double distance29;\n    double distance30;\n    double\
    \ distance31;\n    double distance32;\n    double distance33;\n    double distance34;\n\
    \    double distance35;\n    double distance36;\n    double distance37;\n    double\
    \ distance38;\n    double distance39;\n    double distance40;\n    double distance41;\n\
    \    double distance42;\n    double distance43;\n    double distance44;\n    double\
    \ distance45;\n    double distance46;\n    double distance47;\n    double distance48;\n\
    \    double distance49;\n    double distance50;\n    double distance51;\n    double\
    \ distance52;\n    double distance53;\n    double distance54;\n    double distance55;\n\
    \    double distance56;\n    double distance57;\n    double distance58;\n    double\
    \ distance59;\n    double distance60;\n    double distance61;\n    double distance62;\n\
    \    double distance63;\n    double distance64;\n    double distance65;\n    double\
    \ distance66;\n    double distance67;\n    double distance68;\n    double distance69;\n\
    \    double distance70;\n    double distance71;\n    double distance72;\n    double\
    \ distance73;\n    double distance74;\n    double distance75;\n    double distance76;\n\
    \    double distance77;\n    double distance78;\n    double distance79;\n    double\
    \ distance80;\n    double distance81;\n    double distance82;\n    double distance83;\n\
    \    double distance84;\n    double distance85;\n    double distance86;\n    double\
    \ distance87;\n    double distance88;\n    double distance89\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl3l38qpo.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpl3l38qpo.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpl3l38qpo.cpp:106:1: error: expected\
    \ initializer before \u2018}\u2019 token\n  106 | }\n      | ^\n/tmp/tmpl3l38qpo.cpp:106:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl3l38qpo.cpp:2:\n/tmp/tmpl3l38qpo.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpl3l38qpo.cpp:109:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  109 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpl3l38qpo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfgo7usbl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfgo7usbl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfgo7usbl.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfgo7usbl.cpp:2:\n/tmp/tmpfgo7usbl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfgo7usbl.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfgo7usbl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceSquared\
    \ = 0.0, planet2OrbitDistanceSquared = 0.0;\n    double planet1OrbitDistanceSquared2\
    \ = 0.0, planet2OrbitDistanceSquared2 = 0.0;\n    double planet1OrbitDistanceSquared3\
    \ = 0.0, planet2OrbitDistanceSquared3 = 0.0;\n    double planet1OrbitDistanceSquared4\
    \ = 0.0, planet2OrbitDistanceSquared4 = 0.0;\n    double planet1OrbitDistanceSquared5\
    \ = 0.0, planet2OrbitDistanceSquared5 = 0.0;\n    double planet1OrbitDistanceSquared6\
    \ = 0.0, planet2OrbitDistanceSquared6 = 0.0;\n    double planet1OrbitDistanceSquared7\
    \ = 0.0, planet2OrbitDistanceSquared7 = 0.0;\n    double planet1OrbitDistanceSquared8\
    \ = 0.0, planet2OrbitDistanceSquared8 = 0.0;\n    double planet1OrbitDistanceSquared9\
    \ = 0.0, planet2OrbitDistanceSquared9 = 0.0;\n    double planet1OrbitDistanceSquared10\
    \ = 0.0, planet2OrbitDistanceSquared10 = 0.0;\n    double planet1OrbitDistanceSquared11\
    \ = 0.0, planet2OrbitDistanceSquared11 = 0.0;\n    double planet1OrbitDistanceSquared12\
    \ = 0.0, planet2OrbitDistanceSquared12 = 0.0;\n    double planet1OrbitDistanceSquared13\
    \ = 0.0, planet2OrbitDistanceSquared13 = 0.0;\n    double planet1OrbitDistanceSquared14\
    \ = 0.0, planet2OrbitDistanceSquared14 = 0.0;\n    double planet1OrbitDistanceSquared15\
    \ = 0.0, planet2OrbitDistanceSquared15 = 0.0;\n    double planet1OrbitDistanceSquared16\
    \ = 0.0, planet2OrbitDistanceSquared16 = 0.0;\n    double planet1OrbitDistanceSquared17\
    \ = 0.0, planet2OrbitDistanceSquared17 = 0.0;\n    double planet1OrbitDistanceSquared18\
    \ = 0.0, planet2OrbitDistanceSquared18 = 0.0;\n    double planet1OrbitDistanceSquared19\
    \ = 0.0, planet2OrbitDistanceSquared19 = 0.0;\n    double planet1OrbitDistanceSquared20\
    \ = 0.0, planet2Orbit\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzjn3sol9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzjn3sol9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzjn3sol9.cpp:39:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   39 | }\n      | ^\n/tmp/tmpzjn3sol9.cpp:39:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzjn3sol9.cpp:2:\n/tmp/tmpzjn3sol9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzjn3sol9.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzjn3sol9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjzid13pp.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjzid13pp.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjzid13pp.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjzid13pp.cpp:2:\n/tmp/tmpjzid13pp.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpjzid13pp.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpjzid13pp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_velocity, planet2_orbital_velocity;\n    double planet1_orbital_acceleration,\
    \ planet2_orbital_acceleration;\n    double planet1_orbital_period, planet2_orbital_period;\n\
    \    double planet1_orbital_eccentricity, planet2_orbital_eccentricity;\n    double\
    \ planet1_orbital_semi_major_axis, planet2_orbital_semi_major_axis;\n    double\
    \ planet1_orbital_longitude, planet2_orbital_longitude;\n    double planet1_orbital_inclination,\
    \ planet2_orbital_inclination;\n    double planet1_orbital_aphelion, planet2_orbital_aphelion;\n\
    \    double planet1_orbital_perihelion, planet2_orbital_perihelion;\n    double\
    \ planet1_orbital_aphelion_longitude, planet2_orbital_aphelion_longitude;\n  \
    \  double planet1_orbital_perihelion_longitude, planet2_orbital_perihelion_longitude;\n\
    \    double planet1_orbital_longitude, planet2_orbital_longitude;\n    double\
    \ planet1_orbital_longitude, planet2_orbital_longitude;\n    double planet1_orbital_longitude,\
    \ planet2_orbital_longitude;\n    double planet1_orbital_longitude, planet2_orbital_longitude;\n\
    \    double planet1_orbital_longitude, planet2_orbital_longitude;\n    double\
    \ planet1_orbital_longitude, planet2_orbital_longitude;\n    double planet1_orbital_longitude,\
    \ planet2_orbital_longitude;\n    double planet1_orbital_longitude, planet2_orbital_longitude;\n\
    \    double planet1_orbital_longitude, planet2_orbital_longitude;\n    double\
    \ planet1_orbital_longitude, planet2_orbital_longitude;\n    double planet1_orbital_longitude,\
    \ planet2_orbital_longitude;\n    double planet1_orbital_longitude, planet2_orbital_longitude;\n\
    \    double planet1_orbital_longitude, planet2_orbital_longitude;\n    double\
    \ planet1_orbital_longitude, planet2_orbital_longitude;\n    double planet1_orbital_\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvzfa5oyh.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpvzfa5oyh.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpvzfa5oyh.cpp:31:12: error: redeclaration\
    \ of \u2018double planet1_orbital_longitude\u2019\n   31 |     double planet1_orbital_longitude,\
    \ planet2_orbital_longitude;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzfa5oyh.cpp:25:12:\
    \ note: \u2018double planet1_orbital_longitude\u2019 previously declared here\n\
    \   25 |     double planet1_orbital_longitude, planet2_orbital_longitude;\n  \
    \    |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzfa5oyh.cpp:31:39: error:\
    \ redeclaration of \u2018double planet2_orbital_longitude\u2019\n   31 |     double\
    \ planet1_orbital_longitude, planet2_orbital_longitude;\n      |             \
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzfa5oyh.cpp:25:39:\
    \ note: \u2018double planet2_orbital_longitude\u2019 previously declared here\n\
    \   25 |     double planet1_orbital_longitude, planet2_orbital_longitude;\n  \
    \    |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzfa5oyh.cpp:32:12:\
    \ error: redeclaration of \u2018double planet1_orbital_longitude\u2019\n   32\
    \ |     double planet1_orbital_longitude, planet2_orbital_longitude;\n      |\
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzfa5oyh.cpp:25:12: note: \u2018\
    double planet1_orbital_longitude\u2019 previously declared here\n   25 |     double\
    \ planet1_orbital_longitude, planet2_orbital_longitude;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpvzfa5oyh.cpp:32:39: error: redeclaration of \u2018double planet2_orbital_longitude\u2019\
    \n   32 |     double planet1_orbital_longitude, planet2_orbital_longitude;\n \
    \     |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzfa5oyh.cpp:25:39:\
    \ note: \u2018double planet2_orbital_longitude\u2019 previously declared here\n\
    \   25 |     double planet1_orbital_longitude, planet2_orbital_longitude;\n  \
    \    |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpvzfa5oyh.cpp:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ distance;\n    double sun_distance;\n    double sun_radius = 6378.137;\n   \
    \ double planet1_radius = 6378.137;\n    double planet2_radius = 6378.137;\n \
    \   double planet1_longitude, planet1_latitude, planet2_longitude, planet2_latitude;\n\
    \    double planet1_longitude_deg, planet1_latitude_deg, planet2_longitude_deg,\
    \ planet2_latitude_deg;\n    double planet1_longitude_deg_to_rad, planet1_latitude_deg_to_rad,\
    \ planet2_longitude_deg_to_rad, planet2_latitude_deg_to_rad;\n    double planet1_longitude_deg_to_rad_prime,\
    \ planet1_latitude_deg_to_rad_prime, planet2_longitude_deg_to_rad_prime, planet2_latitude_deg_to_rad_prime;\n\
    \    double planet1_longitude_deg_to_rad_prime_prime, planet1_latitude_deg_to_rad_prime_prime,\
    \ planet2_longitude_deg_to_rad_prime_prime, planet2_latitude_deg_to_rad_prime_prime;\n\
    \    double planet1_longitude_deg_to_rad_prime_prime_prime, planet1_latitude_deg_to_rad_prime_prime_prime,\
    \ planet2_longitude_deg_to_rad_prime_prime_prime, planet2_latitude_deg_to_rad_prime_prime_prime;\n\
    \    double planet1_longitude_deg_to_rad_prime_prime_prime_prime, planet1_latitude_deg_to_rad_prime_prime_prime_prime,\
    \ planet2_longitude_deg_to_rad_prime_prime_prime_prime, planet2_latitude_deg_to_rad_prime_prime_prime_prime;\n\
    \    double planet1_longitude_deg_to_rad_prime_prime_prime_prime_prime, planet1_latitude_deg_to_rad_prime_prime_prime_prime_prime,\
    \ planet2_longitude_deg_to_rad_prime_prime_prime_prime_prime, planet2_latitude_deg_to_rad_prime_prime_prime_prime_prime;\n\
    \    double planet1_longitude_deg_to_rad_prime_prime_prime_prime_prime_prime,\
    \ planet1_latitude_deg_to_rad_prime_prime_prime_prime_prime_prime, planet2_\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpitow4_74.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpitow4_74.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpitow4_74.cpp:32:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   32 | }\n      | ^\n/tmp/tmpitow4_74.cpp:32:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpitow4_74.cpp:2:\n/tmp/tmpitow4_74.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpitow4_74.cpp:35:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   35 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpitow4_74.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::tuple<std::string,\
    \ >();\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9y6mi2gd.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9y6mi2gd.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9y6mi2gd.cpp:20:36: error: template\
    \ argument 2 is invalid\n   20 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9y6mi2gd.cpp:2:\n/tmp/tmp9y6mi2gd.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9y6mi2gd.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9y6mi2gd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistance2,\
    \ planet2OrbitDistance2;\n    double planet1OrbitDistance3, planet2OrbitDistance3;\n\
    \    double planet1OrbitDistance4, planet2OrbitDistance4;\n    double planet1OrbitDistance5,\
    \ planet2OrbitDistance5;\n    double planet1OrbitDistance6, planet2OrbitDistance6;\n\
    \    double planet1OrbitDistance7, planet2OrbitDistance7;\n    double planet1OrbitDistance8,\
    \ planet2OrbitDistance8;\n    double planet1OrbitDistance9, planet2OrbitDistance9;\n\
    \    double planet1OrbitDistance10, planet2OrbitDistance10;\n    double planet1OrbitDistance11,\
    \ planet2OrbitDistance11;\n    double planet1OrbitDistance12, planet2OrbitDistance12;\n\
    \    double planet1OrbitDistance13, planet2OrbitDistance13;\n    double planet1OrbitDistance14,\
    \ planet2OrbitDistance14;\n    double planet1OrbitDistance15, planet2OrbitDistance15;\n\
    \    double planet1OrbitDistance16, planet2OrbitDistance16;\n    double planet1OrbitDistance17,\
    \ planet2OrbitDistance17;\n    double planet1OrbitDistance18, planet2OrbitDistance18;\n\
    \    double planet1OrbitDistance19, planet2OrbitDistance19;\n    double planet1OrbitDistance20,\
    \ planet2OrbitDistance20;\n    double planet1OrbitDistance21, planet2OrbitDistance21;\n\
    \    double planet1OrbitDistance22, planet2OrbitDistance22;\n    double planet1OrbitDistance23,\
    \ planet2OrbitDistance23;\n    double planet1OrbitDistance24, planet2OrbitDistance24;\n\
    \    double planet1OrbitDistance25, planet2OrbitDistance25;\n    double planet1OrbitDistance26,\
    \ planet2OrbitDistance26;\n    double planet1OrbitDistance27, planet2OrbitDistance27;\n\
    \    double planet1OrbitDistance28, planet2OrbitDistance28;\n    double planet1OrbitDistance29,\
    \ plan\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqkjv5hi1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpqkjv5hi1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpqkjv5hi1.cpp:47:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   47 | }\n      | ^\n/tmp/tmpqkjv5hi1.cpp:47:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqkjv5hi1.cpp:2:\n/tmp/tmpqkjv5hi1.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpqkjv5hi1.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpqkjv5hi1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::tuple<std::string,\
    \ >();\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqtva_8vn.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpqtva_8vn.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpqtva_8vn.cpp:20:36: error: template\
    \ argument 2 is invalid\n   20 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqtva_8vn.cpp:2:\n/tmp/tmpqtva_8vn.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpqtva_8vn.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpqtva_8vn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpftzadl_p.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpftzadl_p.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpftzadl_p.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpftzadl_p.cpp:2:\n/tmp/tmpftzadl_p.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpftzadl_p.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpftzadl_p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4_r7_ixa.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4_r7_ixa.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4_r7_ixa.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4_r7_ixa.cpp:2:\n/tmp/tmp4_r7_ixa.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp4_r7_ixa.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4_r7_ixa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitRadius, planet2OrbitRadius;\n    double planet1OrbitDistance, planet2OrbitDistance;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1Orbit\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmc6nfwt3.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmc6nfwt3.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmc6nfwt3.cpp:21:12: error: redeclaration\
    \ of \u2018double planet1OrbitDistanceRadius\u2019\n   21 |     double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpmc6nfwt3.cpp:20:12: note: \u2018double planet1OrbitDistanceRadius\u2019\
    \ previously declared here\n   20 |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmc6nfwt3.cpp:21:40: error:\
    \ redeclaration of \u2018double planet2OrbitDistanceRadius\u2019\n   21 |    \
    \ double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n      |    \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmc6nfwt3.cpp:20:40:\
    \ note: \u2018double planet2OrbitDistanceRadius\u2019 previously declared here\n\
    \   20 |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmc6nfwt3.cpp:22:12:\
    \ error: redeclaration of \u2018double planet1OrbitDistanceRadius\u2019\n   22\
    \ |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n     \
    \ |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmc6nfwt3.cpp:20:12: note: \u2018\
    double planet1OrbitDistanceRadius\u2019 previously declared here\n   20 |    \
    \ double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n      |    \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmc6nfwt3.cpp:22:40: error: redeclaration\
    \ of \u2018double planet2OrbitDistanceRadius\u2019\n   22 |     double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n      |                                       \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpmc6nfwt3.cpp:20:40: note: \u2018double planet2OrbitDistanceRadius\u2019\
    \ previously declared here\n   20 |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \      |                                        ^~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp839gwqzi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp839gwqzi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp839gwqzi.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp839gwqzi.cpp:2:\n/tmp/tmp839gwqzi.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp839gwqzi.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp839gwqzi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    \n    std::string planet1Orbit\
    \ = planet1;\n    std::string planet2Orbit = planet2;\n    \n    std::string planet1OrbitOrbit\
    \ = planet1Orbit + \"Orbit\";\n    std::string planet2OrbitOrbit = planet2Orbit\
    \ + \"Orbit\";\n    \n    std::string planet1OrbitOrbitOrbit = planet1OrbitOrbit\
    \ + \"OrbitOrbit\";\n    std::string planet2OrbitOrbitOrbit = planet2OrbitOrbit\
    \ + \"OrbitOrbit\";\n    \n    std::string planet1OrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbit\
    \ + \"OrbitOrbitOrbit\";\n    std::string planet2OrbitOrbitOrbitOrbit = planet2OrbitOrbitOrbit\
    \ + \"OrbitOrbitOrbit\";\n    \n    std::string planet1OrbitOrbitOrbitOrbitOrbit\
    \ = planet1OrbitOrbitOrbitOrbit + \"OrbitOrbitOrbitOrbit\";\n    std::string planet2OrbitOrbitOrbitOrbitOrbit\
    \ = planet2OrbitOrbitOrbitOrbit + \"OrbitOrbitOrbitOrbit\";\n    \n    std::string\
    \ planet1OrbitOrbitOrbitOrbitOrbitOrbit = planet1OrbitOrbitOrbitOrbitOrbit + \"\
    OrbitOrbitOrbitOrbitOrbitOrbit\";\n    std::string planet2OrbitOrbitOrbitOrbitOrbitOrbit\
    \ = planet2OrbitOrbitOrbitOrbitOrbit + \"OrbitOrbitOrbitOrbitOrbitOrbit\";\n \
    \   \n    std::string planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit = planet1OrbitOr\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_x_d1bft.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_x_d1bft.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_x_d1bft.cpp:38:62: error: \u2018\
    planet1OrbitOr\u2019 was not declared in this scope; did you mean \u2018planet1Orbit\u2019\
    ?\n   38 |     std::string planet1OrbitOrbitOrbitOrbitOrbitOrbitOrbit = planet1OrbitOr\n\
    \      |                                                              ^~~~~~~~~~~~~~\n\
    \      |                                                              planet1Orbit\n\
    /tmp/tmp_x_d1bft.cpp:39:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   39 | }\n      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_x_d1bft.cpp:2:\n/tmp/tmp_x_d1bft.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_x_d1bft.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_x_d1bft.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_Bi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9ni9i8p0.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9ni9i8p0.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9ni9i8p0.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ni9i8p0.cpp:2:\n/tmp/tmp9ni9i8p0.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9ni9i8p0.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9ni9i8p0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orb = planet1 + \" orbit\";\n\
    \    std::string planet2_orb = planet2 + \" orbit\";\n    std::string planet1_sun\
    \ = planet1 + \" sun\";\n    std::string planet2_sun = planet2 + \" sun\";\n \
    \   std::string planet1_planet2 = planet1 + \" \" + planet2;\n    std::string\
    \ planet2_planet1 = planet2 + \" \" + planet1;\n    std::string planet1_planet2_orb\
    \ = planet1_planet2 + \" orbit\";\n    std::string planet2_planet1_orb = planet2_planet1\
    \ + \" orbit\";\n    std::string planet1_planet2_sun = planet1_planet2 + \" sun\"\
    ;\n    std::string planet2_planet1_sun = planet2_planet1 + \" sun\";\n    std::string\
    \ planet1_planet2_planet2 = planet1_planet2 + \" \" + planet2;\n    std::string\
    \ planet2_planet1_planet2 = planet2_planet1 + \" \" + planet2;\n    std::string\
    \ planet1_planet2_planet2_orb = planet1_planet2_planet2 + \" orbit\";\n    std::string\
    \ planet2_planet1_planet2_orb = planet2_planet1_planet2 + \" orbit\";\n    std::string\
    \ planet1_planet2_planet2_sun = planet1_planet2_planet2 + \" sun\";\n    std::string\
    \ planet2_planet1_planet2_sun = planet2_planet1_planet2 + \" sun\";\n    std::string\
    \ planet1_planet2_planet2_planet2 = planet1_planet2_planet2 + \" \" + planet2;\n\
    \    std::string planet2_planet1_planet2_planet2 = planet2_planet1_planet2 + \"\
    \ \" + planet2;\n    std::string planet1_planet2_planet2_planet2_orb = planet1_planet2_planet2_planet2\
    \ + \" orbit\";\n    std::string planet2_planet1_planet2_planet2_orb = planet2_planet1_planet2_planet2\
    \ + \" orbit\";\n    std::string planet1_planet2_planet2_planet2_sun = planet1_planet2_planet2_planet2\
    \ + \" sun\";\n    std::string planet2_planet1_planet2_planet2_sun = planet2_planet1_planet2_planet2\
    \ + \" sun\";\n    std::string planet1_planet2_planet2_plan\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqx1tu32g.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpqx1tu32g.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpqx1tu32g.cpp:40:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   40 | }\n      | ^\n/tmp/tmpqx1tu32g.cpp:40:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqx1tu32g.cpp:2:\n/tmp/tmpqx1tu32g.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpqx1tu32g.cpp:43:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   43 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpqx1tu32g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4ahseksx.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4ahseksx.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4ahseksx.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4ahseksx.cpp:2:\n/tmp/tmp4ahseksx.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp4ahseksx.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4ahseksx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.1; // Radius of the Sun\
    \ in km\n    double planet_radius = 6378.1; // Radius of the planet in km\n  \
    \  double planet_separation = planet_radius - sun_radius;\n    double planet_separation_sq\
    \ = planet_separation * planet_separation;\n    double planet_separation_sq_inv\
    \ = 1 / planet_separation_sq;\n    double planet_separation_sq_inv_2 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_3 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_4 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_5 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_6 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_7 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_8 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_9 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_10 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_11 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_12 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_13 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_14 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_15 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_16 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_17 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_18 = planet_separation_sq_inv\
    \ * planet_separation_sq\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4jsf0v1_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4jsf0v1_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4jsf0v1_.cpp:39:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   39 | }\n     \
    \ | ^\n/tmp/tmp4jsf0v1_.cpp:39:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4jsf0v1_.cpp:2:\n/tmp/tmp4jsf0v1_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp4jsf0v1_.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4jsf0v1_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    \n    std::tuple<std::string,\
    \ > result;\n    \n    if (planet1 == \"Mercury\") {\n        if (planet2 == \"\
    Venus\") {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Earth\") {\n            result.emplace(planet1);\n\
    \            result.emplace(planet2);\n        } else if (planet2 == \"Mars\"\
    ) {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Jupiter\") {\n            result.emplace(planet1);\n\
    \            result.emplace(planet2);\n        } else if (planet2 == \"Saturn\"\
    ) {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Uranus\") {\n            result.emplace(planet1);\n\
    \            result.emplace(planet2);\n        } else if (planet2 == \"Neptune\"\
    ) {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    \        }\n    } else if (planet1 == \"Venus\") {\n        if (planet2 == \"\
    Mercury\") {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Earth\") {\n            result.emplace(planet1);\n\
    \            result.emplace(planet2);\n        } else if (planet2 == \"Mars\"\
    ) {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Jupiter\") {\n            result.emplace(planet1);\n\
    \            result.emplace(planet2);\n        } else if (planet2 == \"Saturn\"\
    ) {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Uranus\") {\n            result.emplace(planet1);\n\
    \            result.emplace(planet2);\n        } else if (planet2 == \"Neptune\"\
    ) {\n            result.emplace(planet1);\n            result.emplace(planet2);\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppay_k5zc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmppay_k5zc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmppay_k5zc.cpp:20:29: error: template\
    \ argument 2 is invalid\n   20 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmppay_k5zc.cpp:24:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   24 |             result.emplace(planet1);\n      |\
    \                    ^~~~~~~\n/tmp/tmppay_k5zc.cpp:25:20: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   25 |             result.emplace(planet2);\n      |             \
    \       ^~~~~~~\n/tmp/tmppay_k5zc.cpp:27:20: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   27 |             result.emplace(planet1);\n      |                    ^~~~~~~\n\
    /tmp/tmppay_k5zc.cpp:28:20: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   28 |            \
    \ result.emplace(planet2);\n      |                    ^~~~~~~\n/tmp/tmppay_k5zc.cpp:30:20:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   30 |             result.emplace(planet1);\n\
    \      |                    ^~~~~~~\n/tmp/tmppay_k5zc.cpp:31:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   31 |             result.emplace(planet2);\n      |\
    \                    ^~~~~~~\n/tmp/tmppay_k5zc.cpp:33:20: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   33 |             result.emplace(planet1);\n      |             \
    \       ^~~~~~~\n/tmp/tmppay_k5zc.cpp:34:20: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   34 |             result.emplace(planet2);\n      |                    ^~~~~~~\n\
    /tmp/tmppay_k5zc.cpp:36:20: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   36 |          "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceToSun,\
    \ planet2OrbitDistanceToSun;\n    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSun;\n\
    \    double planet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1OrbitDistanceToSunAndPlanet2OrbitDistanceToSunAndPlanet1Or\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmd_l34ev.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmd_l34ev.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmd_l34ev.cpp:25:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   25 | }\n      | ^\n/tmp/tmpmd_l34ev.cpp:25:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmd_l34ev.cpp:2:\n/tmp/tmpmd_l34ev.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpmd_l34ev.cpp:28:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   28 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmd_l34ev.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmfdcqqph.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmfdcqqph.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmfdcqqph.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmfdcqqph.cpp:2:\n/tmp/tmpmfdcqqph.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpmfdcqqph.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmfdcqqph.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance;\n    double distance2;\n    double\
    \ distance3;\n    double distance4;\n    double distance5;\n    double distance6;\n\
    \    double distance7;\n    double distance8;\n    double distance9;\n    double\
    \ distance10;\n    double distance11;\n    double distance12;\n    double distance13;\n\
    \    double distance14;\n    double distance15;\n    double distance16;\n    double\
    \ distance17;\n    double distance18;\n    double distance19;\n    double distance20;\n\
    \    double distance21;\n    double distance22;\n    double distance23;\n    double\
    \ distance24;\n    double distance25;\n    double distance26;\n    double distance27;\n\
    \    double distance28;\n    double distance29;\n    double distance30;\n    double\
    \ distance31;\n    double distance32;\n    double distance33;\n    double distance34;\n\
    \    double distance35;\n    double distance36;\n    double distance37;\n    double\
    \ distance38;\n    double distance39;\n    double distance40;\n    double distance41;\n\
    \    double distance42;\n    double distance43;\n    double distance44;\n    double\
    \ distance45;\n    double distance46;\n    double distance47;\n    double distance48;\n\
    \    double distance49;\n    double distance50;\n    double distance51;\n    double\
    \ distance52;\n    double distance53;\n    double distance54;\n    double distance55;\n\
    \    double distance56;\n    double distance57;\n    double distance58;\n    double\
    \ distance59;\n    double distance60;\n    double distance61;\n    double distance62;\n\
    \    double distance63;\n    double distance64;\n    double distance65;\n    double\
    \ distance66;\n    double distance67;\n    double distance68;\n    double distance69;\n\
    \    double distance70;\n    double distance71;\n    double distance72;\n    double\
    \ distance73;\n    double distance74;\n    double distance75;\n    double distance76;\n\
    \    double distance77;\n    double distance78;\n    double distance79;\n    double\
    \ distance80;\n    double distance81;\n    double distance82;\n    double distance83;\n\
    \    double distance84;\n    double distance85;\n    double distance86;\n    double\
    \ distance87;\n    double distance88;\n    double distance89\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp81t7oien.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp81t7oien.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp81t7oien.cpp:106:1: error: expected\
    \ initializer before \u2018}\u2019 token\n  106 | }\n      | ^\n/tmp/tmp81t7oien.cpp:106:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp81t7oien.cpp:2:\n/tmp/tmp81t7oien.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp81t7oien.cpp:109:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  109 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp81t7oien.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpss13ho2b.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpss13ho2b.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpss13ho2b.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpss13ho2b.cpp:2:\n/tmp/tmpss13ho2b.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpss13ho2b.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpss13ho2b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6xl05bcu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp6xl05bcu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp6xl05bcu.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6xl05bcu.cpp:2:\n/tmp/tmp6xl05bcu.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp6xl05bcu.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6xl05bcu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit = planet1 + \"Orbit\";\n\
    \    std::string planet2Orbit = planet2 + \"Orbit\";\n    std::string planet1OrbitSun\
    \ = planet1 + \"OrbitSun\";\n    std::string planet2OrbitSun = planet2 + \"OrbitSun\"\
    ;\n    std::string planet1OrbitMercury = planet1 + \"OrbitMercury\";\n    std::string\
    \ planet2OrbitMercury = planet2 + \"OrbitMercury\";\n    std::string planet1OrbitVenus\
    \ = planet1 + \"OrbitVenus\";\n    std::string planet2OrbitVenus = planet2 + \"\
    OrbitVenus\";\n    std::string planet1OrbitEarth = planet1 + \"OrbitEarth\";\n\
    \    std::string planet2OrbitEarth = planet2 + \"OrbitEarth\";\n    std::string\
    \ planet1OrbitMars = planet1 + \"OrbitMars\";\n    std::string planet2OrbitMars\
    \ = planet2 + \"OrbitMars\";\n    std::string planet1OrbitJupiter = planet1 +\
    \ \"OrbitJupiter\";\n    std::string planet2OrbitJupiter = planet2 + \"OrbitJupiter\"\
    ;\n    std::string planet1OrbitSaturn = planet1 + \"OrbitSaturn\";\n    std::string\
    \ planet2OrbitSaturn = planet2 + \"OrbitSaturn\";\n    std::string planet1OrbitUranus\
    \ = planet1 + \"OrbitUranus\";\n    std::string planet2OrbitUranus = planet2 +\
    \ \"OrbitUranus\";\n    std::string planet1OrbitNeptune = planet1 + \"OrbitNeptune\"\
    ;\n    std::string planet2OrbitNeptune = planet2 + \"OrbitNeptune\";\n    std::string\
    \ planet1OrbitMercuryOrbitSun = planet1OrbitMercury + planet1OrbitSun;\n    std::string\
    \ planet2OrbitMercuryOrbitSun = planet2OrbitMercury + planet2OrbitSun;\n    std::string\
    \ planet1OrbitVenusOrbitSun = planet1OrbitVenus + planet1OrbitSun;\n    std::string\
    \ planet2OrbitVenusOrbitSun = planet2OrbitVenus + planet2OrbitSun;\n\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp48hn3wog.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp48hn3wog.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp48hn3wog.cpp:42:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   42 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp48hn3wog.cpp:2:\n/tmp/tmp48hn3wog.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp48hn3wog.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp48hn3wog.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance2;\n    double distance3;\n    double distance4;\n\
    \    double distance5;\n    double distance6;\n    double distance7;\n    double\
    \ distance8;\n    double distance9;\n    double distance10;\n    double distance11;\n\
    \    double distance12;\n    double distance13;\n    double distance14;\n    double\
    \ distance15;\n    double distance16;\n    double distance17;\n    double distance18;\n\
    \    double distance19;\n    double distance20;\n    double distance21;\n    double\
    \ distance22;\n    double distance23;\n    double distance24;\n    double distance25;\n\
    \    double distance26;\n    double distance27;\n    double distance28;\n    double\
    \ distance29;\n    double distance30;\n    double distance31;\n    double distance32;\n\
    \    double distance33;\n    double distance34;\n    double distance35;\n    double\
    \ distance36;\n    double distance37;\n    double distance38;\n    double distance39;\n\
    \    double distance40;\n    double distance41;\n    double distance42;\n    double\
    \ distance43;\n    double distance44;\n    double distance45;\n    double distance46;\n\
    \    double distance47;\n    double distance48;\n    double distance49;\n    double\
    \ distance50;\n    double distance51;\n    double distance52;\n    double distance53;\n\
    \    double distance54;\n    double distance55;\n    double distance56;\n    double\
    \ distance57;\n    double distance58;\n    double distance59;\n    double distance60;\n\
    \    double distance61;\n    double distance62;\n    double distance63;\n    double\
    \ distance64;\n    double distance65;\n    double distance66;\n    double distance67;\n\
    \    double distance68;\n    double distance69;\n    double distance70;\n    double\
    \ distance71;\n    double distance72;\n    double distance73;\n    double distance74;\n\
    \    double distance75;\n    double distance76;\n    double distance77;\n    double\
    \ distance78;\n    double distance79;\n    double distance80;\n    double distance81;\n\
    \    double distance82;\n    double distance83;\n    double distance84;\n    double\
    \ distance85;\n    double distance86;\n    \n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpwbd139bv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpwbd139bv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpwbd139bv.cpp:105:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  105 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwbd139bv.cpp:2:\n/tmp/tmpwbd139bv.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpwbd139bv.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwbd139bv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistance2,\
    \ planet2OrbitDistance2;\n    double planet1OrbitDistance3, planet2OrbitDistance3;\n\
    \    double planet1OrbitDistance4, planet2OrbitDistance4;\n    double planet1OrbitDistance5,\
    \ planet2OrbitDistance5;\n    double planet1OrbitDistance6, planet2OrbitDistance6;\n\
    \    double planet1OrbitDistance7, planet2OrbitDistance7;\n    double planet1OrbitDistance8,\
    \ planet2OrbitDistance8;\n    double planet1OrbitDistance9, planet2OrbitDistance9;\n\
    \    double planet1OrbitDistance10, planet2OrbitDistance10;\n    double planet1OrbitDistance11,\
    \ planet2OrbitDistance11;\n    double planet1OrbitDistance12, planet2OrbitDistance12;\n\
    \    double planet1OrbitDistance13, planet2OrbitDistance13;\n    double planet1OrbitDistance14,\
    \ planet2OrbitDistance14;\n    double planet1OrbitDistance15, planet2OrbitDistance15;\n\
    \    double planet1OrbitDistance16, planet2OrbitDistance16;\n    double planet1OrbitDistance17,\
    \ planet2OrbitDistance17;\n    double planet1OrbitDistance18, planet2OrbitDistance18;\n\
    \    double planet1OrbitDistance19, planet2OrbitDistance19;\n    double planet1OrbitDistance20,\
    \ planet2OrbitDistance20;\n    double planet1OrbitDistance21, planet2OrbitDistance21;\n\
    \    double planet1OrbitDistance22, planet2OrbitDistance22;\n    double planet1OrbitDistance23,\
    \ planet2OrbitDistance23;\n    double planet1OrbitDistance24, planet2OrbitDistance24;\n\
    \    double planet1OrbitDistance25, planet2OrbitDistance25;\n    double planet1OrbitDistance26,\
    \ planet2OrbitDistance26;\n    double planet1OrbitDistance27, planet2OrbitDistance27;\n\
    \    double planet1OrbitDistance28, planet2OrbitDistance28;\n    double planet1OrbitDistance29,\
    \ plan\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpto8wmhfs.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpto8wmhfs.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpto8wmhfs.cpp:47:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   47 | }\n      | ^\n/tmp/tmpto8wmhfs.cpp:47:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpto8wmhfs.cpp:2:\n/tmp/tmpto8wmhfs.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpto8wmhfs.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpto8wmhfs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_velocity, planet2_orbital_velocity;\n    double planet1_eccentricity,\
    \ planet2_eccentricity;\n    double planet1_semi_major_axis, planet2_semi_major_axis;\n\
    \    double planet1_longitude, planet2_longitude;\n    double planet1_latitude,\
    \ planet2_latitude;\n    double planet1_orbital_period, planet2_orbital_period;\n\
    \    double planet1_eccentricity_of_the_orbit, planet2_eccentricity_of_the_orbit;\n\
    \    double planet1_semi_major_axis_of_the_orbit, planet2_semi_major_axis_of_the_orbit;\n\
    \    double planet1_longitude_degrees, planet2_longitude_degrees;\n    double\
    \ planet1_latitude_degrees, planet2_latitude_degrees;\n    double planet1_orbital_period_degrees,\
    \ planet2_orbital_period_degrees;\n    double planet1_eccentricity_of_the_orbit_in_radians,\
    \ planet2_eccentricity_of_the_orbit_in_radians;\n    double planet1_semi_major_axis_of_the_orbit_in_radians,\
    \ planet2_semi_major_axis_of_the_orbit_in_radians;\n    double planet1_longitude_degrees_of_the_equator,\
    \ planet2_longitude_degrees_of_the_equator;\n    double planet1_latitude_degrees_of_the_equator,\
    \ planet2_latitude_degrees_of_the_equator;\n    double planet1_orbital_period_degrees_of_the_equator,\
    \ planet2_orbital_period_degrees_of_the_equator;\n    double planet1_eccentricity_of_the_orbit_in_radians_of_the_equator,\
    \ planet2_eccentricity_of_the_orbit_in_radians_of_the_equator;\n    double planet1_semi_major_axis_of_the_orbit_in_radians_of_the_equator,\
    \ planet2_semi_major_axis_of_the_orbit_in_radians_of_the_equator;\n    double\
    \ planet1_longitude_degrees_of_the_prime_meridian, planet2_longitude_degrees_of_the_prime_meridian;\n\
    \    double planet1_latitude_degrees_of_the_prime_meridian, planet2_latitude_degrees_of_the_prime_meridian;\n\
    \    double planet1_orbital_period_degrees_of_\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp984c128l.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp984c128l.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp984c128l.cpp:41:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   41 | }\n      | ^\n/tmp/tmp984c128l.cpp:41:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp984c128l.cpp:2:\n/tmp/tmp984c128l.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp984c128l.cpp:44:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   44 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp984c128l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    double distance;\n    double\
    \ distance1;\n    double distance2;\n    double distance3;\n    double distance4;\n\
    \    double distance5;\n    double distance6;\n    double distance7;\n    double\
    \ distance8;\n    double distance9;\n    double distance10;\n    double distance11;\n\
    \    double distance12;\n    double distance13;\n    double distance14;\n    double\
    \ distance15;\n    double distance16;\n    double distance17;\n    double distance18;\n\
    \    double distance19;\n    double distance20;\n    double distance21;\n    double\
    \ distance22;\n    double distance23;\n    double distance24;\n    double distance25;\n\
    \    double distance26;\n    double distance27;\n    double distance28;\n    double\
    \ distance29;\n    double distance30;\n    double distance31;\n    double distance32;\n\
    \    double distance33;\n    double distance34;\n    double distance35;\n    double\
    \ distance36;\n    double distance37;\n    double distance38;\n    double distance39;\n\
    \    double distance40;\n    double distance41;\n    double distance42;\n    double\
    \ distance43;\n    double distance44;\n    double distance45;\n    double distance46;\n\
    \    double distance47;\n    double distance48;\n    double distance49;\n    double\
    \ distance50;\n    double distance51;\n    double distance52;\n    double distance53;\n\
    \    double distance54;\n    double distance55;\n    double distance56;\n    double\
    \ distance57;\n    double distance58;\n    double distance59;\n    double distance60;\n\
    \    double distance61;\n    double distance62;\n    double distance63;\n    double\
    \ distance64;\n    double distance65;\n    double distance66;\n    double distance67;\n\
    \    double distance68;\n    double distance69;\n    double distance70;\n    double\
    \ distance71;\n    double distance72;\n    double distance73;\n    double distance74;\n\
    \    double distance75;\n    double distance76;\n    double distance77;\n    double\
    \ distance78;\n    double distance79;\n    double distance80;\n    double distance81;\n\
    \    double distance82;\n    double distance83;\n    double distance84;\n    double\
    \ distance85;\n    double distance86;\n    double distance87;\n\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkeu25yio.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpkeu25yio.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpkeu25yio.cpp:107:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  107 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkeu25yio.cpp:2:\n/tmp/tmpkeu25yio.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpkeu25yio.cpp:110:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  110 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpkeu25yio.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.1;\n    double planet_radius\
    \ = 6378.1;\n    double planet_separation = planet_radius - sun_radius;\n    double\
    \ planet_separation_squared = planet_separation * planet_separation;\n    double\
    \ planet_separation_cubed = planet_separation_squared * planet_separation_squared;\n\
    \    double planet_separation_cubed2 = planet_separation_cubed * planet_separation_squared;\n\
    \    double planet_separation_cubed3 = planet_separation_cubed * planet_separation_cubed;\n\
    \    double planet_separation_cubed4 = planet_separation_cubed * planet_separation_cubed2;\n\
    \    double planet_separation_cubed5 = planet_separation_cubed * planet_separation_cubed3;\n\
    \    double planet_separation_cubed6 = planet_separation_cubed * planet_separation_cubed4;\n\
    \    double planet_separation_cubed7 = planet_separation_cubed * planet_separation_cubed5;\n\
    \    double planet_separation_cubed8 = planet_separation_cubed * planet_separation_cubed6;\n\
    \    double planet_separation_cubed9 = planet_separation_cubed * planet_separation_cubed7;\n\
    \    double planet_separation_cubed10 = planet_separation_cubed * planet_separation_cubed8;\n\
    \    double planet_separation_cubed11 = planet_separation_cubed * planet_separation_cubed9;\n\
    \    double planet_separation_cubed12 = planet_separation_cubed * planet_separation_cubed10;\n\
    \    double planet_separation_cubed13 = planet_separation_cubed * planet_separation_cubed11;\n\
    \    double planet_separation_cubed14 = planet_separation_cubed * planet_separation_cubed12;\n\
    \    double planet_separation_cubed15 = planet_separation_cubed * planet_separation_cubed13;\n\
    \    double planet_separation_cubed16 = planet_separation_cubed * planet_separation_cubed14;\n\
    \    double planet_separation_cubed17 = planet_separation_cubed * planet_separation_cubed15;\n\
    \    double planet_separation_cubed18 = planet_separation_cubed * planet_separation_cubed16;\n\
    \    double planet_separation_cubed19 = planet_separation_cubed * planet_separation_cubed17;\n\
    \    double planet_separation_cubed20 = planet_separation_\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuvvm38i9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpuvvm38i9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpuvvm38i9.cpp:40:40: error: \u2018\
    planet_separation_\u2019 was not declared in this scope; did you mean \u2018planet_separation\u2019\
    ?\n   40 |     double planet_separation_cubed20 = planet_separation_\n      |\
    \                                        ^~~~~~~~~~~~~~~~~~\n      |         \
    \                               planet_separation\n/tmp/tmpuvvm38i9.cpp:41:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   41 | }\n      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuvvm38i9.cpp:2:\n/tmp/tmpuvvm38i9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpuvvm38i9.cpp:44:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   44 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuvvm38i9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_name = planet1;\n    std::string\
    \ planet2_name = planet2;\n    std::string planet1_orb = planet1_name + \"_orb\"\
    ;\n    std::string planet2_orb = planet2_name + \"_orb\";\n    std::string planet1_orb_pos\
    \ = planet1_orb + \".pos\";\n    std::string planet2_orb_pos = planet2_orb + \"\
    .pos\";\n    std::string planet1_orb_vel = planet1_orb + \".vel\";\n    std::string\
    \ planet2_orb_vel = planet2_orb + \".vel\";\n    std::string planet1_orb_acc =\
    \ planet1_orb + \".acc\";\n    std::string planet2_orb_acc = planet2_orb + \"\
    .acc\";\n    std::string planet1_orb_ang = planet1_orb + \".ang\";\n    std::string\
    \ planet2_orb_ang = planet2_orb + \".ang\";\n    std::string planet1_orb_ang_vel\
    \ = planet1_orb + \".ang.vel\";\n    std::string planet2_orb_ang_vel = planet2_orb\
    \ + \".ang.vel\";\n    std::string planet1_orb_ang_acc = planet1_orb + \".ang.acc\"\
    ;\n    std::string planet2_orb_ang_acc = planet2_orb + \".ang.acc\";\n    std::string\
    \ planet1_orb_ang_ang = planet1_orb + \".ang.ang\";\n    std::string planet2_orb_ang_ang\
    \ = planet2_orb + \".ang.ang\";\n    std::string planet1_orb_ang_ang_vel = planet1_orb\
    \ + \".ang.ang.vel\";\n    std::string planet2_orb_ang_ang_vel = planet2_orb +\
    \ \".ang.ang.vel\";\n    std::string planet1_orb_ang_ang_acc = planet1_orb + \"\
    .ang.ang.acc\";\n    std::string planet2_orb_ang_ang_acc = planet2_orb + \".ang.ang.acc\"\
    ;\n    std::string planet1_orb_ang_ang_ang = planet1_orb + \".ang.ang.ang\";\n\
    \    std::string planet2_orb_ang_ang_ang = planet2_orb + \".ang.ang.ang\";\n \
    \   std::string planet1_orb_ang_ang_ang_vel = planet1_orb + \".ang.ang.ang.vel\"\
    ;\n    std::string planet2_orb_ang\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5afku97r.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp5afku97r.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp5afku97r.cpp:43:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   43 | }\n      | ^\n/tmp/tmp5afku97r.cpp:43:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5afku97r.cpp:2:\n/tmp/tmp5afku97r.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp5afku97r.cpp:46:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   46 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp5afku97r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpw6o6g5gi.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpw6o6g5gi.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpw6o6g5gi.cpp:19:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   19 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw6o6g5gi.cpp:2:\n/tmp/tmpw6o6g5gi.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpw6o6g5gi.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpw6o6g5gi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1Orbit = planet1 + \"Orbit\"\
    ;\n    std::string planet2Orbit = planet2 + \"Orbit\";\n    \n    std::string\
    \ planet1OrbitSun = planet1 + \"OrbitSun\";\n    std::string planet2OrbitSun =\
    \ planet2 + \"OrbitSun\";\n    \n    std::string planet1OrbitMercury = planet1\
    \ + \"OrbitMercury\";\n    std::string planet2OrbitMercury = planet2 + \"OrbitMercury\"\
    ;\n    \n    std::string planet1OrbitVenus = planet1 + \"OrbitVenus\";\n    std::string\
    \ planet2OrbitVenus = planet2 + \"OrbitVenus\";\n    \n    std::string planet1OrbitEarth\
    \ = planet1 + \"OrbitEarth\";\n    std::string planet2OrbitEarth = planet2 + \"\
    OrbitEarth\";\n    \n    std::string planet1OrbitMars = planet1 + \"OrbitMars\"\
    ;\n    std::string planet2OrbitMars = planet2 + \"OrbitMars\";\n    \n    std::string\
    \ planet1OrbitJupiter = planet1 + \"OrbitJupiter\";\n    std::string planet2OrbitJupiter\
    \ = planet2 + \"OrbitJupiter\";\n    \n    std::string planet1OrbitSaturn = planet1\
    \ + \"OrbitSaturn\";\n    std::string planet2OrbitSaturn = planet2 + \"OrbitSaturn\"\
    ;\n    \n    std::string planet1OrbitUranus = planet1 + \"OrbitUranus\";\n   \
    \ std::string planet2OrbitUranus = planet2 + \"OrbitUranus\";\n    \n    std::string\
    \ planet1OrbitNeptune = planet1 + \"OrbitNeptune\";\n    std::string planet2OrbitNeptune\
    \ = planet2 + \"OrbitNeptune\";\n    \n    std::string planet1OrbitMercuryOrbitSun\
    \ = planet1Orbit + \"Sun\";\n    std::string planet2OrbitMercuryOrbitSun = planet2Orbit\
    \ + \"Sun\";\n    \n    std::string planet1OrbitMercuryOrbitMercury = planet1Orbit\
    \ + \"Mercury\";\n    std::string planet2OrbitMercuryOrbitMercury = planet2Orbit\
    \ + \"Mer\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt2bsfoqc.cpp:52:66: warning: missing terminating \" character\n\
    \   52 |     std::string planet2OrbitMercuryOrbitMercury = planet2Orbit + \"Mer\n\
    \      |                                                                  ^\n\
    /tmp/tmpt2bsfoqc.cpp:52:66: error: missing terminating \" character\n   52 | \
    \    std::string planet2OrbitMercuryOrbitMercury = planet2Orbit + \"Mer\n    \
    \  |                                                                  ^~~~\n/tmp/tmpt2bsfoqc.cpp:16:25:\
    \ error: template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmpt2bsfoqc.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpt2bsfoqc.cpp:53:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   53 | }\n \
    \     | ^\n/tmp/tmpt2bsfoqc.cpp:53:1: error: expected \u2018,\u2019 or \u2018\
    ;\u2019 before \u2018}\u2019 token\n/tmp/tmpt2bsfoqc.cpp:53:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2bsfoqc.cpp:2:\n/tmp/tmpt2bsfoqc.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpt2bsfoqc.cpp:56:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   56 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpt2bsfoqc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/inclu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    double a1 = 0.0;\n    double a2 = 0.0;\n \
    \   double b1 = 0.0;\n    double b2 = 0.0;\n    double c1 = 0.0;\n    double c2\
    \ = 0.0;\n    double d1 = 0.0;\n    double d2 = 0.0;\n    double e1 = 0.0;\n \
    \   double e2 = 0.0;\n    double f1 = 0.0;\n    double f2 = 0.0;\n    double g1\
    \ = 0.0;\n    double g2 = 0.0;\n    double h1 = 0.0;\n    double h2 = 0.0;\n \
    \   double i1 = 0.0;\n    double i2 = 0.0;\n    double j1 = 0.0;\n    double j2\
    \ = 0.0;\n    double k1 = 0.0;\n    double k2 = 0.0;\n    double l1 = 0.0;\n \
    \   double l2 = 0.0;\n    double m1 = 0.0;\n    double m2 = 0.0;\n    double n1\
    \ = 0.0;\n    double n2 = 0.0;\n    double o1 = 0.0;\n    double o2 = 0.0;\n \
    \   double p1 = 0.0;\n    double p2 = 0.0;\n    double q1 = 0.0;\n    double q2\
    \ = 0.0;\n    double r1 = 0.0;\n    double r2 = 0.0;\n    double s1 = 0.0;\n \
    \   double s2 = 0.0;\n    double t1 = 0.0;\n    double t2 = 0.0;\n    double u1\
    \ = 0.0;\n    double u2 = 0.0;\n    double v1 = 0.0;\n    double v2 = 0.0;\n \
    \   double w1 = 0.0;\n    double w2 = 0.0;\n    double x1 = 0.0;\n    double x2\
    \ = 0.0;\n    double y1 = 0.0;\n    double y2 = 0.0;\n    double z1 = 0.0;\n \
    \   double z2 = 0.0;\n    double a3 = 0.0;\n    double b3 = 0.0;\n    double c3\
    \ = 0.0;\n    double d3 = 0.0;\n    double e3 = 0.0;\n    double f3 = 0.0;\n \
    \   double g3 = 0.0;\n    double h3 = 0.0;\n    double i3 = 0.0;\n    double j3\
    \ = 0.0;\n    double k3 = 0.0;\n    double l3 = 0.0;\n    double m3 = 0.0;\n \
    \   double n3 = 0.0;\n    double o3 = 0.0;\n    double p3 = 0.0;\n    double q3\
    \ = 0.0;\n    double r3 = 0.0;\n    double s3 = 0.0;\n    double t3 = 0.0;\n \
    \   double u3 = 0.0;\n    double v3 = 0.0;\n    double \n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqb_ojwhy.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpqb_ojwhy.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpqb_ojwhy.cpp:93:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n   93 | }\n      | ^\n/tmp/tmpqb_ojwhy.cpp:93:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqb_ojwhy.cpp:2:\n/tmp/tmpqb_ojwhy.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpqb_ojwhy.cpp:96:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   96 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpqb_ojwhy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4tdfa8gl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4tdfa8gl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4tdfa8gl.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4tdfa8gl.cpp:2:\n/tmp/tmp4tdfa8gl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp4tdfa8gl.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4tdfa8gl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8sas6892.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8sas6892.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8sas6892.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8sas6892.cpp:2:\n/tmp/tmp8sas6892.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8sas6892.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8sas6892.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistance2,\
    \ planet2OrbitDistance2;\n    double planet1OrbitDistance3, planet2OrbitDistance3;\n\
    \    double planet1OrbitDistance4, planet2OrbitDistance4;\n    double planet1OrbitDistance5,\
    \ planet2OrbitDistance5;\n    double planet1OrbitDistance6, planet2OrbitDistance6;\n\
    \    double planet1OrbitDistance7, planet2OrbitDistance7;\n    double planet1OrbitDistance8,\
    \ planet2OrbitDistance8;\n    double planet1OrbitDistance9, planet2OrbitDistance9;\n\
    \    double planet1OrbitDistance10, planet2OrbitDistance10;\n    double planet1OrbitDistance11,\
    \ planet2OrbitDistance11;\n    double planet1OrbitDistance12, planet2OrbitDistance12;\n\
    \    double planet1OrbitDistance13, planet2OrbitDistance13;\n    double planet1OrbitDistance14,\
    \ planet2OrbitDistance14;\n    double planet1OrbitDistance15, planet2OrbitDistance15;\n\
    \    double planet1OrbitDistance16, planet2OrbitDistance16;\n    double planet1OrbitDistance17,\
    \ planet2OrbitDistance17;\n    double planet1OrbitDistance18, planet2OrbitDistance18;\n\
    \    double planet1OrbitDistance19, planet2OrbitDistance19;\n    double planet1OrbitDistance20,\
    \ planet2OrbitDistance20;\n    double planet1OrbitDistance21, planet2OrbitDistance21;\n\
    \    double planet1OrbitDistance22, planet2OrbitDistance22;\n    double planet1OrbitDistance23,\
    \ planet2OrbitDistance23;\n    double planet1OrbitDistance24, planet2OrbitDistance24;\n\
    \    double planet1OrbitDistance25, planet2OrbitDistance25;\n    double planet1OrbitDistance26,\
    \ planet2OrbitDistance26;\n    double planet1OrbitDistance27, planet2OrbitDistance27;\n\
    \    double planet1OrbitDistance28, planet2OrbitDistance28;\n    double planet1OrbitDistance29,\
    \ plan\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpto19qv95.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpto19qv95.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpto19qv95.cpp:47:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   47 | }\n      | ^\n/tmp/tmpto19qv95.cpp:47:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpto19qv95.cpp:2:\n/tmp/tmpto19qv95.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpto19qv95.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpto19qv95.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Write your code here\n    \n    return\
    \ std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmptxoax0ct.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptxoax0ct.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptxoax0ct.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptxoax0ct.cpp:2:\n/tmp/tmptxoax0ct.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmptxoax0ct.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptxoax0ct.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfuj49g8f.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfuj49g8f.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfuj49g8f.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfuj49g8f.cpp:2:\n/tmp/tmpfuj49g8f.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfuj49g8f.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfuj49g8f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    \n    std::tuple<std::string,\
    \ > result;\n    if (planet1 == \"Mercury\") {\n        if (planet2 == \"Venus\"\
    ) {\n            result.emplace(planet2);\n        } else if (planet2 == \"Earth\"\
    ) {\n            result.emplace(planet1);\n        } else if (planet2 == \"Mars\"\
    ) {\n            result.emplace(planet1);\n        } else if (planet2 == \"Jupiter\"\
    ) {\n            result.emplace(planet1);\n        } else if (planet2 == \"Saturn\"\
    ) {\n            result.emplace(planet1);\n        } else if (planet2 == \"Uranus\"\
    ) {\n            result.emplace(planet1);\n        } else if (planet2 == \"Neptune\"\
    ) {\n            result.emplace(planet1);\n        }\n    } else if (planet1 ==\
    \ \"Venus\") {\n        if (planet2 == \"Mercury\") {\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Earth\") {\n            result.emplace(planet1);\n\
    \        } else if (planet2 == \"Mars\") {\n            result.emplace(planet1);\n\
    \        } else if (planet2 == \"Jupiter\") {\n            result.emplace(planet1);\n\
    \        } else if (planet2 == \"Saturn\") {\n            result.emplace(planet1);\n\
    \        } else if (planet2 == \"Uranus\") {\n            result.emplace(planet1);\n\
    \        } else if (planet2 == \"Neptune\") {\n            result.emplace(planet1);\n\
    \        }\n    } else if (planet1 == \"Earth\") {\n        if (planet2 == \"\
    Mercury\") {\n            result.emplace(planet2);\n        } else if (planet2\
    \ == \"Venus\") {\n            result.emplace(planet1);\n        } else if (planet2\
    \ == \"Mars\") {\n            result.emplace(planet1);\n        } else if (planet2\
    \ == \"Jupiter\") {\n            result.emplace(planet1);\n        } else if (planet2\
    \ == \"Saturn\") {\n            result.emplace(planet1);\n        } else if (planet2\
    \ == \"Uranus\") {\n            result.emplace(planet\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpa_gslmcf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpa_gslmcf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpa_gslmcf.cpp:20:29: error: template\
    \ argument 2 is invalid\n   20 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpa_gslmcf.cpp:23:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   23 |             result.emplace(planet2);\n      |\
    \                    ^~~~~~~\n/tmp/tmpa_gslmcf.cpp:25:20: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   25 |             result.emplace(planet1);\n      |             \
    \       ^~~~~~~\n/tmp/tmpa_gslmcf.cpp:27:20: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   27 |             result.emplace(planet1);\n      |                    ^~~~~~~\n\
    /tmp/tmpa_gslmcf.cpp:29:20: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   29 |            \
    \ result.emplace(planet1);\n      |                    ^~~~~~~\n/tmp/tmpa_gslmcf.cpp:31:20:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   31 |             result.emplace(planet1);\n\
    \      |                    ^~~~~~~\n/tmp/tmpa_gslmcf.cpp:33:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   33 |             result.emplace(planet1);\n      |\
    \                    ^~~~~~~\n/tmp/tmpa_gslmcf.cpp:35:20: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   35 |             result.emplace(planet1);\n      |             \
    \       ^~~~~~~\n/tmp/tmpa_gslmcf.cpp:39:20: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   39 |             result.emplace(planet2);\n      |                    ^~~~~~~\n\
    /tmp/tmpa_gslmcf.cpp:41:20: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   41 |          "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0z18_6w9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0z18_6w9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0z18_6w9.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0z18_6w9.cpp:2:\n/tmp/tmp0z18_6w9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp0z18_6w9.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0z18_6w9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::tuple<std::string,\
    \ >();\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjkgzmpbk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjkgzmpbk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjkgzmpbk.cpp:20:36: error: template\
    \ argument 2 is invalid\n   20 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjkgzmpbk.cpp:2:\n/tmp/tmpjkgzmpbk.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpjkgzmpbk.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpjkgzmpbk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpi0g9vc5s.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpi0g9vc5s.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpi0g9vc5s.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi0g9vc5s.cpp:2:\n/tmp/tmpi0g9vc5s.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpi0g9vc5s.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpi0g9vc5s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptplvfgtj.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmptplvfgtj.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmptplvfgtj.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptplvfgtj.cpp:2:\n/tmp/tmptplvfgtj.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmptplvfgtj.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptplvfgtj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.137;\n    double sun_mass\
    \ = 5.97219e24;\n    double planet_mass = 1.99e33;\n    double planet_radius =\
    \ 6378.137;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = 297.85;\n    double planet_orbital_angle\
    \ = 1.57;\n    double planet_orbital_period = \n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0yf2ejj9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0yf2ejj9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0yf2ejj9.cpp:23:12: error: redeclaration\
    \ of \u2018double planet_orbital_period\u2019\n   23 |     double planet_orbital_period\
    \ = 297.85;\n      |            ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0yf2ejj9.cpp:21:12:\
    \ note: \u2018double planet_orbital_period\u2019 previously declared here\n  \
    \ 21 |     double planet_orbital_period = 297.85;\n      |            ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0yf2ejj9.cpp:24:12: error: redeclaration of \u2018double planet_orbital_angle\u2019\
    \n   24 |     double planet_orbital_angle = 1.57;\n      |            ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0yf2ejj9.cpp:22:12: note: \u2018double planet_orbital_angle\u2019 previously\
    \ declared here\n   22 |     double planet_orbital_angle = 1.57;\n      |    \
    \        ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0yf2ejj9.cpp:25:12: error: redeclaration\
    \ of \u2018double planet_orbital_period\u2019\n   25 |     double planet_orbital_period\
    \ = 297.85;\n      |            ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0yf2ejj9.cpp:21:12:\
    \ note: \u2018double planet_orbital_period\u2019 previously declared here\n  \
    \ 21 |     double planet_orbital_period = 297.85;\n      |            ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0yf2ejj9.cpp:26:12: error: redeclaration of \u2018double planet_orbital_angle\u2019\
    \n   26 |     double planet_orbital_angle = 1.57;\n      |            ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0yf2ejj9.cpp:22:12: note: \u2018double planet_orbital_angle\u2019 previously\
    \ declared here\n   22 |     double planet_orbital_angle = 1.57;\n      |    \
    \        ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0yf2ejj9.cpp:27:12: error: redeclaration\
    \ of \u2018double planet_orbital_period\u2019\n   27 |     double planet_orbital_period\
    \ = 297.85;\n      |            ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0yf2ejj9.cpp:21:12:\
    \ note: \u2018double planet_orbital_period\u2019 previously declared here\n  \
    \ 21 |     double planet_orbital_period = 297.85;\n      |            ^~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0yf2ejj9.cpp:28:12: erro"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1;\n    double distance2;\n    double distance3;\n\
    \    double distance4;\n    double distance5;\n    double distance6;\n    double\
    \ distance7;\n    double distance8;\n    double distance9;\n    double distance10;\n\
    \    double distance11;\n    double distance12;\n    double distance13;\n    double\
    \ distance14;\n    double distance15;\n    double distance16;\n    double distance17;\n\
    \    double distance18;\n    double distance19;\n    double distance20;\n    double\
    \ distance21;\n    double distance22;\n    double distance23;\n    double distance24;\n\
    \    double distance25;\n    double distance26;\n    double distance27;\n    double\
    \ distance28;\n    double distance29;\n    double distance30;\n    double distance31;\n\
    \    double distance32;\n    double distance33;\n    double distance34;\n    double\
    \ distance35;\n    double distance36;\n    double distance37;\n    double distance38;\n\
    \    double distance39;\n    double distance40;\n    double distance41;\n    double\
    \ distance42;\n    double distance43;\n    double distance44;\n    double distance45;\n\
    \    double distance46;\n    double distance47;\n    double distance48;\n    double\
    \ distance49;\n    double distance50;\n    double distance51;\n    double distance52;\n\
    \    double distance53;\n    double distance54;\n    double distance55;\n    double\
    \ distance56;\n    double distance57;\n    double distance58;\n    double distance59;\n\
    \    double distance60;\n    double distance61;\n    double distance62;\n    double\
    \ distance63;\n    double distance64;\n    double distance65;\n    double distance66;\n\
    \    double distance67;\n    double distance68;\n    double distance69;\n    double\
    \ distance70;\n    double distance71;\n    double distance72;\n    double distance73;\n\
    \    double distance74;\n    double distance75;\n    double distance76;\n    double\
    \ distance77;\n    double distance78;\n    double distance79;\n    double distance80;\n\
    \    double distance81;\n    double distance82;\n    double distance83;\n    double\
    \ distance84;\n    double distance85;\n    double \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxtu38o6c.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpxtu38o6c.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpxtu38o6c.cpp:105:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmpxtu38o6c.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxtu38o6c.cpp:2:\n/tmp/tmpxtu38o6c.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpxtu38o6c.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpxtu38o6c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1, distance2;\n    double distance1Orbit, distance2Orbit;\n\
    \    double distance1Orbit1, distance2Orbit1;\n    double distance1Orbit2, distance2Orbit2;\n\
    \    double distance1Orbit3, distance2Orbit3;\n    double distance1Orbit4, distance2Orbit4;\n\
    \    double distance1Orbit5, distance2Orbit5;\n    double distance1Orbit6, distance2Orbit6;\n\
    \    double distance1Orbit7, distance2Orbit7;\n    double distance1Orbit8, distance2Orbit8;\n\
    \    double distance1Orbit9, distance2Orbit9;\n    double distance1Orbit10, distance2Orbit10;\n\
    \    double distance1Orbit11, distance2Orbit11;\n    double distance1Orbit12,\
    \ distance2Orbit12;\n    double distance1Orbit13, distance2Orbit13;\n    double\
    \ distance1Orbit14, distance2Orbit14;\n    double distance1Orbit15, distance2Orbit15;\n\
    \    double distance1Orbit16, distance2Orbit16;\n    double distance1Orbit17,\
    \ distance2Orbit17;\n    double distance1Orbit18, distance2Orbit18;\n    double\
    \ distance1Orbit19, distance2Orbit19;\n    double distance1Orbit20, distance2Orbit20;\n\
    \    double distance1Orbit21, distance2Orbit21;\n    double distance1Orbit22,\
    \ distance2Orbit22;\n    double distance1Orbit23, distance2Orbit23;\n    double\
    \ distance1Orbit24, distance2Orbit24;\n    double distance1Orbit25, distance2Orbit25;\n\
    \    double distance1Orbit26, distance2Orbit26;\n    double distance1Orbit27,\
    \ distance2Orbit27;\n    double distance1Orbit28, distance2Orbit28;\n    double\
    \ distance1Orbit29, distance2Orbit29;\n    double distance1Orbit30, distance2Orbit30;\n\
    \    double distance1Orbit31, distance2Orbit31;\n    double distance1Orbit32,\
    \ distance2Orbit32;\n    double distance1Orbit33, distance2Orbit33;\n    double\
    \ distance1Orbit34, distance2Orbit34;\n    double distance1Orbit35, distance2Orbit35;\n\
    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprj2_tlqb.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmprj2_tlqb.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmprj2_tlqb.cpp:57:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   57 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprj2_tlqb.cpp:2:\n/tmp/tmprj2_tlqb.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmprj2_tlqb.cpp:60:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   60 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprj2_tlqb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgf05c4dl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpgf05c4dl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpgf05c4dl.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgf05c4dl.cpp:2:\n/tmp/tmpgf05c4dl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpgf05c4dl.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgf05c4dl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd_zk6fkg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpd_zk6fkg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpd_zk6fkg.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd_zk6fkg.cpp:2:\n/tmp/tmpd_zk6fkg.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpd_zk6fkg.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpd_zk6fkg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1_name = planet1;\n    std::string\
    \ planet2_name = planet2;\n    \n    // The planets whose orbits lie between the\
    \ orbit of planet1 and the orbit \n    // of planet2 are \"sorted\" by their distance\
    \ to the Sun.\n    // The distance is calculated using the formula \n    // d\
    \ = acos(sin(\u03B81)sin(\u03B82) + cos(\u03B81)cos(\u03B82)cos(\u03B83))\n  \
    \  // where \u03B81 and \u03B82 are the latitudes of the planets and \u03B83 is\
    \ the \n    // longitude of the planet. \n    // The distance is calculated using\
    \ the formula \n    // d = acos(sin(\u03B81)sin(\u03B82) + cos(\u03B81)cos(\u03B8\
    2)cos(\u03B83))\n    // where \u03B81 and \u03B82 are the latitudes of the planets\
    \ and \u03B83 is the \n    // longitude of the planet. \n    \n    // The formula\
    \ for calculating the distance between two latitudes \n    // is given by \n \
    \   // d = acos(sin(\u03B81)sin(\u03B82) + cos(\u03B81)cos(\u03B82)cos(\u03B8\
    3))\n    // where \u03B81 and \u03B82 are the latitudes of the planets and \u03B8\
    3 is the \n    // longitude of the planet. \n    \n    // The formula for calculating\
    \ the distance between two longitudes \n    // is given by \n    // d = acos(sin(\u03B8\
    1)sin(\u03B82) + cos(\u03B81)cos(\u03B82)cos(\u03B83))\n    // where \u03B81 and\
    \ \u03B82 are the latitudes of the planets and \u03B83 is the \n    // longitude\
    \ of the planet. \n    \n    // The formula for calculating the distance between\
    \ two latitudes \n    // is given by \n    // d = acos(sin(\u03B81)sin(\u03B8\
    2) + cos(\u03B81)cos(\u03B82)cos(\u03B83))\n    // where \u03B81 and \u03B82 are\
    \ the latitudes of the planets and \u03B83 is the \n    // longitude of the planet.\
    \ \n    \n    // The formula for calculating the distance between two longitudes\
    \ \n    // is given by \n    // d = acos(sin(\u03B81)sin(\u03B82) + cos(\u03B8\
    1)cos(\u03B82)cos(\u03B83))\n    // where \u03B81 and \u03B82 are the latitudes\
    \ of the planets and \u03B83 is the \n    // longitude of the planet. \n    \n\
    \    // The formula for calculating the distance between two latitudes \n    //\
    \ is given by \n    // d = acos(sin(\u03B81)sin(\u03B82) + cos(\u03B81)cos(\u03B8\
    2)cos(\u03B83))\n    // where \u03B81 and \u03B82 are the latitudes of the planets\
    \ and \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbrqlrffb.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbrqlrffb.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbrqlrffb.cpp:60:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   60 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbrqlrffb.cpp:2:\n/tmp/tmpbrqlrffb.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbrqlrffb.cpp:63:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   63 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbrqlrffb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::tuple<std::string,\
    \ >();\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzmjfcmgt.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzmjfcmgt.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzmjfcmgt.cpp:20:36: error: template\
    \ argument 2 is invalid\n   20 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzmjfcmgt.cpp:2:\n/tmp/tmpzmjfcmgt.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzmjfcmgt.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzmjfcmgt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceSquared\
    \ = 0.0, planet2OrbitDistanceSquared = 0.0;\n    double planet1OrbitDistanceSquaredSq\
    \ = 0.0, planet2OrbitDistanceSquaredSq = 0.0;\n    double planet1OrbitDistanceSq\
    \ = 0.0, planet2OrbitDistanceSq = 0.0;\n    double planet1OrbitDistanceSqrt =\
    \ 0.0, planet2OrbitDistanceSqrt = 0.0;\n    double planet1OrbitDistanceSqrt_2\
    \ = 0.0, planet2OrbitDistanceSqrt_2 = 0.0;\n    double planet1OrbitDistanceSqrt_3\
    \ = 0.0, planet2OrbitDistanceSqrt_3 = 0.0;\n    double planet1OrbitDistanceSqrt_4\
    \ = 0.0, planet2OrbitDistanceSqrt_4 = 0.0;\n    double planet1OrbitDistanceSqrt_5\
    \ = 0.0, planet2OrbitDistanceSqrt_5 = 0.0;\n    double planet1OrbitDistanceSqrt_6\
    \ = 0.0, planet2OrbitDistanceSqrt_6 = 0.0;\n    double planet1OrbitDistanceSqrt_7\
    \ = 0.0, planet2OrbitDistanceSqrt_7 = 0.0;\n    double planet1OrbitDistanceSqrt_8\
    \ = 0.0, planet2OrbitDistanceSqrt_8 = 0.0;\n    double planet1OrbitDistanceSqrt_9\
    \ = 0.0, planet2OrbitDistanceSqrt_9 = 0.0;\n    double planet1OrbitDistanceSqrt_10\
    \ = 0.0, planet2OrbitDistanceSqrt_10 = 0.0;\n    double planet1OrbitDistanceSqrt_11\
    \ = 0.0, planet2OrbitDistanceSqrt_11 = 0.0;\n    double planet1OrbitDistanceSqrt_12\
    \ = 0.0, planet2OrbitDistanceSqrt_12 = 0.0;\n    double planet1OrbitDistanceSqrt_13\
    \ = 0.0, planet2OrbitDistanceSqrt_13 = 0.0;\n    double planet1OrbitDistanceSqrt_14\
    \ = 0.0, planet2OrbitDistanceSqrt_14 = 0.0;\n    double planet1OrbitDistanceSqrt_15\
    \ = 0.0, planet2OrbitDistanceSqrt_15 = 0.0;\n    double planet1OrbitDistanceSqrt_16\
    \ = 0.0, planet2Or\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5brr0hc_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp5brr0hc_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp5brr0hc_.cpp:38:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   38 | }\n      | ^\n/tmp/tmp5brr0hc_.cpp:38:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5brr0hc_.cpp:2:\n/tmp/tmp5brr0hc_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp5brr0hc_.cpp:41:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   41 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp5brr0hc_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    \n    return\
    \ std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpmoh9tdxk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmoh9tdxk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmoh9tdxk.cpp:21:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   21 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmoh9tdxk.cpp:2:\n/tmp/tmpmoh9tdxk.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpmoh9tdxk.cpp:25:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   25 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmoh9tdxk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1Orbit, planet2Orbit;\n\
    \    double planet1OrbitRadius, planet2OrbitRadius;\n    double planet1OrbitDistance,\
    \ planet2OrbitDistance;\n    double planet1OrbitDistanceRadians, planet2OrbitDistanceRadians;\n\
    \    double planet1OrbitDistanceRadians2, planet2OrbitDistanceRadians2;\n    double\
    \ planet1OrbitDistanceRadians3, planet2OrbitDistanceRadians3;\n    double planet1OrbitDistanceRadians4,\
    \ planet2OrbitDistanceRadians4;\n    double planet1OrbitDistanceRadians5, planet2OrbitDistanceRadians5;\n\
    \    double planet1OrbitDistanceRadians6, planet2OrbitDistanceRadians6;\n    double\
    \ planet1OrbitDistanceRadians7, planet2OrbitDistanceRadians7;\n    double planet1OrbitDistanceRadians8,\
    \ planet2OrbitDistanceRadians8;\n    double planet1OrbitDistanceRadians9, planet2OrbitDistanceRadians9;\n\
    \    double planet1OrbitDistanceRadians10, planet2OrbitDistanceRadians10;\n  \
    \  double planet1OrbitDistanceRadians11, planet2OrbitDistanceRadians11;\n    double\
    \ planet1OrbitDistanceRadians12, planet2OrbitDistanceRadians12;\n    double planet1OrbitDistanceRadians13,\
    \ planet2OrbitDistanceRadians13;\n    double planet1OrbitDistanceRadians14, planet2OrbitDistanceRadians14;\n\
    \    double planet1OrbitDistanceRadians15, planet2OrbitDistanceRadians15;\n  \
    \  double planet1OrbitDistanceRadians16, planet2OrbitDistanceRadians16;\n    double\
    \ planet1OrbitDistanceRadians17, planet2OrbitDistanceRadians17;\n    double planet1OrbitDistanceRadians18,\
    \ planet2OrbitDistanceRadians18;\n    double planet1OrbitDistanceRadians19, planet2OrbitDistanceRadians19;\n\
    \    double planet1OrbitDistanceRadians20, planet2OrbitDistanceRadians20;\n  \
    \  double planet1OrbitDistanceRadians21, planet2OrbitDistanceRadians21;\n    double\
    \ planet1OrbitDistanceRadians22, planet2\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpnpfeu_xh.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnpfeu_xh.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnpfeu_xh.cpp:43:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   43 | }\n      | ^\n/tmp/tmpnpfeu_xh.cpp:43:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnpfeu_xh.cpp:2:\n/tmp/tmpnpfeu_xh.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpnpfeu_xh.cpp:46:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   46 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpnpfeu_xh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_distance = std::abs(sun_distance(planet1,\
    \ planet2));\n    double sun_radius = std::abs(sun_radius(planet1, planet2));\n\
    \    double planet_distance = std::abs(planet_distance(planet1, planet2));\n \
    \   double planet_radius = std::abs(planet_radius(planet1, planet2));\n    double\
    \ planet_angle = std::abs(planet_angle(planet1, planet2));\n    double planet_mass\
    \ = std::abs(planet_mass(planet1, planet2));\n    double planet_radius = std::abs(planet_radius(planet1,\
    \ planet2));\n    double planet_angle = std::abs(planet_angle(planet1, planet2));\n\
    \    double planet_mass = std::abs(planet_mass(planet1, planet2));\n    double\
    \ planet_distance = std::abs(planet_distance(planet1, planet2));\n    double planet_radius\
    \ = std::abs(planet_radius(planet1, planet2));\n    double planet_angle = std::abs(planet_angle(planet1,\
    \ planet2));\n    double planet_mass = std::abs(planet_mass(planet1, planet2));\n\
    \    double planet_distance = std::abs(planet_distance(planet1, planet2));\n \
    \   double planet_radius = std::abs(planet_radius(planet1, planet2));\n    double\
    \ planet_angle = std::abs(planet_angle(planet1, planet2));\n    double planet_mass\
    \ = std::abs(planet_mass(planet1, planet2));\n    double planet_distance = std::abs(planet_distance(planet1,\
    \ planet2));\n    double planet_radius = std::abs(planet_radius(planet1, planet2));\n\
    \    double planet_angle = std::abs(planet_angle(planet1, planet2));\n    double\
    \ planet_mass = std::abs(planet_mass(planet1, planet2));\n    double planet_distance\
    \ = std::abs(planet_distance(planet1, planet2));\n    double planet_radius = std::abs(planet_radius(planet1,\
    \ planet2));\n    double planet_angle = std::abs(planet_angle(planet1, planet2));\n\
    \    double planet_mass = std::abs(planet_mass(planet1, planet2));\n    double\
    \ planet_distance = std::abs(planet_distance(planet1, planet2));\n    double planet_radius\
    \ = std::abs(planet_radius(planet1, planet2));\n    double planet_angle = std::abs(planet_angle(planet1,\
    \ planet2));\n    double planet_mass = std::abs(plan\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpw41p_vfs.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpw41p_vfs.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpw41p_vfs.cpp:17:65: error: \u2018\
    sun_distance\u2019 cannot be used as a function\n   17 |     double sun_distance\
    \ = std::abs(sun_distance(planet1, planet2));\n      |                       \
    \                                          ^\n/tmp/tmpw41p_vfs.cpp:18:61: error:\
    \ \u2018sun_radius\u2019 cannot be used as a function\n   18 |     double sun_radius\
    \ = std::abs(sun_radius(planet1, planet2));\n      |                         \
    \                                    ^\n/tmp/tmpw41p_vfs.cpp:19:71: error: \u2018\
    planet_distance\u2019 cannot be used as a function\n   19 |     double planet_distance\
    \ = std::abs(planet_distance(planet1, planet2));\n      |                    \
    \                                                   ^\n/tmp/tmpw41p_vfs.cpp:20:67:\
    \ error: \u2018planet_radius\u2019 cannot be used as a function\n   20 |     double\
    \ planet_radius = std::abs(planet_radius(planet1, planet2));\n      |        \
    \                                                           ^\n/tmp/tmpw41p_vfs.cpp:21:65:\
    \ error: \u2018planet_angle\u2019 cannot be used as a function\n   21 |     double\
    \ planet_angle = std::abs(planet_angle(planet1, planet2));\n      |          \
    \                                                       ^\n/tmp/tmpw41p_vfs.cpp:22:63:\
    \ error: \u2018planet_mass\u2019 cannot be used as a function\n   22 |     double\
    \ planet_mass = std::abs(planet_mass(planet1, planet2));\n      |            \
    \                                                   ^\n/tmp/tmpw41p_vfs.cpp:23:12:\
    \ error: redeclaration of \u2018double planet_radius\u2019\n   23 |     double\
    \ planet_radius = std::abs(planet_radius(planet1, planet2));\n      |        \
    \    ^~~~~~~~~~~~~\n/tmp/tmpw41p_vfs.cpp:20:12: note: \u2018double planet_radius\u2019\
    \ previously declared here\n   20 |     double planet_radius = std::abs(planet_radius(planet1,\
    \ planet2));\n      |            ^~~~~~~~~~~~~\n/tmp/tmpw41p_vfs.cpp:23:67: error:\
    \ \u2018pla"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double a1 = 0.0;\n    double a2 = 0.0;\n    double\
    \ b1 = 0.0;\n    double b2 = 0.0;\n    double c1 = 0.0;\n    double c2 = 0.0;\n\
    \    double d1 = 0.0;\n    double d2 = 0.0;\n    double e1 = 0.0;\n    double\
    \ e2 = 0.0;\n    double f1 = 0.0;\n    double f2 = 0.0;\n    double g1 = 0.0;\n\
    \    double g2 = 0.0;\n    double h1 = 0.0;\n    double h2 = 0.0;\n    double\
    \ i1 = 0.0;\n    double i2 = 0.0;\n    double j1 = 0.0;\n    double j2 = 0.0;\n\
    \    double k1 = 0.0;\n    double k2 = 0.0;\n    double l1 = 0.0;\n    double\
    \ l2 = 0.0;\n    double m1 = 0.0;\n    double m2 = 0.0;\n    double n1 = 0.0;\n\
    \    double n2 = 0.0;\n    double o1 = 0.0;\n    double o2 = 0.0;\n    double\
    \ p1 = 0.0;\n    double p2 = 0.0;\n    double q1 = 0.0;\n    double q2 = 0.0;\n\
    \    double r1 = 0.0;\n    double r2 = 0.0;\n    double s1 = 0.0;\n    double\
    \ s2 = 0.0;\n    double t1 = 0.0;\n    double t2 = 0.0;\n    double u1 = 0.0;\n\
    \    double u2 = 0.0;\n    double v1 = 0.0;\n    double v2 = 0.0;\n    double\
    \ w1 = 0.0;\n    double w2 = 0.0;\n    double x1 = 0.0;\n    double x2 = 0.0;\n\
    \    double y1 = 0.0;\n    double y2 = 0.0;\n    double z1 = 0.0;\n    double\
    \ z2 = 0.0;\n    double a3 = 0.0;\n    double b3 = 0.0;\n    double c3 = 0.0;\n\
    \    double d3 = 0.0;\n    double e3 = 0.0;\n    double f3 = 0.0;\n    double\
    \ g3 = 0.0;\n    double h3 = 0.0;\n    double i3 = 0.0;\n    double j3 = 0.0;\n\
    \    double k3 = 0.0;\n    double l3 = 0.0;\n    double m3 = 0.0;\n    double\
    \ n3 = 0.0;\n    double o3 = 0.0;\n    double p3 = 0.0;\n    double q3 = 0.0;\n\
    \    double r3 = 0.0;\n    double s3 = 0.0;\n    double t3 = 0.0;\n    double\
    \ u3 = 0.0;\n    double v3 = 0.0;\n    double w3 = \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp1ybrh3rp.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1ybrh3rp.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1ybrh3rp.cpp:92:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   92 | }\n      | ^\n/tmp/tmp1ybrh3rp.cpp:92:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1ybrh3rp.cpp:2:\n/tmp/tmp1ybrh3rp.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp1ybrh3rp.cpp:95:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   95 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp1ybrh3rp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceSquared\
    \ = 0.0, planet2OrbitDistanceSquared = 0.0;\n    double planet1OrbitDistanceSquared2\
    \ = 0.0, planet2OrbitDistanceSquared2 = 0.0;\n    double planet1OrbitDistanceSquared3\
    \ = 0.0, planet2OrbitDistanceSquared3 = 0.0;\n    double planet1OrbitDistanceSquared4\
    \ = 0.0, planet2OrbitDistanceSquared4 = 0.0;\n    double planet1OrbitDistanceSquared5\
    \ = 0.0, planet2OrbitDistanceSquared5 = 0.0;\n    double planet1OrbitDistanceSquared6\
    \ = 0.0, planet2OrbitDistanceSquared6 = 0.0;\n    double planet1OrbitDistanceSquared7\
    \ = 0.0, planet2OrbitDistanceSquared7 = 0.0;\n    double planet1OrbitDistanceSquared8\
    \ = 0.0, planet2OrbitDistanceSquared8 = 0.0;\n    double planet1OrbitDistanceSquared9\
    \ = 0.0, planet2OrbitDistanceSquared9 = 0.0;\n    double planet1OrbitDistanceSquared10\
    \ = 0.0, planet2OrbitDistanceSquared10 = 0.0;\n    double planet1OrbitDistanceSquared11\
    \ = 0.0, planet2OrbitDistanceSquared11 = 0.0;\n    double planet1OrbitDistanceSquared12\
    \ = 0.0, planet2OrbitDistanceSquared12 = 0.0;\n    double planet1OrbitDistanceSquared13\
    \ = 0.0, planet2OrbitDistanceSquared13 = 0.0;\n    double planet1OrbitDistanceSquared14\
    \ = 0.0, planet2OrbitDistanceSquared14 = 0.0;\n    double planet1OrbitDistanceSquared15\
    \ = 0.0, planet2OrbitDistanceSquared15 = 0.0;\n    double planet1OrbitDistanceSquared16\
    \ = 0.0, planet2OrbitDistanceSquared16 = 0.0;\n    double planet1OrbitDistanceSquared17\
    \ = 0.0, planet2OrbitDistanceSquared17 = 0.0;\n    double planet1OrbitDistanceSquared18\
    \ = 0.0, planet2OrbitDistanceSquared18 = 0.0;\n    double planet1OrbitDistanceSquared19\
    \ = 0.0, planet2OrbitDistanceSquared19 = 0.0;\n    double planet1OrbitDistanceSquared20\
    \ = 0.0, planet2Orbit\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2z6ls2zc.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp2z6ls2zc.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp2z6ls2zc.cpp:39:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   39 | }\n      | ^\n/tmp/tmp2z6ls2zc.cpp:39:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2z6ls2zc.cpp:2:\n/tmp/tmp2z6ls2zc.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp2z6ls2zc.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2z6ls2zc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmizn8195.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmizn8195.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmizn8195.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmizn8195.cpp:2:\n/tmp/tmpmizn8195.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpmizn8195.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmizn8195.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Write your code here\n    \n    return\
    \ std::make_tuple(planet1, planet2);\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpy_rxz02u.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpy_rxz02u.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpy_rxz02u.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy_rxz02u.cpp:2:\n/tmp/tmpy_rxz02u.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpy_rxz02u.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpy_rxz02u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Write your code here\n    \n    return\
    \ std::tuple<std::string, >();\n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpu88xkw1x.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpu88xkw1x.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpu88xkw1x.cpp:20:36: error: template\
    \ argument 2 is invalid\n   20 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu88xkw1x.cpp:2:\n/tmp/tmpu88xkw1x.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpu88xkw1x.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu88xkw1x.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitRadius, planet2OrbitRadius;\n    double planet1OrbitDistance, planet2OrbitDistance;\n\
    \    double planet1OrbitDistanceRadians, planet2OrbitDistanceRadians;\n    double\
    \ planet1OrbitDistanceRadians2, planet2OrbitDistanceRadians2;\n    double planet1OrbitDistanceRadians3,\
    \ planet2OrbitDistanceRadians3;\n    double planet1OrbitDistanceRadians4, planet2OrbitDistanceRadians4;\n\
    \    double planet1OrbitDistanceRadians5, planet2OrbitDistanceRadians5;\n    double\
    \ planet1OrbitDistanceRadians6, planet2OrbitDistanceRadians6;\n    double planet1OrbitDistanceRadians7,\
    \ planet2OrbitDistanceRadians7;\n    double planet1OrbitDistanceRadians8, planet2OrbitDistanceRadians8;\n\
    \    double planet1OrbitDistanceRadians9, planet2OrbitDistanceRadians9;\n    double\
    \ planet1OrbitDistanceRadians10, planet2OrbitDistanceRadians10;\n    double planet1OrbitDistanceRadians11,\
    \ planet2OrbitDistanceRadians11;\n    double planet1OrbitDistanceRadians12, planet2OrbitDistanceRadians12;\n\
    \    double planet1OrbitDistanceRadians13, planet2OrbitDistanceRadians13;\n  \
    \  double planet1OrbitDistanceRadians14, planet2OrbitDistanceRadians14;\n    double\
    \ planet1OrbitDistanceRadians15, planet2OrbitDistanceRadians15;\n    double planet1OrbitDistanceRadians16,\
    \ planet2OrbitDistanceRadians16;\n    double planet1OrbitDistanceRadians17, planet2OrbitDistanceRadians17;\n\
    \    double planet1OrbitDistanceRadians18, planet2OrbitDistanceRadians18;\n  \
    \  double planet1OrbitDistanceRadians19, planet2OrbitDistanceRadians19;\n    double\
    \ planet1OrbitDistanceRadians20, planet2OrbitDistanceRadians20;\n    double planet1OrbitDistanceRadians21,\
    \ planet2OrbitDistanceRadians21;\n    double planet1OrbitDistanceRadians22, planet2Orbit\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8x8oaj7a.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8x8oaj7a.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8x8oaj7a.cpp:42:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   42 | }\n      | ^\n/tmp/tmp8x8oaj7a.cpp:42:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8x8oaj7a.cpp:2:\n/tmp/tmp8x8oaj7a.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8x8oaj7a.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8x8oaj7a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_dist;\n    double planet_dist;\n    double\
    \ planet_angle;\n    double planet_orbit;\n    double planet_orbit2;\n    double\
    \ planet_orbit3;\n    double planet_orbit4;\n    double planet_orbit5;\n    double\
    \ planet_orbit6;\n    double planet_orbit7;\n    double planet_orbit8;\n    double\
    \ planet_orbit9;\n    double planet_orbit10;\n    double planet_orbit11;\n   \
    \ double planet_orbit12;\n    double planet_orbit13;\n    double planet_orbit14;\n\
    \    double planet_orbit15;\n    double planet_orbit16;\n    double planet_orbit17;\n\
    \    double planet_orbit18;\n    double planet_orbit19;\n    double planet_orbit20;\n\
    \    double planet_orbit21;\n    double planet_orbit22;\n    double planet_orbit23;\n\
    \    double planet_orbit24;\n    double planet_orbit25;\n    double planet_orbit26;\n\
    \    double planet_orbit27;\n    double planet_orbit28;\n    double planet_orbit29;\n\
    \    double planet_orbit30;\n    double planet_orbit31;\n    double planet_orbit32;\n\
    \    double planet_orbit33;\n    double planet_orbit34;\n    double planet_orbit35;\n\
    \    double planet_orbit36;\n    double planet_orbit37;\n    double planet_orbit38;\n\
    \    double planet_orbit39;\n    double planet_orbit40;\n    double planet_orbit41;\n\
    \    double planet_orbit42;\n    double planet_orbit43;\n    double planet_orbit44;\n\
    \    double planet_orbit45;\n    double planet_orbit46;\n    double planet_orbit47;\n\
    \    double planet_orbit48;\n    double planet_orbit49;\n    double planet_orbit50;\n\
    \    double planet_orbit51;\n    double planet_orbit52;\n    double planet_orbit53;\n\
    \    double planet_orbit54;\n    double planet_orbit55;\n    double planet_orbit56;\n\
    \    double planet_orbit57;\n    double planet_orbit58;\n    double planet_orbit59;\n\
    \    double planet_orbit60;\n    double planet_orbit61;\n    double planet_orbit62;\n\
    \    double planet_orbit63;\n    double planet_orbit64;\n}\nint main() {\n   \
    \ auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpob2ih3ml.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpob2ih3ml.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpob2ih3ml.cpp:84:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   84 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpob2ih3ml.cpp:2:\n/tmp/tmpob2ih3ml.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpob2ih3ml.cpp:87:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   87 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpob2ih3ml.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit_name = planet1 + \"_orbit\"\
    ;\n    std::string planet2_orbit_name = planet2 + \"_orbit\";\n    std::string\
    \ planet1_orbit_orbit = planet1_orbit_name + \"_orbit\";\n    std::string planet2_orbit_orbit\
    \ = planet2_orbit_name + \"_orbit\";\n    std::string planet1_orbit_orbit2 = planet1_orbit_orbit\
    \ + \"_orbit2\";\n    std::string planet2_orbit_orbit2 = planet2_orbit_orbit +\
    \ \"_orbit2\";\n    std::string planet1_orbit_orbit3 = planet1_orbit_orbit + \"\
    _orbit3\";\n    std::string planet2_orbit_orbit3 = planet2_orbit_orbit + \"_orbit3\"\
    ;\n    std::string planet1_orbit_orbit4 = planet1_orbit_orbit + \"_orbit4\";\n\
    \    std::string planet2_orbit_orbit4 = planet2_orbit_orbit + \"_orbit4\";\n \
    \   std::string planet1_orbit_orbit5 = planet1_orbit_orbit + \"_orbit5\";\n  \
    \  std::string planet2_orbit_orbit5 = planet2_orbit_orbit + \"_orbit5\";\n   \
    \ std::string planet1_orbit_orbit6 = planet1_orbit_orbit + \"_orbit6\";\n    std::string\
    \ planet2_orbit_orbit6 = planet2_orbit_orbit + \"_orbit6\";\n    std::string planet1_orbit_orbit7\
    \ = planet1_orbit_orbit + \"_orbit7\";\n    std::string planet2_orbit_orbit7 =\
    \ planet2_orbit_orbit + \"_orbit7\";\n    std::string planet1_orbit_orbit8 = planet1_orbit_orbit\
    \ + \"_orbit8\";\n    std::string planet2_orbit_orbit8 = planet2_orbit_orbit +\
    \ \"_orbit8\";\n    std::string planet1_orbit_orbit9 = planet1_orbit_orbit + \"\
    _orbit9\";\n    std::string planet2_orbit_orbit9 = planet2_orbit_orbit + \"_orbit9\"\
    ;\n    std::string planet1_orbit_orbit10 = planet1_orbit_orbit + \"_orbit10\"\
    ;\n    std::string planet2_orbit_orbit10 = planet2_orbit_orbit + \"_orbit10\"\
    ;\n    std::string planet1_orbit_orbit11 = planet1_orbit_orbit + \"_orbit11\"\
    ;\n    std::string planet2_orbit_orbit11 = planet2_orbit_orbit + \"_orbit11\"\
    ;\n    std::string planet1_orbit_orbit12 = planet1_orbit_orbit + \"_orbit12\"\
    ;\n    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9_o3xn6v.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9_o3xn6v.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9_o3xn6v.cpp:43:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   43 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9_o3xn6v.cpp:2:\n/tmp/tmp9_o3xn6v.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9_o3xn6v.cpp:46:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   46 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9_o3xn6v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1Orbit = planet1 + \"Orbit\"\
    ;\n    std::string planet2Orbit = planet2 + \"Orbit\";\n    \n    std::string\
    \ planet1OrbitSun = planet1 + \"OrbitSun\";\n    std::string planet2OrbitSun =\
    \ planet2 + \"OrbitSun\";\n    \n    std::string planet1OrbitMercury = planet1\
    \ + \"OrbitMercury\";\n    std::string planet2OrbitMercury = planet2 + \"OrbitMercury\"\
    ;\n    \n    std::string planet1OrbitVenus = planet1 + \"OrbitVenus\";\n    std::string\
    \ planet2OrbitVenus = planet2 + \"OrbitVenus\";\n    \n    std::string planet1OrbitEarth\
    \ = planet1 + \"OrbitEarth\";\n    std::string planet2OrbitEarth = planet2 + \"\
    OrbitEarth\";\n    \n    std::string planet1OrbitMars = planet1 + \"OrbitMars\"\
    ;\n    std::string planet2OrbitMars = planet2 + \"OrbitMars\";\n    \n    std::string\
    \ planet1OrbitJupiter = planet1 + \"OrbitJupiter\";\n    std::string planet2OrbitJupiter\
    \ = planet2 + \"OrbitJupiter\";\n    \n    std::string planet1OrbitSaturn = planet1\
    \ + \"OrbitSaturn\";\n    std::string planet2OrbitSaturn = planet2 + \"OrbitSaturn\"\
    ;\n    \n    std::string planet1OrbitUranus = planet1 + \"OrbitUranus\";\n   \
    \ std::string planet2OrbitUranus = planet2 + \"OrbitUranus\";\n    \n    std::string\
    \ planet1OrbitNeptune = planet1 + \"OrbitNeptune\";\n    std::string planet2OrbitNeptune\
    \ = planet2 + \"OrbitNeptune\";\n    \n    std::string planet1OrbitMercuryOrbitSun\
    \ = planet1Orbit + \"Sun\";\n    std::string planet2OrbitMercuryOrbitSun = planet2Orbit\
    \ + \"Sun\";\n    \n    std::string planet1OrbitMercuryOrbitMercury = planet1Orbit\
    \ + \"Mercury\";\n    std::string planet2OrbitMercuryOrbitMercury = planet2Orbit\
    \ + \"Mer\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv50tuitx.cpp:52:66: warning: missing terminating \" character\n\
    \   52 |     std::string planet2OrbitMercuryOrbitMercury = planet2Orbit + \"Mer\n\
    \      |                                                                  ^\n\
    /tmp/tmpv50tuitx.cpp:52:66: error: missing terminating \" character\n   52 | \
    \    std::string planet2OrbitMercuryOrbitMercury = planet2Orbit + \"Mer\n    \
    \  |                                                                  ^~~~\n/tmp/tmpv50tuitx.cpp:16:25:\
    \ error: template argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string\
    \ planet1, std::string planet2) {\n      |                         ^\n/tmp/tmpv50tuitx.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmpv50tuitx.cpp:53:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   53 | }\n \
    \     | ^\n/tmp/tmpv50tuitx.cpp:53:1: error: expected \u2018,\u2019 or \u2018\
    ;\u2019 before \u2018}\u2019 token\n/tmp/tmpv50tuitx.cpp:53:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv50tuitx.cpp:2:\n/tmp/tmpv50tuitx.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpv50tuitx.cpp:56:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   56 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpv50tuitx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/inclu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps951oykf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmps951oykf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmps951oykf.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps951oykf.cpp:2:\n/tmp/tmps951oykf.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmps951oykf.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmps951oykf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc6ttlsdt.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpc6ttlsdt.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpc6ttlsdt.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc6ttlsdt.cpp:2:\n/tmp/tmpc6ttlsdt.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpc6ttlsdt.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpc6ttlsdt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1_orbit_name = planet1 +\
    \ \"_orbit\";\n    std::string planet2_orbit_name = planet2 + \"_orbit\";\n  \
    \  \n    std::string planet1_orbit_orbit_name = planet1_orbit_name + \"_orbit\"\
    ;\n    std::string planet2_orbit_orbit_name = planet2_orbit_name + \"_orbit\"\
    ;\n    \n    std::string planet1_orbit_orbit_orbit_name = planet1_orbit_orbit_name\
    \ + \"_orbit\";\n    std::string planet2_orbit_orbit_orbit_name = planet2_orbit_orbit_name\
    \ + \"_orbit\";\n    \n    std::string planet1_orbit_orbit_orbit_orbit_name =\
    \ planet1_orbit_orbit_orbit_name + \"_orbit\";\n    std::string planet2_orbit_orbit_orbit_orbit_name\
    \ = planet2_orbit_orbit_orbit_name + \"_orbit\";\n    \n    std::string planet1_orbit_orbit_orbit_orbit_orbit_name\
    \ = planet1_orbit_orbit_orbit_orbit_name + \"_orbit\";\n    std::string planet2_orbit_orbit_orbit_orbit_orbit_name\
    \ = planet2_orbit_orbit_orbit_orbit_name + \"_orbit\";\n    \n    std::string\
    \ planet1_orbit_orbit_orbit_orbit_orbit_orbit_name = planet1_orbit_orbit_orbit_orbit_orbit_name\
    \ + \"_orbit\";\n    std::string planet2_orbit_orbit_orbit_orbit_orbit_orbit_name\
    \ = planet2_orbit_orbit_orbit_orbit_orbit_name + \"_orbit\";\n    \n    std::string\
    \ planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name = planet1_orbit_orbit_orbit_orbit_orbit_orbit_name\
    \ + \"_orbit\";\n    std::string planet2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name\
    \ = planet2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name + \"_orbit\";\n   \
    \ \n    std::string planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name\
    \ = planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name + \"_orbit\"\
    ;\n    std::string planet2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name\
    \ = planet2_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name + \"_orbit\"\
    ;\n    \n    std::string \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjel5e6_n.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjel5e6_n.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjel5e6_n.cpp:39:80: error: \u2018\
    planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name\u2019 was not\
    \ declared in this scope; did you mean \u2018planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name\u2019\
    ?\n   39 |     std::string planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name\
    \ = planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name + \"_orbit\"\
    ;\n      |                                                                   \
    \             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                                     \
    \           planet1_orbit_orbit_orbit_orbit_orbit_orbit_orbit_orbit_name\n/tmp/tmpjel5e6_n.cpp:43:1:\
    \ error: expected unqualified-id before \u2018}\u2019 token\n   43 | }\n     \
    \ | ^\n/tmp/tmpjel5e6_n.cpp:43:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjel5e6_n.cpp:2:\n/tmp/tmpjel5e6_n.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpjel5e6_n.cpp:46:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   46 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgsu65sjz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpgsu65sjz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpgsu65sjz.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgsu65sjz.cpp:2:\n/tmp/tmpgsu65sjz.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpgsu65sjz.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgsu65sjz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    double distance;\n    double angle;\n    double\
    \ distance1;\n    double angle1;\n    double distance2;\n    double angle2;\n\
    \    double distance3;\n    double angle3;\n    double distance4;\n    double\
    \ angle4;\n    double distance5;\n    double angle5;\n    double distance6;\n\
    \    double angle6;\n    double distance7;\n    double angle7;\n    double distance8;\n\
    \    double angle8;\n    double distance9;\n    double angle9;\n    double distance10;\n\
    \    double angle10;\n    double distance11;\n    double angle11;\n    double\
    \ distance12;\n    double angle12;\n    double distance13;\n    double angle13;\n\
    \    double distance14;\n    double angle14;\n    double distance15;\n    double\
    \ angle15;\n    double distance16;\n    double angle16;\n    double distance17;\n\
    \    double angle17;\n    double distance18;\n    double angle18;\n    double\
    \ distance19;\n    double angle19;\n    double distance20;\n    double angle20;\n\
    \    double distance21;\n    double angle21;\n    double distance22;\n    double\
    \ angle22;\n    double distance23;\n    double angle23;\n    double distance24;\n\
    \    double angle24;\n    double distance25;\n    double angle25;\n    double\
    \ distance26;\n    double angle26;\n    double distance27;\n    double angle27;\n\
    \    double distance28;\n    double angle28;\n    double distance29;\n    double\
    \ angle29;\n    double distance30;\n    double angle30;\n    double distance31;\n\
    \    double angle31;\n    double distance32;\n    double angle32;\n    double\
    \ distance33;\n    double angle33;\n    double distance34;\n    double angle34;\n\
    \    double distance35;\n    double angle35;\n    double distance36;\n    double\
    \ angle36;\n    double distance37;\n    double angle37;\n    double distance38;\n\
    \    double angle38;\n    double distance39;\n    double angle39;\n    double\
    \ distance40;\n    double angle40;\n    double distance41;\n    double angle41;\n\
    \    double distance42;\n    double angle42;\n    double distance43;\n    double\
    \ angle43;\n    double distance44;\n    double angle44;\n    double distance45;\n\
    \    double angle45\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9m4uf6b0.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9m4uf6b0.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9m4uf6b0.cpp:110:1: error: expected\
    \ initializer before \u2018}\u2019 token\n  110 | }\n      | ^\n/tmp/tmp9m4uf6b0.cpp:110:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9m4uf6b0.cpp:2:\n/tmp/tmp9m4uf6b0.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9m4uf6b0.cpp:113:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  113 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9m4uf6b0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    \n    std::tuple<std::string,\
    \ > result;\n    \n    if (planet1 == \"Mercury\") {\n        if (planet2 == \"\
    Venus\") {\n            result.emplace(planet2);\n        } else if (planet2 ==\
    \ \"Earth\") {\n            result.emplace(planet2);\n        } else if (planet2\
    \ == \"Mars\") {\n            result.emplace(planet2);\n        } else if (planet2\
    \ == \"Jupiter\") {\n            result.emplace(planet2);\n        } else if (planet2\
    \ == \"Saturn\") {\n            result.emplace(planet2);\n        } else if (planet2\
    \ == \"Uranus\") {\n            result.emplace(planet2);\n        } else if (planet2\
    \ == \"Neptune\") {\n            result.emplace(planet2);\n        }\n    } else\
    \ if (planet1 == \"Venus\") {\n        if (planet2 == \"Mercury\") {\n       \
    \     result.emplace(planet2);\n        } else if (planet2 == \"Earth\") {\n \
    \           result.emplace(planet2);\n        } else if (planet2 == \"Mars\")\
    \ {\n            result.emplace(planet2);\n        } else if (planet2 == \"Jupiter\"\
    ) {\n            result.emplace(planet2);\n        } else if (planet2 == \"Saturn\"\
    ) {\n            result.emplace(planet2);\n        } else if (planet2 == \"Uranus\"\
    ) {\n            result.emplace(planet2);\n        } else if (planet2 == \"Neptune\"\
    ) {\n            result.emplace(planet2);\n        }\n    } else if (planet1 ==\
    \ \"Earth\") {\n        if (planet2 == \"Mercury\") {\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Venus\") {\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Mars\") {\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Jupiter\") {\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Saturn\") {\n            result.emplace(planet2);\n\
    \        } else if (planet2 == \"Uranus\") {\n            result.emplace(\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5gx4s9a1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp5gx4s9a1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp5gx4s9a1.cpp:20:29: error: template\
    \ argument 2 is invalid\n   20 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmp5gx4s9a1.cpp:24:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   24 |             result.emplace(planet2);\n      |\
    \                    ^~~~~~~\n/tmp/tmp5gx4s9a1.cpp:26:20: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   26 |             result.emplace(planet2);\n      |             \
    \       ^~~~~~~\n/tmp/tmp5gx4s9a1.cpp:28:20: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   28 |             result.emplace(planet2);\n      |                    ^~~~~~~\n\
    /tmp/tmp5gx4s9a1.cpp:30:20: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   30 |            \
    \ result.emplace(planet2);\n      |                    ^~~~~~~\n/tmp/tmp5gx4s9a1.cpp:32:20:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   32 |             result.emplace(planet2);\n\
    \      |                    ^~~~~~~\n/tmp/tmp5gx4s9a1.cpp:34:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   34 |             result.emplace(planet2);\n      |\
    \                    ^~~~~~~\n/tmp/tmp5gx4s9a1.cpp:36:20: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   36 |             result.emplace(planet2);\n      |             \
    \       ^~~~~~~\n/tmp/tmp5gx4s9a1.cpp:40:20: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   40 |             result.emplace(planet2);\n      |                    ^~~~~~~\n\
    /tmp/tmp5gx4s9a1.cpp:42:20: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   42 |          "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.137;\n    double planet_radius\
    \ = 6378.137;\n    double planet_separation = planet_radius - sun_radius;\n  \
    \  double planet_separation_sq = planet_separation * planet_separation;\n    double\
    \ planet_separation_sq2 = planet_separation_sq * planet_separation_sq;\n    double\
    \ planet_separation_sq3 = planet_separation_sq2 * planet_separation_sq;\n    double\
    \ planet_separation_sq4 = planet_separation_sq3 * planet_separation_sq;\n    double\
    \ planet_separation_sq5 = planet_separation_sq4 * planet_separation_sq;\n    double\
    \ planet_separation_sq6 = planet_separation_sq5 * planet_separation_sq;\n    double\
    \ planet_separation_sq7 = planet_separation_sq6 * planet_separation_sq;\n    double\
    \ planet_separation_sq8 = planet_separation_sq7 * planet_separation_sq;\n    double\
    \ planet_separation_sq9 = planet_separation_sq8 * planet_separation_sq;\n    double\
    \ planet_separation_sq10 = planet_separation_sq9 * planet_separation_sq;\n   \
    \ double planet_separation_sq11 = planet_separation_sq10 * planet_separation_sq;\n\
    \    double planet_separation_sq12 = planet_separation_sq11 * planet_separation_sq;\n\
    \    double planet_separation_sq13 = planet_separation_sq12 * planet_separation_sq;\n\
    \    double planet_separation_sq14 = planet_separation_sq13 * planet_separation_sq;\n\
    \    double planet_separation_sq15 = planet_separation_sq14 * planet_separation_sq;\n\
    \    double planet_separation_sq16 = planet_separation_sq15 * planet_separation_sq;\n\
    \    double planet_separation_sq17 = planet_separation_sq16 * planet_separation_sq;\n\
    \    double planet_separation_sq18 = planet_separation_sq17 * planet_separation_sq;\n\
    \    double planet_separation_sq19 = planet_separation_sq18 * planet_separation_sq;\n\
    \    double planet_separation_sq20 = planet_separation_sq19 * planet_separation_sq;\n\
    \    double planet_separation_sq21 = planet_separation_sq20 * planet_separation_sq;\n\
    \    double planet_separation_sq22 = planet_separation_sq\n}\nint main() {\n \
    \   auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps8u4gc46.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmps8u4gc46.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmps8u4gc46.cpp:42:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   42 | }\n     \
    \ | ^\n/tmp/tmps8u4gc46.cpp:42:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps8u4gc46.cpp:2:\n/tmp/tmps8u4gc46.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmps8u4gc46.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmps8u4gc46.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi3k3v8uz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpi3k3v8uz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpi3k3v8uz.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi3k3v8uz.cpp:2:\n/tmp/tmpi3k3v8uz.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpi3k3v8uz.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpi3k3v8uz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1;\n    double distance2;\n    double distance3;\n\
    \    double distance4;\n    double distance5;\n    double distance6;\n    double\
    \ distance7;\n    double distance8;\n    double distance9;\n    double distance10;\n\
    \    double distance11;\n    double distance12;\n    double distance13;\n    double\
    \ distance14;\n    double distance15;\n    double distance16;\n    double distance17;\n\
    \    double distance18;\n    double distance19;\n    double distance20;\n    double\
    \ distance21;\n    double distance22;\n    double distance23;\n    double distance24;\n\
    \    double distance25;\n    double distance26;\n    double distance27;\n    double\
    \ distance28;\n    double distance29;\n    double distance30;\n    double distance31;\n\
    \    double distance32;\n    double distance33;\n    double distance34;\n    double\
    \ distance35;\n    double distance36;\n    double distance37;\n    double distance38;\n\
    \    double distance39;\n    double distance40;\n    double distance41;\n    double\
    \ distance42;\n    double distance43;\n    double distance44;\n    double distance45;\n\
    \    double distance46;\n    double distance47;\n    double distance48;\n    double\
    \ distance49;\n    double distance50;\n    double distance51;\n    double distance52;\n\
    \    double distance53;\n    double distance54;\n    double distance55;\n    double\
    \ distance56;\n    double distance57;\n    double distance58;\n    double distance59;\n\
    \    double distance60;\n    double distance61;\n    double distance62;\n    double\
    \ distance63;\n    double distance64;\n    double distance65;\n    double distance66;\n\
    \    double distance67;\n    double distance68;\n    double distance69;\n    double\
    \ distance70;\n    double distance71;\n    double distance72;\n    double distance73;\n\
    \    double distance74;\n    double distance75;\n    double distance76;\n    double\
    \ distance77;\n    double distance78;\n    double distance79;\n    double distance80;\n\
    \    double distance81;\n    double distance82;\n    double distance83;\n    double\
    \ distance84;\n    double distance85;\n    double \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjvdjbovh.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjvdjbovh.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjvdjbovh.cpp:105:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmpjvdjbovh.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjvdjbovh.cpp:2:\n/tmp/tmpjvdjbovh.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpjvdjbovh.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpjvdjbovh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1orb = planet1 + \"orbit\";\n\
    \    std::string planet2orb = planet2 + \"orbit\";\n    std::string planet1orb2\
    \ = planet1 + \"orbit\" + planet2;\n    std::string planet2orb2 = planet2 + \"\
    orbit\" + planet1;\n    std::string planet1orb3 = planet1 + \"orbit\" + planet1\
    \ + \"orbit\";\n    std::string planet2orb3 = planet2 + \"orbit\" + planet2 +\
    \ \"orbit\";\n    std::string planet1orb4 = planet1 + \"orbit\" + planet1 + \"\
    orbit\" + planet1;\n    std::string planet2orb4 = planet2 + \"orbit\" + planet2\
    \ + \"orbit\" + planet2;\n    std::string planet1orb5 = planet1 + \"orbit\" +\
    \ planet1 + \"orbit\" + planet1 + \"orbit\";\n    std::string planet2orb5 = planet2\
    \ + \"orbit\" + planet2 + \"orbit\" + planet2 + \"orbit\";\n    std::string planet1orb6\
    \ = planet1 + \"orbit\" + planet1 + \"orbit\" + planet1 + \"orbit\" + planet1;\n\
    \    std::string planet2orb6 = planet2 + \"orbit\" + planet2 + \"orbit\" + planet2\
    \ + \"orbit\" + planet2;\n    std::string planet1orb7 = planet1 + \"orbit\" +\
    \ planet1 + \"orbit\" + planet1 + \"orbit\" + planet1 + \"orbit\";\n    std::string\
    \ planet2orb7 = planet2 + \"orbit\" + planet2 + \"orbit\" + planet2 + \"orbit\"\
    \ + planet2 + \"orbit\";\n    std::string planet1orb8 = planet1 + \"orbit\" +\
    \ planet1 + \"orbit\" + planet1 + \"orbit\" + planet1 + \"orbit\" + planet1;\n\
    \    std::string planet2orb8 = planet2 + \"orbit\" + planet2 + \"orbit\" + planet2\
    \ + \"orbit\" + planet2 + \"orbit\" + planet2;\n    std::string planet1orb9 =\
    \ planet1 + \"orbit\" + planet1 + \"orbit\" + planet1 + \"orbit\" + planet1 +\
    \ \"orbit\" + planet1 + \"orbit\";\n    std::string planet2orb9 = planet2 + \"\
    orbit\" + planet2 + \"orbit\" + planet2 + \"orbit\" + planet2 + \"orbit\" + planet2\
    \ + \"orbit\";\n    std::string planet1orb10 = planet1 + \"orbit\" + planet1 +\
    \ \"orbit\" + planet1 + \"orbit\" + planet\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvlmy6j1h.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpvlmy6j1h.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpvlmy6j1h.cpp:35:92: error: \u2018\
    planet\u2019 was not declared in this scope; did you mean \u2018planet1\u2019\
    ?\n   35 |     std::string planet1orb10 = planet1 + \"orbit\" + planet1 + \"orbit\"\
    \ + planet1 + \"orbit\" + planet\n      |                                    \
    \                                                        ^~~~~~\n      |     \
    \                                                                            \
    \           planet1\n/tmp/tmpvlmy6j1h.cpp:36:1: error: expected \u2018,\u2019\
    \ or \u2018;\u2019 before \u2018}\u2019 token\n   36 | }\n      | ^\n/tmp/tmpvlmy6j1h.cpp:36:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvlmy6j1h.cpp:2:\n/tmp/tmpvlmy6j1h.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpvlmy6j1h.cpp:39:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   39 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvlmy6j1h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator=="
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaxl2nzaf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpaxl2nzaf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpaxl2nzaf.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpaxl2nzaf.cpp:2:\n/tmp/tmpaxl2nzaf.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpaxl2nzaf.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpaxl2nzaf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu4ol8557.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpu4ol8557.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpu4ol8557.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu4ol8557.cpp:2:\n/tmp/tmpu4ol8557.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpu4ol8557.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu4ol8557.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_longitude = std::acos(std::sqrt(std::pow(planet1.length(),\
    \ 2) + std::pow(planet2.length(), 2)));\n    double sun_latitude = std::acos(std::sqrt(std::pow(planet1.length(),\
    \ 2) + std::pow(planet2.length(), 2)));\n    double sun_distance = std::sqrt(std::pow(planet1.length(),\
    \ 2) + std::pow(planet2.length(), 2));\n    double sun_radius = 6371;\n    double\
    \ sun_angle = std::acos(std::sqrt(std::pow(planet1.length(), 2) + std::pow(planet2.length(),\
    \ 2)));\n    double sun_angle_radian = sun_angle * 180 / M_PI;\n    double sun_angle_radian2\
    \ = sun_angle_radian + 180;\n    double sun_angle_radian3 = sun_angle_radian2\
    \ + 180;\n    double sun_angle_radian4 = sun_angle_radian3 + 180;\n    double\
    \ sun_angle_radian5 = sun_angle_radian4 + 180;\n    double sun_angle_radian6 =\
    \ sun_angle_radian5 + 180;\n    double sun_angle_radian7 = sun_angle_radian6 +\
    \ 180;\n    double sun_angle_radian8 = sun_angle_radian7 + 180;\n    double sun_angle_radian9\
    \ = sun_angle_radian8 + 180;\n    double sun_angle_radian10 = sun_angle_radian9\
    \ + 180;\n    double sun_angle_radian11 = sun_angle_radian10 + 180;\n    double\
    \ sun_angle_radian12 = sun_angle_radian11 + 180;\n    double sun_angle_radian13\
    \ = sun_angle_radian12 + 180;\n    double sun_angle_radian14 = sun_angle_radian13\
    \ + 180;\n    double sun_angle_radian15 = sun_angle_radian14 + 180;\n    double\
    \ sun_angle_radian16 = sun_angle_radian15 + 180;\n    double sun_angle_radian17\
    \ = sun_angle_radian16 + 180;\n    double sun_angle_radian18 = sun_angle_radian17\
    \ + 180;\n    double sun_angle_radian19 = sun_angle_radian18 + 180;\n    double\
    \ sun_angle_radian20 = sun_angle_radian19 + 180;\n    double sun_angle_radian21\
    \ = sun_angle_radian20 + 180;\n    double sun_angle_radian22 = sun_angle_radian21\
    \ + 180;\n    double sun_angle_radian23 = sun_angle_radian22 + 180;\n    double\
    \ sun_angle_radian24 = sun_angle_radian23 + 18\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpur28vwc7.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpur28vwc7.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpur28vwc7.cpp:46:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   46 | }\n     \
    \ | ^\n/tmp/tmpur28vwc7.cpp:46:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpur28vwc7.cpp:2:\n/tmp/tmpur28vwc7.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpur28vwc7.cpp:49:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   49 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpur28vwc7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_orbit_angle, planet2_orbit_angle;\n\
    \    double planet1_orbit_distance, planet2_orbit_distance;\n    double planet1_orbit_velocity,\
    \ planet2_orbit_velocity;\n    double planet1_orbit_period, planet2_orbit_period;\n\
    \    double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double\
    \ planet1_orbit_semimajor_axis, planet2_orbit_semimajor_axis;\n    double planet1_orbit_inclination,\
    \ planet2_orbit_inclination;\n    double planet1_orbit_longitude, planet2_orbit_longitude;\n\
    \    double planet1_orbit_latitude, planet2_orbit_latitude;\n    double planet1_orbit_altitude,\
    \ planet2_orbit_altitude;\n    double planet1_orbit_longitude_deg, planet2_orbit_longitude_deg;\n\
    \    double planet1_orbit_latitude_deg, planet2_orbit_latitude_deg;\n    double\
    \ planet1_orbit_altitude_deg, planet2_orbit_altitude_deg;\n    double planet1_orbit_semimajor_axis_deg,\
    \ planet2_orbit_semimajor_axis_deg;\n    double planet1_orbit_eccentricity_deg,\
    \ planet2_orbit_eccentricity_deg;\n    double planet1_orbit_inclination_deg, planet2_orbit_inclination_deg;\n\
    \    double planet1_orbit_longitude_deg_to_radian, planet2_orbit_longitude_deg_to_radian;\n\
    \    double planet1_orbit_latitude_deg_to_radian, planet2_orbit_latitude_deg_to_radian;\n\
    \    double planet1_orbit_altitude_deg_to_radian, planet2_orbit_altitude_deg_to_radian;\n\
    \    double planet1_orbit_semimajor_axis_deg_to_radian, planet2_orbit_semimajor_axis_deg_to_radian;\n\
    \    double planet1_orbit_eccentricity_deg_to_radian, planet2_orbit_eccentricity_deg_to_radian;\n\
    \    double planet1_orbit_inclination_deg_to_radian, planet2_orbit_inclination_deg_to_radian;\n\
    \    double planet1_orbit_longitude_deg_to_\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpsmmjv6dn.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpsmmjv6dn.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpsmmjv6dn.cpp:42:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   42 | }\n      | ^\n/tmp/tmpsmmjv6dn.cpp:42:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsmmjv6dn.cpp:2:\n/tmp/tmpsmmjv6dn.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpsmmjv6dn.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsmmjv6dn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwieqhvzk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpwieqhvzk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpwieqhvzk.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwieqhvzk.cpp:2:\n/tmp/tmpwieqhvzk.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpwieqhvzk.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwieqhvzk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_name = planet1;\n    std::string\
    \ planet2_name = planet2;\n    std::string planet1_name1 = planet1;\n    std::string\
    \ planet2_name2 = planet2;\n    std::string planet1_name2 = planet1;\n    std::string\
    \ planet2_name1 = planet2;\n    std::string planet1_name3 = planet1;\n    std::string\
    \ planet2_name3 = planet2;\n    std::string planet1_name4 = planet1;\n    std::string\
    \ planet2_name4 = planet2;\n    std::string planet1_name5 = planet1;\n    std::string\
    \ planet2_name5 = planet2;\n    std::string planet1_name6 = planet1;\n    std::string\
    \ planet2_name6 = planet2;\n    std::string planet1_name7 = planet1;\n    std::string\
    \ planet2_name7 = planet2;\n    std::string planet1_name8 = planet1;\n    std::string\
    \ planet2_name8 = planet2;\n    std::string planet1_name9 = planet1;\n    std::string\
    \ planet2_name9 = planet2;\n    std::string planet1_name10 = planet1;\n    std::string\
    \ planet2_name10 = planet2;\n    std::string planet1_name11 = planet1;\n    std::string\
    \ planet2_name11 = planet2;\n    std::string planet1_name12 = planet1;\n    std::string\
    \ planet2_name12 = planet2;\n    std::string planet1_name13 = planet1;\n    std::string\
    \ planet2_name13 = planet2;\n    std::string planet1_name14 = planet1;\n    std::string\
    \ planet2_name14 = planet2;\n    std::string planet1_name15 = planet1;\n    std::string\
    \ planet2_name15 = planet2;\n    std::string planet1_name16 = planet1;\n    std::string\
    \ planet2_name16 = planet2;\n    std::string planet1_name17 = planet1;\n    std::string\
    \ planet2_name17 = planet2;\n    std::string planet1_name18 = planet1;\n    std::string\
    \ planet2_name18 = planet2;\n    std::string planet1_name19 = planet1;\n    std::string\
    \ planet2_name19 = planet2;\n    std::string planet1_name20 = planet1;\n    std::string\
    \ planet2_name20 = planet2;\n    std::string planet1_name21 = planet1;\n    std::string\
    \ planet2_name21 = planet2;\n    std::string planet1_name22 = planet1;\n\n}\n\
    int main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2ytoaj6c.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp2ytoaj6c.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp2ytoaj6c.cpp:63:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   63 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2ytoaj6c.cpp:2:\n/tmp/tmp2ytoaj6c.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp2ytoaj6c.cpp:66:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   66 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp2ytoaj6c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.1;\n    double planet_radius\
    \ = 6378.1;\n    double planet_separation = planet_radius - sun_radius;\n    double\
    \ planet_separation_sq = planet_separation * planet_separation;\n    double planet_separation_cub\
    \ = planet_separation_sq * planet_separation_sq;\n    double planet_separation_cub_sq\
    \ = planet_separation_cub * planet_separation_cub;\n    double planet_separation_cub_cub\
    \ = planet_separation_cub_sq * planet_separation_cub_sq;\n    double planet_separation_cub_cub_sq\
    \ = planet_separation_cub_cub * planet_separation_cub_cub;\n    double planet_separation_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_sq * planet_separation_cub_cub_sq;\n    double planet_separation_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_sq * planet_separation_cub_cub_cub_sq;\n   \
    \ double planet_separation_cub_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub_sq\
    \ * planet_separation_cub_cub_cub_cub_sq;\n    double planet_separation_cub_cub_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_cub_cub_sq * planet_separation_cub_cub_cub_cub_cub_sq;\n\
    \    double planet_separation_cub_cub_cub_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub_cub_cub_sq\
    \ * planet_separation_cub_cub_cub_cub_cub_cub_sq;\n    double planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_sq * planet_separation_cub_cub_cub_cub_cub_cub_cub_sq;\n\
    \    double planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq\
    \ * plan\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm0tb079o.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpm0tb079o.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpm0tb079o.cpp:30:71: error: \u2018\
    planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_sq\u2019 was not declared in\
    \ this scope; did you mean \u2018planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq\u2019\
    ?\n   30 |     double planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_sq * planet_separation_cub_cub_cub_cub_cub_cub_cub_sq;\n\
    \      |                                                                     \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |             \
    \                                                          planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq\n\
    /tmp/tmpm0tb079o.cpp:31:134: error: \u2018plan\u2019 was not declared in this\
    \ scope\n   31 |     double planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq * plan\n      | \
    \                                                                            \
    \                                                         ^~~~\n/tmp/tmpm0tb079o.cpp:32:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   32 | }\n      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm0tb079o.cpp:2:\n/tmp/tmpm0tb079o.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpm0tb079o.cpp:35:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   35 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                 "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.1;\n    double planet_radius\
    \ = 6378.1;\n    double planet_separation = planet_radius - sun_radius;\n    double\
    \ planet_separation_sq = planet_separation * planet_separation;\n    double planet_separation_sq2\
    \ = planet_separation_sq * planet_separation_sq;\n    double planet_separation_sq3\
    \ = planet_separation_sq2 * planet_separation_sq;\n    double planet_separation_sq4\
    \ = planet_separation_sq3 * planet_separation_sq;\n    double planet_separation_sq5\
    \ = planet_separation_sq4 * planet_separation_sq;\n    double planet_separation_sq6\
    \ = planet_separation_sq5 * planet_separation_sq;\n    double planet_separation_sq7\
    \ = planet_separation_sq6 * planet_separation_sq;\n    double planet_separation_sq8\
    \ = planet_separation_sq7 * planet_separation_sq;\n    double planet_separation_sq9\
    \ = planet_separation_sq8 * planet_separation_sq;\n    double planet_separation_sq10\
    \ = planet_separation_sq9 * planet_separation_sq;\n    double planet_separation_sq11\
    \ = planet_separation_sq10 * planet_separation_sq;\n    double planet_separation_sq12\
    \ = planet_separation_sq11 * planet_separation_sq;\n    double planet_separation_sq13\
    \ = planet_separation_sq12 * planet_separation_sq;\n    double planet_separation_sq14\
    \ = planet_separation_sq13 * planet_separation_sq;\n    double planet_separation_sq15\
    \ = planet_separation_sq14 * planet_separation_sq;\n    double planet_separation_sq16\
    \ = planet_separation_sq15 * planet_separation_sq;\n    double planet_separation_sq17\
    \ = planet_separation_sq16 * planet_separation_sq;\n    double planet_separation_sq18\
    \ = planet_separation_sq17 * planet_separation_sq;\n    double planet_separation_sq19\
    \ = planet_separation_sq18 * planet_separation_sq;\n    double planet_separation_sq20\
    \ = planet_separation_sq19 * planet_separation_sq;\n    double planet_separation_sq21\
    \ = planet_separation_sq20 * planet_separation_sq;\n    double planet_separation_sq22\
    \ = planet_separation_sq21 * \n}\nint main() {\n    auto candidate = bf;\n   \
    \ assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpmgvdr8uo.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmgvdr8uo.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmgvdr8uo.cpp:42:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   42 | }\n      | ^\n/tmp/tmpmgvdr8uo.cpp:42:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmgvdr8uo.cpp:2:\n/tmp/tmpmgvdr8uo.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpmgvdr8uo.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmgvdr8uo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7o7k6nkq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp7o7k6nkq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp7o7k6nkq.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7o7k6nkq.cpp:2:\n/tmp/tmp7o7k6nkq.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp7o7k6nkq.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7o7k6nkq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp38x36w_2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp38x36w_2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp38x36w_2.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp38x36w_2.cpp:2:\n/tmp/tmp38x36w_2.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp38x36w_2.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp38x36w_2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_name = planet1;\n    std::string\
    \ planet2_name = planet2;\n    std::string planet1_name_sun = \"Sun\";\n    std::string\
    \ planet2_name_sun = \"Sun\";\n    std::string planet1_orbit_sun = \"Mercury\"\
    ;\n    std::string planet2_orbit_sun = \"Neptune\";\n    std::string planet1_orbit_mercury\
    \ = \"Venus\";\n    std::string planet2_orbit_neptune = \"Earth\";\n    std::string\
    \ planet1_orbit_venus = \"Earth\";\n    std::string planet2_orbit_earth = \"Mars\"\
    ;\n    std::string planet1_orbit_mars = \"Jupiter\";\n    std::string planet2_orbit_jupiter\
    \ = \"Saturn\";\n    std::string planet1_orbit_saturn = \"Uranus\";\n    std::string\
    \ planet2_orbit_uranus = \"Neptune\";\n    std::string planet1_orbit_uranus =\
    \ \"Uranus\";\n    std::string planet2_orbit_neptune = \"Neptune\";\n    std::string\
    \ planet1_orbit_uranus = \"Uranus\";\n    std::string planet2_orbit_uranus = \"\
    Uranus\";\n    std::string planet1_orbit_uranus = \"Uranus\";\n    std::string\
    \ planet2_orbit_uranus = \"Uranus\";\n    std::string planet1_orbit_uranus = \"\
    Uranus\";\n    std::string planet2_orbit_uranus = \"Uranus\";\n    std::string\
    \ planet1_orbit_uranus = \"Uranus\";\n    std::string planet2_orbit_uranus = \"\
    Uranus\";\n    std::string planet1_orbit_uranus = \"Uranus\";\n    std::string\
    \ planet2_orbit_uranus = \"Uranus\";\n    std::string planet1_orbit_uranus = \"\
    Uranus\";\n    std::string planet2_orbit_uranus = \"Uranus\";\n    std::string\
    \ planet1_orbit_uranus = \"Uranus\";\n    std::string planet2_orbit_uranus = \"\
    Uranus\";\n    std::string planet1_orbit_uranus = \"Uranus\";\n    std::string\
    \ planet2_orbit_uranus = \"Uranus\";\n    std::string planet1_orbit_uranus = \"\
    Uranus\";\n    std::string planet2_orbit_uranus = \"Uranus\";\n    \n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcebg77aq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpcebg77aq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpcebg77aq.cpp:32:17: error: redeclaration\
    \ of \u2018std::string planet2_orbit_neptune\u2019\n   32 |     std::string planet2_orbit_neptune\
    \ = \"Neptune\";\n      |                 ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:24:17:\
    \ note: \u2018std::string planet2_orbit_neptune\u2019 previously declared here\n\
    \   24 |     std::string planet2_orbit_neptune = \"Earth\";\n      |         \
    \        ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:33:17: error: redeclaration\
    \ of \u2018std::string planet1_orbit_uranus\u2019\n   33 |     std::string planet1_orbit_uranus\
    \ = \"Uranus\";\n      |                 ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:31:17:\
    \ note: \u2018std::string planet1_orbit_uranus\u2019 previously declared here\n\
    \   31 |     std::string planet1_orbit_uranus = \"Uranus\";\n      |         \
    \        ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:34:17: error: redeclaration\
    \ of \u2018std::string planet2_orbit_uranus\u2019\n   34 |     std::string planet2_orbit_uranus\
    \ = \"Uranus\";\n      |                 ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:30:17:\
    \ note: \u2018std::string planet2_orbit_uranus\u2019 previously declared here\n\
    \   30 |     std::string planet2_orbit_uranus = \"Neptune\";\n      |        \
    \         ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:35:17: error: redeclaration\
    \ of \u2018std::string planet1_orbit_uranus\u2019\n   35 |     std::string planet1_orbit_uranus\
    \ = \"Uranus\";\n      |                 ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:31:17:\
    \ note: \u2018std::string planet1_orbit_uranus\u2019 previously declared here\n\
    \   31 |     std::string planet1_orbit_uranus = \"Uranus\";\n      |         \
    \        ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:36:17: error: redeclaration\
    \ of \u2018std::string planet2_orbit_uranus\u2019\n   36 |     std::string planet2_orbit_uranus\
    \ = \"Uranus\";\n      |                 ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpcebg77aq.cpp:30:17:\
    \ note: \u2018std::string planet2_orbit_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitRadius, planet2OrbitRadius;\n    double planet1OrbitDistance, planet2OrbitDistance;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double\
    \ planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n    double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \    double planet1Orbit\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk7p3tcd9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpk7p3tcd9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpk7p3tcd9.cpp:21:12: error: redeclaration\
    \ of \u2018double planet1OrbitDistanceRadius\u2019\n   21 |     double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpk7p3tcd9.cpp:20:12: note: \u2018double planet1OrbitDistanceRadius\u2019\
    \ previously declared here\n   20 |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk7p3tcd9.cpp:21:40: error:\
    \ redeclaration of \u2018double planet2OrbitDistanceRadius\u2019\n   21 |    \
    \ double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n      |    \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk7p3tcd9.cpp:20:40:\
    \ note: \u2018double planet2OrbitDistanceRadius\u2019 previously declared here\n\
    \   20 |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk7p3tcd9.cpp:22:12:\
    \ error: redeclaration of \u2018double planet1OrbitDistanceRadius\u2019\n   22\
    \ |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n     \
    \ |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk7p3tcd9.cpp:20:12: note: \u2018\
    double planet1OrbitDistanceRadius\u2019 previously declared here\n   20 |    \
    \ double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n      |    \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk7p3tcd9.cpp:22:40: error: redeclaration\
    \ of \u2018double planet2OrbitDistanceRadius\u2019\n   22 |     double planet1OrbitDistanceRadius,\
    \ planet2OrbitDistanceRadius;\n      |                                       \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpk7p3tcd9.cpp:20:40: note: \u2018double planet2OrbitDistanceRadius\u2019\
    \ previously declared here\n   20 |     double planet1OrbitDistanceRadius, planet2OrbitDistanceRadius;\n\
    \      |                                        ^~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_distance = std::abs(planet1.length()\
    \ - planet2.length());\n    double sun_radius = 6378.1;\n    double planet_distance\
    \ = std::abs(planet1.length() - planet2.length());\n    double planet_radius =\
    \ 6378.1;\n    double planet_angle = std::atan2(planet1.length(), planet2.length());\n\
    \    double planet_angle_rad = planet_angle * 180 / M_PI;\n    double planet_angle_rad_2\
    \ = planet_angle_rad * planet_angle_rad;\n    double planet_angle_rad_3 = planet_angle_rad_2\
    \ * planet_angle_rad;\n    double planet_angle_rad_4 = planet_angle_rad_3 * planet_angle_rad;\n\
    \    double planet_angle_rad_5 = planet_angle_rad_4 * planet_angle_rad;\n    double\
    \ planet_angle_rad_6 = planet_angle_rad_5 * planet_angle_rad;\n    double planet_angle_rad_7\
    \ = planet_angle_rad_6 * planet_angle_rad;\n    double planet_angle_rad_8 = planet_angle_rad_7\
    \ * planet_angle_rad;\n    double planet_angle_rad_9 = planet_angle_rad_8 * planet_angle_rad;\n\
    \    double planet_angle_rad_10 = planet_angle_rad_9 * planet_angle_rad;\n   \
    \ double planet_angle_rad_11 = planet_angle_rad_10 * planet_angle_rad;\n    double\
    \ planet_angle_rad_12 = planet_angle_rad_11 * planet_angle_rad;\n    double planet_angle_rad_13\
    \ = planet_angle_rad_12 * planet_angle_rad;\n    double planet_angle_rad_14 =\
    \ planet_angle_rad_13 * planet_angle_rad;\n    double planet_angle_rad_15 = planet_angle_rad_14\
    \ * planet_angle_rad;\n    double planet_angle_rad_16 = planet_angle_rad_15 *\
    \ planet_angle_rad;\n    double planet_angle_rad_17 = planet_angle_rad_16 * planet_angle_rad;\n\
    \    double planet_angle_rad_18 = planet_angle_rad_17 * planet_angle_rad;\n  \
    \  double planet_angle_rad_19 = planet_angle_rad_18 * planet_angle_rad;\n    double\
    \ planet_angle_rad_20 = planet_angle_rad_19 * planet_angle_rad;\n    double planet_angle_rad_21\
    \ = planet_angle_rad_20 * planet_angle_ra\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpdq2kgpzf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpdq2kgpzf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpdq2kgpzf.cpp:17:71: error: call\
    \ of overloaded \u2018abs(std::__cxx11::basic_string<char>::size_type)\u2019 is\
    \ ambiguous\n   17 |     double sun_distance = std::abs(planet1.length() - planet2.length());\n\
    \      |                                                                     \
    \  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpdq2kgpzf.cpp:2:\n/usr/include/stdlib.h:770:12:\
    \ note: candidate: \u2018int abs(int)\u2019\n  770 | extern int abs (int __x)\
    \ __THROW __attribute__ ((__const__)) __wur;\n      |            ^~~\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpdq2kgpzf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:56:3:\
    \ note: candidate: \u2018long int std::abs(long int)\u2019\n   56 |   abs(long\
    \ __i) { return __builtin_labs(__i); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:61:3:\
    \ note: candidate: \u2018long long int std::abs(long long int)\u2019\n   61 |\
    \   abs(long long __x) { return __builtin_llabs (__x); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:71:3:\
    \ note: candidate: \u2018constexpr double std::abs(double)\u2019\n   71 |   abs(double\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:75:3:\
    \ note: candidate: \u2018constexpr float std::abs(float)\u2019\n   75 |   abs(float\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpc800338i.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpc800338i.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpc800338i.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc800338i.cpp:2:\n/tmp/tmpc800338i.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpc800338i.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpc800338i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1033ozu7.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp1033ozu7.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp1033ozu7.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1033ozu7.cpp:2:\n/tmp/tmp1033ozu7.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp1033ozu7.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp1033ozu7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double a = std::abs(planet1.length() - planet2.length());\n\
    \    if (a > 0.1) {\n        return std::make_tuple(planet1, planet2);\n    }\n\
    \    if (a < 0.1) {\n        return std::make_tuple(planet2, planet1);\n    }\n\
    \    if (planet1.length() > planet2.length()) {\n        return std::make_tuple(planet1,\
    \ planet2);\n    }\n    if (planet1.length() < planet2.length()) {\n        return\
    \ std::make_tuple(planet2, planet1);\n    }\n    if (planet1.length() == planet2.length())\
    \ {\n        return std::make_tuple(planet1, planet2);\n    }\n    return std::make_tuple(\"\
    \", \"\");\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0oxlb9uv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0oxlb9uv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0oxlb9uv.cpp:17:60: error: call\
    \ of overloaded \u2018abs(std::__cxx11::basic_string<char>::size_type)\u2019 is\
    \ ambiguous\n   17 |     double a = std::abs(planet1.length() - planet2.length());\n\
    \      |                                                            ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp0oxlb9uv.cpp:2:\n/usr/include/stdlib.h:770:12:\
    \ note: candidate: \u2018int abs(int)\u2019\n  770 | extern int abs (int __x)\
    \ __THROW __attribute__ ((__const__)) __wur;\n      |            ^~~\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp0oxlb9uv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:56:3:\
    \ note: candidate: \u2018long int std::abs(long int)\u2019\n   56 |   abs(long\
    \ __i) { return __builtin_labs(__i); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:61:3:\
    \ note: candidate: \u2018long long int std::abs(long long int)\u2019\n   61 |\
    \   abs(long long __x) { return __builtin_llabs (__x); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:71:3:\
    \ note: candidate: \u2018constexpr double std::abs(double)\u2019\n   71 |   abs(double\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:75:3:\
    \ note: candidate: \u2018constexpr float std::abs(float)\u2019\n   75 |   abs(float\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:79:3:\
    \ not"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1, distance2;\n    double angle;\n    double angle1,\
    \ angle2;\n    double angleDiff;\n    double angleDiff1, angleDiff2;\n    double\
    \ angleDiffSum;\n    double angleDiffSum1, angleDiffSum2;\n    double angleSum;\n\
    \    double angleSum1, angleSum2;\n    double angleSumDiff;\n    double angleSumDiff1,\
    \ angleSumDiff2;\n    double angleSumDiffSum;\n    double angleSumDiffSum1, angleSumDiffSum2;\n\
    \    double angleSumSum;\n    double angleSumSum1, angleSumSum2;\n    double angleSumSumDiff;\n\
    \    double angleSumSumDiff1, angleSumSumDiff2;\n    double angleSumSumDiffSum;\n\
    \    double angleSumSumDiffSum1, angleSumSumDiffSum2;\n    double angleSumSumSum;\n\
    \    double angleSumSumSum1, angleSumSumSum2;\n    double angleSumSumSumDiff;\n\
    \    double angleSumSumSumDiff1, angleSumSumSumDiff2;\n    double angleSumSumSumDiffSum;\n\
    \    double angleSumSumSumDiffSum1, angleSumSumSumDiffSum2;\n    double angleSumSumSumSum;\n\
    \    double angleSumSumSumSum1, angleSumSumSumSum2;\n    double angleSumSumSumSumDiff;\n\
    \    double angleSumSumSumSumDiff1, angleSumSumSumSumDiff2;\n    double angleSumSumSumSumDiffSum;\n\
    \    double angleSumSumSumSumDiffSum1, angleSumSumSumSumDiffSum2;\n    double\
    \ angleSumSumSumSumSum;\n    double angleSumSumSumSumSum1, angleSumSumSumSumSum2;\n\
    \    double angleSumSumSumSumSumDiff;\n    double angleSumSumSumSumSumDiff1, angleSumSumSumSumSumDiff2;\n\
    \    double angleSumSumSumSumSumDiffSum;\n    double angleSumSumSumSumSumDiffSum1,\
    \ angleSumSumSumSumSumDiffSum2;\n    double angleSumSumSumSumSumSum;\n    double\
    \ angleSumSumSumSumSumSum1, angleSumSumSumSumSumSum2;\n    double angleSumSumSumSumSumSumDiff;\n\
    \    double angleSumSumSumSumSumSumDiff1, angleSumSumSumSumSumSumDiff2;\n    double\
    \ angleSumSumSumSumSumSumDiffSum;\n    double angleSum\n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9eorxp1v.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp9eorxp1v.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp9eorxp1v.cpp:62:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   62 | }\n      | ^\n/tmp/tmp9eorxp1v.cpp:62:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9eorxp1v.cpp:2:\n/tmp/tmp9eorxp1v.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp9eorxp1v.cpp:65:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   65 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp9eorxp1v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    double distance;\n    double angle;\n    double\
    \ distance1;\n    double angle1;\n    double distance2;\n    double angle2;\n\
    \    double distance3;\n    double angle3;\n    double distance4;\n    double\
    \ angle4;\n    double distance5;\n    double angle5;\n    double distance6;\n\
    \    double angle6;\n    double distance7;\n    double angle7;\n    double distance8;\n\
    \    double angle8;\n    double distance9;\n    double angle9;\n    double distance10;\n\
    \    double angle10;\n    double distance11;\n    double angle11;\n    double\
    \ distance12;\n    double angle12;\n    double distance13;\n    double angle13;\n\
    \    double distance14;\n    double angle14;\n    double distance15;\n    double\
    \ angle15;\n    double distance16;\n    double angle16;\n    double distance17;\n\
    \    double angle17;\n    double distance18;\n    double angle18;\n    double\
    \ distance19;\n    double angle19;\n    double distance20;\n    double angle20;\n\
    \    double distance21;\n    double angle21;\n    double distance22;\n    double\
    \ angle22;\n    double distance23;\n    double angle23;\n    double distance24;\n\
    \    double angle24;\n    double distance25;\n    double angle25;\n    double\
    \ distance26;\n    double angle26;\n    double distance27;\n    double angle27;\n\
    \    double distance28;\n    double angle28;\n    double distance29;\n    double\
    \ angle29;\n    double distance30;\n    double angle30;\n    double distance31;\n\
    \    double angle31;\n    double distance32;\n    double angle32;\n    double\
    \ distance33;\n    double angle33;\n    double distance34;\n    double angle34;\n\
    \    double distance35;\n    double angle35;\n    double distance36;\n    double\
    \ angle36;\n    double distance37;\n    double angle37;\n    double distance38;\n\
    \    double angle38;\n    double distance39;\n    double angle39;\n    double\
    \ distance40;\n    double angle40;\n    double distance41;\n    double angle41;\n\
    \    double distance42;\n    double angle42;\n    double distance43;\n    double\
    \ angle43;\n    double distance44;\n    double angle44;\n    double distance45;\n\
    \    double angle45\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppw25wcaq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmppw25wcaq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmppw25wcaq.cpp:110:1: error: expected\
    \ initializer before \u2018}\u2019 token\n  110 | }\n      | ^\n/tmp/tmppw25wcaq.cpp:110:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppw25wcaq.cpp:2:\n/tmp/tmppw25wcaq.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmppw25wcaq.cpp:113:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  113 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppw25wcaq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprrez63d7.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmprrez63d7.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmprrez63d7.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprrez63d7.cpp:2:\n/tmp/tmprrez63d7.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmprrez63d7.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprrez63d7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgf6krzm9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpgf6krzm9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpgf6krzm9.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgf6krzm9.cpp:2:\n/tmp/tmpgf6krzm9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpgf6krzm9.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgf6krzm9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit = planet1 + \" orbit\"\
    ;\n    std::string planet2Orbit = planet2 + \" orbit\";\n    std::string planet1OrbitSun\
    \ = planet1 + \" orbit sun\";\n    std::string planet2OrbitSun = planet2 + \"\
    \ orbit sun\";\n    std::string planet1OrbitSunAndPlanet2 = planet1 + \" orbit\
    \ sun and \" + planet2;\n    std::string planet2OrbitSunAndPlanet1 = planet2 +\
    \ \" orbit sun and \" + planet1;\n    std::string planet1OrbitSunAndPlanet2AndPlanet1\
    \ = planet1 + \" orbit sun and \" + planet2 + \" and \" + planet1;\n    std::string\
    \ planet2OrbitSunAndPlanet1AndPlanet2 = planet2 + \" orbit sun and \" + planet1\
    \ + \" and \" + planet2;\n    std::string planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2\
    \ = planet1 + \" orbit sun and \" + planet2 + \" and \" + planet1 + \" and \"\
    \ + planet2;\n    std::string planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2AndPlanet1\
    \ = planet1 + \" orbit sun and \" + planet2 + \" and \" + planet1 + \" and \"\
    \ + planet2 + \" and \" + planet1;\n    std::string planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2AndPlanet1AndPlanet2\
    \ = planet1 + \" orbit sun and \" + planet2 + \" and \" + planet1 + \" and \"\
    \ + planet2 + \" and \" + planet1 + \" and \" + planet2;\n    std::string planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2AndPlanet1AndPlanet2AndPlanet1\
    \ = planet1 + \" orbit sun and \" + planet2 + \" and \" + planet1 + \" and \"\
    \ + planet2 + \" and \" + planet1 + \" and \" + planet2 + \" and \" + planet1;\n\
    \    std::string planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2AndPlanet1AndPlanet2AndPlanet1AndPlanet2\
    \ = planet1 + \" orbit sun and \" + planet2 + \" and \" + planet1 + \" and \"\
    \ + planet2 + \" and \" + planet1 + \" and \" + planet2 + \" and \" + planet1\
    \ + \" and \" + planet2;\n    std::string planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2AndPlanet\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg4mi02y4.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpg4mi02y4.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpg4mi02y4.cpp:31:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   31 | }\n      | ^\n/tmp/tmpg4mi02y4.cpp:31:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg4mi02y4.cpp:2:\n/tmp/tmpg4mi02y4.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpg4mi02y4.cpp:34:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   34 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpg4mi02y4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != planet2);\n    \n    std::string\
    \ planet1_orbit_name = planet1 + \"_orbit\";\n    std::string planet2_orbit_name\
    \ = planet2 + \"_orbit\";\n    \n    double planet1_orbit[8]; // The orbit of\
    \ planet1\n    double planet2_orbit[8]; // The orbit of planet2\n    \n    double\
    \ sun_radius = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance2 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance3 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance4 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance5 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance6 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance7 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance8 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance9 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance10 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance11 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance12 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance13 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance14 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance15 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance16 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance17 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance18 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance19 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance20 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance21 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance22 = 0.0;\n    \n    // The distance between the two planets\n    double\
    \ distance23 = 0.0;\n    \n    // The distance between the two planets\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpytxpnh0p.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpytxpnh0p.cpp:2:\n/tmp/tmpytxpnh0p.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpytxpnh0p.cpp:100:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  100 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpytxpnh0p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpytxpnh0p.cpp:2:\n/tmp/tmpytxpnh0p.cpp:100:85: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    int\u2019\n  100 |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.1;\n    double planet_radius\
    \ = 6378.1;\n    double planet_separation = planet_radius - sun_radius;\n    double\
    \ planet_separation_sq = planet_separation * planet_separation;\n    double planet_separation_sq2\
    \ = planet_separation_sq * planet_separation_sq;\n    double planet_separation_sq3\
    \ = planet_separation_sq2 * planet_separation_sq;\n    double planet_separation_sq4\
    \ = planet_separation_sq3 * planet_separation_sq;\n    double planet_separation_sq5\
    \ = planet_separation_sq4 * planet_separation_sq;\n    double planet_separation_sq6\
    \ = planet_separation_sq5 * planet_separation_sq;\n    double planet_separation_sq7\
    \ = planet_separation_sq6 * planet_separation_sq;\n    double planet_separation_sq8\
    \ = planet_separation_sq7 * planet_separation_sq;\n    double planet_separation_sq9\
    \ = planet_separation_sq8 * planet_separation_sq;\n    double planet_separation_sq10\
    \ = planet_separation_sq9 * planet_separation_sq;\n    double planet_separation_sq11\
    \ = planet_separation_sq10 * planet_separation_sq;\n    double planet_separation_sq12\
    \ = planet_separation_sq11 * planet_separation_sq;\n    double planet_separation_sq13\
    \ = planet_separation_sq12 * planet_separation_sq;\n    double planet_separation_sq14\
    \ = planet_separation_sq13 * planet_separation_sq;\n    double planet_separation_sq15\
    \ = planet_separation_sq14 * planet_separation_sq;\n    double planet_separation_sq16\
    \ = planet_separation_sq15 * planet_separation_sq;\n    double planet_separation_sq17\
    \ = planet_separation_sq16 * planet_separation_sq;\n    double planet_separation_sq18\
    \ = planet_separation_sq17 * planet_separation_sq;\n    double planet_separation_sq19\
    \ = planet_separation_sq18 * planet_separation_sq;\n    double planet_separation_sq20\
    \ = planet_separation_sq19 * planet_separation_sq;\n    double planet_separation_sq21\
    \ = planet_separation_sq20 * planet_separation_sq;\n    double planet_separation_sq22\
    \ = planet_separation_sq21 * \n}\nint main() {\n    auto candidate = bf;\n   \
    \ assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfzl_sz0z.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpfzl_sz0z.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpfzl_sz0z.cpp:42:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   42 | }\n      | ^\n/tmp/tmpfzl_sz0z.cpp:42:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfzl_sz0z.cpp:2:\n/tmp/tmpfzl_sz0z.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpfzl_sz0z.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpfzl_sz0z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1, distance2;\n    double distance1Orbit, distance2Orbit;\n\
    \    double distance1Orbit1, distance2Orbit1;\n    double distance1Orbit2, distance2Orbit2;\n\
    \    double distance1Orbit3, distance2Orbit3;\n    double distance1Orbit4, distance2Orbit4;\n\
    \    double distance1Orbit5, distance2Orbit5;\n    double distance1Orbit6, distance2Orbit6;\n\
    \    double distance1Orbit7, distance2Orbit7;\n    double distance1Orbit8, distance2Orbit8;\n\
    \    double distance1Orbit9, distance2Orbit9;\n    double distance1Orbit10, distance2Orbit10;\n\
    \    double distance1Orbit11, distance2Orbit11;\n    double distance1Orbit12,\
    \ distance2Orbit12;\n    double distance1Orbit13, distance2Orbit13;\n    double\
    \ distance1Orbit14, distance2Orbit14;\n    double distance1Orbit15, distance2Orbit15;\n\
    \    double distance1Orbit16, distance2Orbit16;\n    double distance1Orbit17,\
    \ distance2Orbit17;\n    double distance1Orbit18, distance2Orbit18;\n    double\
    \ distance1Orbit19, distance2Orbit19;\n    double distance1Orbit20, distance2Orbit20;\n\
    \    double distance1Orbit21, distance2Orbit21;\n    double distance1Orbit22,\
    \ distance2Orbit22;\n    double distance1Orbit23, distance2Orbit23;\n    double\
    \ distance1Orbit24, distance2Orbit24;\n    double distance1Orbit25, distance2Orbit25;\n\
    \    double distance1Orbit26, distance2Orbit26;\n    double distance1Orbit27,\
    \ distance2Orbit27;\n    double distance1Orbit28, distance2Orbit28;\n    double\
    \ distance1Orbit29, distance2Orbit29;\n    double distance1Orbit30, distance2Orbit30;\n\
    \    double distance1Orbit31, distance2Orbit31;\n    double distance1Orbit32,\
    \ distance2Orbit32;\n    double distance1Orbit33, distance2Orbit33;\n    double\
    \ distance1Orbit34, distance2Orbit34;\n    double distance1Orbit35, distance2Orbit35;\n\
    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqnwtlxnm.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpqnwtlxnm.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpqnwtlxnm.cpp:57:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   57 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqnwtlxnm.cpp:2:\n/tmp/tmpqnwtlxnm.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpqnwtlxnm.cpp:60:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   60 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpqnwtlxnm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceSquared\
    \ = 0.0, planet2OrbitDistanceSquared = 0.0;\n    double planet1OrbitDistanceSquared2\
    \ = 0.0, planet2OrbitDistanceSquared2 = 0.0;\n    double planet1OrbitDistanceSquared3\
    \ = 0.0, planet2OrbitDistanceSquared3 = 0.0;\n    double planet1OrbitDistanceSquared4\
    \ = 0.0, planet2OrbitDistanceSquared4 = 0.0;\n    double planet1OrbitDistanceSquared5\
    \ = 0.0, planet2OrbitDistanceSquared5 = 0.0;\n    double planet1OrbitDistanceSquared6\
    \ = 0.0, planet2OrbitDistanceSquared6 = 0.0;\n    double planet1OrbitDistanceSquared7\
    \ = 0.0, planet2OrbitDistanceSquared7 = 0.0;\n    double planet1OrbitDistanceSquared8\
    \ = 0.0, planet2OrbitDistanceSquared8 = 0.0;\n    double planet1OrbitDistanceSquared9\
    \ = 0.0, planet2OrbitDistanceSquared9 = 0.0;\n    double planet1OrbitDistanceSquared10\
    \ = 0.0, planet2OrbitDistanceSquared10 = 0.0;\n    double planet1OrbitDistanceSquared11\
    \ = 0.0, planet2OrbitDistanceSquared11 = 0.0;\n    double planet1OrbitDistanceSquared12\
    \ = 0.0, planet2OrbitDistanceSquared12 = 0.0;\n    double planet1OrbitDistanceSquared13\
    \ = 0.0, planet2OrbitDistanceSquared13 = 0.0;\n    double planet1OrbitDistanceSquared14\
    \ = 0.0, planet2OrbitDistanceSquared14 = 0.0;\n    double planet1OrbitDistanceSquared15\
    \ = 0.0, planet2OrbitDistanceSquared15 = 0.0;\n    double planet1OrbitDistanceSquared16\
    \ = 0.0, planet2OrbitDistanceSquared16 = 0.0;\n    double planet1OrbitDistanceSquared17\
    \ = 0.0, planet2OrbitDistanceSquared17 = 0.0;\n    double planet1OrbitDistanceSquared18\
    \ = 0.0, planet2OrbitDistanceSquared18 = 0.0;\n    double planet1OrbitDistanceSquared19\
    \ = 0.0, planet2OrbitDistanceSquared19 = 0.0;\n    double planet1OrbitDistanceSquared20\
    \ = 0.0, planet2Orbit\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsw1z75t8.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpsw1z75t8.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpsw1z75t8.cpp:39:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   39 | }\n      | ^\n/tmp/tmpsw1z75t8.cpp:39:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsw1z75t8.cpp:2:\n/tmp/tmpsw1z75t8.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpsw1z75t8.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsw1z75t8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance = 0;\n    double distance2 = 0;\n\
    \    double distance3 = 0;\n    double distance4 = 0;\n    double distance5 =\
    \ 0;\n    double distance6 = 0;\n    double distance7 = 0;\n    double distance8\
    \ = 0;\n    double distance9 = 0;\n    double distance10 = 0;\n    double distance11\
    \ = 0;\n    double distance12 = 0;\n    double distance13 = 0;\n    double distance14\
    \ = 0;\n    double distance15 = 0;\n    double distance16 = 0;\n    double distance17\
    \ = 0;\n    double distance18 = 0;\n    double distance19 = 0;\n    double distance20\
    \ = 0;\n    double distance21 = 0;\n    double distance22 = 0;\n    double distance23\
    \ = 0;\n    double distance24 = 0;\n    double distance25 = 0;\n    double distance26\
    \ = 0;\n    double distance27 = 0;\n    double distance28 = 0;\n    double distance29\
    \ = 0;\n    double distance30 = 0;\n    double distance31 = 0;\n    double distance32\
    \ = 0;\n    double distance33 = 0;\n    double distance34 = 0;\n    double distance35\
    \ = 0;\n    double distance36 = 0;\n    double distance37 = 0;\n    double distance38\
    \ = 0;\n    double distance39 = 0;\n    double distance40 = 0;\n    double distance41\
    \ = 0;\n    double distance42 = 0;\n    double distance43 = 0;\n    double distance44\
    \ = 0;\n    double distance45 = 0;\n    double distance46 = 0;\n    double distance47\
    \ = 0;\n    double distance48 = 0;\n    double distance49 = 0;\n    double distance50\
    \ = 0;\n    double distance51 = 0;\n    double distance52 = 0;\n    double distance53\
    \ = 0;\n    double distance54 = 0;\n    double distance55 = 0;\n    double distance56\
    \ = 0;\n    double distance57 = 0;\n    double distance58 = 0;\n    double distance59\
    \ = 0;\n    double distance60 = 0;\n    double distance61 = 0;\n    double distance62\
    \ = 0;\n    double distance63 = 0;\n    double distance64 = 0;\n    double distance65\
    \ = 0;\n    double distance66 = 0;\n    double distance67 = 0;\n    double distance68\
    \ = 0;\n    double distance69 = 0;\n    double distance70 = 0;\n    double distance71\
    \ = 0;\n    double distance72 = 0;\n    double distance73 = 0;\n    double distance74\
    \ = 0;\n    double distance75 = 0;\n    double distance76 = 0;\n    double distance77\
    \ = 0;\n    double distance78 = 0;\n    double distance79 = 0;\n    double distance80\
    \ = 0;\n    double distance81 = 0;\n    double distance82 = 0;\n    double distance83\
    \ = 0;\n    double distance84 = 0;\n    double distance85 = 0;\n    double distance86\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpabdacusl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpabdacusl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpabdacusl.cpp:104:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  104 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpabdacusl.cpp:2:\n/tmp/tmpabdacusl.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpabdacusl.cpp:107:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  107 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpabdacusl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistance2,\
    \ planet2OrbitDistance2;\n    double planet1OrbitDistance3, planet2OrbitDistance3;\n\
    \    double planet1OrbitDistance4, planet2OrbitDistance4;\n    double planet1OrbitDistance5,\
    \ planet2OrbitDistance5;\n    double planet1OrbitDistance6, planet2OrbitDistance6;\n\
    \    double planet1OrbitDistance7, planet2OrbitDistance7;\n    double planet1OrbitDistance8,\
    \ planet2OrbitDistance8;\n    double planet1OrbitDistance9, planet2OrbitDistance9;\n\
    \    double planet1OrbitDistance10, planet2OrbitDistance10;\n    double planet1OrbitDistance11,\
    \ planet2OrbitDistance11;\n    double planet1OrbitDistance12, planet2OrbitDistance12;\n\
    \    double planet1OrbitDistance13, planet2OrbitDistance13;\n    double planet1OrbitDistance14,\
    \ planet2OrbitDistance14;\n    double planet1OrbitDistance15, planet2OrbitDistance15;\n\
    \    double planet1OrbitDistance16, planet2OrbitDistance16;\n    double planet1OrbitDistance17,\
    \ planet2OrbitDistance17;\n    double planet1OrbitDistance18, planet2OrbitDistance18;\n\
    \    double planet1OrbitDistance19, planet2OrbitDistance19;\n    double planet1OrbitDistance20,\
    \ planet2OrbitDistance20;\n    double planet1OrbitDistance21, planet2OrbitDistance21;\n\
    \    double planet1OrbitDistance22, planet2OrbitDistance22;\n    double planet1OrbitDistance23,\
    \ planet2OrbitDistance23;\n    double planet1OrbitDistance24, planet2OrbitDistance24;\n\
    \    double planet1OrbitDistance25, planet2OrbitDistance25;\n    double planet1OrbitDistance26,\
    \ planet2OrbitDistance26;\n    double planet1OrbitDistance27, planet2OrbitDistance27;\n\
    \    double planet1OrbitDistance28, planet2OrbitDistance28;\n    double planet1OrbitDistance29,\
    \ plan\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpttvx5du1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpttvx5du1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpttvx5du1.cpp:47:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   47 | }\n      | ^\n/tmp/tmpttvx5du1.cpp:47:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpttvx5du1.cpp:2:\n/tmp/tmpttvx5du1.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpttvx5du1.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpttvx5du1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppwj7ap4p.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmppwj7ap4p.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmppwj7ap4p.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppwj7ap4p.cpp:2:\n/tmp/tmppwj7ap4p.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmppwj7ap4p.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppwj7ap4p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1Orbit, planet2Orbit;\n\
    \    \n    planet1Orbit = planet1 + \" orbit\";\n    planet2Orbit = planet2 +\
    \ \" orbit\";\n    \n    double distance1, distance2;\n    \n    distance1 = std::abs(planet1.length()\
    \ - planet2.length());\n    distance2 = std::abs(planet2.length() - planet1.length());\n\
    \    \n    if (distance1 < distance2) {\n        std::swap(planet1, planet2);\n\
    \    }\n    \n    std::tuple<std::string, > result;\n    \n    if (planet1 ==\
    \ planet2) {\n        return std::make_tuple(planet1, planet2);\n    }\n    \n\
    \    if (planet1Orbit == planet2Orbit) {\n        return std::make_tuple(planet1,\
    \ planet2);\n    }\n    \n    if (planet1Orbit < planet2Orbit) {\n        std::tie(planet1,\
    \ planet2) = std::make_tuple(planet2, planet1);\n    }\n    \n    if (planet1Orbit\
    \ > planet2Orbit) {\n        std::tie(planet1, planet2) = std::make_tuple(planet1,\
    \ planet2);\n    }\n    \n    if (planet1Orbit == planet2Orbit) {\n        return\
    \ std::make_tuple(planet1, planet2);\n    }\n    \n    if (planet1Orbit < planet2Orbit)\
    \ {\n        std::tie(planet1, planet2) = std::make_tuple(planet1, planet2);\n\
    \    }\n    \n    if (planet1Orbit > planet2Orbit) {\n        std::tie(planet1,\
    \ planet2) = std::make_tuple(planet1, planet2);\n    }\n    \n    if (planet1Orbit\
    \ == planet2Orbit) {\n        return std::make_tuple(planet1, planet2);\n    }\n\
    \    \n    if (planet1Orbit < planet2Orbit) {\n        std::tie(planet1, planet2)\
    \ = std::make_tuple(planet1, planet2);\n    }\n    \n    if (planet1Orbit > planet2Orbit)\
    \ {\n        std::tie(planet1, planet2) = std::make_tuple(planet1, planet2);\n\
    \    }\n    \n    if (planet1Orbit == planet2Orbit) {\n        return std::make_tuple(planet1,\
    \ planet2);\n    }\n    \n    if (planet1Orbit \n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpodsww0bl.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpodsww0bl.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpodsww0bl.cpp:25:61: error: call\
    \ of overloaded \u2018abs(std::__cxx11::basic_string<char>::size_type)\u2019 is\
    \ ambiguous\n   25 |     distance1 = std::abs(planet1.length() - planet2.length());\n\
    \      |                                                             ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpodsww0bl.cpp:2:\n/usr/include/stdlib.h:770:12:\
    \ note: candidate: \u2018int abs(int)\u2019\n  770 | extern int abs (int __x)\
    \ __THROW __attribute__ ((__const__)) __wur;\n      |            ^~~\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpodsww0bl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:56:3:\
    \ note: candidate: \u2018long int std::abs(long int)\u2019\n   56 |   abs(long\
    \ __i) { return __builtin_labs(__i); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:61:3:\
    \ note: candidate: \u2018long long int std::abs(long long int)\u2019\n   61 |\
    \   abs(long long __x) { return __builtin_llabs (__x); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:71:3:\
    \ note: candidate: \u2018constexpr double std::abs(double)\u2019\n   71 |   abs(double\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:75:3:\
    \ note: candidate: \u2018constexpr float std::abs(float)\u2019\n   75 |   abs(float\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:79:3:\
    \ n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != \"\");\n    assert(planet2 !=\
    \ \"\");\n    std::tuple<std::string, > result;\n    double sun_radius = 6378.1;\n\
    \    double planet_radius = 6378.1;\n    double planet_separation = planet_radius\
    \ - sun_radius;\n    double planet_separation_sq = planet_separation * planet_separation;\n\
    \    double planet_separation_sq_inv = 1 / planet_separation_sq;\n    double planet_separation_sq_inv_2\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_3\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_4\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_5\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_6\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_7\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_8\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_9\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_10\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_11\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_12\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_13\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_14\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_15\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_16\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_17\
    \ = planet_separation_sq_inv * planet_separation_sq_inv;\n    double planet_separation_sq_inv_18\
    \ = planet_separation_sq\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3tv0appp.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp3tv0appp.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp3tv0appp.cpp:19:29: error: template\
    \ argument 2 is invalid\n   19 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmp3tv0appp.cpp:42:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   42 | }\n     \
    \ | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3tv0appp.cpp:2:\n/tmp/tmp3tv0appp.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp3tv0appp.cpp:45:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   45 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3tv0appp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbzuvpldg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbzuvpldg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbzuvpldg.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbzuvpldg.cpp:2:\n/tmp/tmpbzuvpldg.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbzuvpldg.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbzuvpldg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjzusjxgq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjzusjxgq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjzusjxgq.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjzusjxgq.cpp:2:\n/tmp/tmpjzusjxgq.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpjzusjxgq.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpjzusjxgq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkgi0czgq.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpkgi0czgq.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpkgi0czgq.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkgi0czgq.cpp:2:\n/tmp/tmpkgi0czgq.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpkgi0czgq.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpkgi0czgq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double a1 = 0.0;\n    double a2 = 0.0;\n    double\
    \ a3 = 0.0;\n    double a4 = 0.0;\n    double a5 = 0.0;\n    double a6 = 0.0;\n\
    \    double a7 = 0.0;\n    double a8 = 0.0;\n    double a9 = 0.0;\n    double\
    \ a10 = 0.0;\n    double a11 = 0.0;\n    double a12 = 0.0;\n    double a13 = 0.0;\n\
    \    double a14 = 0.0;\n    double a15 = 0.0;\n    double a16 = 0.0;\n    double\
    \ a17 = 0.0;\n    double a18 = 0.0;\n    double a19 = 0.0;\n    double a20 = 0.0;\n\
    \    double a21 = 0.0;\n    double a22 = 0.0;\n    double a23 = 0.0;\n    double\
    \ a24 = 0.0;\n    double a25 = 0.0;\n    double a26 = 0.0;\n    double a27 = 0.0;\n\
    \    double a28 = 0.0;\n    double a29 = 0.0;\n    double a30 = 0.0;\n    double\
    \ a31 = 0.0;\n    double a32 = 0.0;\n    double a33 = 0.0;\n    double a34 = 0.0;\n\
    \    double a35 = 0.0;\n    double a36 = 0.0;\n    double a37 = 0.0;\n    double\
    \ a38 = 0.0;\n    double a39 = 0.0;\n    double a40 = 0.0;\n    double a41 = 0.0;\n\
    \    double a42 = 0.0;\n    double a43 = 0.0;\n    double a44 = 0.0;\n    double\
    \ a45 = 0.0;\n    double a46 = 0.0;\n    double a47 = 0.0;\n    double a48 = 0.0;\n\
    \    double a49 = 0.0;\n    double a50 = 0.0;\n    double a51 = 0.0;\n    double\
    \ a52 = 0.0;\n    double a53 = 0.0;\n    double a54 = 0.0;\n    double a55 = 0.0;\n\
    \    double a56 = 0.0;\n    double a57 = 0.0;\n    double a58 = 0.0;\n    double\
    \ a59 = 0.0;\n    double a60 = 0.0;\n    double a61 = 0.0;\n    double a62 = 0.0;\n\
    \    double a63 = 0.0;\n    double a64 = 0.0;\n    double a65 = 0.0;\n    double\
    \ a66 = 0.0;\n    double a67 = 0.0;\n    double a68 = 0.0;\n    double a69 = 0.0;\n\
    \    double a70 = 0.0;\n    double a71 = 0.0;\n    double a72 = 0.0;\n    double\
    \ a73 = 0.0;\n    double a74\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcs4ii_nu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpcs4ii_nu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpcs4ii_nu.cpp:91:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   91 | }\n      | ^\n/tmp/tmpcs4ii_nu.cpp:91:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcs4ii_nu.cpp:2:\n/tmp/tmpcs4ii_nu.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpcs4ii_nu.cpp:94:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   94 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpcs4ii_nu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8wzysmql.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8wzysmql.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8wzysmql.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8wzysmql.cpp:2:\n/tmp/tmp8wzysmql.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8wzysmql.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8wzysmql.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceSquared\
    \ = 0.0, planet2OrbitDistanceSquared = 0.0;\n    double planet1OrbitDistanceSquared2\
    \ = 0.0, planet2OrbitDistanceSquared2 = 0.0;\n    double planet1OrbitDistanceSquared3\
    \ = 0.0, planet2OrbitDistanceSquared3 = 0.0;\n    double planet1OrbitDistanceSquared4\
    \ = 0.0, planet2OrbitDistanceSquared4 = 0.0;\n    double planet1OrbitDistanceSquared5\
    \ = 0.0, planet2OrbitDistanceSquared5 = 0.0;\n    double planet1OrbitDistanceSquared6\
    \ = 0.0, planet2OrbitDistanceSquared6 = 0.0;\n    double planet1OrbitDistanceSquared7\
    \ = 0.0, planet2OrbitDistanceSquared7 = 0.0;\n    double planet1OrbitDistanceSquared8\
    \ = 0.0, planet2OrbitDistanceSquared8 = 0.0;\n    double planet1OrbitDistanceSquared9\
    \ = 0.0, planet2OrbitDistanceSquared9 = 0.0;\n    double planet1OrbitDistanceSquared10\
    \ = 0.0, planet2OrbitDistanceSquared10 = 0.0;\n    double planet1OrbitDistanceSquared11\
    \ = 0.0, planet2OrbitDistanceSquared11 = 0.0;\n    double planet1OrbitDistanceSquared12\
    \ = 0.0, planet2OrbitDistanceSquared12 = 0.0;\n    double planet1OrbitDistanceSquared13\
    \ = 0.0, planet2OrbitDistanceSquared13 = 0.0;\n    double planet1OrbitDistanceSquared14\
    \ = 0.0, planet2OrbitDistanceSquared14 = 0.0;\n    double planet1OrbitDistanceSquared15\
    \ = 0.0, planet2OrbitDistanceSquared15 = 0.0;\n    double planet1OrbitDistanceSquared16\
    \ = 0.0, planet2OrbitDistanceSquared16 = 0.0;\n    double planet1OrbitDistanceSquared17\
    \ = 0.0, planet2OrbitDistanceSquared17 = 0.0;\n    double planet1OrbitDistanceSquared18\
    \ = 0.0, planet2OrbitDistanceSquared18 = 0.0;\n    double planet1OrbitDistanceSquared19\
    \ = 0.0, planet2OrbitDistanceSquared19 = 0.0;\n    double planet1OrbitDistanceSquared20\
    \ = 0.0, planet2Orbit\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf522c33i.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpf522c33i.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpf522c33i.cpp:39:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   39 | }\n      | ^\n/tmp/tmpf522c33i.cpp:39:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf522c33i.cpp:2:\n/tmp/tmpf522c33i.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpf522c33i.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpf522c33i.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance1;\n    double distance2;\n    double distance3;\n\
    \    double distance4;\n    double distance5;\n    double distance6;\n    double\
    \ distance7;\n    double distance8;\n    double distance9;\n    double distance10;\n\
    \    double distance11;\n    double distance12;\n    double distance13;\n    double\
    \ distance14;\n    double distance15;\n    double distance16;\n    double distance17;\n\
    \    double distance18;\n    double distance19;\n    double distance20;\n    double\
    \ distance21;\n    double distance22;\n    double distance23;\n    double distance24;\n\
    \    double distance25;\n    double distance26;\n    double distance27;\n    double\
    \ distance28;\n    double distance29;\n    double distance30;\n    double distance31;\n\
    \    double distance32;\n    double distance33;\n    double distance34;\n    double\
    \ distance35;\n    double distance36;\n    double distance37;\n    double distance38;\n\
    \    double distance39;\n    double distance40;\n    double distance41;\n    double\
    \ distance42;\n    double distance43;\n    double distance44;\n    double distance45;\n\
    \    double distance46;\n    double distance47;\n    double distance48;\n    double\
    \ distance49;\n    double distance50;\n    double distance51;\n    double distance52;\n\
    \    double distance53;\n    double distance54;\n    double distance55;\n    double\
    \ distance56;\n    double distance57;\n    double distance58;\n    double distance59;\n\
    \    double distance60;\n    double distance61;\n    double distance62;\n    double\
    \ distance63;\n    double distance64;\n    double distance65;\n    double distance66;\n\
    \    double distance67;\n    double distance68;\n    double distance69;\n    double\
    \ distance70;\n    double distance71;\n    double distance72;\n    double distance73;\n\
    \    double distance74;\n    double distance75;\n    double distance76;\n    double\
    \ distance77;\n    double distance78;\n    double distance79;\n    double distance80;\n\
    \    double distance81;\n    double distance82;\n    double distance83;\n    double\
    \ distance84;\n    double distance85;\n    double \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpmcwlkxqk.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpmcwlkxqk.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpmcwlkxqk.cpp:105:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmpmcwlkxqk.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmcwlkxqk.cpp:2:\n/tmp/tmpmcwlkxqk.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpmcwlkxqk.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmcwlkxqk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc9vx2tn1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpc9vx2tn1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpc9vx2tn1.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc9vx2tn1.cpp:2:\n/tmp/tmpc9vx2tn1.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpc9vx2tn1.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpc9vx2tn1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpob302jcm.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpob302jcm.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpob302jcm.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpob302jcm.cpp:2:\n/tmp/tmpob302jcm.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpob302jcm.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpob302jcm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbe_52a5q.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbe_52a5q.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbe_52a5q.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbe_52a5q.cpp:2:\n/tmp/tmpbe_52a5q.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbe_52a5q.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbe_52a5q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpunooges1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpunooges1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpunooges1.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpunooges1.cpp:2:\n/tmp/tmpunooges1.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpunooges1.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpunooges1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double a = 0.0;\n    double b = 0.0;\n    double\
    \ c = 0.0;\n    double d = 0.0;\n    double e = 0.0;\n    double f = 0.0;\n  \
    \  double g = 0.0;\n    double h = 0.0;\n    double i = 0.0;\n    double j = 0.0;\n\
    \    double k = 0.0;\n    double l = 0.0;\n    double m = 0.0;\n    double n =\
    \ 0.0;\n    double o = 0.0;\n    double p = 0.0;\n    double q = 0.0;\n    double\
    \ r = 0.0;\n    double s = 0.0;\n    double t = 0.0;\n    double u = 0.0;\n  \
    \  double v = 0.0;\n    double w = 0.0;\n    double x = 0.0;\n    double y = 0.0;\n\
    \    double z = 0.0;\n    double a = 0.0;\n    double b = 0.0;\n    double c =\
    \ 0.0;\n    double d = 0.0;\n    double e = 0.0;\n    double f = 0.0;\n    double\
    \ g = 0.0;\n    double h = 0.0;\n    double i = 0.0;\n    double j = 0.0;\n  \
    \  double k = 0.0;\n    double l = 0.0;\n    double m = 0.0;\n    double n = 0.0;\n\
    \    double o = 0.0;\n    double p = 0.0;\n    double q = 0.0;\n    double r =\
    \ 0.0;\n    double s = 0.0;\n    double t = 0.0;\n    double u = 0.0;\n    double\
    \ v = 0.0;\n    double w = 0.0;\n    double x = 0.0;\n    double y = 0.0;\n  \
    \  double z = 0.0;\n    double a = 0.0;\n    double b = 0.0;\n    double c = 0.0;\n\
    \    double d = 0.0;\n    double e = 0.0;\n    double f = 0.0;\n    double g =\
    \ 0.0;\n    double h = 0.0;\n    double i = 0.0;\n    double j = 0.0;\n    double\
    \ k = 0.0;\n    double l = 0.0;\n    double m = 0.0;\n    double n = 0.0;\n  \
    \  double o = 0.0;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n\
    \    double s = 0.0;\n    double t = 0.0;\n    double u = 0.0;\n    double v =\
    \ 0.0;\n    double w = 0.0;\n    double x = 0.0;\n    double y = 0.0;\n    double\
    \ z = 0.0;\n    double a = 0.0;\n    double b = 0.0;\n    double c = 0.0;\n  \
    \  double d = 0.0;\n    double e = 0.0;\n    double f = 0.0;\n    double g = 0.0;\n\
    \    double \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnixe0fxn.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpnixe0fxn.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpnixe0fxn.cpp:43:12: error: redeclaration\
    \ of \u2018double a\u2019\n   43 |     double a = 0.0;\n      |            ^\n\
    /tmp/tmpnixe0fxn.cpp:17:12: note: \u2018double a\u2019 previously declared here\n\
    \   17 |     double a = 0.0;\n      |            ^\n/tmp/tmpnixe0fxn.cpp:44:12:\
    \ error: redeclaration of \u2018double b\u2019\n   44 |     double b = 0.0;\n\
    \      |            ^\n/tmp/tmpnixe0fxn.cpp:18:12: note: \u2018double b\u2019\
    \ previously declared here\n   18 |     double b = 0.0;\n      |            ^\n\
    /tmp/tmpnixe0fxn.cpp:45:12: error: redeclaration of \u2018double c\u2019\n   45\
    \ |     double c = 0.0;\n      |            ^\n/tmp/tmpnixe0fxn.cpp:19:12: note:\
    \ \u2018double c\u2019 previously declared here\n   19 |     double c = 0.0;\n\
    \      |            ^\n/tmp/tmpnixe0fxn.cpp:46:12: error: redeclaration of \u2018\
    double d\u2019\n   46 |     double d = 0.0;\n      |            ^\n/tmp/tmpnixe0fxn.cpp:20:12:\
    \ note: \u2018double d\u2019 previously declared here\n   20 |     double d =\
    \ 0.0;\n      |            ^\n/tmp/tmpnixe0fxn.cpp:47:12: error: redeclaration\
    \ of \u2018double e\u2019\n   47 |     double e = 0.0;\n      |            ^\n\
    /tmp/tmpnixe0fxn.cpp:21:12: note: \u2018double e\u2019 previously declared here\n\
    \   21 |     double e = 0.0;\n      |            ^\n/tmp/tmpnixe0fxn.cpp:48:12:\
    \ error: redeclaration of \u2018double f\u2019\n   48 |     double f = 0.0;\n\
    \      |            ^\n/tmp/tmpnixe0fxn.cpp:22:12: note: \u2018double f\u2019\
    \ previously declared here\n   22 |     double f = 0.0;\n      |            ^\n\
    /tmp/tmpnixe0fxn.cpp:49:12: error: redeclaration of \u2018double g\u2019\n   49\
    \ |     double g = 0.0;\n      |            ^\n/tmp/tmpnixe0fxn.cpp:23:12: note:\
    \ \u2018double g\u2019 previously declared here\n   23 |     double g = 0.0;\n\
    \      |            ^\n/tmp/tmpnixe0fxn.cpp:50:12: error: redeclaration of \u2018\
    double h\u2019\n   50 |     double h = 0.0;\n      |            ^\n/tmp/tmpnixe0fxn.cpp:24:12:\
    \ note: \u2018double h\u2019 previously declared her"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphxdl0ilt.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmphxdl0ilt.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmphxdl0ilt.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphxdl0ilt.cpp:2:\n/tmp/tmphxdl0ilt.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmphxdl0ilt.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphxdl0ilt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp8hbgol26.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8hbgol26.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8hbgol26.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8hbgol26.cpp:2:\n/tmp/tmp8hbgol26.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8hbgol26.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8hbgol26.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp75r928us.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp75r928us.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp75r928us.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp75r928us.cpp:2:\n/tmp/tmp75r928us.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp75r928us.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp75r928us.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance2;\n    double distance3;\n    double distance4;\n\
    \    double distance5;\n    double distance6;\n    double distance7;\n    double\
    \ distance8;\n    double distance9;\n    double distance10;\n    double distance11;\n\
    \    double distance12;\n    double distance13;\n    double distance14;\n    double\
    \ distance15;\n    double distance16;\n    double distance17;\n    double distance18;\n\
    \    double distance19;\n    double distance20;\n    double distance21;\n    double\
    \ distance22;\n    double distance23;\n    double distance24;\n    double distance25;\n\
    \    double distance26;\n    double distance27;\n    double distance28;\n    double\
    \ distance29;\n    double distance30;\n    double distance31;\n    double distance32;\n\
    \    double distance33;\n    double distance34;\n    double distance35;\n    double\
    \ distance36;\n    double distance37;\n    double distance38;\n    double distance39;\n\
    \    double distance40;\n    double distance41;\n    double distance42;\n    double\
    \ distance43;\n    double distance44;\n    double distance45;\n    double distance46;\n\
    \    double distance47;\n    double distance48;\n    double distance49;\n    double\
    \ distance50;\n    double distance51;\n    double distance52;\n    double distance53;\n\
    \    double distance54;\n    double distance55;\n    double distance56;\n    double\
    \ distance57;\n    double distance58;\n    double distance59;\n    double distance60;\n\
    \    double distance61;\n    double distance62;\n    double distance63;\n    double\
    \ distance64;\n    double distance65;\n    double distance66;\n    double distance67;\n\
    \    double distance68;\n    double distance69;\n    double distance70;\n    double\
    \ distance71;\n    double distance72;\n    double distance73;\n    double distance74;\n\
    \    double distance75;\n    double distance76;\n    double distance77;\n    double\
    \ distance78;\n    double distance79;\n    double distance80;\n    double distance81;\n\
    \    double distance82;\n    double distance83;\n    double distance84;\n    double\
    \ distance85;\n    double distance86;\n    \n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpgi53gntr.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpgi53gntr.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpgi53gntr.cpp:105:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  105 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgi53gntr.cpp:2:\n/tmp/tmpgi53gntr.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpgi53gntr.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgi53gntr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit_name, planet2_orbit_name;\n\
    \    double planet1_orbit_distance, planet2_orbit_distance;\n    double planet1_orbit_period,\
    \ planet2_orbit_period;\n    double planet1_orbit_inclination, planet2_orbit_inclination;\n\
    \    double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double\
    \ planet1_orbit_semimajor_axis, planet2_orbit_semimajor_axis;\n    double planet1_orbit_inclination_angle,\
    \ planet2_orbit_inclination_angle;\n    double planet1_orbit_longitude, planet2_orbit_longitude;\n\
    \    double planet1_orbit_latitude, planet2_orbit_latitude;\n    double planet1_orbit_inclination_angle_radians,\
    \ planet2_orbit_inclination_angle_radians;\n    double planet1_orbit_eccentricity_radians,\
    \ planet2_orbit_eccentricity_radians;\n    double planet1_orbit_semimajor_axis_radians,\
    \ planet2_orbit_semimajor_axis_radians;\n    double planet1_orbit_longitude_degrees,\
    \ planet2_orbit_longitude_degrees;\n    double planet1_orbit_latitude_degrees,\
    \ planet2_orbit_latitude_degrees;\n    double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n    double planet1_orbit_latitude_degrees_radians,\
    \ planet2_orbit_latitude_degrees_radians;\n    double planet1_orbit_inclination_angle_radians,\
    \ planet2_orbit_inclination_angle_radians;\n    double planet1_orbit_eccentricity_radians,\
    \ planet2_orbit_eccentricity_radians;\n    double planet1_orbit_semimajor_axis_radians,\
    \ planet2_orbit_semimajor_axis_radians;\n    double planet1_orbit_longitude_degrees,\
    \ planet2_orbit_longitude_degrees;\n    double planet1_orbit_latitude_degrees,\
    \ planet2_orbit_latitude_degrees;\n    double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n    double planet1_orbit_latitude_degrees_radians,\
    \ planet2_orbit_latitude_degrees_radians;\n    double planet1_orbit_inclination_angle_radians,\
    \ planet2_orbit_inclination_angle_radians;\n    double planet1_orbit_eccentricity_radians,\
    \ \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8nvjpb2e.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8nvjpb2e.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8nvjpb2e.cpp:33:12: error: redeclaration\
    \ of \u2018double planet1_orbit_inclination_angle_radians\u2019\n   33 |     double\
    \ planet1_orbit_inclination_angle_radians, planet2_orbit_inclination_angle_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8nvjpb2e.cpp:26:12:\
    \ note: \u2018double planet1_orbit_inclination_angle_radians\u2019 previously\
    \ declared here\n   26 |     double planet1_orbit_inclination_angle_radians, planet2_orbit_inclination_angle_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8nvjpb2e.cpp:33:53:\
    \ error: redeclaration of \u2018double planet2_orbit_inclination_angle_radians\u2019\
    \n   33 |     double planet1_orbit_inclination_angle_radians, planet2_orbit_inclination_angle_radians;\n\
    \      |                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp8nvjpb2e.cpp:26:53: note: \u2018double planet2_orbit_inclination_angle_radians\u2019\
    \ previously declared here\n   26 |     double planet1_orbit_inclination_angle_radians,\
    \ planet2_orbit_inclination_angle_radians;\n      |                          \
    \                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8nvjpb2e.cpp:34:12:\
    \ error: redeclaration of \u2018double planet1_orbit_eccentricity_radians\u2019\
    \n   34 |     double planet1_orbit_eccentricity_radians, planet2_orbit_eccentricity_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8nvjpb2e.cpp:27:12:\
    \ note: \u2018double planet1_orbit_eccentricity_radians\u2019 previously declared\
    \ here\n   27 |     double planet1_orbit_eccentricity_radians, planet2_orbit_eccentricity_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8nvjpb2e.cpp:34:48:\
    \ error: redeclaration of \u2018double planet2_orbit_eccentricity_radians\u2019\
    \n   34 |     double planet1_orbit_eccentricity_radians, planet2_orbit_ecc"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double earthOrbit = 1.49597870700e11, mercuryOrbit\
    \ = 1.49597870700e11, venusOrbit = 1.49597870700e11, marsOrbit = 1.49597870700e11,\
    \ jupiterOrbit = 1.49597870700e11, saturnOrbit = 1.49597870700e11, uranusOrbit\
    \ = 1.49597870700e11, neptuneOrbit = 1.49597870700e11;\n    double earthOrbitSun\
    \ = 1.49597870700e11, mercuryOrbitSun = 1.49597870700e11, venusOrbitSun = 1.49597870700e11,\
    \ marsOrbitSun = 1.49597870700e11, jupiterOrbitSun = 1.49597870700e11, saturnOrbitSun\
    \ = 1.49597870700e11, uranusOrbitSun = 1.49597870700e11, neptuneOrbitSun = 1.49597870700e11;\n\
    \    double earthOrbitMercury = 1.49597870700e11, mercuryOrbitMercury = 1.49597870700e11,\
    \ venusOrbitMercury = 1.49597870700e11, marsOrbitMercury = 1.49597870700e11, jupiterOrbitMercury\
    \ = 1.49597870700e11, saturnOrbitMercury = 1.49597870700e11, uranusOrbitMercury\
    \ = 1.49597870700e11, neptuneOrbitMercury = 1.49597870700e11;\n    double earthOrbitVenus\
    \ = 1.49597870700e11, mercuryOrbitVenus = 1.49597870700e11, venusOrbitVenus =\
    \ 1.49597870700e11, marsOrbitVenus = 1.49597870700e11, jupiterOrbitVenus = 1.49597870700e11,\
    \ saturnOrbitVenus = 1.49597870700e11, uranusOrbitVenus = 1.49597870700e11, neptuneOrbitVenus\
    \ = 1.495978707\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpguu0x9ds.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpguu0x9ds.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpguu0x9ds.cpp:21:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   21 | }\n     \
    \ | ^\n/tmp/tmpguu0x9ds.cpp:21:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpguu0x9ds.cpp:2:\n/tmp/tmpguu0x9ds.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpguu0x9ds.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpguu0x9ds.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    double sun_distance = 0;\n    double sun_distance2\
    \ = 0;\n    double sun_distance3 = 0;\n    double sun_distance4 = 0;\n    double\
    \ sun_distance5 = 0;\n    double sun_distance6 = 0;\n    double sun_distance7\
    \ = 0;\n    double sun_distance8 = 0;\n    double sun_distance9 = 0;\n    double\
    \ sun_distance10 = 0;\n    double sun_distance11 = 0;\n    double sun_distance12\
    \ = 0;\n    double sun_distance13 = 0;\n    double sun_distance14 = 0;\n    double\
    \ sun_distance15 = 0;\n    double sun_distance16 = 0;\n    double sun_distance17\
    \ = 0;\n    double sun_distance18 = 0;\n    double sun_distance19 = 0;\n    double\
    \ sun_distance20 = 0;\n    double sun_distance21 = 0;\n    double sun_distance22\
    \ = 0;\n    double sun_distance23 = 0;\n    double sun_distance24 = 0;\n    double\
    \ sun_distance25 = 0;\n    double sun_distance26 = 0;\n    double sun_distance27\
    \ = 0;\n    double sun_distance28 = 0;\n    double sun_distance29 = 0;\n    double\
    \ sun_distance30 = 0;\n    double sun_distance31 = 0;\n    double sun_distance32\
    \ = 0;\n    double sun_distance33 = 0;\n    double sun_distance34 = 0;\n    double\
    \ sun_distance35 = 0;\n    double sun_distance36 = 0;\n    double sun_distance37\
    \ = 0;\n    double sun_distance38 = 0;\n    double sun_distance39 = 0;\n    double\
    \ sun_distance40 = 0;\n    double sun_distance41 = 0;\n    double sun_distance42\
    \ = 0;\n    double sun_distance43 = 0;\n    double sun_distance44 = 0;\n    double\
    \ sun_distance45 = 0;\n    double sun_distance46 = 0;\n    double sun_distance47\
    \ = 0;\n    double sun_distance48 = 0;\n    double sun_distance49 = 0;\n    double\
    \ sun_distance50 = 0;\n    double sun_distance51 = 0;\n    double sun_distance52\
    \ = 0;\n    double sun_distance53 = 0;\n    double sun_distance54 = 0;\n    double\
    \ sun_distance55 = 0;\n    double sun_distance56 = 0;\n    double sun_distance57\
    \ = 0;\n    double sun_distance58 = 0;\n    double sun_distance59 = 0;\n    double\
    \ sun_distance60 = 0;\n    double sun_distance61 = 0;\n    double sun_distance62\
    \ = 0;\n    double sun_distance63 = 0;\n    double sun_distance64 = 0;\n    double\
    \ sun\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa9vgw9wu.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpa9vgw9wu.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpa9vgw9wu.cpp:83:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   83 | }\n      | ^\n/tmp/tmpa9vgw9wu.cpp:83:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa9vgw9wu.cpp:2:\n/tmp/tmpa9vgw9wu.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpa9vgw9wu.cpp:86:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   86 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpa9vgw9wu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_orbit_distance, planet2_orbit_distance;\n\
    \    double planet1_orbit_angle, planet2_orbit_angle;\n    double planet1_orbit_period,\
    \ planet2_orbit_period;\n    double planet1_orbit_inclination, planet2_orbit_inclination;\n\
    \    double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double\
    \ planet1_orbit_semi_major_axis, planet2_orbit_semi_major_axis;\n    double planet1_orbit_longitude,\
    \ planet2_orbit_longitude;\n    double planet1_orbit_latitude, planet2_orbit_latitude;\n\
    \    double planet1_orbit_inclination, planet2_orbit_inclination;\n    double\
    \ planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double planet1_orbit_semi_major_axis,\
    \ planet2_orbit_semi_major_axis;\n    double planet1_orbit_longitude, planet2_orbit_longitude;\n\
    \    double planet1_orbit_latitude, planet2_orbit_latitude;\n    double planet1_orbit_inclination,\
    \ planet2_orbit_inclination;\n    double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n\
    \    double planet1_orbit_semi_major_axis, planet2_orbit_semi_major_axis;\n  \
    \  double planet1_orbit_longitude, planet2_orbit_longitude;\n    double planet1_orbit_latitude,\
    \ planet2_orbit_latitude;\n    double planet1_orbit_inclination, planet2_orbit_inclination;\n\
    \    double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double\
    \ planet1_orbit_semi_major_axis, planet2_orbit_semi_major_axis;\n    double planet1_orbit_longitude,\
    \ planet2_orbit_longitude;\n    double planet1_orbit_latitude, planet2_orbit_latitude;\n\
    \    double planet1_orbit_inclination, planet2_orbit_inclination;\n    double\
    \ planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double planet1_orbit_semi_\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr843eyx7.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpr843eyx7.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpr843eyx7.cpp:27:12: error: redeclaration\
    \ of \u2018double planet1_orbit_inclination\u2019\n   27 |     double planet1_orbit_inclination,\
    \ planet2_orbit_inclination;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr843eyx7.cpp:22:12:\
    \ note: \u2018double planet1_orbit_inclination\u2019 previously declared here\n\
    \   22 |     double planet1_orbit_inclination, planet2_orbit_inclination;\n  \
    \    |            ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr843eyx7.cpp:27:39: error:\
    \ redeclaration of \u2018double planet2_orbit_inclination\u2019\n   27 |     double\
    \ planet1_orbit_inclination, planet2_orbit_inclination;\n      |             \
    \                          ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr843eyx7.cpp:22:39:\
    \ note: \u2018double planet2_orbit_inclination\u2019 previously declared here\n\
    \   22 |     double planet1_orbit_inclination, planet2_orbit_inclination;\n  \
    \    |                                       ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr843eyx7.cpp:28:12:\
    \ error: redeclaration of \u2018double planet1_orbit_eccentricity\u2019\n   28\
    \ |     double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n     \
    \ |            ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr843eyx7.cpp:23:12: note: \u2018\
    double planet1_orbit_eccentricity\u2019 previously declared here\n   23 |    \
    \ double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n      |    \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr843eyx7.cpp:28:40: error: redeclaration\
    \ of \u2018double planet2_orbit_eccentricity\u2019\n   28 |     double planet1_orbit_eccentricity,\
    \ planet2_orbit_eccentricity;\n      |                                       \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpr843eyx7.cpp:23:40: note: \u2018double planet2_orbit_eccentricity\u2019\
    \ previously declared here\n   23 |     double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n\
    \      |                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~\n/tm"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double a1 = 0, a2 = 0, b1 = 0, b2 = 0, c1 = 0, c2\
    \ = 0, d = 0;\n    double e1 = 0, e2 = 0, f1 = 0, f2 = 0, g1 = 0, g2 = 0, h1 =\
    \ 0, h2 = 0;\n    double i1 = 0, i2 = 0, j1 = 0, j2 = 0, k1 = 0, k2 = 0, l1 =\
    \ 0, l2 = 0;\n    double m1 = 0, m2 = 0, n1 = 0, n2 = 0, o1 = 0, o2 = 0;\n   \
    \ double p1 = 0, p2 = 0, q1 = 0, q2 = 0, r1 = 0, r2 = 0, s1 = 0, s2 = 0;\n   \
    \ double t1 = 0, t2 = 0, u1 = 0, u2 = 0, v1 = 0, v2 = 0;\n    double w1 = 0, w2\
    \ = 0;\n    double x1 = 0, x2 = 0;\n    double y1 = 0, y2 = 0;\n    double z1\
    \ = 0, z2 = 0;\n    double a1_1 = 0, a1_2 = 0, a2_1 = 0, a2_2 = 0;\n    double\
    \ b1_1 = 0, b1_2 = 0, b2_1 = 0, b2_2 = 0;\n    double c1_1 = 0, c1_2 = 0, c2_1\
    \ = 0, c2_2 = 0;\n    double d1_1 = 0, d1_2 = 0, d2_1 = 0, d2_2 = 0;\n    double\
    \ e1_1 = 0, e1_2 = 0, e2_1 = 0, e2_2 = 0;\n    double f1_1 = 0, f1_2 = 0, f2_1\
    \ = 0, f2_2 = 0;\n    double g1_1 = 0, g1_2 = 0, g2_1 = 0, g2_2 = 0;\n    double\
    \ h1_1 = 0, h1_2 = 0, h2_1 = 0, h2_2 = 0;\n    double i1_1 = 0, i1_2 = 0, i2_1\
    \ = 0, i2_2 = 0;\n    double j1_1 = 0, j1_2 = 0, j2_1 = 0, j2_2 = 0;\n    double\
    \ k1_1 = 0, k1_2 = 0, k2_1 = 0, k2_2 = 0;\n    double l1_1 = 0, l1_2 = 0, l2_1\
    \ = 0, l2_2 = 0;\n    double m1_1 = 0, m1_2 = 0, m2_1 = 0, m2_2 = 0;\n    double\
    \ n1_1 = 0, n1_2 = 0, n2_1 = 0, n2_2 = 0;\n    double o1_1 = 0, o1_2 = 0, o2_1\
    \ = 0, o2_2 = 0;\n    double p1_1 = 0, p1_2 = 0, p2_1 = 0, p2_2 = 0;\n    double\
    \ q1_1 = 0, q1_2 = 0, q2_1 = 0, q2_2 = 0;\n    double r1_1 = 0, r1_2 = 0, r2_1\
    \ = 0, r2_2 = 0;\n    double s1_1 = 0, s1_2 = 0, s2_1 = 0, s2_2 = 0;\n    double\
    \ t1_1 = 0, t1_2 = 0, \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp46vl9j37.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp46vl9j37.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp46vl9j37.cpp:47:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n   47 | }\n      | ^\n/tmp/tmp46vl9j37.cpp:47:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp46vl9j37.cpp:2:\n/tmp/tmp46vl9j37.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp46vl9j37.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp46vl9j37.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    // Your code here\n    \n}\nint main() {\n    auto\
    \ candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvo3_f5wd.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpvo3_f5wd.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpvo3_f5wd.cpp:19:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   19 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvo3_f5wd.cpp:2:\n/tmp/tmpvo3_f5wd.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpvo3_f5wd.cpp:22:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   22 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvo3_f5wd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmplryxel_2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmplryxel_2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmplryxel_2.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplryxel_2.cpp:2:\n/tmp/tmplryxel_2.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmplryxel_2.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmplryxel_2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    \n    double sun_radius\
    \ = 6378.16; // Radius of the Sun in kilometers\n    double planet_radius = 6378.16;\
    \ // Radius of a planet in kilometers\n    double planet_separation = planet_radius\
    \ - sun_radius;\n    double planet_separation_sq = planet_separation * planet_separation;\n\
    \    double planet_separation_cub = planet_separation_sq * planet_separation_sq;\n\
    \    double planet_separation_cub_sq = planet_separation_cub * planet_separation_cub;\n\
    \    \n    double planet_separation_cub_sq_squared = planet_separation_cub_sq\
    \ * planet_separation_cub_sq;\n    double planet_separation_cub_sq_squared_reciprocal\
    \ = 1 / planet_separation_cub_sq_squared_reciprocal;\n    \n    double planet_separation_cub_sq_squared_reciprocal_2\
    \ = planet_separation_cub_sq_squared_reciprocal * planet_separation_cub_sq_squared_reciprocal;\n\
    \    double planet_separation_cub_sq_squared_reciprocal_3 = planet_separation_cub_sq_squared_reciprocal_2\
    \ * planet_separation_cub_sq_squared_reciprocal;\n    double planet_separation_cub_sq_squared_reciprocal_4\
    \ = planet_separation_cub_sq_squared_reciprocal_3 * planet_separation_cub_sq_squared_reciprocal;\n\
    \    double planet_separation_cub_sq_squared_reciprocal_5 = planet_separation_cub_sq_squared_reciprocal_4\
    \ * planet_separation_cub_sq_squared_reciprocal;\n    double planet_separation_cub_sq_squared_reciprocal_6\
    \ = planet_separation_cub_sq_squared_reciprocal_5 * planet_separation_cub_sq_squared_\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmparm5d8i5.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmparm5d8i5.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmparm5d8i5.cpp:34:108: error: \u2018\
    planet_separation_cub_sq_squared_\u2019 was not declared in this scope; did you\
    \ mean \u2018planet_separation_cub_sq_squared\u2019?\n   34 |     double planet_separation_cub_sq_squared_reciprocal_6\
    \ = planet_separation_cub_sq_squared_reciprocal_5 * planet_separation_cub_sq_squared_\n\
    \      |                                                                     \
    \                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  \
    \    |                                                                       \
    \                                     planet_separation_cub_sq_squared\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmparm5d8i5.cpp:2:\n/tmp/tmparm5d8i5.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmparm5d8i5.cpp:38:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   38 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmparm5d8i5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_distance = std::abs(planet1.length()\
    \ - planet2.length());\n    double sun_radius = 6378.1;\n    double planet_distance\
    \ = std::abs(planet1.length() - planet2.length());\n    double planet_radius =\
    \ 6378.1;\n    double planet_separation = planet_radius - planet_distance;\n \
    \   double planet_separation_angle = planet_separation * M_PI / 180;\n    double\
    \ planet_separation_angle_2 = planet_separation_angle * planet_separation_angle;\n\
    \    double planet_separation_angle_3 = planet_separation_angle_2 * planet_separation_angle_2;\n\
    \    double planet_separation_angle_4 = planet_separation_angle_3 * planet_separation_angle_3;\n\
    \    double planet_separation_angle_5 = planet_separation_angle_4 * planet_separation_angle_4;\n\
    \    double planet_separation_angle_6 = planet_separation_angle_5 * planet_separation_angle_5;\n\
    \    double planet_separation_angle_7 = planet_separation_angle_6 * planet_separation_angle_6;\n\
    \    double planet_separation_angle_8 = planet_separation_angle_7 * planet_separation_angle_7;\n\
    \    double planet_separation_angle_9 = planet_separation_angle_8 * planet_separation_angle_8;\n\
    \    double planet_separation_angle_10 = planet_separation_angle_9 * planet_separation_angle_9;\n\
    \    double planet_separation_angle_11 = planet_separation_angle_10 * planet_separation_angle_10;\n\
    \    double planet_separation_angle_12 = planet_separation_angle_11 * planet_separation_angle_11;\n\
    \    double planet_separation_angle_13 = planet_separation_angle_12 * planet_separation_angle_12;\n\
    \    double planet_separation_angle_14 = planet_separation_angle_13 * planet_separation_angle_13;\n\
    \    double planet_separation_angle_15 = planet_separation_angle_14 * planet_separation_angle_14;\n\
    \    double planet_separation_angle_16 = planet_separation_angle_15 * planet_separation_angle_15;\n\
    \    double planet_separation_angle_17 = planet_separation_angle_16 * planet_separation_angle_16;\n\
    \    double planet_separation_angle_18 = planet_separation_angle_17 * planet_separation_angle_17;\n\
    \    double planet_separation_angle_19 = planet_separation_angle_18 * planet_separation_angle_18;\n\
    \    double planet_separation_angle_20 = planet_separation_angle_19 * planet_separation_angle_19;\n\
    \    \n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjobs96q2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpjobs96q2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpjobs96q2.cpp:17:71: error: call\
    \ of overloaded \u2018abs(std::__cxx11::basic_string<char>::size_type)\u2019 is\
    \ ambiguous\n   17 |     double sun_distance = std::abs(planet1.length() - planet2.length());\n\
    \      |                                                                     \
    \  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpjobs96q2.cpp:2:\n/usr/include/stdlib.h:770:12:\
    \ note: candidate: \u2018int abs(int)\u2019\n  770 | extern int abs (int __x)\
    \ __THROW __attribute__ ((__const__)) __wur;\n      |            ^~~\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:47,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpjobs96q2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:56:3:\
    \ note: candidate: \u2018long int std::abs(long int)\u2019\n   56 |   abs(long\
    \ __i) { return __builtin_labs(__i); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:61:3:\
    \ note: candidate: \u2018long long int std::abs(long long int)\u2019\n   61 |\
    \   abs(long long __x) { return __builtin_llabs (__x); }\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:71:3:\
    \ note: candidate: \u2018constexpr double std::abs(double)\u2019\n   71 |   abs(double\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/std_abs.h:75:3:\
    \ note: candidate: \u2018constexpr float std::abs(float)\u2019\n   75 |   abs(float\
    \ __x)\n      |   ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit_name, planet2_orbit_name;\n\
    \    double planet1_orbit_distance, planet2_orbit_distance;\n    double planet1_orbit_period,\
    \ planet2_orbit_period;\n    double planet1_orbit_inclination, planet2_orbit_inclination;\n\
    \    double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double\
    \ planet1_orbit_semimajor_axis, planet2_orbit_semimajor_axis;\n    double planet1_orbit_inclination_angle,\
    \ planet2_orbit_inclination_angle;\n    double planet1_orbit_longitude, planet2_orbit_longitude;\n\
    \    double planet1_orbit_latitude, planet2_orbit_latitude;\n    double planet1_orbit_altitude,\
    \ planet2_orbit_altitude;\n    double planet1_orbit_longitude_degrees, planet2_orbit_longitude_degrees;\n\
    \    double planet1_orbit_latitude_degrees, planet2_orbit_latitude_degrees;\n\
    \    double planet1_orbit_altitude_meters, planet2_orbit_altitude_meters;\n  \
    \  double planet1_orbit_semimajor_axis_meters, planet2_orbit_semimajor_axis_meters;\n\
    \    double planet1_orbit_inclination_angle_radians, planet2_orbit_inclination_angle_radians;\n\
    \    double planet1_orbit_eccentricity_meters, planet2_orbit_eccentricity_meters;\n\
    \    double planet1_orbit_longitude_degrees_radians, planet2_orbit_longitude_degrees_radians;\n\
    \    double planet1_orbit_latitude_degrees_radians, planet2_orbit_latitude_degrees_radians;\n\
    \    double planet1_orbit_altitude_meters_meters, planet2_orbit_altitude_meters_meters;\n\
    \    double planet1_orbit_semimajor_axis_meters_meters, planet2_orbit_semimajor_axis_meters_meters;\n\
    \    double planet1_orbit_inclination_angle_radians_radians, planet2_orbit_inclination_angle_radians_radians;\n\
    \    double planet1_orbit_eccentricity_meters_meters, planet2_orbit_eccentricity_meters_meters;\n\
    \    double planet1_orbit_longitude_degrees_radians_radians, planet2_orbit_longitude_degrees_radians_radians;\n\
    \    double planet1_orbit_latitude_degree\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpr3iedj9k.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpr3iedj9k.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpr3iedj9k.cpp:41:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   41 | }\n      | ^\n/tmp/tmpr3iedj9k.cpp:41:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpr3iedj9k.cpp:2:\n/tmp/tmpr3iedj9k.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpr3iedj9k.cpp:44:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   44 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpr3iedj9k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5wbtkzg4.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp5wbtkzg4.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp5wbtkzg4.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5wbtkzg4.cpp:2:\n/tmp/tmp5wbtkzg4.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp5wbtkzg4.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp5wbtkzg4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4eiqq3vf.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp4eiqq3vf.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp4eiqq3vf.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4eiqq3vf.cpp:2:\n/tmp/tmp4eiqq3vf.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp4eiqq3vf.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4eiqq3vf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1_name = planet1;\n    std::string\
    \ planet2_name = planet2;\n    \n    // Write your code here\n    \n    return\
    \ std::make_tuple(planet1_name, planet2_name);\n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvp5jsa6r.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpvp5jsa6r.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpvp5jsa6r.cpp:23:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   23 |     return\
    \ std::make_tuple(planet1_name, planet2_name);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvp5jsa6r.cpp:2:\n/tmp/tmpvp5jsa6r.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpvp5jsa6r.cpp:27:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   27 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpvp5jsa6r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operato"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1orb = planet1 + \"Orbit\";\n\
    \    std::string planet2orb = planet2 + \"Orbit\";\n    std::string planet1sun\
    \ = planet1 + \"Sun\";\n    std::string planet2sun = planet2 + \"Sun\";\n    std::string\
    \ planet1orbsun = planet1orb + planet1sun;\n    std::string planet2orbsun = planet2orb\
    \ + planet2sun;\n    std::string planet1orbsunorb = planet1orbsun + planet2orbsun;\n\
    \    std::string planet2orbsunorb = planet2orbsun + planet1orbsun;\n    std::string\
    \ planet1orbsunorbsun = planet1orbsunorb + planet2orbsun;\n    std::string planet2orbsunorbsun\
    \ = planet2orbsunorb + planet1orbsun;\n    std::string planet1orbsunorbsunorb\
    \ = planet1orbsunorbsun + planet2orbsunorb;\n    std::string planet2orbsunorbsunorb\
    \ = planet2orbsunorbsun + planet1orbsunorb;\n    std::string planet1orbsunorbsunorbsun\
    \ = planet1orbsunorbsunorb + planet2orbsunorbsun;\n    std::string planet2orbsunorbsunorbsun\
    \ = planet2orbsunorbsunorb + planet1orbsunorbsun;\n    std::string planet1orbsunorbsunorbsunorb\
    \ = planet1orbsunorbsunorbsun + planet2orbsunorbsunorb;\n    std::string planet2orbsunorbsunorbsunorb\
    \ = planet2orbsunorbsunorbsun + planet1orbsunorbsunorbsun;\n    std::string planet1orbsunorbsunorbsunorbsun\
    \ = planet1orbsunorbsunorbsunorb + planet2orbsunorbsunorbsunorb;\n    std::string\
    \ planet2orbsunorbsunorbsunorbsun = planet2orbsunorbsunorbsunorb\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3zglffeo.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp3zglffeo.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp3zglffeo.cpp:35:1: error: expected\
    \ \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   35 | }\n     \
    \ | ^\n/tmp/tmp3zglffeo.cpp:35:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3zglffeo.cpp:2:\n/tmp/tmp3zglffeo.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp3zglffeo.cpp:38:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   38 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3zglffeo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n         "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_82l4gnz.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_82l4gnz.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_82l4gnz.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_82l4gnz.cpp:2:\n/tmp/tmp_82l4gnz.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_82l4gnz.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_82l4gnz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprgs5ly1c.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmprgs5ly1c.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmprgs5ly1c.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprgs5ly1c.cpp:2:\n/tmp/tmprgs5ly1c.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmprgs5ly1c.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprgs5ly1c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistanceSquared\
    \ = 0.0, planet2OrbitDistanceSquared = 0.0;\n    double planet1OrbitDistanceSquared2\
    \ = 0.0, planet2OrbitDistanceSquared2 = 0.0;\n    double planet1OrbitDistanceSquared3\
    \ = 0.0, planet2OrbitDistanceSquared3 = 0.0;\n    double planet1OrbitDistanceSquared4\
    \ = 0.0, planet2OrbitDistanceSquared4 = 0.0;\n    double planet1OrbitDistanceSquared5\
    \ = 0.0, planet2OrbitDistanceSquared5 = 0.0;\n    double planet1OrbitDistanceSquared6\
    \ = 0.0, planet2OrbitDistanceSquared6 = 0.0;\n    double planet1OrbitDistanceSquared7\
    \ = 0.0, planet2OrbitDistanceSquared7 = 0.0;\n    double planet1OrbitDistanceSquared8\
    \ = 0.0, planet2OrbitDistanceSquared8 = 0.0;\n    double planet1OrbitDistanceSquared9\
    \ = 0.0, planet2OrbitDistanceSquared9 = 0.0;\n    double planet1OrbitDistanceSquared10\
    \ = 0.0, planet2OrbitDistanceSquared10 = 0.0;\n    double planet1OrbitDistanceSquared11\
    \ = 0.0, planet2OrbitDistanceSquared11 = 0.0;\n    double planet1OrbitDistanceSquared12\
    \ = 0.0, planet2OrbitDistanceSquared12 = 0.0;\n    double planet1OrbitDistanceSquared13\
    \ = 0.0, planet2OrbitDistanceSquared13 = 0.0;\n    double planet1OrbitDistanceSquared14\
    \ = 0.0, planet2OrbitDistanceSquared14 = 0.0;\n    double planet1OrbitDistanceSquared15\
    \ = 0.0, planet2OrbitDistanceSquared15 = 0.0;\n    double planet1OrbitDistanceSquared16\
    \ = 0.0, planet2OrbitDistanceSquared16 = 0.0;\n    double planet1OrbitDistanceSquared17\
    \ = 0.0, planet2OrbitDistanceSquared17 = 0.0;\n    double planet1OrbitDistanceSquared18\
    \ = 0.0, planet2OrbitDistanceSquared18 = 0.0;\n    double planet1OrbitDistanceSquared19\
    \ = 0.0, planet2OrbitDistanceSquared19 = 0.0;\n    double planet1OrbitDistanceSquared20\
    \ = 0.0, planet2Orbit\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdm56glmv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpdm56glmv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpdm56glmv.cpp:39:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   39 | }\n      | ^\n/tmp/tmpdm56glmv.cpp:39:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdm56glmv.cpp:2:\n/tmp/tmpdm56glmv.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpdm56glmv.cpp:42:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   42 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdm56glmv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 != planet2);\n    std::tuple<std::string,\
    \ > result;\n    \n    double sun_radius = 6378.137;\n    double planet_radius\
    \ = 6378.137;\n    double planet_separation = planet_radius - sun_radius;\n  \
    \  double planet_separation_sq = planet_separation * planet_separation;\n    double\
    \ planet_separation_cub = planet_separation_sq * planet_separation_sq;\n    double\
    \ planet_separation_cub_sq = planet_separation_cub * planet_separation_cub;\n\
    \    double planet_separation_cub_cub = planet_separation_cub_sq * planet_separation_cub_sq;\n\
    \    double planet_separation_cub_cub_sq = planet_separation_cub_cub * planet_separation_cub_cub;\n\
    \    double planet_separation_cub_cub_cub_sq = planet_separation_cub_cub_cub *\
    \ planet_separation_cub_cub_sq;\n    double planet_separation_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_cub * planet_separation_cub_cub_cub_sq;\n  \
    \  double planet_separation_cub_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub_cub\
    \ * planet_separation_cub_cub_cub_cub_sq;\n    double planet_separation_cub_cub_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_cub_cub_cub * planet_separation_cub_cub_cub_cub_cub_sq;\n\
    \    double planet_separation_cub_cub_cub_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub_cub_cub_cub\
    \ * planet_separation_cub_cub_cub_cub_cub_cub_sq;\n    double planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_sq\
    \ = planet_separation_cub_cub_cub_cub_cub_cub_cub_cub * planet_separation_cub_cub_cub_cub_cub_cub_sq;\n\
    \    double planet_separation_cub_cub_cub_cub_cub_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub_cub_cu\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbt8b1hk1.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbt8b1hk1.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbt8b1hk1.cpp:18:29: error: template\
    \ argument 2 is invalid\n   18 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmpbt8b1hk1.cpp:28:47: error: \u2018planet_separation_cub_cub_cub\u2019\
    \ was not declared in this scope; did you mean \u2018planet_separation_cub_cub_cub_sq\u2019\
    ?\n   28 |     double planet_separation_cub_cub_cub_sq = planet_separation_cub_cub_cub\
    \ * planet_separation_cub_cub_sq;\n      |                                   \
    \            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                          \
    \                     planet_separation_cub_cub_cub_sq\n/tmp/tmpbt8b1hk1.cpp:29:51:\
    \ error: \u2018planet_separation_cub_cub_cub_cub\u2019 was not declared in this\
    \ scope; did you mean \u2018planet_separation_cub_cub_cub_cub_sq\u2019?\n   29\
    \ |     double planet_separation_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub\
    \ * planet_separation_cub_cub_cub_sq;\n      |                               \
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |              \
    \                                     planet_separation_cub_cub_cub_cub_sq\n/tmp/tmpbt8b1hk1.cpp:30:55:\
    \ error: \u2018planet_separation_cub_cub_cub_cub_cub\u2019 was not declared in\
    \ this scope; did you mean \u2018planet_separation_cub_cub_cub_cub_cub_sq\u2019\
    ?\n   30 |     double planet_separation_cub_cub_cub_cub_cub_sq = planet_separation_cub_cub_cub_cub_cub\
    \ * planet_separation_cub_cub_cub_cub_sq;\n      |                           \
    \                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |  \
    \                                                     planet_separation_cub_cub_cub_cub_cub_sq\n\
    /tmp/tmpbt8b1hk1.cpp:31:59: error: \u2018planet_separation_cub_cub_cub_cub_cub_cub\u2019\
    \ was not declared in this scope; did you mean \u2018planet_separation_cub_cub_cub_cub_cub_cub_sq\u2019\
    ?\n   31 |     double planet_separation_cub_cub_cub_cub_cub_cub_s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance;\n    double angle;\n    double\
    \ distance2;\n    double angle2;\n    double distance3;\n    double angle3;\n\
    \    double distance4;\n    double angle4;\n    double distance5;\n    double\
    \ angle5;\n    double distance6;\n    double angle6;\n    double distance7;\n\
    \    double angle7;\n    double distance8;\n    double angle8;\n    double distance9;\n\
    \    double angle9;\n    double distance10;\n    double angle10;\n    double distance11;\n\
    \    double angle11;\n    double distance12;\n    double angle12;\n    double\
    \ distance13;\n    double angle13;\n    double distance14;\n    double angle14;\n\
    \    double distance15;\n    double angle15;\n    double distance16;\n    double\
    \ angle16;\n    double distance17;\n    double angle17;\n    double distance18;\n\
    \    double angle18;\n    double distance19;\n    double angle19;\n    double\
    \ distance20;\n    double angle20;\n    double distance21;\n    double angle21;\n\
    \    double distance22;\n    double angle22;\n    double distance23;\n    double\
    \ angle23;\n    double distance24;\n    double angle24;\n    double distance25;\n\
    \    double angle25;\n    double distance26;\n    double angle26;\n    double\
    \ distance27;\n    double angle27;\n    double distance28;\n    double angle28;\n\
    \    double distance29;\n    double angle29;\n    double distance30;\n    double\
    \ angle30;\n    double distance31;\n    double angle31;\n    double distance32;\n\
    \    double angle32;\n    double distance33;\n    double angle33;\n    double\
    \ distance34;\n    double angle34;\n    double distance35;\n    double angle35;\n\
    \    double distance36;\n    double angle36;\n    double distance37;\n    double\
    \ angle37;\n    double distance38;\n    double angle38;\n    double distance39;\n\
    \    double angle39;\n    double distance40;\n    double angle40;\n    double\
    \ distance41;\n    double angle41;\n    double distance42;\n    double angle42;\n\
    \    double distance43;\n    double angle43;\n    double distance44;\n    double\
    \ angle44;\n    double distance45;\n    double angle45;\n    double distance46;\n\
    \    double angle4\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphuxibe9t.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmphuxibe9t.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmphuxibe9t.cpp:109:1: error: expected\
    \ initializer before \u2018}\u2019 token\n  109 | }\n      | ^\n/tmp/tmphuxibe9t.cpp:109:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphuxibe9t.cpp:2:\n/tmp/tmphuxibe9t.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmphuxibe9t.cpp:112:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  112 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphuxibe9t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8q1pw02n.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8q1pw02n.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8q1pw02n.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8q1pw02n.cpp:2:\n/tmp/tmp8q1pw02n.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8q1pw02n.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8q1pw02n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistance2,\
    \ planet2OrbitDistance2;\n    double planet1OrbitDistance3, planet2OrbitDistance3;\n\
    \    double planet1OrbitDistance4, planet2OrbitDistance4;\n    double planet1OrbitDistance5,\
    \ planet2OrbitDistance5;\n    double planet1OrbitDistance6, planet2OrbitDistance6;\n\
    \    double planet1OrbitDistance7, planet2OrbitDistance7;\n    double planet1OrbitDistance8,\
    \ planet2OrbitDistance8;\n    double planet1OrbitDistance9, planet2OrbitDistance9;\n\
    \    double planet1OrbitDistance10, planet2OrbitDistance10;\n    double planet1OrbitDistance11,\
    \ planet2OrbitDistance11;\n    double planet1OrbitDistance12, planet2OrbitDistance12;\n\
    \    double planet1OrbitDistance13, planet2OrbitDistance13;\n    double planet1OrbitDistance14,\
    \ planet2OrbitDistance14;\n    double planet1OrbitDistance15, planet2OrbitDistance15;\n\
    \    double planet1OrbitDistance16, planet2OrbitDistance16;\n    double planet1OrbitDistance17,\
    \ planet2OrbitDistance17;\n    double planet1OrbitDistance18, planet2OrbitDistance18;\n\
    \    double planet1OrbitDistance19, planet2OrbitDistance19;\n    double planet1OrbitDistance20,\
    \ planet2OrbitDistance20;\n    double planet1OrbitDistance21, planet2OrbitDistance21;\n\
    \    double planet1OrbitDistance22, planet2OrbitDistance22;\n    double planet1OrbitDistance23,\
    \ planet2OrbitDistance23;\n    double planet1OrbitDistance24, planet2OrbitDistance24;\n\
    \    double planet1OrbitDistance25, planet2OrbitDistance25;\n    double planet1OrbitDistance26,\
    \ planet2OrbitDistance26;\n    double planet1OrbitDistance27, planet2OrbitDistance27;\n\
    \    double planet1OrbitDistance28, planet2OrbitDistance28;\n    double planet1OrbitDistance29,\
    \ plan\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzyeql387.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzyeql387.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzyeql387.cpp:47:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   47 | }\n      | ^\n/tmp/tmpzyeql387.cpp:47:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzyeql387.cpp:2:\n/tmp/tmpzyeql387.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzyeql387.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzyeql387.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    std::tuple<std::string,\
    \ > result;\n    if (planet1 == \"Mercury\" && planet2 == \"Venus\") {\n     \
    \   result.emplace(planet1);\n        result.emplace(planet2);\n    } else if\
    \ (planet1 == \"Venus\" && planet2 == \"Mercury\") {\n        result.emplace(planet1);\n\
    \        result.emplace(planet2);\n    } else if (planet1 == \"Earth\" && planet2\
    \ == \"Mercury\") {\n        result.emplace(planet1);\n        result.emplace(planet2);\n\
    \    } else if (planet1 == \"Mars\" && planet2 == \"Mercury\") {\n        result.emplace(planet1);\n\
    \        result.emplace(planet2);\n    } else if (planet1 == \"Jupiter\" && planet2\
    \ == \"Mercury\") {\n        result.emplace(planet1);\n        result.emplace(planet2);\n\
    \    } else if (planet1 == \"Saturn\" && planet2 == \"Mercury\") {\n        result.emplace(planet1);\n\
    \        result.emplace(planet2);\n    } else if (planet1 == \"Uranus\" && planet2\
    \ == \"Mercury\") {\n        result.emplace(planet1);\n        result.emplace(planet2);\n\
    \    } else if (planet1 == \"Neptune\" && planet2 == \"Mercury\") {\n        result.emplace(planet1);\n\
    \        result.emplace(planet2);\n    } else if (planet1 == \"Mercury\" && planet2\
    \ == \"Earth\") {\n        result.emplace(planet1);\n        result.emplace(planet2);\n\
    \    } else if (planet1 == \"Venus\" && planet2 == \"Earth\") {\n        result.emplace(planet1);\n\
    \        result.emplace(planet2);\n    } else if (planet1 == \"Earth\" && planet2\
    \ == \"Earth\") {\n        result.emplace(planet1);\n        result.emplace(planet2);\n\
    \    } else if (planet1 == \"Mars\" && planet2 == \"Earth\") {\n        result.emplace(planet\n\
    }\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"),\
    \ (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0cwwup9t.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp0cwwup9t.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp0cwwup9t.cpp:19:29: error: template\
    \ argument 2 is invalid\n   19 |     std::tuple<std::string, > result;\n     \
    \ |                             ^\n/tmp/tmp0cwwup9t.cpp:21:16: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   21 |         result.emplace(planet1);\n      |    \
    \            ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:22:16: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   22 |         result.emplace(planet2);\n      |                ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:24:16:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   24 |         result.emplace(planet1);\n\
    \      |                ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:25:16: error: request for\
    \ member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type\
    \ \u2018int\u2019\n   25 |         result.emplace(planet2);\n      |         \
    \       ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:27:16: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   27 |         result.emplace(planet1);\n      |                ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:28:16:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   28 |         result.emplace(planet2);\n\
    \      |                ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:30:16: error: request for\
    \ member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type\
    \ \u2018int\u2019\n   30 |         result.emplace(planet1);\n      |         \
    \       ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:31:16: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   31 |         result.emplace(planet2);\n      |                ^~~~~~~\n/tmp/tmp0cwwup9t.cpp:33:16:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   33 |         result.emplace(planet1);\n\
    \      |                ^~~~~~~\n/tmp/tmp0"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprvwwa27h.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmprvwwa27h.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmprvwwa27h.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprvwwa27h.cpp:2:\n/tmp/tmprvwwa27h.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmprvwwa27h.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmprvwwa27h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code goes here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzte029xn.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzte029xn.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzte029xn.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzte029xn.cpp:2:\n/tmp/tmpzte029xn.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzte029xn.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzte029xn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj19so7iw.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpj19so7iw.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpj19so7iw.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj19so7iw.cpp:2:\n/tmp/tmpj19so7iw.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpj19so7iw.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpj19so7iw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double sun_radius = 6378.1;\n    double planet_radius\
    \ = 6378.1;\n    double planet_separation = planet_radius - sun_radius;\n    double\
    \ planet_separation_sq = planet_separation * planet_separation;\n    double planet_separation_sq_inv\
    \ = 1 / planet_separation_sq;\n    double planet_separation_sq_inv_2 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_3 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_4 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_5 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_6 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_7 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_8 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_9 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_10 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_11 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_12 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_13 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_14 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_15 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_16 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_17 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_18 = planet_separation_sq_inv\
    \ * planet_separation_sq_inv;\n    double planet_separation_sq_inv_19\n}\nint\
    \ main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8i3gptl2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp8i3gptl2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp8i3gptl2.cpp:40:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   40 | }\n      | ^\n/tmp/tmp8i3gptl2.cpp:40:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp8i3gptl2.cpp:2:\n/tmp/tmp8i3gptl2.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp8i3gptl2.cpp:43:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   43 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp8i3gptl2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Write your code here\n    \n    return\
    \ std::tuple<std::string, >();\n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5kdrf8i_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp5kdrf8i_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp5kdrf8i_.cpp:20:36: error: template\
    \ argument 2 is invalid\n   20 |     return std::tuple<std::string, >();\n   \
    \   |                                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5kdrf8i_.cpp:2:\n/tmp/tmp5kdrf8i_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp5kdrf8i_.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp5kdrf8i_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbnncmjh9.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbnncmjh9.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbnncmjh9.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbnncmjh9.cpp:2:\n/tmp/tmpbnncmjh9.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbnncmjh9.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbnncmjh9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n}\nint main() {\n    auto candidate = bf;\n  \
    \  assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpu80uzwk_.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpu80uzwk_.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpu80uzwk_.cpp:18:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   18 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu80uzwk_.cpp:2:\n/tmp/tmpu80uzwk_.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpu80uzwk_.cpp:21:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   21 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu80uzwk_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance = 0;\n    double angle = 0;\n  \
    \  double distance2 = 0;\n    double angle2 = 0;\n    double distance3 = 0;\n\
    \    double angle3 = 0;\n    double distance4 = 0;\n    double angle4 = 0;\n \
    \   double distance5 = 0;\n    double angle5 = 0;\n    double distance6 = 0;\n\
    \    double angle6 = 0;\n    double distance7 = 0;\n    double angle7 = 0;\n \
    \   double distance8 = 0;\n    double angle8 = 0;\n    double distance9 = 0;\n\
    \    double angle9 = 0;\n    double distance10 = 0;\n    double angle10 = 0;\n\
    \    double distance11 = 0;\n    double angle11 = 0;\n    double distance12 =\
    \ 0;\n    double angle12 = 0;\n    double distance13 = 0;\n    double angle13\
    \ = 0;\n    double distance14 = 0;\n    double angle14 = 0;\n    double distance15\
    \ = 0;\n    double angle15 = 0;\n    double distance16 = 0;\n    double angle16\
    \ = 0;\n    double distance17 = 0;\n    double angle17 = 0;\n    double distance18\
    \ = 0;\n    double angle18 = 0;\n    double distance19 = 0;\n    double angle19\
    \ = 0;\n    double distance20 = 0;\n    double angle20 = 0;\n    double distance21\
    \ = 0;\n    double angle21 = 0;\n    double distance22 = 0;\n    double angle22\
    \ = 0;\n    double distance23 = 0;\n    double angle23 = 0;\n    double distance24\
    \ = 0;\n    double angle24 = 0;\n    double distance25 = 0;\n    double angle25\
    \ = 0;\n    double distance26 = 0;\n    double angle26 = 0;\n    double distance27\
    \ = 0;\n    double angle27 = 0;\n    double distance28 = 0;\n    double angle28\
    \ = 0;\n    double distance29 = 0;\n    double angle29 = 0;\n    double distance30\
    \ = 0;\n    double angle30 = 0;\n    double distance31 = 0;\n    double angle31\
    \ = 0;\n    double distance32 = 0;\n    double angle32 = 0;\n    double distance33\
    \ = 0;\n    double angle33 = 0;\n    double distance34 = 0;\n    double angle34\
    \ = 0;\n    double distance35 = 0;\n    double angle35 = 0;\n    double distance36\
    \ = 0;\n    double angle36 = 0;\n    double distance37 = 0;\n    double angle37\
    \ = 0;\n    double distance38 = 0;\n    double angle38 = 0;\n    double distance39\
    \ = 0;\n    double angle39 = 0;\n    double distance40 = 0;\n    double angle40\
    \ = 0;\n    double distance41 = 0;\n    double angle41 = 0;\n    double distance42\
    \ = 0;\n    double angle42 = 0;\n    double distance43 = 0;\n    double angle43\
    \ = 0;\n    double distance44 = 0;\n\n}\nint main() {\n    auto candidate = bf;\n\
    \    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\"\
    , \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpzd23hi3c.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpzd23hi3c.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpzd23hi3c.cpp:105:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  105 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzd23hi3c.cpp:2:\n/tmp/tmpzd23hi3c.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpzd23hi3c.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzd23hi3c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    double distance;\n    double distance2;\n    double\
    \ distance3;\n    double distance4;\n    double distance5;\n    double distance6;\n\
    \    double distance7;\n    double distance8;\n    double distance9;\n    double\
    \ distance10;\n    double distance11;\n    double distance12;\n    double distance13;\n\
    \    double distance14;\n    double distance15;\n    double distance16;\n    double\
    \ distance17;\n    double distance18;\n    double distance19;\n    double distance20;\n\
    \    double distance21;\n    double distance22;\n    double distance23;\n    double\
    \ distance24;\n    double distance25;\n    double distance26;\n    double distance27;\n\
    \    double distance28;\n    double distance29;\n    double distance30;\n    double\
    \ distance31;\n    double distance32;\n    double distance33;\n    double distance34;\n\
    \    double distance35;\n    double distance36;\n    double distance37;\n    double\
    \ distance38;\n    double distance39;\n    double distance40;\n    double distance41;\n\
    \    double distance42;\n    double distance43;\n    double distance44;\n    double\
    \ distance45;\n    double distance46;\n    double distance47;\n    double distance48;\n\
    \    double distance49;\n    double distance50;\n    double distance51;\n    double\
    \ distance52;\n    double distance53;\n    double distance54;\n    double distance55;\n\
    \    double distance56;\n    double distance57;\n    double distance58;\n    double\
    \ distance59;\n    double distance60;\n    double distance61;\n    double distance62;\n\
    \    double distance63;\n    double distance64;\n    double distance65;\n    double\
    \ distance66;\n    double distance67;\n    double distance68;\n    double distance69;\n\
    \    double distance70;\n    double distance71;\n    double distance72;\n    double\
    \ distance73;\n    double distance74;\n    double distance75;\n    double distance76;\n\
    \    double distance77;\n    double distance78;\n    double distance79;\n    double\
    \ distance80;\n    double distance81;\n    double distance82;\n    double distance83;\n\
    \    double distance84;\n    double distance85;\n    double distance86;\n    double\
    \ distance87;\n    double distance88;\n    double distance89\n}\nint main() {\n\
    \    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"))\
    \ == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj_dy4dh0.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpj_dy4dh0.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpj_dy4dh0.cpp:106:1: error: expected\
    \ initializer before \u2018}\u2019 token\n  106 | }\n      | ^\n/tmp/tmpj_dy4dh0.cpp:106:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj_dy4dh0.cpp:2:\n/tmp/tmpj_dy4dh0.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpj_dy4dh0.cpp:109:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  109 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpj_dy4dh0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ distance;\n    double distance2;\n    double distance3;\n    double distance4;\n\
    \    double distance5;\n    double distance6;\n    double distance7;\n    double\
    \ distance8;\n    double distance9;\n    double distance10;\n    double distance11;\n\
    \    double distance12;\n    double distance13;\n    double distance14;\n    double\
    \ distance15;\n    double distance16;\n    double distance17;\n    double distance18;\n\
    \    double distance19;\n    double distance20;\n    double distance21;\n    double\
    \ distance22;\n    double distance23;\n    double distance24;\n    double distance25;\n\
    \    double distance26;\n    double distance27;\n    double distance28;\n    double\
    \ distance29;\n    double distance30;\n    double distance31;\n    double distance32;\n\
    \    double distance33;\n    double distance34;\n    double distance35;\n    double\
    \ distance36;\n    double distance37;\n    double distance38;\n    double distance39;\n\
    \    double distance40;\n    double distance41;\n    double distance42;\n    double\
    \ distance43;\n    double distance44;\n    double distance45;\n    double distance46;\n\
    \    double distance47;\n    double distance48;\n    double distance49;\n    double\
    \ distance50;\n    double distance51;\n    double distance52;\n    double distance53;\n\
    \    double distance54;\n    double distance55;\n    double distance56;\n    double\
    \ distance57;\n    double distance58;\n    double distance59;\n    double distance60;\n\
    \    double distance61;\n    double distance62;\n    double distance63;\n    double\
    \ distance64;\n    double distance65;\n    double distance66;\n    double distance67;\n\
    \    double distance68;\n    double distance69;\n    double distance70;\n    double\
    \ distance71;\n    double distance72;\n    double distance73;\n    double distance74;\n\
    \    double distance75;\n    double distance76;\n    double distance77;\n    double\
    \ distance78;\n    double distance79;\n    double distance80;\n    double distance81;\n\
    \    double distance82;\n    double distance83;\n    double distance84;\n    double\
    \ distance85;\n    double distance86;\n    \n}\nint main() {\n    auto candidate\
    \ = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) == std::make_tuple(\"\
    Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Mercury\")) == std::make_tuple(\"\
    Venus\"));\n    assert(candidate((\"Mercury\"), (\"Uranus\")) == std::make_tuple(\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"));\n    assert(candidate((\"\
    Neptune\"), (\"Venus\")) == std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"), (\"Earth\")) ==\
    \ (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"Mars\"\
    ), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n    assert(candidate((\"\
    Jupiter\"), (\"Makemake\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpwtdubfv2.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpwtdubfv2.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpwtdubfv2.cpp:105:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  105 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwtdubfv2.cpp:2:\n/tmp/tmpwtdubfv2.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpwtdubfv2.cpp:108:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  108 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpwtdubfv2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    assert(planet1 == \"Mercury\" || planet1 == \"Venus\"\
    \ || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" ||\
    \ planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\");\n\
    \    assert(planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\");\n    std::tuple<std::string,\
    \ > result;\n    if (planet1 == planet2) {\n        return result;\n    }\n  \
    \  if (planet1 == \"Mercury\") {\n        if (planet2 == \"Venus\") {\n      \
    \      result.emplace(planet2);\n        }\n        if (planet2 == \"Earth\")\
    \ {\n            result.emplace(planet2);\n        }\n        if (planet2 == \"\
    Mars\") {\n            result.emplace(planet2);\n        }\n        if (planet2\
    \ == \"Jupiter\") {\n            result.emplace(planet2);\n        }\n       \
    \ if (planet2 == \"Saturn\") {\n            result.emplace(planet2);\n       \
    \ }\n        if (planet2 == \"Uranus\") {\n            result.emplace(planet2);\n\
    \        }\n        if (planet2 == \"Neptune\") {\n            result.emplace(planet2);\n\
    \        }\n    }\n    if (planet1 == \"Venus\") {\n        if (planet2 == \"\
    Mercury\") {\n            result.emplace(planet2);\n        }\n        if (planet2\
    \ == \"Earth\") {\n            result.emplace(planet2);\n        }\n        if\
    \ (planet2 == \"Mars\") {\n            result.emplace(planet2);\n        }\n \
    \       if (planet2 == \"Jupiter\") {\n            result.emplace(planet2);\n\
    \        }\n        if (planet2 == \"Saturn\") {\n            result.emplace(planet2);\n\
    \        }\n        if (planet2 == \"Uranus\") {\n            result.emplace(planet2);\n\
    \        }\n        if (planet2 == \"Neptune\") {\n            result.emplace(planet2);\n\
    \        }\n    }\n    if (planet1 == \"Earth\") {\n        if (planet2 == \"\
    Mercury\") {\n            result.emplace(planet2);\n        }\n        if (planet2\
    \ == \"Venus\") {\n            result.emplace(planet2);\n        }\n        if\
    \ (planet2 == \"Mars\") {\n            result.emplace(planet2);\n        }\n \
    \       if (planet2 == \"J\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8f3fhe2r.cpp:79:24: warning: missing terminating \" character\n\
    \   79 |         if (planet2 == \"J\n      |                        ^\n/tmp/tmp8f3fhe2r.cpp:79:24:\
    \ error: missing terminating \" character\n   79 |         if (planet2 == \"J\n\
    \      |                        ^~\n/tmp/tmp8f3fhe2r.cpp:16:25: error: template\
    \ argument 2 is invalid\n   16 | std::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n      |                         ^\n/tmp/tmp8f3fhe2r.cpp:\
    \ In function \u2018int bf(std::string, std::string)\u2019:\n/tmp/tmp8f3fhe2r.cpp:19:29:\
    \ error: template argument 2 is invalid\n   19 |     std::tuple<std::string, >\
    \ result;\n      |                             ^\n/tmp/tmp8f3fhe2r.cpp:25:20:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   25 |             result.emplace(planet2);\n\
    \      |                    ^~~~~~~\n/tmp/tmp8f3fhe2r.cpp:28:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   28 |             result.emplace(planet2);\n      |\
    \                    ^~~~~~~\n/tmp/tmp8f3fhe2r.cpp:31:20: error: request for member\
    \ \u2018emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    int\u2019\n   31 |             result.emplace(planet2);\n      |             \
    \       ^~~~~~~\n/tmp/tmp8f3fhe2r.cpp:34:20: error: request for member \u2018\
    emplace\u2019 in \u2018result\u2019, which is of non-class type \u2018int\u2019\
    \n   34 |             result.emplace(planet2);\n      |                    ^~~~~~~\n\
    /tmp/tmp8f3fhe2r.cpp:37:20: error: request for member \u2018emplace\u2019 in \u2018\
    result\u2019, which is of non-class type \u2018int\u2019\n   37 |            \
    \ result.emplace(planet2);\n      |                    ^~~~~~~\n/tmp/tmp8f3fhe2r.cpp:40:20:\
    \ error: request for member \u2018emplace\u2019 in \u2018result\u2019, which is\
    \ of non-class type \u2018int\u2019\n   40 |             result.emplace(planet2);\n\
    \      |                    ^~~~~~~\n/tmp/tmp8f3fhe2r.cpp:43:20: error: request\
    \ for member \u2018emplace\u2019 in \u2018result\u2019, which is of non-class\
    \ type \u2018int\u2019\n   43 |             result.emplace(planet2);\n      |\
    \                    ^~~~~~~\n/tmp/tmp8f3fhe2r.cpp:48:20: error: request for"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1_orbit, planet2_orbit;\n    double\
    \ planet1_distance, planet2_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_distance, planet2_orbital_distance;\n\
    \    double planet1_orbital_distance, planet2_orbital_distance;\n    double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n    double planet1_orbital_\n}\nint main() {\n  \
    \  auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\")) ==\
    \ std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"),\
    \ (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoxw7dtk8.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpoxw7dtk8.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpoxw7dtk8.cpp:20:12: error: redeclaration\
    \ of \u2018double planet1_orbital_distance\u2019\n   20 |     double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoxw7dtk8.cpp:19:12:\
    \ note: \u2018double planet1_orbital_distance\u2019 previously declared here\n\
    \   19 |     double planet1_orbital_distance, planet2_orbital_distance;\n    \
    \  |            ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoxw7dtk8.cpp:20:38: error: redeclaration\
    \ of \u2018double planet2_orbital_distance\u2019\n   20 |     double planet1_orbital_distance,\
    \ planet2_orbital_distance;\n      |                                      ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpoxw7dtk8.cpp:19:38: note: \u2018double planet2_orbital_distance\u2019\
    \ previously declared here\n   19 |     double planet1_orbital_distance, planet2_orbital_distance;\n\
    \      |                                      ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoxw7dtk8.cpp:21:12:\
    \ error: redeclaration of \u2018double planet1_orbital_distance\u2019\n   21 |\
    \     double planet1_orbital_distance, planet2_orbital_distance;\n      |    \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoxw7dtk8.cpp:19:12: note: \u2018double\
    \ planet1_orbital_distance\u2019 previously declared here\n   19 |     double\
    \ planet1_orbital_distance, planet2_orbital_distance;\n      |            ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpoxw7dtk8.cpp:21:38: error: redeclaration of \u2018double planet2_orbital_distance\u2019\
    \n   21 |     double planet1_orbital_distance, planet2_orbital_distance;\n   \
    \   |                                      ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoxw7dtk8.cpp:19:38:\
    \ note: \u2018double planet2_orbital_distance\u2019 previously declared here\n\
    \   19 |     double planet1_orbital_distance, planet2_orbital_distance;\n    \
    \  |                                      ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpoxw7dtk8.cpp:22:12:\
    \ error: redeclaration of \u2018doub"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    // Your code here\n    \n    return std::make_tuple(planet1,\
    \ planet2);\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"\
    Jupiter\"), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmposw9xs5c.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmposw9xs5c.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmposw9xs5c.cpp:20:27: error: cannot\
    \ convert \u2018std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >\u2019 to \u2018int\u2019 in return\n   20 |     return\
    \ std::make_tuple(planet1, planet2);\n      |            ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n\
    \      |                           |\n      |                           std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmposw9xs5c.cpp:2:\n/tmp/tmposw9xs5c.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmposw9xs5c.cpp:24:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   24 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmposw9xs5c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    std::string planet1_orbit_name, planet2_orbit_name;\n\
    \    double planet1_orbit_distance, planet2_orbit_distance;\n    double planet1_orbit_period,\
    \ planet2_orbit_period;\n    double planet1_orbit_inclination, planet2_orbit_inclination;\n\
    \    double planet1_orbit_eccentricity, planet2_orbit_eccentricity;\n    double\
    \ planet1_orbit_semimajor_axis, planet2_orbit_semimajor_axis;\n    double planet1_orbit_inclination_angle,\
    \ planet2_orbit_inclination_angle;\n    double planet1_orbit_longitude, planet2_orbit_longitude;\n\
    \    double planet1_orbit_latitude, planet2_orbit_latitude;\n    double planet1_orbit_inclination_angle_radians,\
    \ planet2_orbit_inclination_angle_radians;\n    double planet1_orbit_eccentricity_radians,\
    \ planet2_orbit_eccentricity_radians;\n    double planet1_orbit_semimajor_axis_radians,\
    \ planet2_orbit_semimajor_axis_radians;\n    double planet1_orbit_longitude_degrees,\
    \ planet2_orbit_longitude_degrees;\n    double planet1_orbit_latitude_degrees,\
    \ planet2_orbit_latitude_degrees;\n    double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n    double planet1_orbit_latitude_degrees_radians,\
    \ planet2_orbit_latitude_degrees_radians;\n    double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n    double planet1_orbit_latitude_degrees_radians,\
    \ planet2_orbit_latitude_degrees_radians;\n    double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n    double planet1_orbit_latitude_degrees_radians,\
    \ planet2_orbit_latitude_degrees_radians;\n    double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n    double planet1_orbit_latitude_degrees_radians,\
    \ planet2_orbit_latitude_degrees_radians;\n    double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n    double planet1_orbit_latitude_degrees_radians,\
    \ planet2_orbit_latitude_degrees_radians;\n    double planet1_or\n}\nint main()\
    \ {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"), (\"Neptune\"\
    )) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"Earth\"\
    ), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"Mercury\"\
    ), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) == std::make_tuple(\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n  \
    \  assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp16f_rg93.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp16f_rg93.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp16f_rg93.cpp:34:12: error: redeclaration\
    \ of \u2018double planet1_orbit_longitude_degrees_radians\u2019\n   34 |     double\
    \ planet1_orbit_longitude_degrees_radians, planet2_orbit_longitude_degrees_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp16f_rg93.cpp:32:12:\
    \ note: \u2018double planet1_orbit_longitude_degrees_radians\u2019 previously\
    \ declared here\n   32 |     double planet1_orbit_longitude_degrees_radians, planet2_orbit_longitude_degrees_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp16f_rg93.cpp:34:53:\
    \ error: redeclaration of \u2018double planet2_orbit_longitude_degrees_radians\u2019\
    \n   34 |     double planet1_orbit_longitude_degrees_radians, planet2_orbit_longitude_degrees_radians;\n\
    \      |                                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp16f_rg93.cpp:32:53: note: \u2018double planet2_orbit_longitude_degrees_radians\u2019\
    \ previously declared here\n   32 |     double planet1_orbit_longitude_degrees_radians,\
    \ planet2_orbit_longitude_degrees_radians;\n      |                          \
    \                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp16f_rg93.cpp:35:12:\
    \ error: redeclaration of \u2018double planet1_orbit_latitude_degrees_radians\u2019\
    \n   35 |     double planet1_orbit_latitude_degrees_radians, planet2_orbit_latitude_degrees_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp16f_rg93.cpp:33:12:\
    \ note: \u2018double planet1_orbit_latitude_degrees_radians\u2019 previously declared\
    \ here\n   33 |     double planet1_orbit_latitude_degrees_radians, planet2_orbit_latitude_degrees_radians;\n\
    \      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp16f_rg93.cpp:35:52:\
    \ error: redeclaration of \u2018double planet2_orbit_latitude_degrees_radians\u2019\
    \n   35 |     double planet1_orbit_lat"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_rvouasv.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmp_rvouasv.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmp_rvouasv.cpp:274:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n  274 | }\n\
    \      | ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_rvouasv.cpp:2:\n/tmp/tmp_rvouasv.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmp_rvouasv.cpp:277:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n  277 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_rvouasv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n          \
    \       from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// There are eight planets\
    \ in our solar system: the closerst to the Sun \n// is Mercury, the next one is\
    \ Venus, then Earth, Mars, Jupiter, Saturn, \n// Uranus, Neptune.\n// Write a\
    \ function that takes two planet names as strings planet1 and planet2. \n// The\
    \ function should return a tuple containing all planets whose orbits are \n//\
    \ located between the orbit of planet1 and the orbit of planet2, sorted by \n\
    // the proximity to the sun. \n// The function should return an empty tuple if\
    \ planet1 or planet2\n// are not correct planet names. \n// Examples\n// bf(\"\
    Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n// bf(\"Earth\", \"Mercury\"\
    ) ==> (\"Venus\")\n// bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"\
    Mars\", \"Jupiter\", \"Saturn\")\nstd::tuple<std::string, > bf(std::string planet1,\
    \ std::string planet2) {\n    std::string planet1Orbit, planet2Orbit;\n    double\
    \ planet1OrbitDistance, planet2OrbitDistance;\n    double planet1OrbitDistance2,\
    \ planet2OrbitDistance2;\n    double planet1OrbitDistance3, planet2OrbitDistance3;\n\
    \    double planet1OrbitDistance4, planet2OrbitDistance4;\n    double planet1OrbitDistance5,\
    \ planet2OrbitDistance5;\n    double planet1OrbitDistance6, planet2OrbitDistance6;\n\
    \    double planet1OrbitDistance7, planet2OrbitDistance7;\n    double planet1OrbitDistance8,\
    \ planet2OrbitDistance8;\n    double planet1OrbitDistance9, planet2OrbitDistance9;\n\
    \    double planet1OrbitDistance10, planet2OrbitDistance10;\n    double planet1OrbitDistance11,\
    \ planet2OrbitDistance11;\n    double planet1OrbitDistance12, planet2OrbitDistance12;\n\
    \    double planet1OrbitDistance13, planet2OrbitDistance13;\n    double planet1OrbitDistance14,\
    \ planet2OrbitDistance14;\n    double planet1OrbitDistance15, planet2OrbitDistance15;\n\
    \    double planet1OrbitDistance16, planet2OrbitDistance16;\n    double planet1OrbitDistance17,\
    \ planet2OrbitDistance17;\n    double planet1OrbitDistance18, planet2OrbitDistance18;\n\
    \    double planet1OrbitDistance19, planet2OrbitDistance19;\n    double planet1OrbitDistance20,\
    \ planet2OrbitDistance20;\n    double planet1OrbitDistance21, planet2OrbitDistance21;\n\
    \    double planet1OrbitDistance22, planet2OrbitDistance22;\n    double planet1OrbitDistance23,\
    \ planet2OrbitDistance23;\n    double planet1OrbitDistance24, planet2OrbitDistance24;\n\
    \    double planet1OrbitDistance25, planet2OrbitDistance25;\n    double planet1OrbitDistance26,\
    \ planet2OrbitDistance26;\n    double planet1OrbitDistance27, planet2OrbitDistance27;\n\
    \    double planet1OrbitDistance28, planet2OrbitDistance28;\n    double planet1OrbitDistance29,\
    \ plan\n}\nint main() {\n    auto candidate = bf;\n    assert(candidate((\"Jupiter\"\
    ), (\"Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n    assert(candidate((\"\
    Earth\"), (\"Mercury\")) == std::make_tuple(\"Venus\"));\n    assert(candidate((\"\
    Mercury\"), (\"Uranus\")) == std::make_tuple(\"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\"));\n    assert(candidate((\"Neptune\"), (\"Venus\")) ==\
    \ std::make_tuple(\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"));\n\
    \    assert(candidate((\"Earth\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Mars\"), (\"Earth\")) == (std::tuple<std::string, >(std::tuple<long>)));\n\
    \    assert(candidate((\"Jupiter\"), (\"Makemake\")) == (std::tuple<std::string,\
    \ >(std::tuple<long>)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbabo6wfg.cpp:16:25: error: template argument 2 is invalid\n   16\
    \ | std::tuple<std::string, > bf(std::string planet1, std::string planet2) {\n\
    \      |                         ^\n/tmp/tmpbabo6wfg.cpp: In function \u2018int\
    \ bf(std::string, std::string)\u2019:\n/tmp/tmpbabo6wfg.cpp:47:1: error: expected\
    \ initializer before \u2018}\u2019 token\n   47 | }\n      | ^\n/tmp/tmpbabo6wfg.cpp:47:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbabo6wfg.cpp:2:\n/tmp/tmpbabo6wfg.cpp: In function\
    \ \u2018int main()\u2019:\n/tmp/tmpbabo6wfg.cpp:50:48: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018int\u2019 and \u2018std::tuple<const\
    \ char*, const char*>\u2019)\n   50 |     assert(candidate((\"Jupiter\"), (\"\
    Neptune\")) == std::make_tuple(\"Saturn\", \"Uranus\"));\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^~ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                     |      \
    \                                      |\n      |                     int    \
    \                                      std::tuple<const char*, const char*>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpbabo6wfg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n        "
  exit_code: 1
  status: SyntaxError
