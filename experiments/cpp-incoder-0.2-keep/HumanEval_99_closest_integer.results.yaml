name: HumanEval_99_closest_integer
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long diff\
    \ = n - ans;\n    while (diff > 1) {\n        diff /= 10;\n        ans++;\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn_i8nwb4.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpn_i8nwb4.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmpn_i8nwb4.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ count = 0;\n    long sum = 0;\n    long i = 0;\n    long j = 0;\n    long k\
    \ = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n \
    \   long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t\
    \ = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n \
    \   long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C\
    \ = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n \
    \   long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L\
    \ = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n \
    \   long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U\
    \ = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n \
    \   long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d\
    \ = 0;\n    long e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n \
    \   long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m\
    \ = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n \
    \   long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v\
    \ = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n \
    \   long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E\
    \ = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n \
    \   long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N\
    \ = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n \
    \   long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W\
    \ = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n \
    \   long b = 0;\n    long c = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8tfq8o1l.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp8tfq8o1l.cpp:74:10: error: redeclaration of \u2018long int i\u2019\n\
    \   74 |     long i = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:22:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   22 |     long i = 0;\n \
    \     |          ^\n/tmp/tmp8tfq8o1l.cpp:75:10: error: redeclaration of \u2018\
    long int j\u2019\n   75 |     long j = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:23:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   23 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:76:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   76 |     long k = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:24:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   24 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:77:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   77 |     long l = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:25:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   25 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:78:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   78 |     long m = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:26:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   26 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:79:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   79 |     long n = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:27:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   27 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:80:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   80 |     long o = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:28:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   28 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:81:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   81 |     long p = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:29:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   29 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:82:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   82 |     long q = 0;\n      |          ^\n/tmp/tmp8tfq8o1l.cpp:30:10:\
    \ note: \u2018long int q\u2019 previously declared here\n   30 |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int v = std::\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpagy3p7kg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpagy3p7kg.cpp:24:19: error: redeclaration of \u2018long long int w\u2019\
    \n   24 |     long long int w = std::stoll(value);\n      |                  \
    \ ^\n/tmp/tmpagy3p7kg.cpp:20:19: note: \u2018long long int w\u2019 previously\
    \ declared here\n   20 |     long long int w = std::stoll(value);\n      |   \
    \                ^\n/tmp/tmpagy3p7kg.cpp:25:19: error: redeclaration of \u2018\
    long long int x\u2019\n   25 |     long long int x = std::stoll(value);\n    \
    \  |                   ^\n/tmp/tmpagy3p7kg.cpp:17:19: note: \u2018long long int\
    \ x\u2019 previously declared here\n   17 |     long long int x = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:26:19: error: redeclaration\
    \ of \u2018long long int y\u2019\n   26 |     long long int y = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:18:19: note: \u2018long long\
    \ int y\u2019 previously declared here\n   18 |     long long int y = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:27:19: error: redeclaration\
    \ of \u2018long long int z\u2019\n   27 |     long long int z = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:19:19: note: \u2018long long\
    \ int z\u2019 previously declared here\n   19 |     long long int z = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:28:19: error: redeclaration\
    \ of \u2018long long int w\u2019\n   28 |     long long int w = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:20:19: note: \u2018long long\
    \ int w\u2019 previously declared here\n   20 |     long long int w = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:29:19: error: redeclaration\
    \ of \u2018long long int t\u2019\n   29 |     long long int t = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:21:19: note: \u2018long long\
    \ int t\u2019 previously declared here\n   21 |     long long int t = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp:30:19: error: redeclaration\
    \ of \u2018long long int u\u2019\n   30 |     long long int u = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmpagy3p7kg.cpp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ int temp = 0;\n    long long int temp2 = 0;\n    long long int temp3 = 0;\n\
    \    long long int temp4 = 0;\n    long long int temp5 = 0;\n    long long int\
    \ temp6 = 0;\n    long long int temp7 = 0;\n    long long int temp8 = 0;\n   \
    \ long long int temp9 = 0;\n    long long int temp10 = 0;\n    long long int temp11\
    \ = 0;\n    long long int temp12 = 0;\n    long long int temp13 = 0;\n    long\
    \ long int temp14 = 0;\n    long long int temp15 = 0;\n    long long int temp16\
    \ = 0;\n    long long int temp17 = 0;\n    long long int temp18 = 0;\n    long\
    \ long int temp19 = 0;\n    long long int temp20 = 0;\n    long long int temp21\
    \ = 0;\n    long long int temp22 = 0;\n    long long int temp23 = 0;\n    long\
    \ long int temp24 = 0;\n    long long int temp25 = 0;\n    long long int temp26\
    \ = 0;\n    long long int temp27 = 0;\n    long long int temp28 = 0;\n    long\
    \ long int temp29 = 0;\n    long long int temp30 = 0;\n    long long int temp31\
    \ = 0;\n    long long int temp32 = 0;\n    long long int temp33 = 0;\n    long\
    \ long int temp34 = 0;\n    long long int temp35 = 0;\n    long long int temp36\
    \ = 0;\n    long long int temp37 = 0;\n    long long int temp38 = 0;\n    long\
    \ long int temp39 = 0;\n    long long int temp40 = 0;\n    long long int temp41\
    \ = 0;\n    long long int temp42 = 0;\n    long long int temp43 = 0;\n    long\
    \ long int temp44 = 0;\n    long long int temp45 = 0;\n    long long int temp46\
    \ = 0;\n    long long int temp47 = 0;\n    long long int temp48 = 0;\n    long\
    \ long int temp49 = 0;\n    long long int temp50 = 0;\n    long long int temp51\
    \ = 0;\n    long long int temp52 = 0;\n    long long int temp53 = 0;\n    long\
    \ long int temp54 = 0;\n    long long int temp55 = 0;\n    long long int temp56\
    \ = 0;\n    long long int temp57 = 0;\n    long long int temp58 = 0;\n    long\
    \ long int temp59 = 0;\n    long long int temp60 = 0;\n    long long int temp61\
    \ = 0;\n    long long int temp62 = 0;\n    long long int temp63 = 0;\n\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmphniwqdj9: /tmp/tmphniwqdj9.cpp:86: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int lower = 0, upper = std::numeric_limits<long long\
    \ int>::max();\n    long long int mid = 0;\n    long long int closest = 0;\n \
    \   long long int diff = 0;\n    long long int diff2 = 0;\n    long long int diff3\
    \ = 0;\n    long long int diff4 = 0;\n    long long int diff5 = 0;\n    long long\
    \ int diff6 = 0;\n    long long int diff7 = 0;\n    long long int diff8 = 0;\n\
    \    long long int diff9 = 0;\n    long long int diff10 = 0;\n    long long int\
    \ diff11 = 0;\n    long long int diff12 = 0;\n    long long int diff13 = 0;\n\
    \    long long int diff14 = 0;\n    long long int diff15 = 0;\n    long long int\
    \ diff16 = 0;\n    long long int diff17 = 0;\n    long long int diff18 = 0;\n\
    \    long long int diff19 = 0;\n    long long int diff20 = 0;\n    long long int\
    \ diff21 = 0;\n    long long int diff22 = 0;\n    long long int diff23 = 0;\n\
    \    long long int diff24 = 0;\n    long long int diff25 = 0;\n    long long int\
    \ diff26 = 0;\n    long long int diff27 = 0;\n    long long int diff28 = 0;\n\
    \    long long int diff29 = 0;\n    long long int diff30 = 0;\n    long long int\
    \ diff31 = 0;\n    long long int diff32 = 0;\n    long long int diff33 = 0;\n\
    \    long long int diff34 = 0;\n    long long int diff35 = 0;\n    long long int\
    \ diff36 = 0;\n    long long int diff37 = 0;\n    long long int diff38 = 0;\n\
    \    long long int diff39 = 0;\n    long long int diff40 = 0;\n    long long int\
    \ diff41 = 0;\n    long long int diff42 = 0;\n    long long int diff43 = 0;\n\
    \    long long int diff44 = 0;\n    long long int diff45 = 0;\n    long long int\
    \ diff46 = 0;\n    long long int diff47 = 0;\n    long long int diff48 = 0;\n\
    \    long long int diff49 = 0;\n    long long int diff50 = 0;\n    long long int\
    \ diff51 = 0;\n    long long int diff52 = 0;\n    long long int diff53 = 0;\n\
    \    long long int diff54 = 0;\n    long long int diff55 = 0;\n    long long int\
    \ diff56 = 0;\n    long long int diff57 = 0;\n    long long int diff58 = 0;\n\
    \    long long int diff59 = 0;\n    long long int diff60 = 0;\n    long long \n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp53j0rffc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp53j0rffc.cpp:81:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   81 | }\n      | ^\n/tmp/tmp53j0rffc.cpp:81:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int n = 0;\n    long long int m = 0;\n    long long\
    \ int minDiff = std::numeric_limits<long long int>::max();\n    long long int\
    \ maxDiff = std::numeric_limits<long long int>::min();\n    long long int diff\
    \ = 0;\n    long long int diff2 = 0;\n    long long int diff3 = 0;\n    long long\
    \ int diff4 = 0;\n    long long int diff5 = 0;\n    long long int diff6 = 0;\n\
    \    long long int diff7 = 0;\n    long long int diff8 = 0;\n    long long int\
    \ diff9 = 0;\n    long long int diff10 = 0;\n    long long int diff11 = 0;\n \
    \   long long int diff12 = 0;\n    long long int diff13 = 0;\n    long long int\
    \ diff14 = 0;\n    long long int diff15 = 0;\n    long long int diff16 = 0;\n\
    \    long long int diff17 = 0;\n    long long int diff18 = 0;\n    long long int\
    \ diff19 = 0;\n    long long int diff20 = 0;\n    long long int diff21 = 0;\n\
    \    long long int diff22 = 0;\n    long long int diff23 = 0;\n    long long int\
    \ diff24 = 0;\n    long long int diff25 = 0;\n    long long int diff26 = 0;\n\
    \    long long int diff27 = 0;\n    long long int diff28 = 0;\n    long long int\
    \ diff29 = 0;\n    long long int diff30 = 0;\n    long long int diff31 = 0;\n\
    \    long long int diff32 = 0;\n    long long int diff33 = 0;\n    long long int\
    \ diff34 = 0;\n    long long int diff35 = 0;\n    long long int diff36 = 0;\n\
    \    long long int diff37 = 0;\n    long long int diff38 = 0;\n    long long int\
    \ diff39 = 0;\n    long long int diff40 = 0;\n    long long int diff41 = 0;\n\
    \    long long int diff42 = 0;\n    long long int diff43 = 0;\n    long long int\
    \ diff44 = 0;\n    long long int diff45 = 0;\n    long long int diff46 = 0;\n\
    \    long long int diff47 = 0;\n    long long int diff48 = 0;\n    long long int\
    \ diff49 = 0;\n    long long int diff50 = 0;\n    long long int diff51 = 0;\n\
    \    long long int diff52 = 0;\n    long long int diff53 = 0;\n    long long int\
    \ diff54 = 0;\n    long long int diff55 = 0;\n    long long int diff56 = 0;\n\
    \    long long int diff57 = 0;\n    long long int diff58 = 0;\n    long long \n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppeu6wizt.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppeu6wizt.cpp:80:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmppeu6wizt.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long mod = num % 10;\n    long diff = num - mod;\n    long num2 = std::stoll(value);\n\
    \    long mod2 = num2 % 10;\n    long diff2 = num2 - mod2;\n    if (diff == diff2)\
    \ {\n        ans = num;\n    } else {\n        ans = num2;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc91ygaj1.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpc91ygaj1.cpp:20:10: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |     long diff = num - mod;\n      |          ^~~~\n/tmp/tmpc91ygaj1.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgd0fnh8h.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpgd0fnh8h.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmpgd0fnh8h.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    long diff = upper\
    \ - lower;\n    if (diff > 0)\n        return lower;\n    else if (diff < 0)\n\
    \        return upper;\n    else\n        return std::stoll(value);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp_2c_vlmy: /tmp/tmp_2c_vlmy.cpp:28: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long limit =\
    \ atoi(value.c_str());\n    long limit = abs(limit);\n    long limit = limit +\
    \ 1;\n    long limit = limit * limit;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n   \
    \ long limit = limit / 2;\n    long limit = limit / 2;\n    long limit = limit\
    \ / 2;\n    long limit = limit / 2;\n    long limit = limit / 2;\n    long limit\
    \ = limit / 2;\n    long limit = limit / \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkzwwn1kn.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpkzwwn1kn.cpp:20:10: error: redeclaration of \u2018long int limit\u2019\
    \n   20 |     long limit = abs(limit);\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:19:10:\
    \ note: \u2018long int limit\u2019 previously declared here\n   19 |     long\
    \ limit = atoi(value.c_str());\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:21:10:\
    \ error: redeclaration of \u2018long int limit\u2019\n   21 |     long limit =\
    \ limit + 1;\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:19:10: note: \u2018\
    long int limit\u2019 previously declared here\n   19 |     long limit = atoi(value.c_str());\n\
    \      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:22:10: error: redeclaration of \u2018\
    long int limit\u2019\n   22 |     long limit = limit * limit;\n      |       \
    \   ^~~~~\n/tmp/tmpkzwwn1kn.cpp:19:10: note: \u2018long int limit\u2019 previously\
    \ declared here\n   19 |     long limit = atoi(value.c_str());\n      |      \
    \    ^~~~~\n/tmp/tmpkzwwn1kn.cpp:23:10: error: redeclaration of \u2018long int\
    \ limit\u2019\n   23 |     long limit = limit / 2;\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:19:10:\
    \ note: \u2018long int limit\u2019 previously declared here\n   19 |     long\
    \ limit = atoi(value.c_str());\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:24:10:\
    \ error: redeclaration of \u2018long int limit\u2019\n   24 |     long limit =\
    \ limit / 2;\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:19:10: note: \u2018\
    long int limit\u2019 previously declared here\n   19 |     long limit = atoi(value.c_str());\n\
    \      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:25:10: error: redeclaration of \u2018\
    long int limit\u2019\n   25 |     long limit = limit / 2;\n      |          ^~~~~\n\
    /tmp/tmpkzwwn1kn.cpp:19:10: note: \u2018long int limit\u2019 previously declared\
    \ here\n   19 |     long limit = atoi(value.c_str());\n      |          ^~~~~\n\
    /tmp/tmpkzwwn1kn.cpp:26:10: error: redeclaration of \u2018long int limit\u2019\
    \n   26 |     long limit = limit / 2;\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:19:10:\
    \ note: \u2018long int limit\u2019 previously declared here\n   19 |     long\
    \ limit = atoi(value.c_str());\n      |          ^~~~~\n/tmp/tmpkzwwn1kn.cpp:27:10:\
    \ error: redeclaration of \u2018long"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long long temp2\
    \ = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long temp5\
    \ = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long temp8\
    \ = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long temp11\
    \ = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long long temp14\
    \ = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n    long long temp17\
    \ = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n    long long temp20\
    \ = 0;\n    long long temp21 = 0;\n    long long temp22 = 0;\n    long long temp23\
    \ = 0;\n    long long temp24 = 0;\n    long long temp25 = 0;\n    long long temp26\
    \ = 0;\n    long long temp27 = 0;\n    long long temp28 = 0;\n    long long temp29\
    \ = 0;\n    long long temp30 = 0;\n    long long temp31 = 0;\n    long long temp32\
    \ = 0;\n    long long temp33 = 0;\n    long long temp34 = 0;\n    long long temp35\
    \ = 0;\n    long long temp36 = 0;\n    long long temp37 = 0;\n    long long temp38\
    \ = 0;\n    long long temp39 = 0;\n    long long temp40 = 0;\n    long long temp41\
    \ = 0;\n    long long temp42 = 0;\n    long long temp43 = 0;\n    long long temp44\
    \ = 0;\n    long long temp45 = 0;\n    long long temp46 = 0;\n    long long temp47\
    \ = 0;\n    long long temp48 = 0;\n    long long temp49 = 0;\n    long long temp50\
    \ = 0;\n    long long temp51 = 0;\n    long long temp52 = 0;\n    long long temp53\
    \ = 0;\n    long long temp54 = 0;\n    long long temp55 = 0;\n    long long temp56\
    \ = 0;\n    long long temp57 = 0;\n    long long temp58 = 0;\n    long long temp59\
    \ = 0;\n    long long temp60 = 0;\n    long long temp61 = 0;\n    long long temp62\
    \ = 0;\n    long long temp63 = 0;\n    long long temp64 = 0;\n    long long temp65\
    \ = 0;\n    long long temp66 = 0;\n    long long temp67 = 0;\n    long long temp68\
    \ = 0;\n    long long temp69 = 0;\n    long long temp70 = 0;\n    long long temp71\
    \ = 0;\n    long long temp72 = 0;\n    long long temp73 = 0;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpml6emsxs: /tmp/tmpml6emsxs.cpp:94: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long diff = num - ans;\n    long mod = diff % 10;\n    long diff2 = diff /\
    \ 10;\n    long diff3 = diff / 100;\n    long diff4 = diff / 1000;\n    long diff5\
    \ = diff / 100000;\n    long diff6 = diff / 1000000;\n    long diff7 = diff /\
    \ 10000000;\n    long diff8 = diff / 1000000000;\n    long diff9 = diff / 10000000000;\n\
    \    long diff10 = diff / 100000000000;\n    long diff11 = diff / 1000000000000;\n\
    \    long diff12 = diff / 10000000000000;\n    long diff13 = diff / 100000000000000;\n\
    \    long diff14 = diff / 1000000000000000;\n    long diff15 = diff / 10000000000000000L;\n\
    \    long diff16 = diff / 100000000000000000;\n    long diff17 = diff / 10000000000000000L;\n\
    \    long diff18 = diff / 10000000000000000L;\n    long diff19 = diff / 10000000000000000L;\n\
    \    long diff20 = diff / 10000000000000000L;\n    long diff21 = diff / 10000000000000000L;\n\
    \    long diff22 = diff / 10000000000000000L;\n    long diff23 = diff / 10000000000000000L;\n\
    \    long diff24 = diff / 10000000000000000L;\n    long diff25 = diff / 10000000000000000L;\n\
    \    long diff26 = diff / 10000000000000000L;\n    long diff27 = diff / 10000000000000000L;\n\
    \    long diff28 = diff / 10000000000000000L;\n    long diff29 = diff / 10000000000000000L;\n\
    \    long diff30 = diff / 10000000000000000L;\n    long diff31 = diff / 10000000000000000L;\n\
    \    long diff32 = diff / 10000000000000000L;\n    long diff33 = diff / 10000000000000000L;\n\
    \    long diff34 = diff / 10000000000000000L;\n    long diff35 = diff / 10000000000000000L;\n\
    \    long diff36 = diff / 10000000000000000L;\n    long diff37 = diff / 10000000000000000L;\n\
    \    long diff38 = diff / 10000000000000000L;\n    long diff39 = diff / 10000000000000000L;\n\
    \    long diff40 = diff / 10000000000000000L;\n    long diff41 = diff / 10000000000000000L;\n\
    \    long diff\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvykowzoh.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpvykowzoh.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = num - ans;\n      |          ^~~~\n/tmp/tmpvykowzoh.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmpvykowzoh.cpp:62:1: error:\
    \ expected initializer before \u2018}\u2019 token\n   62 | }\n      | ^\n/tmp/tmpvykowzoh.cpp:62:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long temp = 0;\n   \
    \ long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m =\
    \ 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n   \
    \ long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v =\
    \ 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n   \
    \ long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E =\
    \ 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n   \
    \ long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N =\
    \ 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n   \
    \ long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W =\
    \ 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long AA = 0;\n  \
    \  long AB = 0;\n    long AC = 0;\n    long AD = 0;\n    long AE = 0;\n    long\
    \ AF = 0;\n    long AG = 0;\n    long AH = 0;\n    long AI = 0;\n    long AJ =\
    \ 0;\n    long AK = 0;\n    long AL = 0;\n    long AM = 0;\n    long AN = 0;\n\
    \    long AO = 0;\n    long AP = 0;\n    long AQ = 0;\n    long AR = 0;\n    long\
    \ AS = 0;\n    long AT = 0;\n    long AU = 0;\n    long AV = 0;\n    long AW =\
    \ 0;\n    long AX = 0;\n    long AY = 0;\n    long AZ = 0;\n    long BA = 0;\n\
    \    long BB = 0;\n    long BC = 0;\n    long BD = 0;\n    long BE = 0;\n    long\
    \ BF = 0;\n    long BG = 0;\n    long BH = 0;\n    long BI = 0;\n    long BJ =\
    \ 0;\n    long BK = 0;\n    long BL = 0;\n    long BM = 0;\n    long BN = 0;\n\
    \    long BO = 0;\n    long BP = 0;\n    long BQ = 0;\n    long BR = 0;\n    long\
    \ BS = 0;\n    long BT = 0;\n    long BU = 0;\n    long BV = 0;\n    long BW =\
    \ 0;\n    long BX = 0;\n    long BY = 0;\n    long BZ = 0;\n    long CA = 0;\n\
    \    long CB = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp3oth_kqm: /tmp/tmp3oth_kqm.cpp:122: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long power =\
    \ 1;\n    long sum = 0;\n    long count = 0;\n    long sum2 = 0;\n    long sum3\
    \ = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n    long sum7\
    \ = 0;\n    long sum8 = 0;\n    long sum9 = 0;\n    long sum10 = 0;\n    long\
    \ sum11 = 0;\n    long sum12 = 0;\n    long sum13 = 0;\n    long sum14 = 0;\n\
    \    long sum15 = 0;\n    long sum16 = 0;\n    long sum17 = 0;\n    long sum18\
    \ = 0;\n    long sum19 = 0;\n    long sum20 = 0;\n    long sum21 = 0;\n    long\
    \ sum22 = 0;\n    long sum23 = 0;\n    long sum24 = 0;\n    long sum25 = 0;\n\
    \    long sum26 = 0;\n    long sum27 = 0;\n    long sum28 = 0;\n    long sum29\
    \ = 0;\n    long sum30 = 0;\n    long sum31 = 0;\n    long sum32 = 0;\n    long\
    \ sum33 = 0;\n    long sum34 = 0;\n    long sum35 = 0;\n    long sum36 = 0;\n\
    \    long sum37 = 0;\n    long sum38 = 0;\n    long sum39 = 0;\n    long sum40\
    \ = 0;\n    long sum41 = 0;\n    long sum42 = 0;\n    long sum43 = 0;\n    long\
    \ sum44 = 0;\n    long sum45 = 0;\n    long sum46 = 0;\n    long sum47 = 0;\n\
    \    long sum48 = 0;\n    long sum49 = 0;\n    long sum50 = 0;\n    long sum51\
    \ = 0;\n    long sum52 = 0;\n    long sum53 = 0;\n    long sum54 = 0;\n    long\
    \ sum55 = 0;\n    long sum56 = 0;\n    long sum57 = 0;\n    long sum58 = 0;\n\
    \    long sum59 = 0;\n    long sum60 = 0;\n    long sum61 = 0;\n    long sum62\
    \ = 0;\n    long sum63 = 0;\n    long sum64 = 0;\n    long sum65 = 0;\n    long\
    \ sum66 = 0;\n    long sum67 = 0;\n    long sum68 = 0;\n    long sum69 = 0;\n\
    \    long sum70 = 0;\n    long sum71 = 0;\n    long sum72 = 0;\n    long sum73\
    \ = 0;\n    long sum74 = 0;\n    long sum75 = 0;\n    long sum76 = 0;\n    long\
    \ sum77 = 0;\n    long sum78 = 0;\n    long sum79 = 0;\n    long sum80 = 0;\n\
    \    long sum81 = 0;\n    long sum82 = 0;\n    long \n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmyhe5fj5.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpmyhe5fj5.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpmyhe5fj5.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int l1 = 0, l2 = 0, l3 = 0, l4 = 0;\n    long long int\
    \ l5 = 0, l6 = 0, l7 = 0;\n    long long int l8 = 0, l9 = 0;\n    long long int\
    \ l10 = 0;\n    long long int l11 = 0;\n    long long int l12 = 0;\n    long long\
    \ int l13 = 0;\n    long long int l14 = 0;\n    long long int l15 = 0;\n    long\
    \ long int l16 = 0;\n    long long int l17 = 0;\n    long long int l18 = 0;\n\
    \    long long int l19 = 0;\n    long long int l20 = 0;\n    long long int l21\
    \ = 0;\n    long long int l22 = 0;\n    long long int l23 = 0;\n    long long\
    \ int l24 = 0;\n    long long int l25 = 0;\n    long long int l26 = 0;\n    long\
    \ long int l27 = 0;\n    long long int l28 = 0;\n    long long int l29 = 0;\n\
    \    long long int l30 = 0;\n    long long int l31 = 0;\n    long long int l32\
    \ = 0;\n    long long int l33 = 0;\n    long long int l34 = 0;\n    long long\
    \ int l35 = 0;\n    long long int l36 = 0;\n    long long int l37 = 0;\n    long\
    \ long int l38 = 0;\n    long long int l39 = 0;\n    long long int l40 = 0;\n\
    \    long long int l41 = 0;\n    long long int l42 = 0;\n    long long int l43\
    \ = 0;\n    long long int l44 = 0;\n    long long int l45 = 0;\n    long long\
    \ int l46 = 0;\n    long long int l47 = 0;\n    long long int l48 = 0;\n    long\
    \ long int l49 = 0;\n    long long int l50 = 0;\n    long long int l51 = 0;\n\
    \    long long int l52 = 0;\n    long long int l53 = 0;\n    long long int l54\
    \ = 0;\n    long long int l55 = 0;\n    long long int l56 = 0;\n    long long\
    \ int l57 = 0;\n    long long int l58 = 0;\n    long long int l59 = 0;\n    long\
    \ long int l60 = 0;\n    long long int l61 = 0;\n    long long int l62 = 0;\n\
    \    long long int l63 = 0;\n    long long int l64 = 0;\n    long long int l65\
    \ = 0;\n    long long int l66 = 0;\n    long long int l67 = 0;\n    long long\
    \ int l68 = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpv88w81fj: /tmp/tmpv88w81fj.cpp:82: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = atoi(value.c_str());\n    if (ans == 0) {\n       \
    \ ans = 1;\n    }\n    long diff = abs(ans - 1);\n    long diff2 = abs(ans - 2);\n\
    \    long diff3 = abs(ans - 3);\n    long diff4 = abs(ans - 4);\n    long diff5\
    \ = abs(ans - 5);\n    long diff6 = abs(ans - 6);\n    long diff7 = abs(ans -\
    \ 7);\n    long diff8 = abs(ans - 8);\n    long diff9 = abs(ans - 9);\n    long\
    \ diff10 = abs(ans - 10);\n    long diff11 = abs(ans - 11);\n    long diff12 =\
    \ abs(ans - 12);\n    long diff13 = abs(ans - 13);\n    long diff14 = abs(ans\
    \ - 14);\n    long diff15 = abs(ans - 15);\n    long diff16 = abs(ans - 16);\n\
    \    long diff17 = abs(ans - 17);\n    long diff18 = abs(ans - 18);\n    long\
    \ diff19 = abs(ans - 19);\n    long diff20 = abs(ans - 20);\n    long diff21 =\
    \ abs(ans - 21);\n    long diff22 = abs(ans - 22);\n    long diff23 = abs(ans\
    \ - 23);\n    long diff24 = abs(ans - 24);\n    long diff25 = abs(ans - 25);\n\
    \    long diff26 = abs(ans - 26);\n    long diff27 = abs(ans - 27);\n    long\
    \ diff28 = abs(ans - 28);\n    long diff29 = abs(ans - 29);\n    long diff30 =\
    \ abs(ans - 30);\n    long diff31 = abs(ans - 31);\n    long diff32 = abs(ans\
    \ - 32);\n    long diff33 = abs(ans - 33);\n    long diff34 = abs(ans - 34);\n\
    \    long diff35 = abs(ans - 35);\n    long diff36 = abs(ans - 36);\n    long\
    \ diff37 = abs(ans - 37);\n    long diff38 = abs(ans - 38);\n    long diff39 =\
    \ abs(ans - 39);\n    long diff40 = abs(ans - 40);\n    long diff41 = abs(ans\
    \ - 41);\n    long diff42 = abs(ans - 42);\n    long diff43 = abs(ans - 43);\n\
    \    long diff44 = abs(ans - 44);\n    long diff45 = abs(ans - 45);\n    long\
    \ diff46 = abs(ans - 46);\n    long diff47 = abs(ans - 47);\n    long diff48\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8d_2o42l.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp8d_2o42l.cpp:69:1: error: expected initializer before \u2018}\u2019\
    \ token\n   69 | }\n      | ^\n/tmp/tmp8d_2o42l.cpp:69:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    temp = std::stoll(value);\n\
    \    diff = temp - ans;\n    if (diff < 0) {\n        diff = diff * -1;\n    }\n\
    \    ans = temp;\n    if (diff < 1) {\n        ans = ans + 1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp0_i2flsr: /tmp/tmp0_i2flsr.cpp:33: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), closest;\n    if (upper\
    \ < lower) {\n        std::swap(lower, upper);\n    }\n    do {\n        closest\
    \ = (lower + upper) / 2;\n        if (closest == upper) {\n            break;\n\
    \        }\n        if (closest < value) {\n            lower = closest;\n   \
    \     } else {\n            upper = closest;\n        }\n    } while (upper -\
    \ lower > 1);\n    return closest;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_lpv5512.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_lpv5512.cpp:26:21: error: no match for \u2018operator<\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   26 |         if (closest < value) {\n      |             ~~~~~~~ ^ ~~~~~\n\
    \      |             |         |\n      |             long int  std::string {aka\
    \ std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_lpv5512.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1048:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator<(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1048 |     operator<(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1048:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp_lpv5512.cpp:26:23:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   26 |         if (closest < value) {\n      |  \
    \                     ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_lpv5512.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1124:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator<(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1124 |     operator<(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1124:5: note:\
    \   template argument d"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int first = 0;\n    long long int second = 0;\n    long\
    \ long int third = 0;\n    long long int fourth = 0;\n    long long int fifth\
    \ = 0;\n    long long int sixth = 0;\n    long long int seventh = 0;\n    long\
    \ long int eighth = 0;\n    long long int ninth = 0;\n    long long int tenth\
    \ = 0;\n    long long int eleventh = 0;\n    long long int twelfth = 0;\n    long\
    \ long int thirteenth = 0;\n    long long int fourteenth = 0;\n    long long int\
    \ fifteenth = 0;\n    long long int sixteenth = 0;\n    long long int seventeenth\
    \ = 0;\n    long long int eighteenth = 0;\n    long long int nineteenth = 0;\n\
    \    long long int twentieth = 0;\n    long long int twenty_first = 0;\n    long\
    \ long int twenty_second = 0;\n    long long int twenty_third = 0;\n    long long\
    \ int twenty_fourth = 0;\n    long long int twenty_fifth = 0;\n    long long int\
    \ twenty_sixth = 0;\n    long long int twenty_seventh = 0;\n    long long int\
    \ twenty_eighth = 0;\n    long long int twenty_ninth = 0;\n    long long int twenty_tenth\
    \ = 0;\n    long long int twenty_eleventh = 0;\n    long long int twenty_twelfth\
    \ = 0;\n    long long int twenty_thirteenth = 0;\n    long long int twenty_fourteenth\
    \ = 0;\n    long long int twenty_fifteenth = 0;\n    long long int twenty_sixteenth\
    \ = 0;\n    long long int twenty_seventeenth = 0;\n    long long int twenty_eighteenth\
    \ = 0;\n    long long int twenty_nineteenth = 0;\n    long long int thirtieth\
    \ = 0;\n    long long int thirty_first = 0;\n    long long int thirty_second =\
    \ 0;\n    long long int thirty_third = 0;\n    long long int thirty_fourth = 0;\n\
    \    long long int thirty_fifth = 0;\n    long long int thirty_sixth = 0;\n  \
    \  long long int thirty_seventh = 0;\n    long long int thirty_eighth = 0;\n \
    \   long long int thirty_ninth = 0;\n    long long int thirty_tenth = 0;\n   \
    \ long long int \n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvq2r0x66.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpvq2r0x66.cpp:68:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   68 | }\n      | ^\n/tmp/tmpvq2r0x66.cpp:68:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int num;\n    long long int closest;\n    num = atoll(value.c_str());\n\
    \    closest = num;\n    long long int diff = abs(num - closest);\n    long long\
    \ int diff2 = abs(num - closest + 1);\n    long long int diff3 = abs(num - closest\
    \ + 2);\n    long long int diff4 = abs(num - closest + 3);\n    long long int\
    \ diff5 = abs(num - closest + 4);\n    long long int diff6 = abs(num - closest\
    \ + 5);\n    long long int diff7 = abs(num - closest + 6);\n    long long int\
    \ diff8 = abs(num - closest + 7);\n    long long int diff9 = abs(num - closest\
    \ + 8);\n    long long int diff10 = abs(num - closest + 9);\n    long long int\
    \ diff11 = abs(num - closest + 10);\n    long long int diff12 = abs(num - closest\
    \ + 11);\n    long long int diff13 = abs(num - closest + 12);\n    long long int\
    \ diff14 = abs(num - closest + 13);\n    long long int diff15 = abs(num - closest\
    \ + 14);\n    long long int diff16 = abs(num - closest + 15);\n    long long int\
    \ diff17 = abs(num - closest + 16);\n    long long int diff18 = abs(num - closest\
    \ + 17);\n    long long int diff19 = abs(num - closest + 18);\n    long long int\
    \ diff20 = abs(num - closest + 19);\n    long long int diff21 = abs(num - closest\
    \ + 20);\n    long long int diff22 = abs(num - closest + 21);\n    long long int\
    \ diff23 = abs(num - closest + 22);\n    long long int diff24 = abs(num - closest\
    \ + 23);\n    long long int diff25 = abs(num - closest + 24);\n    long long int\
    \ diff26 = abs(num - closest + 25);\n    long long int diff27 = abs(num - closest\
    \ + 26);\n    long long int diff28 = abs(num - closest + 27);\n    long long int\
    \ diff29 = abs(num - closest + 28);\n    long long int diff30 = abs(num - closest\
    \ + 29);\n    long long int diff31 = abs(num - closest + 30);\n    long long int\
    \ diff32 = abs(num - closest + 31);\n    long long int diff33 = abs(num - closest\
    \ + 32);\n    long long int diff34 = abs(num - closest + 33);\n    long long int\
    \ diff35 = \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg0b5p502.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpg0b5p502.cpp:56:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   56 | }\n      | ^\n/tmp/tmpg0b5p502.cpp:56:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long diff = 0;\n   \
    \ long temp = 0;\n    long sum = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5\
    \ = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long \n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprpj0pnba.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmprpj0pnba.cpp:105:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  105 | }\n      | ^\n/tmp/tmprpj0pnba.cpp:105:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long temp2 =\
    \ 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp2x3fut83: /tmp/tmp2x3fut83.cpp:106: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long mid =\
    \ (lower + upper) / 2;\n    long diff = std::abs(value - mid);\n    if (diff >\
    \ lower) {\n        lower = mid;\n    } else if (diff < upper) {\n        upper\
    \ = mid;\n    }\n    return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw9fftf1d.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpw9fftf1d.cpp:19:32: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   19 |     long diff = std::abs(value - mid);\n\
    \      |                          ~~~~~ ^ ~~~\n      |                       \
    \   |       |\n      |                          |       long int\n      |    \
    \                      std::string {aka std::__cxx11::basic_string<char>}\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpw9fftf1d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpw9fftf1d.cpp:19:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   19\
    \ |     long diff = std::abs(value - mid);\n      |                          \
    \        ^~~\nIn file included from /shared/ce"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), diff = upper - lower;\n\
    \    while (diff > 0) {\n        diff /= 10;\n        lower++;\n    }\n    while\
    \ (diff < 0) {\n        diff *= 10;\n        upper--;\n    }\n    if (upper -\
    \ lower == 0) {\n        return lower;\n    }\n    long mid = (lower + upper)\
    \ / 2;\n    if (mid == 0) {\n        return lower;\n    }\n    if (diff < 0) {\n\
    \        return closest_integer(value + \"0\");\n    }\n    return closest_integer(value\
    \ + \"9\");\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  stoll\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = std::abs(atoi(value.c_str()));\n\
    \    long mid = diff / 2;\n    long left = diff - mid;\n    long right = diff\
    \ + mid;\n    if (left < right) {\n        ans = mid;\n    } else {\n        ans\
    \ = right;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpjgrux_2c: /tmp/tmpjgrux_2c.cpp:31: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long d\
    \ = n - 1;\n    while (d >= 0) {\n        diff += d;\n        ans += d;\n    \
    \    d /= 10;\n    }\n    if (diff > 0)\n        ans -= diff;\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long mod = num % 10;\n    if (mod != 0) {\n        diff = num - mod;\n   \
    \     ans = mod - 1;\n    } else {\n        diff = num;\n        ans = 0;\n  \
    \  }\n    while (diff > 0) {\n        diff /= 10;\n        ans++;\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpk0na77_a: /tmp/tmpk0na77_a.cpp:35: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans = temp;\n\
    \    if (diff < 0) {\n        diff = diff * -1;\n    }\n    return diff;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpo2uxt0c6: /tmp/tmpo2uxt0c6.cpp:31: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n  \
    \  long diff = 0, mid = 0;\n    long diff2 = 0;\n    long mid2 = 0;\n    long\
    \ mid3 = 0;\n    long mid4 = 0;\n    long mid5 = 0;\n    long mid6 = 0;\n    long\
    \ mid7 = 0;\n    long mid8 = 0;\n    long mid9 = 0;\n    long mid10 = 0;\n   \
    \ long mid11 = 0;\n    long mid12 = 0;\n    long mid13 = 0;\n    long mid14 =\
    \ 0;\n    long mid15 = 0;\n    long mid16 = 0;\n    long mid17 = 0;\n    long\
    \ mid18 = 0;\n    long mid19 = 0;\n    long mid20 = 0;\n    long mid21 = 0;\n\
    \    long mid22 = 0;\n    long mid23 = 0;\n    long mid24 = 0;\n    long mid25\
    \ = 0;\n    long mid26 = 0;\n    long mid27 = 0;\n    long mid28 = 0;\n    long\
    \ mid29 = 0;\n    long mid30 = 0;\n    long mid31 = 0;\n    long mid32 = 0;\n\
    \    long mid33 = 0;\n    long mid34 = 0;\n    long mid35 = 0;\n    long mid36\
    \ = 0;\n    long mid37 = 0;\n    long mid38 = 0;\n    long mid39 = 0;\n    long\
    \ mid40 = 0;\n    long mid41 = 0;\n    long mid42 = 0;\n    long mid43 = 0;\n\
    \    long mid44 = 0;\n    long mid45 = 0;\n    long mid46 = 0;\n    long mid47\
    \ = 0;\n    long mid48 = 0;\n    long mid49 = 0;\n    long mid50 = 0;\n    long\
    \ mid51 = 0;\n    long mid52 = 0;\n    long mid53 = 0;\n    long mid54 = 0;\n\
    \    long mid55 = 0;\n    long mid56 = 0;\n    long mid57 = 0;\n    long mid58\
    \ = 0;\n    long mid59 = 0;\n    long mid60 = 0;\n    long mid61 = 0;\n    long\
    \ mid62 = 0;\n    long mid63 = 0;\n    long mid64 = 0;\n    long mid65 = 0;\n\
    \    long mid66 = 0;\n    long mid67 = 0;\n    long mid68 = 0;\n    long mid69\
    \ = 0;\n    long mid70 = 0;\n    long mid71 = 0;\n    long mid72 = 0;\n    long\
    \ mid73 = 0;\n    long mid74 = 0;\n    long mid75 = 0;\n    long mid76 = 0;\n\
    \    long mid77 = 0;\n    long mid78 = 0;\n    long mid79 = 0;\n    long mid80\
    \ = 0;\n    long mid81 = 0;\n    long mid82 = 0;\n    long \n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdw1cx2xr.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpdw1cx2xr.cpp:102:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  102 | }\n      | ^\n/tmp/tmpdw1cx2xr.cpp:102:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int x = stoi(value);\n    long long int y = x;\n   \
    \ long long int z = x;\n    long long int a = x;\n    long long int b = x;\n \
    \   long long int c = x;\n    long long int d = x;\n    long long int e = x;\n\
    \    long long int f = x;\n    long long int g = x;\n    long long int h = x;\n\
    \    long long int i = x;\n    long long int j = x;\n    long long int k = x;\n\
    \    long long int l = x;\n    long long int m = x;\n    long long int n = x;\n\
    \    long long int o = x;\n    long long int p = x;\n    long long int q = x;\n\
    \    long long int r = x;\n    long long int s = x;\n    long long int t = x;\n\
    \    long long int u = x;\n    long long int v = x;\n    long long int w = x;\n\
    \    long long int x = x;\n    long long int y = x;\n    long long int z = x;\n\
    \    long long int a = x;\n    long long int b = x;\n    long long int c = x;\n\
    \    long long int d = x;\n    long long int e = x;\n    long long int f = x;\n\
    \    long long int g = x;\n    long long int h = x;\n    long long int i = x;\n\
    \    long long int j = x;\n    long long int k = x;\n    long long int l = x;\n\
    \    long long int m = x;\n    long long int n = x;\n    long long int o = x;\n\
    \    long long int p = x;\n    long long int q = x;\n    long long int r = x;\n\
    \    long long int s = x;\n    long long int t = x;\n    long long int u = x;\n\
    \    long long int v = x;\n    long long int w = x;\n    long long int x = x;\n\
    \    long long int y = x;\n    long long int z = x;\n    long long int a = x;\n\
    \    long long int b = x;\n    long long int c = x;\n    long long int d = x;\n\
    \    long long int e = x;\n    long long int f = x;\n    long long int g = x;\n\
    \    long long int h = x;\n    long long int i = x;\n    long long int j = x;\n\
    \    long long int k = x;\n    long long int l = x;\n    long long int m = x;\n\
    \    long long int n = x;\n    long long int o = x;\n    long long int p = x;\n\
    \    long long int q = x;\n    long long int r = x;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2pzdk_g8.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2pzdk_g8.cpp:43:19: error: redeclaration of \u2018long long int x\u2019\
    \n   43 |     long long int x = x;\n      |                   ^\n/tmp/tmp2pzdk_g8.cpp:17:19:\
    \ note: \u2018long long int x\u2019 previously declared here\n   17 |     long\
    \ long int x = stoi(value);\n      |                   ^\n/tmp/tmp2pzdk_g8.cpp:44:19:\
    \ error: redeclaration of \u2018long long int y\u2019\n   44 |     long long int\
    \ y = x;\n      |                   ^\n/tmp/tmp2pzdk_g8.cpp:18:19: note: \u2018\
    long long int y\u2019 previously declared here\n   18 |     long long int y =\
    \ x;\n      |                   ^\n/tmp/tmp2pzdk_g8.cpp:45:19: error: redeclaration\
    \ of \u2018long long int z\u2019\n   45 |     long long int z = x;\n      |  \
    \                 ^\n/tmp/tmp2pzdk_g8.cpp:19:19: note: \u2018long long int z\u2019\
    \ previously declared here\n   19 |     long long int z = x;\n      |        \
    \           ^\n/tmp/tmp2pzdk_g8.cpp:46:19: error: redeclaration of \u2018long\
    \ long int a\u2019\n   46 |     long long int a = x;\n      |                \
    \   ^\n/tmp/tmp2pzdk_g8.cpp:20:19: note: \u2018long long int a\u2019 previously\
    \ declared here\n   20 |     long long int a = x;\n      |                   ^\n\
    /tmp/tmp2pzdk_g8.cpp:47:19: error: redeclaration of \u2018long long int b\u2019\
    \n   47 |     long long int b = x;\n      |                   ^\n/tmp/tmp2pzdk_g8.cpp:21:19:\
    \ note: \u2018long long int b\u2019 previously declared here\n   21 |     long\
    \ long int b = x;\n      |                   ^\n/tmp/tmp2pzdk_g8.cpp:48:19: error:\
    \ redeclaration of \u2018long long int c\u2019\n   48 |     long long int c =\
    \ x;\n      |                   ^\n/tmp/tmp2pzdk_g8.cpp:22:19: note: \u2018long\
    \ long int c\u2019 previously declared here\n   22 |     long long int c = x;\n\
    \      |                   ^\n/tmp/tmp2pzdk_g8.cpp:49:19: error: redeclaration\
    \ of \u2018long long int d\u2019\n   49 |     long long int d = x;\n      |  \
    \                 ^\n/tmp/tmp2pzdk_g8.cpp:23:19: note: \u2018long long int d\u2019\
    \ previously declared here\n   23 |     long long int d = x;\n      |        \
    \           ^\n/tmp/tmp2pzdk_g8.cpp:50:19: error: redeclaration of \u2018long\
    \ long int e\u2019\n   50 |   "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long long\
    \ temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long long\
    \ temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long long\
    \ temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n    long\
    \ long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n   \
    \ long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 = 0;\n\
    \    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21 =\
    \ 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpp5g9knc9: /tmp/tmpp5g9knc9.cpp:95: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    while (upper -\
    \ lower > 1) {\n        long mid = (lower + upper) / 2;\n        if (std::stoll(value)\
    \ == mid) {\n            return mid;\n        } else if (std::stoll(value) < mid)\
    \ {\n            upper = mid;\n        } else {\n            lower = mid;\n  \
    \      }\n    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp3ftzvook: /tmp/tmp3ftzvook.cpp:32: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long temp;\n\
    \    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff < 0) {\n\
    \        diff *= -1;\n    }\n    if (diff > 10) {\n        diff = diff / 10;\n\
    \    }\n    ans = temp + diff;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp49vvj6ro: /tmp/tmp49vvj6ro.cpp:33: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    if (upper > lower)\
    \ {\n        long mid = (lower + upper) / 2;\n        if (mid > upper) {\n   \
    \         upper = mid;\n        } else if (mid < lower) {\n            lower =\
    \ mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpobpi9xyc: /tmp/tmpobpi9xyc.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    if (upper < lower)\
    \ {\n        std::swap(lower, upper);\n    }\n    long mid = (lower + upper) /\
    \ 2;\n    if (mid * mid > value) {\n        mid = (lower + upper) / 2;\n    }\n\
    \    if (mid * mid < value) {\n        mid = (lower + upper) / 2;\n    }\n   \
    \ return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph1lkit7m.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmph1lkit7m.cpp:22:19: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   22 |     if (mid * mid > value) {\n      |         ~~~~~~~~~ ^ ~~~~~\n\
    \      |             |       |\n      |             |       std::string {aka std::__cxx11::basic_string<char>}\n\
    \      |             long int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmph1lkit7m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmph1lkit7m.cpp:22:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   22 |     if (mid * mid > value) {\n      |    \
    \                 ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmph1lkit7m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5: note:\
    \   te"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long temp2 =\
    \ 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmplh37tev8: /tmp/tmplh37tev8.cpp:106: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    if (upper < lower)\
    \ {\n        std::swap(lower, upper);\n    }\n    long mid = (lower + upper) /\
    \ 2;\n    if (mid * mid > value) {\n        mid = mid * mid - value;\n    }\n\
    \    return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_kcqxu6j.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_kcqxu6j.cpp:22:19: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   22 |     if (mid * mid > value) {\n      |         ~~~~~~~~~ ^ ~~~~~\n\
    \      |             |       |\n      |             |       std::string {aka std::__cxx11::basic_string<char>}\n\
    \      |             long int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_kcqxu6j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp_kcqxu6j.cpp:22:21:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   22 |     if (mid * mid > value) {\n      |    \
    \                 ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_kcqxu6j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5: note:\
    \   te"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = atoi(value.c_str());\n    if (ans < 0)\n        ans\
    \ = -ans;\n    long diff = ans - ans % 10;\n    if (diff == 0)\n        return\
    \ ans;\n    long diff2 = ans - ans % 10;\n    if (diff > diff2)\n        diff\
    \ = diff2;\n    return ans + diff;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpf0rx3z3c: /tmp/tmpf0rx3z3c.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long\
    \ temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n\
    \    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10\
    \ = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n   \
    \ long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17\
    \ = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n   \
    \ long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24\
    \ = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n   \
    \ long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31\
    \ = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n   \
    \ long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38\
    \ = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n   \
    \ long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45\
    \ = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n   \
    \ long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52\
    \ = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n   \
    \ long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59\
    \ = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n   \
    \ long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n    long temp66\
    \ = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n   \
    \ long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n    long temp73\
    \ = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n   \
    \ long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n    long temp80\
    \ = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83 = 0;\n   \
    \ long temp84 = 0;\n    long temp85 = 0;\n    long \n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfagb_y_0.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpfagb_y_0.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpfagb_y_0.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long diff\
    \ = n - ans;\n    long mid = (ans + n) / 2;\n    long middiff = mid-ans;\n   \
    \ if (middiff > diff) {\n        ans = mid;\n        diff = middiff;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprd55omq2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmprd55omq2.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmprd55omq2.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int closest;\n    long long int farthest;\n    long\
    \ long int diff;\n    long long int temp;\n    long long int temp2;\n    long\
    \ long int temp3;\n    long long int temp4;\n    long long int temp5;\n    long\
    \ long int temp6;\n    long long int temp7;\n    long long int temp8;\n    long\
    \ long int temp9;\n    long long int temp10;\n    long long int temp11;\n    long\
    \ long int temp12;\n    long long int temp13;\n    long long int temp14;\n   \
    \ long long int temp15;\n    long long int temp16;\n    long long int temp17;\n\
    \    long long int temp18;\n    long long int temp19;\n    long long int temp20;\n\
    \    long long int temp21;\n    long long int temp22;\n    long long int temp23;\n\
    \    long long int temp24;\n    long long int temp25;\n    long long int temp26;\n\
    \    long long int temp27;\n    long long int temp28;\n    long long int temp29;\n\
    \    long long int temp30;\n    long long int temp31;\n    long long int temp32;\n\
    \    long long int temp33;\n    long long int temp34;\n    long long int temp35;\n\
    \    long long int temp36;\n    long long int temp37;\n    long long int temp38;\n\
    \    long long int temp39;\n    long long int temp40;\n    long long int temp41;\n\
    \    long long int temp42;\n    long long int temp43;\n    long long int temp44;\n\
    \    long long int temp45;\n    long long int temp46;\n    long long int temp47;\n\
    \    long long int temp48;\n    long long int temp49;\n    long long int temp50;\n\
    \    long long int temp51;\n    long long int temp52;\n    long long int temp53;\n\
    \    long long int temp54;\n    long long int temp55;\n    long long int temp56;\n\
    \    long long int temp57;\n    long long int temp58;\n    long long int temp59;\n\
    \    long long int temp60;\n    long long int temp61;\n    long long int temp62;\n\
    \    long long int temp63;\n    long long int temp\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmgewwtyi.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpmgewwtyi.cpp:84:1: error: expected initializer before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmpmgewwtyi.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long long temp2\
    \ = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long temp5\
    \ = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long temp8\
    \ = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long temp11\
    \ = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long long temp14\
    \ = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n    long long temp17\
    \ = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n    long long temp20\
    \ = 0;\n    long long temp21 = 0;\n    long long temp22 = 0;\n    long long temp23\
    \ = 0;\n    long long temp24 = 0;\n    long long temp25 = 0;\n    long long temp26\
    \ = 0;\n    long long temp27 = 0;\n    long long temp28 = 0;\n    long long temp29\
    \ = 0;\n    long long temp30 = 0;\n    long long temp31 = 0;\n    long long temp32\
    \ = 0;\n    long long temp33 = 0;\n    long long temp34 = 0;\n    long long temp35\
    \ = 0;\n    long long temp36 = 0;\n    long long temp37 = 0;\n    long long temp38\
    \ = 0;\n    long long temp39 = 0;\n    long long temp40 = 0;\n    long long temp41\
    \ = 0;\n    long long temp42 = 0;\n    long long temp43 = 0;\n    long long temp44\
    \ = 0;\n    long long temp45 = 0;\n    long long temp46 = 0;\n    long long temp47\
    \ = 0;\n    long long temp48 = 0;\n    long long temp49 = 0;\n    long long temp50\
    \ = 0;\n    long long temp51 = 0;\n    long long temp52 = 0;\n    long long temp53\
    \ = 0;\n    long long temp54 = 0;\n    long long temp55 = 0;\n    long long temp56\
    \ = 0;\n    long long temp57 = 0;\n    long long temp58 = 0;\n    long long temp59\
    \ = 0;\n    long long temp60 = 0;\n    long long temp61 = 0;\n    long long temp62\
    \ = 0;\n    long long temp63 = 0;\n    long long temp64 = 0;\n    long long temp65\
    \ = 0;\n    long long temp66 = 0;\n    long long temp67 = 0;\n    long long temp68\
    \ = 0;\n    long long temp69 = 0;\n    long long temp70 = 0;\n    long long temp71\
    \ = 0;\n    long long temp72 = 0;\n    long long temp73 = 0;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpv3q3trd8: /tmp/tmpv3q3trd8.cpp:94: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int lower = 0, upper = std::numeric_limits<long long\
    \ int>::max();\n    long long int mid = 0;\n    long long int diff = 0;\n    long\
    \ long int closest = 0;\n    long long int diff2 = 0;\n    long long int closest2\
    \ = 0;\n    long long int mid2 = 0;\n    long long int mid3 = 0;\n    long long\
    \ int mid4 = 0;\n    long long int mid5 = 0;\n    long long int mid6 = 0;\n  \
    \  long long int mid7 = 0;\n    long long int mid8 = 0;\n    long long int mid9\
    \ = 0;\n    long long int mid10 = 0;\n    long long int mid11 = 0;\n    long long\
    \ int mid12 = 0;\n    long long int mid13 = 0;\n    long long int mid14 = 0;\n\
    \    long long int mid15 = 0;\n    long long int mid16 = 0;\n    long long int\
    \ mid17 = 0;\n    long long int mid18 = 0;\n    long long int mid19 = 0;\n   \
    \ long long int mid20 = 0;\n    long long int mid21 = 0;\n    long long int mid22\
    \ = 0;\n    long long int mid23 = 0;\n    long long int mid24 = 0;\n    long long\
    \ int mid25 = 0;\n    long long int mid26 = 0;\n    long long int mid27 = 0;\n\
    \    long long int mid28 = 0;\n    long long int mid29 = 0;\n    long long int\
    \ mid30 = 0;\n    long long int mid31 = 0;\n    long long int mid32 = 0;\n   \
    \ long long int mid33 = 0;\n    long long int mid34 = 0;\n    long long int mid35\
    \ = 0;\n    long long int mid36 = 0;\n    long long int mid37 = 0;\n    long long\
    \ int mid38 = 0;\n    long long int mid39 = 0;\n    long long int mid40 = 0;\n\
    \    long long int mid41 = 0;\n    long long int mid42 = 0;\n    long long int\
    \ mid43 = 0;\n    long long int mid44 = 0;\n    long long int mid45 = 0;\n   \
    \ long long int mid46 = 0;\n    long long int mid47 = 0;\n    long long int mid48\
    \ = 0;\n    long long int mid49 = 0;\n    long long int mid50 = 0;\n    long long\
    \ int mid51 = 0;\n    long long int mid52 = 0;\n    long long int mid53 = 0;\n\
    \    long long int mid54 = 0;\n    long long int mid55 = 0;\n    long long int\
    \ mid56 = 0;\n    long long int mid57 = 0;\n    long long int mid58 = 0;\n   \
    \ long long int mid\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplh_g3txa.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplh_g3txa.cpp:81:1: error: expected initializer before \u2018}\u2019\
    \ token\n   81 | }\n      | ^\n/tmp/tmplh_g3txa.cpp:81:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int temp;\n    long long int temp2;\n    long long int\
    \ temp3;\n    long long int temp4;\n    long long int temp5;\n    long long int\
    \ temp6;\n    long long int temp7;\n    long long int temp8;\n    long long int\
    \ temp9;\n    long long int temp10;\n    long long int temp11;\n    long long\
    \ int temp12;\n    long long int temp13;\n    long long int temp14;\n    long\
    \ long int temp15;\n    long long int temp16;\n    long long int temp17;\n   \
    \ long long int temp18;\n    long long int temp19;\n    long long int temp20;\n\
    \    long long int temp21;\n    long long int temp22;\n    long long int temp23;\n\
    \    long long int temp24;\n    long long int temp25;\n    long long int temp26;\n\
    \    long long int temp27;\n    long long int temp28;\n    long long int temp29;\n\
    \    long long int temp30;\n    long long int temp31;\n    long long int temp32;\n\
    \    long long int temp33;\n    long long int temp34;\n    long long int temp35;\n\
    \    long long int temp36;\n    long long int temp37;\n    long long int temp38;\n\
    \    long long int temp39;\n    long long int temp40;\n    long long int temp41;\n\
    \    long long int temp42;\n    long long int temp43;\n    long long int temp44;\n\
    \    long long int temp45;\n    long long int temp46;\n    long long int temp47;\n\
    \    long long int temp48;\n    long long int temp49;\n    long long int temp50;\n\
    \    long long int temp51;\n    long long int temp52;\n    long long int temp53;\n\
    \    long long int temp54;\n    long long int temp55;\n    long long int temp56;\n\
    \    long long int temp57;\n    long long int temp58;\n    long long int temp59;\n\
    \    long long int temp60;\n    long long int temp61;\n    long long int temp62;\n\
    \    long long int temp63;\n    long long int temp64;\n    long long int temp65;\n\
    \    long long int temp66;\n    long long int \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpveym0pxp.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpveym0pxp.cpp:84:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmpveym0pxp.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), mid;\n    while (upper\
    \ - lower > 1) {\n        mid = (lower + upper) / 2;\n        if (mid * mid >\
    \ upper * lower) {\n            upper = mid;\n        } else {\n            lower\
    \ = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmphvtdttkc: /tmp/tmphvtdttkc.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int num;\n    long long int min;\n    long long int\
    \ max;\n    long long int mid;\n    long long int diff;\n    long long int diff2;\n\
    \    long long int diff3;\n    long long int diff4;\n    long long int diff5;\n\
    \    long long int diff6;\n    long long int diff7;\n    long long int diff8;\n\
    \    long long int diff9;\n    long long int diff10;\n    long long int diff11;\n\
    \    long long int diff12;\n    long long int diff13;\n    long long int diff14;\n\
    \    long long int diff15;\n    long long int diff16;\n    long long int diff17;\n\
    \    long long int diff18;\n    long long int diff19;\n    long long int diff20;\n\
    \    long long int diff21;\n    long long int diff22;\n    long long int diff23;\n\
    \    long long int diff24;\n    long long int diff25;\n    long long int diff26;\n\
    \    long long int diff27;\n    long long int diff28;\n    long long int diff29;\n\
    \    long long int diff30;\n    long long int diff31;\n    long long int diff32;\n\
    \    long long int diff33;\n    long long int diff34;\n    long long int diff35;\n\
    \    long long int diff36;\n    long long int diff37;\n    long long int diff38;\n\
    \    long long int diff39;\n    long long int diff40;\n    long long int diff41;\n\
    \    long long int diff42;\n    long long int diff43;\n    long long int diff44;\n\
    \    long long int diff45;\n    long long int diff46;\n    long long int diff47;\n\
    \    long long int diff48;\n    long long int diff49;\n    long long int diff50;\n\
    \    long long int diff51;\n    long long int diff52;\n    long long int diff53;\n\
    \    long long int diff54;\n    long long int diff55;\n    long long int diff56;\n\
    \    long long int diff57;\n    long long int diff58;\n    long long int diff59;\n\
    \    long long int diff60;\n    long long int diff61;\n    long long int diff62;\n\
    \    long long int diff63;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp2cl9e4bh: /tmp/tmp2cl9e4bh.cpp:88: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long temp = 0;\n    long diff = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n\
    \    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long\
    \ r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n\
    \    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long\
    \ b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n\
    \    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long\
    \ k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n\
    \    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long\
    \ t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n\
    \    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long\
    \ C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n\
    \    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long\
    \ L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n\
    \    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long\
    \ U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n\
    \    long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long\
    \ d = 0;\n    long e\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcinfbxej.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpcinfbxej.cpp:72:10: error: redeclaration of \u2018long int i\u2019\n\
    \   72 |     long i = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:20:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   20 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpcinfbxej.cpp:73:10: error: redeclaration of \u2018\
    long int j\u2019\n   73 |     long j = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:21:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   21 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:74:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   74 |     long k = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:22:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   22 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:75:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   75 |     long l = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:23:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   23 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:76:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   76 |     long m = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:24:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   24 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:77:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   77 |     long n = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:25:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   25 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:78:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   78 |     long o = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:26:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   26 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:79:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   79 |     long p = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:27:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   27 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:80:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   80 |     long q = 0;\n      |          ^\n/tmp/tmpcinfbxej.cpp:28:10:\
    \ note: \u2018long int q\u2019 previously declared here\n   28 |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long\
    \ temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n\
    \    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10\
    \ = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n   \
    \ long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17\
    \ = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n   \
    \ long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24\
    \ = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n   \
    \ long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31\
    \ = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n   \
    \ long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38\
    \ = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n   \
    \ long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45\
    \ = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n   \
    \ long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52\
    \ = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n   \
    \ long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59\
    \ = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n   \
    \ long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n    long temp66\
    \ = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n   \
    \ long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n    long temp73\
    \ = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n   \
    \ long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n    long temp80\
    \ = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83 = 0;\n   \
    \ long temp84 = 0;\n    long temp85 = 0;\n    long \n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjiy6hr4c.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjiy6hr4c.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpjiy6hr4c.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    if (upper == lower)\
    \ {\n        upper = upper + 1;\n    }\n    while (upper - lower > 1) {\n    \
    \    long mid = (lower + upper) / 2;\n        long midValue = std::stoll(value);\n\
    \        if (midValue == mid) {\n            upper = mid;\n        } else {\n\
    \            lower = mid;\n        }\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpoj1z6dn9: /tmp/tmpoj1z6dn9.cpp:34: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, sign = 1;\n    long long\
    \ temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long long\
    \ temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long long\
    \ temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long long\
    \ temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n    long\
    \ long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n   \
    \ long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 = 0;\n\
    \    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21 =\
    \ 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp3vnx61h1: /tmp/tmp3vnx61h1.cpp:95: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = stoi(value);\n    diff = abs(temp - ans);\n    ans =\
    \ temp;\n    while (diff > 1) {\n        diff /= 10;\n        ans++;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpebl4sw8l: /tmp/tmpebl4sw8l.cpp:31: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), diff = upper - lower;\n\
    \    while (diff > 0) {\n        diff /= 10;\n        lower += diff;\n    }\n\
    \    while (diff < 0) {\n        diff *= 10;\n        upper -= diff;\n    }\n\
    \    return lower + diff;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpky_je1bq: /tmp/tmpky_je1bq.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), mid;\n    while (lower\
    \ <= upper) {\n        mid = (lower + upper) / 2;\n        if (mid * mid == value)\
    \ {\n            return mid;\n        } else if (mid * mid < value) {\n      \
    \      lower = mid + 1;\n        } else {\n            upper = mid - 1;\n    \
    \    }\n    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1a94b_sg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp1a94b_sg.cpp:20:23: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   20 |         if (mid * mid == value) {\n      |             ~~~~~~~~~ ^~\
    \ ~~~~~\n      |                 |        |\n      |                 long int\
    \ std::string {aka std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp1a94b_sg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp1a94b_sg.cpp:20:26:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   20 |         if (mid * mid == value) {\n      |\
    \                          ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp1a94b_sg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5: note"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n\
    \    long m = stoi(value);\n    long diff = abs(n - m);\n    long mid = n + (diff\
    \ / 2);\n    long mid2 = m + (diff / 2);\n    long mid3 = mid + (diff / 2);\n\
    \    long mid4 = mid2 + (diff / 2);\n    long mid5 = mid3 + (diff / 2);\n    long\
    \ mid6 = mid4 + (diff / 2);\n    long mid7 = mid5 + (diff / 2);\n    long mid8\
    \ = mid6 + (diff / 2);\n    long mid9 = mid7 + (diff / 2);\n    long mid10 = mid8\
    \ + (diff / 2);\n    long mid11 = mid9 + (diff / 2);\n    long mid12 = mid10 +\
    \ (diff / 2);\n    long mid13 = mid11 + (diff / 2);\n    long mid14 = mid12 +\
    \ (diff / 2);\n    long mid15 = mid13 + (diff / 2);\n    long mid16 = mid14 +\
    \ (diff / 2);\n    long mid17 = mid15 + (diff / 2);\n    long mid18 = mid16 +\
    \ (diff / 2);\n    long mid19 = mid17 + (diff / 2);\n    long mid20 = mid18 +\
    \ (diff / 2);\n    long mid21 = mid19 + (diff / 2);\n    long mid22 = mid20 +\
    \ (diff / 2);\n    long mid23 = mid21 + (diff / 2);\n    long mid24 = mid22 +\
    \ (diff / 2);\n    long mid25 = mid23 + (diff / 2);\n    long mid26 = mid24 +\
    \ (diff / 2);\n    long mid27 = mid25 + (diff / 2);\n    long mid28 = mid26 +\
    \ (diff / 2);\n    long mid29 = mid27 + (diff / 2);\n    long mid30 = mid28 +\
    \ (diff / 2);\n    long mid31 = mid29 + (diff / 2);\n    long mid32 = mid30 +\
    \ (diff / 2);\n    long mid33 = mid31 + (diff / 2);\n    long mid34 = mid32 +\
    \ (diff / 2);\n    long mid35 = mid33 + (diff / 2);\n    long mid36 = mid34 +\
    \ (diff / 2);\n    long mid37 = mid35 + (diff / 2);\n    long mid38 = mid36 +\
    \ (diff / 2);\n    long mid39 = mid37 + (diff / 2);\n    long mid40 = mid38 +\
    \ (diff / 2);\n    long mid41 = mid39 + (diff / 2);\n    \n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvrwi9zm2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpvrwi9zm2.cpp:21:10: error: redeclaration of \u2018long int diff\u2019\
    \n   21 |     long diff = abs(n - m);\n      |          ^~~~\n/tmp/tmpvrwi9zm2.cpp:18:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmpvrwi9zm2.cpp:64:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   64 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpowkspg2v.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpowkspg2v.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmpowkspg2v.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long diff\
    \ = n - ans;\n    while (diff > 1) {\n        diff /= 10;\n        ans += diff;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmtnor90c.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpmtnor90c.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmpmtnor90c.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    long diff = upper\
    \ - lower;\n    if (diff == 0) {\n        return lower;\n    }\n    if (diff >\
    \ 0) {\n        return lower + 1;\n    }\n    return upper - 1;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpzbn27d3g: /tmp/tmpzbn27d3g.cpp:29: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long temp2 =\
    \ 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpgchuuqb6: /tmp/tmpgchuuqb6.cpp:106: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    if (upper == lower)\
    \ {\n        return lower;\n    }\n    long mid = (lower + upper) / 2;\n    long\
    \ diff = upper - lower;\n    if (diff == 0) {\n        return mid;\n    }\n  \
    \  if (diff > 0) {\n        return mid;\n    }\n    return mid - 1;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp9yi30fdk: /tmp/tmp9yi30fdk.cpp:33: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long num = std::stoll(value);\n\
    \    long div = num / 10;\n    long mod = num % 10;\n    long temp2 = div;\n \
    \   long temp3 = mod;\n    long temp4 = div;\n    long temp5 = mod;\n    long\
    \ temp6 = div;\n    long temp7 = mod;\n    long temp8 = div;\n    long temp9 =\
    \ mod;\n    long temp10 = div;\n    long temp11 = mod;\n    long temp12 = div;\n\
    \    long temp13 = mod;\n    long temp14 = div;\n    long temp15 = mod;\n    long\
    \ temp16 = div;\n    long temp17 = mod;\n    long temp18 = div;\n    long temp19\
    \ = mod;\n    long temp20 = div;\n    long temp21 = mod;\n    long temp22 = div;\n\
    \    long temp23 = mod;\n    long temp24 = div;\n    long temp25 = mod;\n    long\
    \ temp26 = div;\n    long temp27 = mod;\n    long temp28 = div;\n    long temp29\
    \ = mod;\n    long temp30 = div;\n    long temp31 = mod;\n    long temp32 = div;\n\
    \    long temp33 = mod;\n    long temp34 = div;\n    long temp35 = mod;\n    long\
    \ temp36 = div;\n    long temp37 = mod;\n    long temp38 = div;\n    long temp39\
    \ = mod;\n    long temp40 = div;\n    long temp41 = mod;\n    long temp42 = div;\n\
    \    long temp43 = mod;\n    long temp44 = div;\n    long temp45 = mod;\n    long\
    \ temp46 = div;\n    long temp47 = mod;\n    long temp48 = div;\n    long temp49\
    \ = mod;\n    long temp50 = div;\n    long temp51 = mod;\n    long temp52 = div;\n\
    \    long temp53 = mod;\n    long temp54 = div;\n    long temp55 = mod;\n    long\
    \ temp56 = div;\n    long temp57 = mod;\n    long temp58 = div;\n    long temp59\
    \ = mod;\n    long temp60 = div;\n    long temp61 = mod;\n    long temp62 = div\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpif1fz8a0.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpif1fz8a0.cpp:83:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   83 | }\n      | ^\n/tmp/tmpif1fz8a0.cpp:83:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int int_value = std::stoll(value);\n    long long int\
    \ closest_int_value = int_value;\n    long long int closest_int_value_2 = int_value;\n\
    \    long long int closest_int_value_3 = int_value;\n    long long int closest_int_value_4\
    \ = int_value;\n    long long int closest_int_value_5 = int_value;\n    long long\
    \ int closest_int_value_6 = int_value;\n    long long int closest_int_value_7\
    \ = int_value;\n    long long int closest_int_value_8 = int_value;\n    long long\
    \ int closest_int_value_9 = int_value;\n    long long int closest_int_value_10\
    \ = int_value;\n    long long int closest_int_value_11 = int_value;\n    long\
    \ long int closest_int_value_12 = int_value;\n    long long int closest_int_value_13\
    \ = int_value;\n    long long int closest_int_value_14 = int_value;\n    long\
    \ long int closest_int_value_15 = int_value;\n    long long int closest_int_value_16\
    \ = int_value;\n    long long int closest_int_value_17 = int_value;\n    long\
    \ long int closest_int_value_18 = int_value;\n    long long int closest_int_value_19\
    \ = int_value;\n    long long int closest_int_value_20 = int_value;\n    long\
    \ long int closest_int_value_21 = int_value;\n    long long int closest_int_value_22\
    \ = int_value;\n    long long int closest_int_value_23 = int_value;\n    long\
    \ long int closest_int_value_24 = int_value;\n    long long int closest_int_value_25\
    \ = int_value;\n    long long int closest_int_value_26 = int_value;\n    long\
    \ long int closest_int_value_27 = int_value;\n    long long int closest_int_value_28\
    \ = int_value;\n    long long int closest_int_value_29 = int_value;\n    long\
    \ long int closest_int_value_30 = int_value;\n    long long int closest_int_value_31\
    \ = int_value;\n    long long int closest_int_value_32 = int_value;\n    long\
    \ long int closest_int_value_33 = int_value;\n    long long int closest_int_value_34\
    \ = int_value;\n    long long int closest_int_value_35 = int_value;\n    long\
    \ long int closest_int_value_36 = int_value;\n    long long int closest_int_value_37\
    \ = int_value;\n    long long int closest_int_value_38 = int_value;\n    long\
    \ long int closest_int_value_39 = int_value;\n    long long int closest_int_value_40\
    \ = int_value;\n    long long int closest_int_value_41 = int_value;\n    long\
    \ long int closest_int_value_42 = int_value;\n    long long int closest_int_value_43\
    \ = \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdtq4gqjf.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpdtq4gqjf.cpp:61:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   61 | }\n      | ^\n/tmp/tmpdtq4gqjf.cpp:61:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long len = 0;\n    long count = 0;\n    long sum\
    \ = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long\
    \ temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n\
    \    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12\
    \ = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n   \
    \ long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb2pi1xs1.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpb2pi1xs1.cpp:105:1: error: expected initializer before \u2018}\u2019\
    \ token\n  105 | }\n      | ^\n/tmp/tmpb2pi1xs1.cpp:105:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int int_value = std::stoll(value);\n    long long int\
    \ int_min = std::numeric_limits<long long int>::min();\n    long long int int_max\
    \ = std::numeric_limits<long long int>::max();\n    if (int_value < int_min) {\n\
    \        int_value = int_min;\n    }\n    if (int_value > int_max) {\n       \
    \ int_value = int_max;\n    }\n    return int_value;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmph2g29w0q: /tmp/tmph2g29w0q.cpp:31: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = abs(atoi(value.c_str()));\n   \
    \ long diff = diff % 10;\n    long diff2 = diff % 10;\n    long diff3 = diff %\
    \ 10;\n    long diff4 = diff % 10;\n    long diff5 = diff % 10;\n    long diff6\
    \ = diff % 10;\n    long diff7 = diff % 10;\n    long diff8 = diff % 10;\n   \
    \ long diff9 = diff % 10;\n    long diff10 = diff % 10;\n    long diff11 = diff\
    \ % 10;\n    long diff12 = diff % 10;\n    long diff13 = diff % 10;\n    long\
    \ diff14 = diff % 10;\n    long diff15 = diff % 10;\n    long diff16 = diff %\
    \ 10;\n    long diff17 = diff % 10;\n    long diff18 = diff % 10;\n    long diff19\
    \ = diff % 10;\n    long diff20 = diff % 10;\n    long diff21 = diff % 10;\n \
    \   long diff22 = diff % 10;\n    long diff23 = diff % 10;\n    long diff24 =\
    \ diff % 10;\n    long diff25 = diff % 10;\n    long diff26 = diff % 10;\n   \
    \ long diff27 = diff % 10;\n    long diff28 = diff % 10;\n    long diff29 = diff\
    \ % 10;\n    long diff30 = diff % 10;\n    long diff31 = diff % 10;\n    long\
    \ diff32 = diff % 10;\n    long diff33 = diff % 10;\n    long diff34 = diff %\
    \ 10;\n    long diff35 = diff % 10;\n    long diff36 = diff % 10;\n    long diff37\
    \ = diff % 10;\n    long diff38 = diff % 10;\n    long diff39 = diff % 10;\n \
    \   long diff40 = diff % 10;\n    long diff41 = diff % 10;\n    long diff42 =\
    \ diff % 10;\n    long diff43 = diff % 10;\n    long diff44 = diff % 10;\n   \
    \ long diff45 = diff % 10;\n    long diff46 = diff % 10;\n    long diff47 = diff\
    \ % 10;\n    long diff48 = diff % 10;\n    long diff49 = diff % 10;\n    long\
    \ diff50 = diff % 10;\n    long diff51 = diff % 10;\n    long diff52 = diff %\
    \ 10;\n    long diff53 = diff % 10;\n    long diff54 = diff % 10;\n    long diff55\
    \ = diff % 10;\n    long diff56 = diff % 10;\n    long diff57 = \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9xh291dd.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9xh291dd.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = diff % 10;\n      |          ^~~~\n/tmp/tmp9xh291dd.cpp:18:10:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long diff\
    \ = abs(atoi(value.c_str()));\n      |          ^~~~\n/tmp/tmp9xh291dd.cpp:76:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   76 | }\n \
    \     | ^\n/tmp/tmp9xh291dd.cpp:76:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long diff = std::abs(num - ans);\n    if (diff > 1) {\n        diff = diff\
    \ - 1;\n    }\n    ans = num - diff;\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppkc58hvz.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppkc58hvz.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = std::abs(num - ans);\n      |          ^~~~\n/tmp/tmppkc58hvz.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwegt9iui.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpwegt9iui.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmpwegt9iui.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), diff = upper - lower;\n\
    \    long mid = 0;\n    while (diff > 0) {\n        mid = (lower + upper) / 2;\n\
    \        diff = upper - mid;\n        if (diff > 0)\n            upper = mid;\n\
    \        else\n            lower = mid;\n    }\n    return lower;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpqiewfa3u: /tmp/tmpqiewfa3u.cpp:31: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n\
    \    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9\
    \ = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n   \
    \ long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprxcbaxmn.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmprxcbaxmn.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmprxcbaxmn.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int a = stoi(value);\n    long long int b = a;\n   \
    \ long long int c = a;\n    long long int d = a;\n    long long int e = a;\n \
    \   long long int f = a;\n    long long int g = a;\n    long long int h = a;\n\
    \    long long int i = a;\n    long long int j = a;\n    long long int k = a;\n\
    \    long long int l = a;\n    long long int m = a;\n    long long int n = a;\n\
    \    long long int o = a;\n    long long int p = a;\n    long long int q = a;\n\
    \    long long int r = a;\n    long long int s = a;\n    long long int t = a;\n\
    \    long long int u = a;\n    long long int v = a;\n    long long int w = a;\n\
    \    long long int x = a;\n    long long int y = a;\n    long long int z = a;\n\
    \    long long int A = a;\n    long long int B = a;\n    long long int C = a;\n\
    \    long long int D = a;\n    long long int E = a;\n    long long int F = a;\n\
    \    long long int G = a;\n    long long int H = a;\n    long long int I = a;\n\
    \    long long int J = a;\n    long long int K = a;\n    long long int L = a;\n\
    \    long long int M = a;\n    long long int N = a;\n    long long int O = a;\n\
    \    long long int P = a;\n    long long int Q = a;\n    long long int R = a;\n\
    \    long long int S = a;\n    long long int T = a;\n    long long int U = a;\n\
    \    long long int V = a;\n    long long int W = a;\n    long long int X = a;\n\
    \    long long int Y = a;\n    long long int Z = a;\n    long long int a = a;\n\
    \    long long int b = a;\n    long long int c = a;\n    long long int d = a;\n\
    \    long long int e = a;\n    long long int f = a;\n    long long int g = a;\n\
    \    long long int h = a;\n    long long int i = a;\n    long long int j = a;\n\
    \    long long int k = a;\n    long long int l = a;\n    long long int m = a;\n\
    \    long long int n = a;\n    long long int o = a;\n    long long int p = a;\n\
    \    long long int q = a;\n    long \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphdnj0k3u.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphdnj0k3u.cpp:69:19: error: redeclaration of \u2018long long int a\u2019\
    \n   69 |     long long int a = a;\n      |                   ^\n/tmp/tmphdnj0k3u.cpp:17:19:\
    \ note: \u2018long long int a\u2019 previously declared here\n   17 |     long\
    \ long int a = stoi(value);\n      |                   ^\n/tmp/tmphdnj0k3u.cpp:70:19:\
    \ error: redeclaration of \u2018long long int b\u2019\n   70 |     long long int\
    \ b = a;\n      |                   ^\n/tmp/tmphdnj0k3u.cpp:18:19: note: \u2018\
    long long int b\u2019 previously declared here\n   18 |     long long int b =\
    \ a;\n      |                   ^\n/tmp/tmphdnj0k3u.cpp:71:19: error: redeclaration\
    \ of \u2018long long int c\u2019\n   71 |     long long int c = a;\n      |  \
    \                 ^\n/tmp/tmphdnj0k3u.cpp:19:19: note: \u2018long long int c\u2019\
    \ previously declared here\n   19 |     long long int c = a;\n      |        \
    \           ^\n/tmp/tmphdnj0k3u.cpp:72:19: error: redeclaration of \u2018long\
    \ long int d\u2019\n   72 |     long long int d = a;\n      |                \
    \   ^\n/tmp/tmphdnj0k3u.cpp:20:19: note: \u2018long long int d\u2019 previously\
    \ declared here\n   20 |     long long int d = a;\n      |                   ^\n\
    /tmp/tmphdnj0k3u.cpp:73:19: error: redeclaration of \u2018long long int e\u2019\
    \n   73 |     long long int e = a;\n      |                   ^\n/tmp/tmphdnj0k3u.cpp:21:19:\
    \ note: \u2018long long int e\u2019 previously declared here\n   21 |     long\
    \ long int e = a;\n      |                   ^\n/tmp/tmphdnj0k3u.cpp:74:19: error:\
    \ redeclaration of \u2018long long int f\u2019\n   74 |     long long int f =\
    \ a;\n      |                   ^\n/tmp/tmphdnj0k3u.cpp:22:19: note: \u2018long\
    \ long int f\u2019 previously declared here\n   22 |     long long int f = a;\n\
    \      |                   ^\n/tmp/tmphdnj0k3u.cpp:75:19: error: redeclaration\
    \ of \u2018long long int g\u2019\n   75 |     long long int g = a;\n      |  \
    \                 ^\n/tmp/tmphdnj0k3u.cpp:23:19: note: \u2018long long int g\u2019\
    \ previously declared here\n   23 |     long long int g = a;\n      |        \
    \           ^\n/tmp/tmphdnj0k3u.cpp:76:19: error: redeclaration of \u2018long\
    \ long int h\u2019\n   76 |   "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0, power = 1;\n    long\
    \ num = std::stoll(value);\n    while(num > 0) {\n        ans += num % 10;\n \
    \       num /= 10;\n        power *= 10;\n    }\n    while(power > 1) {\n    \
    \    ans -= power % 10;\n        power /= 10;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpjtcvluno: /tmp/tmpjtcvluno.cpp:33: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, i = 0;\n    long sum = 0;\n\
    \    long temp;\n    long diff = abs(atoi(value.c_str()));\n    long min = diff;\n\
    \    long max = diff;\n    long mid = 0;\n    long mid2;\n    long mid3;\n   \
    \ long mid4;\n    long mid5;\n    long mid6;\n    long mid7;\n    long mid8;\n\
    \    long mid9;\n    long mid10;\n    long mid11;\n    long mid12;\n    long mid13;\n\
    \    long mid14;\n    long mid15;\n    long mid16;\n    long mid17;\n    long\
    \ mid18;\n    long mid19;\n    long mid20;\n    long mid21;\n    long mid22;\n\
    \    long mid23;\n    long mid24;\n    long mid25;\n    long mid26;\n    long\
    \ mid27;\n    long mid28;\n    long mid29;\n    long mid30;\n    long mid31;\n\
    \    long mid32;\n    long mid33;\n    long mid34;\n    long mid35;\n    long\
    \ mid36;\n    long mid37;\n    long mid38;\n    long mid39;\n    long mid40;\n\
    \    long mid41;\n    long mid42;\n    long mid43;\n    long mid44;\n    long\
    \ mid45;\n    long mid46;\n    long mid47;\n    long mid48;\n    long mid49;\n\
    \    long mid50;\n    long mid51;\n    long mid52;\n    long mid53;\n    long\
    \ mid54;\n    long mid55;\n    long mid56;\n    long mid57;\n    long mid58;\n\
    \    long mid59;\n    long mid60;\n    long mid61;\n    long mid62;\n    long\
    \ mid63;\n    long mid64;\n    long mid65;\n    long mid66;\n    long mid67;\n\
    \    long mid68;\n    long mid69;\n    long mid70;\n    long mid71;\n    long\
    \ mid72;\n    long mid73;\n    long mid74;\n    long mid75;\n    long mid76;\n\
    \    long mid77;\n    long mid78;\n    long mid79;\n    long mid80;\n    long\
    \ mid81;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpco0eom5h: /tmp/tmpco0eom5h.cpp:110: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n\
    \    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long\
    \ r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n\
    \    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long\
    \ b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n\
    \    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long\
    \ k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n\
    \    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long\
    \ t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n\
    \    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long\
    \ C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n\
    \    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long\
    \ L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n\
    \    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long\
    \ U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n\
    \    long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long\
    \ d = 0;\n    long e\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj8qg_kbt.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpj8qg_kbt.cpp:72:10: error: redeclaration of \u2018long int i\u2019\n\
    \   72 |     long i = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:20:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   20 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpj8qg_kbt.cpp:73:10: error: redeclaration of \u2018\
    long int j\u2019\n   73 |     long j = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:21:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   21 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:74:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   74 |     long k = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:22:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   22 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:75:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   75 |     long l = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:23:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   23 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:76:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   76 |     long m = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:24:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   24 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:77:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   77 |     long n = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:25:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   25 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:78:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   78 |     long o = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:26:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   26 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:79:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   79 |     long p = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:27:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   27 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:80:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   80 |     long q = 0;\n      |          ^\n/tmp/tmpj8qg_kbt.cpp:28:10:\
    \ note: \u2018long int q\u2019 previously declared here\n   28 |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long diff\
    \ = n - ans;\n    long mid = diff / 2;\n    long left = ans - mid;\n    long right\
    \ = ans + mid;\n    if (diff % 2 == 0) {\n        if (left > right) {\n      \
    \      ans = right;\n        } else {\n            ans = left;\n        }\n  \
    \  } else {\n        if (left > right) {\n            ans = left;\n        } else\
    \ {\n            ans = right;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk0x673ea.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpk0x673ea.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmpk0x673ea.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n\
    \    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9\
    \ = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n   \
    \ long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxn7s6wck.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxn7s6wck.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpxn7s6wck.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long diff = std::abs(num - ans);\n    while (diff > 1) {\n        diff /=\
    \ 10;\n        ans += diff;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbih38qua.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpbih38qua.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = std::abs(num - ans);\n      |          ^~~~\n/tmp/tmpbih38qua.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long temp = 0;\n   \
    \ long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 =\
    \ 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj1i65yqv.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpj1i65yqv.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpj1i65yqv.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = std::abs(atoi(value.c_str()));\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff\
    \ = std::abs(diff);\n    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n\
    \    long diff = std::abs(diff);\n    long diff = std::abs(diff);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7_0xxar3.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp7_0xxar3.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = std::abs(diff);\n      |          ^~~~\n/tmp/tmp7_0xxar3.cpp:18:10:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long diff\
    \ = std::abs(atoi(value.c_str()));\n      |          ^~~~\n/tmp/tmp7_0xxar3.cpp:20:10:\
    \ error: redeclaration of \u2018long int diff\u2019\n   20 |     long diff = std::abs(diff);\n\
    \      |          ^~~~\n/tmp/tmp7_0xxar3.cpp:18:10: note: \u2018long int diff\u2019\
    \ previously declared here\n   18 |     long diff = std::abs(atoi(value.c_str()));\n\
    \      |          ^~~~\n/tmp/tmp7_0xxar3.cpp:21:10: error: redeclaration of \u2018\
    long int diff\u2019\n   21 |     long diff = std::abs(diff);\n      |        \
    \  ^~~~\n/tmp/tmp7_0xxar3.cpp:18:10: note: \u2018long int diff\u2019 previously\
    \ declared here\n   18 |     long diff = std::abs(atoi(value.c_str()));\n    \
    \  |          ^~~~\n/tmp/tmp7_0xxar3.cpp:22:10: error: redeclaration of \u2018\
    long int diff\u2019\n   22 |     long diff = std::abs(diff);\n      |        \
    \  ^~~~\n/tmp/tmp7_0xxar3.cpp:18:10: note: \u2018long int diff\u2019 previously\
    \ declared here\n   18 |     long diff = std::abs(atoi(value.c_str()));\n    \
    \  |          ^~~~\n/tmp/tmp7_0xxar3.cpp:23:10: error: redeclaration of \u2018\
    long int diff\u2019\n   23 |     long diff = std::abs(diff);\n      |        \
    \  ^~~~\n/tmp/tmp7_0xxar3.cpp:18:10: note: \u2018long int diff\u2019 previously\
    \ declared here\n   18 |     long diff = std::abs(atoi(value.c_str()));\n    \
    \  |          ^~~~\n/tmp/tmp7_0xxar3.cpp:24:10: error: redeclaration of \u2018\
    long int diff\u2019\n   24 |     long diff = std::abs(diff);\n      |        \
    \  ^~~~\n/tmp/tmp7_0xxar3.cpp:18:10: note: \u2018long int diff\u2019 previously\
    \ declared here\n   18 |     long diff = std::abs(atoi(value.c_str()));\n    \
    \  |          ^~~~\n/tmp/tmp7_0xxar3.cpp:25:10: error: redeclaration of \u2018\
    long int diff\u2019\n   25 |     long diff = std::abs(diff);\n      |        \
    \  ^~~~\n/tmp/tmp7_0xxar3.cpp:18:10: note: \u2018long int diff\u2019 previously\
    \ declared here\n   18 |     long diff = std::abs(atoi(value.c_str()));\n    \
    \  |          ^~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int num;\n    long long int diff;\n    long long int\
    \ temp;\n    long long int temp2;\n    long long int temp3;\n    long long int\
    \ temp4;\n    long long int temp5;\n    long long int temp6;\n    long long int\
    \ temp7;\n    long long int temp8;\n    long long int temp9;\n    long long int\
    \ temp10;\n    long long int temp11;\n    long long int temp12;\n    long long\
    \ int temp13;\n    long long int temp14;\n    long long int temp15;\n    long\
    \ long int temp16;\n    long long int temp17;\n    long long int temp18;\n   \
    \ long long int temp19;\n    long long int temp20;\n    long long int temp21;\n\
    \    long long int temp22;\n    long long int temp23;\n    long long int temp24;\n\
    \    long long int temp25;\n    long long int temp26;\n    long long int temp27;\n\
    \    long long int temp28;\n    long long int temp29;\n    long long int temp30;\n\
    \    long long int temp31;\n    long long int temp32;\n    long long int temp33;\n\
    \    long long int temp34;\n    long long int temp35;\n    long long int temp36;\n\
    \    long long int temp37;\n    long long int temp38;\n    long long int temp39;\n\
    \    long long int temp40;\n    long long int temp41;\n    long long int temp42;\n\
    \    long long int temp43;\n    long long int temp44;\n    long long int temp45;\n\
    \    long long int temp46;\n    long long int temp47;\n    long long int temp48;\n\
    \    long long int temp49;\n    long long int temp50;\n    long long int temp51;\n\
    \    long long int temp52;\n    long long int temp53;\n    long long int temp54;\n\
    \    long long int temp55;\n    long long int temp56;\n    long long int temp57;\n\
    \    long long int temp58;\n    long long int temp59;\n    long long int temp60;\n\
    \    long long int temp61;\n    long long int temp62;\n    long long int temp63;\n\
    \    long long int temp64;\n    long long int temp65\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjwtiw8jl.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjwtiw8jl.cpp:84:1: error: expected initializer before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmpjwtiw8jl.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int a = stoi(value);\n    long long int b = stoi(value);\n\
    \    long long int c = stoi(value);\n    long long int d = stoi(value);\n    long\
    \ long int e = stoi(value);\n    long long int f = stoi(value);\n    long long\
    \ int g = stoi(value);\n    long long int h = stoi(value);\n    long long int\
    \ i = stoi(value);\n    long long int j = stoi(value);\n    long long int k =\
    \ stoi(value);\n    long long int l = stoi(value);\n    long long int m = stoi(value);\n\
    \    long long int n = stoi(value);\n    long long int o = stoi(value);\n    long\
    \ long int p = stoi(value);\n    long long int q = stoi(value);\n    long long\
    \ int r = stoi(value);\n    long long int s = stoi(value);\n    long long int\
    \ t = stoi(value);\n    long long int u = stoi(value);\n    long long int v =\
    \ stoi(value);\n    long long int w = stoi(value);\n    long long int x = stoi(value);\n\
    \    long long int y = stoi(value);\n    long long int z = stoi(value);\n    long\
    \ long int a = stoi(value);\n    long long int b = stoi(value);\n    long long\
    \ int c = stoi(value);\n    long long int d = stoi(value);\n    long long int\
    \ e = stoi(value);\n    long long int f = stoi(value);\n    long long int g =\
    \ stoi(value);\n    long long int h = stoi(value);\n    long long int i = stoi(value);\n\
    \    long long int j = stoi(value);\n    long long int k = stoi(value);\n    long\
    \ long int l = stoi(value);\n    long long int m = stoi(value);\n    long long\
    \ int n = stoi(value);\n    long long int o = stoi(value);\n    long long int\
    \ p = stoi(value);\n    long long int q = stoi(value);\n    long long int r =\
    \ stoi(value);\n    long long int s = stoi(value);\n    long long int t = stoi(value);\n\
    \    long long int u = stoi(value);\n    long long int v = stoi(value);\n    long\
    \ long int w = stoi(value);\n    long long int x = stoi(value);\n    long long\
    \ int y = stoi(value);\n    long long int z = stoi(value);\n    long long int\
    \ a = stoi(value);\n    long long int b = stoi(value);\n    long long int c =\
    \ stoi(value);\n    long long int d = stoi(value);\n    long long int e = stoi(value);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0sbgzidh.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp0sbgzidh.cpp:43:19: error: redeclaration of \u2018long long int a\u2019\
    \n   43 |     long long int a = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:17:19:\
    \ note: \u2018long long int a\u2019 previously declared here\n   17 |     long\
    \ long int a = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:44:19:\
    \ error: redeclaration of \u2018long long int b\u2019\n   44 |     long long int\
    \ b = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:18:19: note:\
    \ \u2018long long int b\u2019 previously declared here\n   18 |     long long\
    \ int b = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:45:19:\
    \ error: redeclaration of \u2018long long int c\u2019\n   45 |     long long int\
    \ c = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:19:19: note:\
    \ \u2018long long int c\u2019 previously declared here\n   19 |     long long\
    \ int c = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:46:19:\
    \ error: redeclaration of \u2018long long int d\u2019\n   46 |     long long int\
    \ d = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:20:19: note:\
    \ \u2018long long int d\u2019 previously declared here\n   20 |     long long\
    \ int d = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:47:19:\
    \ error: redeclaration of \u2018long long int e\u2019\n   47 |     long long int\
    \ e = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:21:19: note:\
    \ \u2018long long int e\u2019 previously declared here\n   21 |     long long\
    \ int e = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:48:19:\
    \ error: redeclaration of \u2018long long int f\u2019\n   48 |     long long int\
    \ f = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:22:19: note:\
    \ \u2018long long int f\u2019 previously declared here\n   22 |     long long\
    \ int f = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:49:19:\
    \ error: redeclaration of \u2018long long int g\u2019\n   49 |     long long int\
    \ g = stoi(value);\n      |                   ^\n/tmp/tmp0sbgzidh.cpp:23:19: note:\
    \ \u2018long long int g\u2019 previously declared here\n   23 |     long long"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0;\n    long temp;\n \
    \   long diff = abs(atoi(value.c_str()));\n    long sum = 0;\n    long count =\
    \ 0;\n    long temp1 = abs(atoi(value.c_str()));\n    long temp2 = abs(atoi(value.c_str()));\n\
    \    long temp3 = abs(atoi(value.c_str()));\n    long temp4 = abs(atoi(value.c_str()));\n\
    \    long temp5 = abs(atoi(value.c_str()));\n    long temp6 = abs(atoi(value.c_str()));\n\
    \    long temp7 = abs(atoi(value.c_str()));\n    long temp8 = abs(atoi(value.c_str()));\n\
    \    long temp9 = abs(atoi(value.c_str()));\n    long temp10 = abs(atoi(value.c_str()));\n\
    \    long temp11 = abs(atoi(value.c_str()));\n    long temp12 = abs(atoi(value.c_str()));\n\
    \    long temp13 = abs(atoi(value.c_str()));\n    long temp14 = abs(atoi(value.c_str()));\n\
    \    long temp15 = abs(atoi(value.c_str()));\n    long temp16 = abs(atoi(value.c_str()));\n\
    \    long temp17 = abs(atoi(value.c_str()));\n    long temp18 = abs(atoi(value.c_str()));\n\
    \    long temp19 = abs(atoi(value.c_str()));\n    long temp20 = abs(atoi(value.c_str()));\n\
    \    long temp21 = abs(atoi(value.c_str()));\n    long temp22 = abs(atoi(value.c_str()));\n\
    \    long temp23 = abs(atoi(value.c_str()));\n    long temp24 = abs(atoi(value.c_str()));\n\
    \    long temp25 = abs(atoi(value.c_str()));\n    long temp26 = abs(atoi(value.c_str()));\n\
    \    long temp27 = abs(atoi(value.c_str()));\n    long temp28 = abs(atoi(value.c_str()));\n\
    \    long temp29 = abs(atoi(value.c_str()));\n    long temp30 = abs(atoi(value.c_str()));\n\
    \    long temp31 = abs(atoi(value.c_str()));\n    long temp32 = abs(atoi(value.c_str()));\n\
    \    long temp33 = abs(atoi(value.c_str()));\n    long temp34 = abs(atoi(value.c_str()));\n\
    \    long temp35 = abs(atoi(value.c_str()));\n    long temp36 = abs(atoi(value.c_str()));\n\
    \    long temp37 = abs(atoi(value.c_str()));\n    long temp38 = abs(atoi\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp36gxqtdw.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp36gxqtdw.cpp:60:27: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   60 |     long temp38 = abs(atoi\n      |                      ~  \
    \  ^\n      |                           )\n   61 | }\n      | ~              \
    \            \n/tmp/tmp36gxqtdw.cpp:61:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   61 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long temp = 0;\n   \
    \ long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m =\
    \ 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n   \
    \ long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v =\
    \ 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n   \
    \ long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E =\
    \ 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n   \
    \ long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N =\
    \ 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n   \
    \ long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W =\
    \ 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n   \
    \ long b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f =\
    \ 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n   \
    \ long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o =\
    \ 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n   \
    \ long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x =\
    \ 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n   \
    \ long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G =\
    \ 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n   \
    \ long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P =\
    \ 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n   \
    \ long U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y =\
    \ 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n   \
    \ long d = 0;\n    long e\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplch3k82r.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplch3k82r.cpp:72:10: error: redeclaration of \u2018long int i\u2019\n\
    \   72 |     long i = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:20:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   20 |     long i = 0;\n \
    \     |          ^\n/tmp/tmplch3k82r.cpp:73:10: error: redeclaration of \u2018\
    long int j\u2019\n   73 |     long j = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:21:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   21 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:74:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   74 |     long k = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:22:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   22 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:75:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   75 |     long l = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:23:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   23 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:76:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   76 |     long m = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:24:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   24 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:77:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   77 |     long n = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:25:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   25 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:78:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   78 |     long o = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:26:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   26 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:79:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   79 |     long p = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:27:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   27 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:80:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   80 |     long q = 0;\n      |          ^\n/tmp/tmplch3k82r.cpp:28:10:\
    \ note: \u2018long int q\u2019 previously declared here\n   28 |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long x = 0,\
    \ y = 0;\n    long xx = 0, yy = 0;\n    long xy = 0, yx = 0, xx = 0, yy = 0, xy\
    \ = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy = 0, yx = 0, xx =\
    \ 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx = 0, xx = 0, yy = 0,\
    \ xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy = 0, yx = 0, xx\
    \ = 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx = 0, xx = 0, yy =\
    \ 0, xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy = 0, yx = 0,\
    \ xx = 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx = 0, xx = 0, yy\
    \ = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy = 0, yx =\
    \ 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx = 0, xx = 0,\
    \ yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy = 0, yx\
    \ = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx = 0, xx =\
    \ 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy = 0,\
    \ yx = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx = 0, xx\
    \ = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy =\
    \ 0, yx = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx = 0,\
    \ xx = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0, xy\
    \ = 0, yx = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0;\n    long xy = 0, yx =\
    \ 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n    long xx = 0, yy = 0,\
    \ xy = 0, yx = 0, xx = 0, y\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpllu8sqxf.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpllu8sqxf.cpp:21:26: error: redeclaration of \u2018long int xx\u2019\
    \n   21 |     long xy = 0, yx = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy\
    \ = 0;\n      |                          ^~\n/tmp/tmpllu8sqxf.cpp:20:10: note:\
    \ \u2018long int xx\u2019 previously declared here\n   20 |     long xx = 0, yy\
    \ = 0;\n      |          ^~\n/tmp/tmpllu8sqxf.cpp:21:34: error: redeclaration\
    \ of \u2018long int yy\u2019\n   21 |     long xy = 0, yx = 0, xx = 0, yy = 0,\
    \ xy = 0, yx = 0, xx = 0, yy = 0;\n      |                                  ^~\n\
    /tmp/tmpllu8sqxf.cpp:20:18: note: \u2018long int yy\u2019 previously declared\
    \ here\n   20 |     long xx = 0, yy = 0;\n      |                  ^~\n/tmp/tmpllu8sqxf.cpp:21:42:\
    \ error: redeclaration of \u2018long int xy\u2019\n   21 |     long xy = 0, yx\
    \ = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n      |              \
    \                            ^~\n/tmp/tmpllu8sqxf.cpp:21:10: note: \u2018long\
    \ int xy\u2019 previously declared here\n   21 |     long xy = 0, yx = 0, xx =\
    \ 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n      |          ^~\n/tmp/tmpllu8sqxf.cpp:21:50:\
    \ error: redeclaration of \u2018long int yx\u2019\n   21 |     long xy = 0, yx\
    \ = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n      |              \
    \                                    ^~\n/tmp/tmpllu8sqxf.cpp:21:18: note: \u2018\
    long int yx\u2019 previously declared here\n   21 |     long xy = 0, yx = 0, xx\
    \ = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy = 0;\n      |                  ^~\n\
    /tmp/tmpllu8sqxf.cpp:21:58: error: redeclaration of \u2018long int xx\u2019\n\
    \   21 |     long xy = 0, yx = 0, xx = 0, yy = 0, xy = 0, yx = 0, xx = 0, yy =\
    \ 0;\n      |                                                          ^~\n/tmp/tmpllu8sqxf.cpp:20:10:\
    \ note: \u2018long int xx\u2019 previously declared here\n   20 |     long xx\
    \ = 0, yy = 0;\n      |          ^~\n/tmp/tmpllu8sqxf.cpp:21:66: error: redeclaration\
    \ of \u2018long int yy\u2019\n   21 |     long xy = 0, yx = 0, xx = 0, yy = 0,\
    \ xy = 0, yx = 0, xx = 0, yy = 0;\n      |                                   \
    \                               ^~\n/tmp/tmpllu8s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, power = 1;\n    long long num = std::stoll(value);\n\
    \    while(power < num) {\n        ans += power;\n        power *= 10;\n    }\n\
    \    while(power > num) {\n        ans -= power;\n        power *= 10;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmphd_z3j5z: /tmp/tmphd_z3j5z.cpp:31: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long sum = 0;\n    long\
    \ mid = 0;\n    long diff2 = 0;\n    long sum2 = 0;\n    long mid2 = 0;\n    long\
    \ diff3 = 0;\n    long sum3 = 0;\n    long mid3 = 0;\n    long diff4 = 0;\n  \
    \  long sum4 = 0;\n    long mid4 = 0;\n    long diff5 = 0;\n    long sum5 = 0;\n\
    \    long mid5 = 0;\n    long diff6 = 0;\n    long sum6 = 0;\n    long mid6 =\
    \ 0;\n    long diff7 = 0;\n    long sum7 = 0;\n    long mid7 = 0;\n    long diff8\
    \ = 0;\n    long sum8 = 0;\n    long mid8 = 0;\n    long diff9 = 0;\n    long\
    \ sum9 = 0;\n    long mid9 = 0;\n    long diff10 = 0;\n    long sum10 = 0;\n \
    \   long mid10 = 0;\n    long diff11 = 0;\n    long sum11 = 0;\n    long mid11\
    \ = 0;\n    long diff12 = 0;\n    long sum12 = 0;\n    long mid12 = 0;\n    long\
    \ diff13 = 0;\n    long sum13 = 0;\n    long mid13 = 0;\n    long diff14 = 0;\n\
    \    long sum14 = 0;\n    long mid14 = 0;\n    long diff15 = 0;\n    long sum15\
    \ = 0;\n    long mid15 = 0;\n    long diff16 = 0;\n    long sum16 = 0;\n    long\
    \ mid16 = 0;\n    long diff17 = 0;\n    long sum17 = 0;\n    long mid17 = 0;\n\
    \    long diff18 = 0;\n    long sum18 = 0;\n    long mid18 = 0;\n    long diff19\
    \ = 0;\n    long sum19 = 0;\n    long mid19 = 0;\n    long diff20 = 0;\n    long\
    \ sum20 = 0;\n    long mid20 = 0;\n    long diff21 = 0;\n    long sum21 = 0;\n\
    \    long mid21 = 0;\n    long diff22 = 0;\n    long sum22 = 0;\n    long mid22\
    \ = 0;\n    long diff23 = 0;\n    long sum23 = 0;\n    long mid23 = 0;\n    long\
    \ diff24 = 0;\n    long sum24 = 0;\n    long mid24 = 0;\n    long diff25 = 0;\n\
    \    long sum25 = 0;\n    long mid25 = 0;\n    long diff26 = 0;\n    long sum26\
    \ = 0;\n    long mid26 = 0;\n    long diff27 = 0;\n    long sum27 = 0;\n    long\
    \ mid27 = 0;\n    long diff28 = 0;\n    long sum28 = 0;\n    long mid28 = 0;\n\
    \    long diff29 = 0;\n    long sum29 = 0;\n    long mid29 = 0;\n\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpmi9rp4d9: /tmp/tmpmi9rp4d9.cpp:109: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long diff\
    \ = n - ans;\n    long mod = n - diff;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkuk83uyy.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpkuk83uyy.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmpkuk83uyy.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmpkuk83uyy.cpp:21:10:\
    \ error: redeclaration of \u2018long int mod\u2019\n   21 |     long mod = mod\
    \ % 10;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:20:10: note: \u2018long int\
    \ mod\u2019 previously declared here\n   20 |     long mod = n - diff;\n     \
    \ |          ^~~\n/tmp/tmpkuk83uyy.cpp:22:10: error: redeclaration of \u2018long\
    \ int mod\u2019\n   22 |     long mod = mod % 10;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:20:10:\
    \ note: \u2018long int mod\u2019 previously declared here\n   20 |     long mod\
    \ = n - diff;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:23:10: error: redeclaration\
    \ of \u2018long int mod\u2019\n   23 |     long mod = mod % 10;\n      |     \
    \     ^~~\n/tmp/tmpkuk83uyy.cpp:20:10: note: \u2018long int mod\u2019 previously\
    \ declared here\n   20 |     long mod = n - diff;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:24:10:\
    \ error: redeclaration of \u2018long int mod\u2019\n   24 |     long mod = mod\
    \ % 10;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:20:10: note: \u2018long int\
    \ mod\u2019 previously declared here\n   20 |     long mod = n - diff;\n     \
    \ |          ^~~\n/tmp/tmpkuk83uyy.cpp:25:10: error: redeclaration of \u2018long\
    \ int mod\u2019\n   25 |     long mod = mod % 10;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:20:10:\
    \ note: \u2018long int mod\u2019 previously declared here\n   20 |     long mod\
    \ = n - diff;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:26:10: error: redeclaration\
    \ of \u2018long int mod\u2019\n   26 |     long mod = mod % 10;\n      |     \
    \     ^~~\n/tmp/tmpkuk83uyy.cpp:20:10: note: \u2018long int mod\u2019 previously\
    \ declared here\n   20 |     long mod = n - diff;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:27:10:\
    \ error: redeclaration of \u2018long int mod\u2019\n   27 |     long mod = mod\
    \ % 10;\n      |          ^~~\n/tmp/tmpkuk83uyy.cpp:20:10: note: \u2018long int\
    \ mod\u2019 previously declared here\n   20 |     long mo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0, temp = 0;\n    long\
    \ long int temp2 = 0, temp3 = 0, temp4 = 0;\n    long long int temp5 = 0, temp6\
    \ = 0, temp7 = 0;\n    long long int temp8 = 0, temp9 = 0;\n    long long int\
    \ temp10 = 0;\n    long long int temp11 = 0;\n    long long int temp12 = 0;\n\
    \    long long int temp13 = 0;\n    long long int temp14 = 0;\n    long long int\
    \ temp15 = 0;\n    long long int temp16 = 0;\n    long long int temp17 = 0;\n\
    \    long long int temp18 = 0;\n    long long int temp19 = 0;\n    long long int\
    \ temp20 = 0;\n    long long int temp21 = 0;\n    long long int temp22 = 0;\n\
    \    long long int temp23 = 0;\n    long long int temp24 = 0;\n    long long int\
    \ temp25 = 0;\n    long long int temp26 = 0;\n    long long int temp27 = 0;\n\
    \    long long int temp28 = 0;\n    long long int temp29 = 0;\n    long long int\
    \ temp30 = 0;\n    long long int temp31 = 0;\n    long long int temp32 = 0;\n\
    \    long long int temp33 = 0;\n    long long int temp34 = 0;\n    long long int\
    \ temp35 = 0;\n    long long int temp36 = 0;\n    long long int temp37 = 0;\n\
    \    long long int temp38 = 0;\n    long long int temp39 = 0;\n    long long int\
    \ temp40 = 0;\n    long long int temp41 = 0;\n    long long int temp42 = 0;\n\
    \    long long int temp43 = 0;\n    long long int temp44 = 0;\n    long long int\
    \ temp45 = 0;\n    long long int temp46 = 0;\n    long long int temp47 = 0;\n\
    \    long long int temp48 = 0;\n    long long int temp49 = 0;\n    long long int\
    \ temp50 = 0;\n    long long int temp51 = 0;\n    long long int temp52 = 0;\n\
    \    long long int temp53 = 0;\n    long long int temp54 = 0;\n    long long int\
    \ temp55 = 0;\n    long long int temp56 = 0;\n    long long int temp57 = 0;\n\
    \    long long int temp58 = 0;\n    long long int temp59 = 0;\n    long long int\
    \ temp60 = 0;\n    long long int temp61 = 0;\n    long long int temp62 = 0;\n\
    \    long long int temp63 = 0;\n    long long int temp64 = 0;\n    long long int\
    \ temp65 = 0;\n    long long int temp66 = 0;\n    long long int temp\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl8edhd5w.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpl8edhd5w.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmpl8edhd5w.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long temp = 0;\n   \
    \ long sum = 0;\n    long count = 0;\n    long i = 0;\n    long j = 0;\n    long\
    \ k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n\
    \    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long\
    \ t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n\
    \    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long\
    \ C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n\
    \    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long\
    \ L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n\
    \    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long\
    \ U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n\
    \    long Z = 0;\n    long AA = 0;\n    long BB = 0;\n    long CC = 0;\n    long\
    \ DD = 0;\n    long EE = 0;\n    long FF = 0;\n    long GG = 0;\n    long HH =\
    \ 0;\n    long II = 0;\n    long JJ = 0;\n    long KK = 0;\n    long LL = 0;\n\
    \    long MM = 0;\n    long NN = 0;\n    long OO = 0;\n    long PP = 0;\n    long\
    \ QQ = 0;\n    long RR = 0;\n    long SS = 0;\n    long TT = 0;\n    long UU =\
    \ 0;\n    long VV = 0;\n    long WW = 0;\n    long XX = 0;\n    long YY = 0;\n\
    \    long ZZ = 0;\n    long AAA = 0;\n    long BBB = 0;\n    long CCC = 0;\n \
    \   long DDD = 0;\n    long EEE = 0;\n    long FFF = 0;\n    long GGG = 0;\n \
    \   long HHH = 0;\n    long III = 0;\n    long JJJ = 0;\n    long KKK = 0;\n \
    \   long LLL = 0;\n    long MMM = 0;\n    long NNN = 0;\n    long OOO = 0;\n \
    \   long PPP = 0;\n    long QQQ = 0;\n    long RRR = 0;\n    long SSS = 0;\n \
    \   long TTT = 0;\n    long UUU = 0;\n    long VVV = 0;\n    long WWW = 0;\n \
    \   long XXX\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7brfl7gc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp7brfl7gc.cpp:116:1: error: expected initializer before \u2018}\u2019\
    \ token\n  116 | }\n      | ^\n/tmp/tmp7brfl7gc.cpp:116:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    long long temp2;\n\
    \    long long temp3;\n    long long temp4;\n    long long temp5;\n    long long\
    \ temp6;\n    long long temp7;\n    long long temp8;\n    long long temp9;\n \
    \   long long temp10;\n    long long temp11;\n    long long temp12;\n    long\
    \ long temp13;\n    long long temp14;\n    long long temp15;\n    long long temp16;\n\
    \    long long temp17;\n    long long temp18;\n    long long temp19;\n    long\
    \ long temp20;\n    long long temp21;\n    long long temp22;\n    long long temp23;\n\
    \    long long temp24;\n    long long temp25;\n    long long temp26;\n    long\
    \ long temp27;\n    long long temp28;\n    long long temp29;\n    long long temp30;\n\
    \    long long temp31;\n    long long temp32;\n    long long temp33;\n    long\
    \ long temp34;\n    long long temp35;\n    long long temp36;\n    long long temp37;\n\
    \    long long temp38;\n    long long temp39;\n    long long temp40;\n    long\
    \ long temp41;\n    long long temp42;\n    long long temp43;\n    long long temp44;\n\
    \    long long temp45;\n    long long temp46;\n    long long temp47;\n    long\
    \ long temp48;\n    long long temp49;\n    long long temp50;\n    long long temp51;\n\
    \    long long temp52;\n    long long temp53;\n    long long temp54;\n    long\
    \ long temp55;\n    long long temp56;\n    long long temp57;\n    long long temp58;\n\
    \    long long temp59;\n    long long temp60;\n    long long temp61;\n    long\
    \ long temp62;\n    long long temp63;\n    long long temp64;\n    long long temp65;\n\
    \    long long temp66;\n    long long temp67;\n    long long temp68;\n    long\
    \ long temp69;\n    long long temp70;\n    long long temp71;\n    long long temp72;\n\
    \    long long temp73;\n    long long temp74;\n    long long temp75;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp34ljtbj4: /tmp/tmp34ljtbj4.cpp:96: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, sign = 1;\n    // If value is negative, make it\
    \ positive\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n\
    \    }\n    // Parse the number into an integer and add it to the answer\n   \
    \ long num = std::stoll(value);\n    ans += num * sign;\n    // If the number\
    \ is equidistant from two integers, round it away from zero\n    if (num > 0)\
    \ {\n        ans -= num / 2;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpfhvhs0l8: /tmp/tmpfhvhs0l8.cpp:34: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, power = 0, diff = 0;\n  \
    \  long num = std::stoi(value);\n    long diff = num - ans;\n    while(diff >=\
    \ 0) {\n        diff /= 10;\n        power++;\n    }\n    diff = num - ans;\n\
    \    while(diff < 0) {\n        diff *= 10;\n        power--;\n    }\n    while(power\
    \ > 0) {\n        ans += diff;\n        diff /= 10;\n        power--;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3wx7t0qa.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp3wx7t0qa.cpp:20:10: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |     long diff = num - ans;\n      |          ^~~~\n/tmp/tmp3wx7t0qa.cpp:18:30:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long ans\
    \ = 0, power = 0, diff = 0;\n      |                              ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int val = 0;\n    long long int minVal = std::numeric_limits<long\
    \ long int>::max();\n    long long int maxVal = std::numeric_limits<long long\
    \ int>::min();\n    long long int midVal = 0;\n    long long int midVal2 = 0;\n\
    \    long long int midVal3 = 0;\n    long long int midVal4 = 0;\n    long long\
    \ int midVal5 = 0;\n    long long int midVal6 = 0;\n    long long int midVal7\
    \ = 0;\n    long long int midVal8 = 0;\n    long long int midVal9 = 0;\n    long\
    \ long int midVal10 = 0;\n    long long int midVal11 = 0;\n    long long int midVal12\
    \ = 0;\n    long long int midVal13 = 0;\n    long long int midVal14 = 0;\n   \
    \ long long int midVal15 = 0;\n    long long int midVal16 = 0;\n    long long\
    \ int midVal17 = 0;\n    long long int midVal18 = 0;\n    long long int midVal19\
    \ = 0;\n    long long int midVal20 = 0;\n    long long int midVal21 = 0;\n   \
    \ long long int midVal22 = 0;\n    long long int midVal23 = 0;\n    long long\
    \ int midVal24 = 0;\n    long long int midVal25 = 0;\n    long long int midVal26\
    \ = 0;\n    long long int midVal27 = 0;\n    long long int midVal28 = 0;\n   \
    \ long long int midVal29 = 0;\n    long long int midVal30 = 0;\n    long long\
    \ int midVal31 = 0;\n    long long int midVal32 = 0;\n    long long int midVal33\
    \ = 0;\n    long long int midVal34 = 0;\n    long long int midVal35 = 0;\n   \
    \ long long int midVal36 = 0;\n    long long int midVal37 = 0;\n    long long\
    \ int midVal38 = 0;\n    long long int midVal39 = 0;\n    long long int midVal40\
    \ = 0;\n    long long int midVal41 = 0;\n    long long int midVal42 = 0;\n   \
    \ long long int midVal43 = 0;\n    long long int midVal44 = 0;\n    long long\
    \ int midVal45 = 0;\n    long long int midVal46 = 0;\n    long long int midVal47\
    \ = 0;\n    long long int midVal48 = 0;\n    long long int midVal49 = 0;\n   \
    \ long long int midVal50 = 0;\n    long long int midVal51 = 0;\n    long long\
    \ int midVal52 = 0;\n    long long int midVal\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprcj2rhsg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmprcj2rhsg.cpp:73:1: error: expected initializer before \u2018}\u2019\
    \ token\n   73 | }\n      | ^\n/tmp/tmprcj2rhsg.cpp:73:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ int temp = 0;\n    long long int temp2 = 0;\n    long long int temp3 = 0;\n\
    \    long long int temp4 = 0;\n    long long int temp5 = 0;\n    long long int\
    \ temp6 = 0;\n    long long int temp7 = 0;\n    long long int temp8 = 0;\n   \
    \ long long int temp9 = 0;\n    long long int temp10 = 0;\n    long long int temp11\
    \ = 0;\n    long long int temp12 = 0;\n    long long int temp13 = 0;\n    long\
    \ long int temp14 = 0;\n    long long int temp15 = 0;\n    long long int temp16\
    \ = 0;\n    long long int temp17 = 0;\n    long long int temp18 = 0;\n    long\
    \ long int temp19 = 0;\n    long long int temp20 = 0;\n    long long int temp21\
    \ = 0;\n    long long int temp22 = 0;\n    long long int temp23 = 0;\n    long\
    \ long int temp24 = 0;\n    long long int temp25 = 0;\n    long long int temp26\
    \ = 0;\n    long long int temp27 = 0;\n    long long int temp28 = 0;\n    long\
    \ long int temp29 = 0;\n    long long int temp30 = 0;\n    long long int temp31\
    \ = 0;\n    long long int temp32 = 0;\n    long long int temp33 = 0;\n    long\
    \ long int temp34 = 0;\n    long long int temp35 = 0;\n    long long int temp36\
    \ = 0;\n    long long int temp37 = 0;\n    long long int temp38 = 0;\n    long\
    \ long int temp39 = 0;\n    long long int temp40 = 0;\n    long long int temp41\
    \ = 0;\n    long long int temp42 = 0;\n    long long int temp43 = 0;\n    long\
    \ long int temp44 = 0;\n    long long int temp45 = 0;\n    long long int temp46\
    \ = 0;\n    long long int temp47 = 0;\n    long long int temp48 = 0;\n    long\
    \ long int temp49 = 0;\n    long long int temp50 = 0;\n    long long int temp51\
    \ = 0;\n    long long int temp52 = 0;\n    long long int temp53 = 0;\n    long\
    \ long int temp54 = 0;\n    long long int temp55 = 0;\n    long long int temp56\
    \ = 0;\n    long long int temp57 = 0;\n    long long int temp58 = 0;\n    long\
    \ long int temp59 = 0;\n    long long int temp60 = 0;\n    long long int temp61\
    \ = 0;\n    long long int temp62 = 0;\n    long long int temp63 = 0;\n\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpge2jq9ur: /tmp/tmpge2jq9ur.cpp:86: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long d = std::stoll(value);\n    long x = std::stoll(value);\n\
    \    long y = std::stoll(value);\n    long z = std::stoll(value);\n    long a\
    \ = std::stoll(value);\n    long b = std::stoll(value);\n    long c = std::stoll(value);\n\
    \    long d = std::stoll(value);\n    long e = std::stoll(value);\n    long f\
    \ = std::stoll(value);\n    long g = std::stoll(value);\n    long h = std::stoll(value);\n\
    \    long i = std::stoll(value);\n    long j = std::stoll(value);\n    long k\
    \ = std::stoll(value);\n    long l = std::stoll(value);\n    long m = std::stoll(value);\n\
    \    long n = std::stoll(value);\n    long o = std::stoll(value);\n    long p\
    \ = std::stoll(value);\n    long q = std::stoll(value);\n    long r = std::stoll(value);\n\
    \    long s = std::stoll(value);\n    long t = std::stoll(value);\n    long u\
    \ = std::stoll(value);\n    long v = std::stoll(value);\n    long w = std::stoll(value);\n\
    \    long x = std::stoll(value);\n    long y = std::stoll(value);\n    long z\
    \ = std::stoll(value);\n    long a = std::stoll(value);\n    long b = std::stoll(value);\n\
    \    long c = std::stoll(value);\n    long d = std::stoll(value);\n    long e\
    \ = std::stoll(value);\n    long f = std::stoll(value);\n    long g = std::stoll(value);\n\
    \    long h = std::stoll(value);\n    long i = std::stoll(value);\n    long j\
    \ = std::stoll(value);\n    long k = std::stoll(value);\n    long l = std::stoll(value);\n\
    \    long m = std::stoll(value);\n    long n = std::stoll(value);\n    long o\
    \ = std::stoll(value);\n    long p = std::stoll(value);\n    long q = std::stoll(value);\n\
    \    long r = std::stoll(value);\n    long s = std::stoll(value);\n    long t\
    \ = std::stoll(value);\n    long u = std::stoll(value);\n    long v = std::stoll(value);\n\
    \    long w = std::stoll(value);\n    long x = std::stoll(value);\n    long y\
    \ = std::stoll(value);\n    long z = std::stoll(value);\n    long a = \n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjww0us1j.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjww0us1j.cpp:25:10: error: redeclaration of \u2018long int d\u2019\n\
    \   25 |     long d = std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:18:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   18 |     long d =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:45:10: error: redeclaration\
    \ of \u2018long int x\u2019\n   45 |     long x = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpjww0us1j.cpp:19:10: note: \u2018long int x\u2019 previously\
    \ declared here\n   19 |     long x = std::stoll(value);\n      |          ^\n\
    /tmp/tmpjww0us1j.cpp:46:10: error: redeclaration of \u2018long int y\u2019\n \
    \  46 |     long y = std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:20:10:\
    \ note: \u2018long int y\u2019 previously declared here\n   20 |     long y =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:47:10: error: redeclaration\
    \ of \u2018long int z\u2019\n   47 |     long z = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpjww0us1j.cpp:21:10: note: \u2018long int z\u2019 previously\
    \ declared here\n   21 |     long z = std::stoll(value);\n      |          ^\n\
    /tmp/tmpjww0us1j.cpp:48:10: error: redeclaration of \u2018long int a\u2019\n \
    \  48 |     long a = std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:22:10:\
    \ note: \u2018long int a\u2019 previously declared here\n   22 |     long a =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:49:10: error: redeclaration\
    \ of \u2018long int b\u2019\n   49 |     long b = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpjww0us1j.cpp:23:10: note: \u2018long int b\u2019 previously\
    \ declared here\n   23 |     long b = std::stoll(value);\n      |          ^\n\
    /tmp/tmpjww0us1j.cpp:50:10: error: redeclaration of \u2018long int c\u2019\n \
    \  50 |     long c = std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:24:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   24 |     long c =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpjww0us1j.cpp:51:10: error: redeclaration\
    \ of \u2018long int d\u2019\n   51 |     long d = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpjww0us1j.cpp:18:10: note: \u2018long int d\u2019 previously\
    \ declar"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n  \
    \  long mid = 0;\n    long diff = 0;\n    long closest_val = std::numeric_limits<long>::max();\n\
    \    long closest_diff = 0;\n    long closest_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_diff = 0;\n    long closest_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_diff = 0;\n    long closest_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_diff = 0;\n    long closest_int_int_int_int_val\
    \ = std::numeric_limits<long>::max();\n    long closest_int_int_int_int_diff =\
    \ 0;\n    long closest_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_int_int_diff = 0;\n    long closest_int_int_int_int_int_int_val\
    \ = std::numeric_limits<long>::max();\n    long closest_int_int_int_int_int_int_diff\
    \ = 0;\n    long closest_int_int_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_int_int_int_int_diff = 0;\n    long closest_int_int_int_int_int_int_int_int_val\
    \ = std::numeric_limits<long>::max();\n    long closest_int_int_int_int_int_int_int_int_diff\
    \ = 0;\n    long closest_int_int_int_int_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_int_int_int_int_int_int_diff = 0;\n    long closest_int_int_int_int_int_int_int_int_int_val\
    \ = std::numeric_limits<long>::max();\n    long closest_int_int_int_int_int_int_int_int_int_int_diff\
    \ = 0;\n    long closest_int_int_int_int_int_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_int_int_int_int_int_int_int_int_diff = 0;\n    long\
    \ closest_int_int_int_int_int_int_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_int_int_int_int_int_int_int_int_int_diff = 0;\n\
    \    long closest_int_int_int_int_int_int_int_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_int_int_int_int_int_int_int_int_int_int_diff = 0;\n\
    \    long closest_int_int_int_int_int_int_int_int_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \    long closest_int_int_int_int_int_int_int_int_int_int_int_int_int_\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpua0kuboe.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpua0kuboe.cpp:40:10: error: redeclaration of \u2018long int closest_int_int_int_int_int_int_int_int_int_val\u2019\
    \n   40 |     long closest_int_int_int_int_int_int_int_int_int_val = std::numeric_limits<long>::max();\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpua0kuboe.cpp:38:10:\
    \ note: \u2018long int closest_int_int_int_int_int_int_int_int_int_val\u2019 previously\
    \ declared here\n   38 |     long closest_int_int_int_int_int_int_int_int_int_val\
    \ = std::numeric_limits<long>::max();\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpua0kuboe.cpp:50:1: error: expected initializer before \u2018}\u2019 token\n\
    \   50 | }\n      | ^\n/tmp/tmpua0kuboe.cpp:50:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long l = 0;\n    long\
    \ r = 100;\n    long mid = 0;\n    long diff = 0;\n    long mid2 = 0;\n    long\
    \ diff2 = 0;\n    long mid3 = 0;\n    long diff3 = 0;\n    long mid4 = 0;\n  \
    \  long diff4 = 0;\n    long mid5 = 0;\n    long diff5 = 0;\n    long mid6 = 0;\n\
    \    long diff6 = 0;\n    long mid7 = 0;\n    long diff7 = 0;\n    long mid8 =\
    \ 0;\n    long diff8 = 0;\n    long mid9 = 0;\n    long diff9 = 0;\n    long mid10\
    \ = 0;\n    long diff10 = 0;\n    long mid11 = 0;\n    long diff11 = 0;\n    long\
    \ mid12 = 0;\n    long diff12 = 0;\n    long mid13 = 0;\n    long diff13 = 0;\n\
    \    long mid14 = 0;\n    long diff14 = 0;\n    long mid15 = 0;\n    long diff15\
    \ = 0;\n    long mid16 = 0;\n    long diff16 = 0;\n    long mid17 = 0;\n    long\
    \ diff17 = 0;\n    long mid18 = 0;\n    long diff18 = 0;\n    long mid19 = 0;\n\
    \    long diff19 = 0;\n    long mid20 = 0;\n    long diff20 = 0;\n    long mid21\
    \ = 0;\n    long diff21 = 0;\n    long mid22 = 0;\n    long diff22 = 0;\n    long\
    \ mid23 = 0;\n    long diff23 = 0;\n    long mid24 = 0;\n    long diff24 = 0;\n\
    \    long mid25 = 0;\n    long diff25 = 0;\n    long mid26 = 0;\n    long diff26\
    \ = 0;\n    long mid27 = 0;\n    long diff27 = 0;\n    long mid28 = 0;\n    long\
    \ diff28 = 0;\n    long mid29 = 0;\n    long diff29 = 0;\n    long mid30 = 0;\n\
    \    long diff30 = 0;\n    long mid31 = 0;\n    long diff31 = 0;\n    long mid32\
    \ = 0;\n    long diff32 = 0;\n    long mid33 = 0;\n    long diff33 = 0;\n    long\
    \ mid34 = 0;\n    long diff34 = 0;\n    long mid35 = 0;\n    long diff35 = 0;\n\
    \    long mid36 = 0;\n    long diff36 = 0;\n    long mid37 = 0;\n    long diff37\
    \ = 0;\n    long mid38 = 0;\n    long diff38 = 0;\n    long mid39 = 0;\n    long\
    \ diff39 = 0;\n    long mid40 = 0;\n    long diff40 = 0;\n    long mid41 = 0;\n\
    \    long diff41 = 0;\n    long mid42 = 0;\n    long diff42\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6fc4rsei.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6fc4rsei.cpp:105:1: error: expected initializer before \u2018}\u2019\
    \ token\n  105 | }\n      | ^\n/tmp/tmp6fc4rsei.cpp:105:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long temp = 0;\n   \
    \ long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 =\
    \ 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe71i76m9.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpe71i76m9.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpe71i76m9.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = std::abs(atoi(value.c_str()));\n\
    \    long min = std::abs(atoi(value.substr(0, value.size()-1).c_str()));\n   \
    \ long max = std::abs(atoi(value.substr(1, value.size()-1).c_str()));\n    long\
    \ mid = min + (max - min) / 2;\n    if (diff == min) {\n        ans = mid;\n \
    \   } else if (diff == max) {\n        ans = mid;\n    } else {\n        ans =\
    \ mid;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpt3l1wd1j: /tmp/tmpt3l1wd1j.cpp:33: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int num = atoll(value.c_str());\n    long long int closest;\n\
    \    long long int diff;\n    if (num < 0)\n        closest = -num;\n    else\n\
    \        closest = num;\n    diff = closest - num;\n    if (diff < 0)\n      \
    \  diff += num;\n    return diff;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp720n3w8a: /tmp/tmp720n3w8a.cpp:31: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long diff\
    \ = upper - lower;\n    long mid = lower + (diff / 2);\n    if (diff % 2 == 0)\
    \ {\n        if (mid < lower) {\n            return lower;\n        } else if\
    \ (mid > upper) {\n            return upper;\n        } else {\n            return\
    \ mid;\n        }\n    } else {\n        if (mid < lower) {\n            return\
    \ lower;\n        } else if (mid > upper) {\n            return upper;\n     \
    \   } else {\n            return mid;\n        }\n    }\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp__9lj4jy: /tmp/tmp__9lj4jy.cpp:40: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    long long temp2;\n\
    \    long long temp3;\n    long long temp4;\n    long long temp5;\n    long long\
    \ temp6;\n    long long temp7;\n    long long temp8;\n    long long temp9;\n \
    \   long long temp10;\n    long long temp11;\n    long long temp12;\n    long\
    \ long temp13;\n    long long temp14;\n    long long temp15;\n    long long temp16;\n\
    \    long long temp17;\n    long long temp18;\n    long long temp19;\n    long\
    \ long temp20;\n    long long temp21;\n    long long temp22;\n    long long temp23;\n\
    \    long long temp24;\n    long long temp25;\n    long long temp26;\n    long\
    \ long temp27;\n    long long temp28;\n    long long temp29;\n    long long temp30;\n\
    \    long long temp31;\n    long long temp32;\n    long long temp33;\n    long\
    \ long temp34;\n    long long temp35;\n    long long temp36;\n    long long temp37;\n\
    \    long long temp38;\n    long long temp39;\n    long long temp40;\n    long\
    \ long temp41;\n    long long temp42;\n    long long temp43;\n    long long temp44;\n\
    \    long long temp45;\n    long long temp46;\n    long long temp47;\n    long\
    \ long temp48;\n    long long temp49;\n    long long temp50;\n    long long temp51;\n\
    \    long long temp52;\n    long long temp53;\n    long long temp54;\n    long\
    \ long temp55;\n    long long temp56;\n    long long temp57;\n    long long temp58;\n\
    \    long long temp59;\n    long long temp60;\n    long long temp61;\n    long\
    \ long temp62;\n    long long temp63;\n    long long temp64;\n    long long temp65;\n\
    \    long long temp66;\n    long long temp67;\n    long long temp68;\n    long\
    \ long temp69;\n    long long temp70;\n    long long temp71;\n    long long temp72;\n\
    \    long long temp73;\n    long long temp74;\n    long long temp75;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp2cmy3yap: /tmp/tmp2cmy3yap.cpp:96: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n  \
    \  long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ diff2 = 0;\n    long diff3 = 0;\n    long diff4 = 0;\n    long diff5 = 0;\n\
    \    long diff6 = 0;\n    long diff7 = 0;\n    long diff8 = 0;\n    long diff9\
    \ = 0;\n    long diff10 = 0;\n    long diff11 = 0;\n    long diff12 = 0;\n   \
    \ long diff13 = 0;\n    long diff14 = 0;\n    long diff15 = 0;\n    long diff16\
    \ = 0;\n    long diff17 = 0;\n    long diff18 = 0;\n    long diff19 = 0;\n   \
    \ long diff20 = 0;\n    long diff21 = 0;\n    long diff22 = 0;\n    long diff23\
    \ = 0;\n    long diff24 = 0;\n    long diff25 = 0;\n    long diff26 = 0;\n   \
    \ long diff27 = 0;\n    long diff28 = 0;\n    long diff29 = 0;\n    long diff30\
    \ = 0;\n    long diff31 = 0;\n    long diff32 = 0;\n    long diff33 = 0;\n   \
    \ long diff34 = 0;\n    long diff35 = 0;\n    long diff36 = 0;\n    long diff37\
    \ = 0;\n    long diff38 = 0;\n    long diff39 = 0;\n    long diff40 = 0;\n   \
    \ long diff41 = 0;\n    long diff42 = 0;\n    long diff43 = 0;\n    long diff44\
    \ = 0;\n    long diff45 = 0;\n    long diff46 = 0;\n    long diff47 = 0;\n   \
    \ long diff48 = 0;\n    long diff49 = 0;\n    long diff50 = 0;\n    long diff51\
    \ = 0;\n    long diff52 = 0;\n    long diff53 = 0;\n    long diff54 = 0;\n   \
    \ long diff55 = 0;\n    long diff56 = 0;\n    long diff57 = 0;\n    long diff58\
    \ = 0;\n    long diff59 = 0;\n    long diff60 = 0;\n    long diff61 = 0;\n   \
    \ long diff62 = 0;\n    long diff63 = 0;\n    long diff64 = 0;\n    long diff65\
    \ = 0;\n    long diff66 = 0;\n    long diff67 = 0;\n    long diff68 = 0;\n   \
    \ long diff69 = 0;\n    long diff70 = 0;\n    long diff71 = 0;\n    long diff72\
    \ = 0;\n    long diff73 = 0;\n    long diff74 = 0;\n    long diff75 = 0;\n   \
    \ long diff76 = 0;\n    long diff77 = 0;\n    long diff78 = 0;\n    long diff79\
    \ = 0;\n    long diff80 = 0;\n    long diff81 = 0;\n    long diff\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq1u4m13w.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpq1u4m13w.cpp:101:1: error: expected initializer before \u2018}\u2019\
    \ token\n  101 | }\n      | ^\n/tmp/tmpq1u4m13w.cpp:101:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long diff\
    \ = n - ans;\n    long mod = n - diff;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n    long mod = mod % 10;\n    long mod\
    \ = mod % 10;\n    long mod = mod % 10;\n\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6f_9jcgs.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6f_9jcgs.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmp6f_9jcgs.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmp6f_9jcgs.cpp:21:10:\
    \ error: redeclaration of \u2018long int mod\u2019\n   21 |     long mod = mod\
    \ % 10;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:20:10: note: \u2018long int\
    \ mod\u2019 previously declared here\n   20 |     long mod = n - diff;\n     \
    \ |          ^~~\n/tmp/tmp6f_9jcgs.cpp:22:10: error: redeclaration of \u2018long\
    \ int mod\u2019\n   22 |     long mod = mod % 10;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:20:10:\
    \ note: \u2018long int mod\u2019 previously declared here\n   20 |     long mod\
    \ = n - diff;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:23:10: error: redeclaration\
    \ of \u2018long int mod\u2019\n   23 |     long mod = mod % 10;\n      |     \
    \     ^~~\n/tmp/tmp6f_9jcgs.cpp:20:10: note: \u2018long int mod\u2019 previously\
    \ declared here\n   20 |     long mod = n - diff;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:24:10:\
    \ error: redeclaration of \u2018long int mod\u2019\n   24 |     long mod = mod\
    \ % 10;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:20:10: note: \u2018long int\
    \ mod\u2019 previously declared here\n   20 |     long mod = n - diff;\n     \
    \ |          ^~~\n/tmp/tmp6f_9jcgs.cpp:25:10: error: redeclaration of \u2018long\
    \ int mod\u2019\n   25 |     long mod = mod % 10;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:20:10:\
    \ note: \u2018long int mod\u2019 previously declared here\n   20 |     long mod\
    \ = n - diff;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:26:10: error: redeclaration\
    \ of \u2018long int mod\u2019\n   26 |     long mod = mod % 10;\n      |     \
    \     ^~~\n/tmp/tmp6f_9jcgs.cpp:20:10: note: \u2018long int mod\u2019 previously\
    \ declared here\n   20 |     long mod = n - diff;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:27:10:\
    \ error: redeclaration of \u2018long int mod\u2019\n   27 |     long mod = mod\
    \ % 10;\n      |          ^~~\n/tmp/tmp6f_9jcgs.cpp:20:10: note: \u2018long int\
    \ mod\u2019 previously declared here\n   20 |     long mo"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = atoi(value.c_str());\n    long diff = abs(ans - ans);\n\
    \    if (diff < 1) {\n        return ans;\n    }\n    long mid = ans / 2;\n  \
    \  long mid2 = mid / 2;\n    if (abs(mid - mid2) < diff) {\n        return mid;\n\
    \    }\n    return mid2;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp3k6tflji: /tmp/tmp3k6tflji.cpp:32: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int x = 0;\n    long long int y = 0;\n    long long\
    \ int z = 0;\n    long long int xx = 0, yy = 0, zz = 0;\n    long long int xy\
    \ = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n    long\
    \ long int xw = 0, yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz = 0;\n\
    \    long long int xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz = 0,\
    \ zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n    long long int xx =\
    \ 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0, zzz = 0;\n    long long\
    \ int xz = 0, yz = 0, zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n  \
    \  long long int xx = 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0, zzz\
    \ = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n    long long int xw = 0,\
    \ yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz = 0;\n    long long int\
    \ xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n    long\
    \ long int xw = 0, yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz = 0;\n\
    \    long long int xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz = 0,\
    \ zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n    long long int xx =\
    \ 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0, zzz = 0;\n    long long\
    \ int xz = 0, yz = 0, zzz = 0;\n    long long int xw = 0, yw = 0, zw = 0;\n  \
    \  long long int xx = 0, yy = 0, zz = 0;\n    long long int xy = 0, yz = 0, zzz\
    \ = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n    long long int xw = 0,\
    \ yw = 0, zw = 0;\n    long long int xx = 0, yy = 0, zz = 0;\n    long long int\
    \ xy = 0, yz = 0, zzz = 0;\n    long long int xz = 0, yz = 0, zzz = 0;\n    long\
    \ long int xw = 0, yw = 0, \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqk8e3y7t.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpqk8e3y7t.cpp:22:27: error: redeclaration of \u2018long long int yz\u2019\
    \n   22 |     long long int xz = 0, yz = 0, zzz = 0;\n      |                \
    \           ^~\n/tmp/tmpqk8e3y7t.cpp:21:27: note: \u2018long long int yz\u2019\
    \ previously declared here\n   21 |     long long int xy = 0, yz = 0, zzz = 0;\n\
    \      |                           ^~\n/tmp/tmpqk8e3y7t.cpp:22:35: error: redeclaration\
    \ of \u2018long long int zzz\u2019\n   22 |     long long int xz = 0, yz = 0,\
    \ zzz = 0;\n      |                                   ^~~\n/tmp/tmpqk8e3y7t.cpp:21:35:\
    \ note: \u2018long long int zzz\u2019 previously declared here\n   21 |     long\
    \ long int xy = 0, yz = 0, zzz = 0;\n      |                                 \
    \  ^~~\n/tmp/tmpqk8e3y7t.cpp:24:19: error: redeclaration of \u2018long long int\
    \ xx\u2019\n   24 |     long long int xx = 0, yy = 0, zz = 0;\n      |       \
    \            ^~\n/tmp/tmpqk8e3y7t.cpp:20:19: note: \u2018long long int xx\u2019\
    \ previously declared here\n   20 |     long long int xx = 0, yy = 0, zz = 0;\n\
    \      |                   ^~\n/tmp/tmpqk8e3y7t.cpp:24:27: error: redeclaration\
    \ of \u2018long long int yy\u2019\n   24 |     long long int xx = 0, yy = 0, zz\
    \ = 0;\n      |                           ^~\n/tmp/tmpqk8e3y7t.cpp:20:27: note:\
    \ \u2018long long int yy\u2019 previously declared here\n   20 |     long long\
    \ int xx = 0, yy = 0, zz = 0;\n      |                           ^~\n/tmp/tmpqk8e3y7t.cpp:24:35:\
    \ error: redeclaration of \u2018long long int zz\u2019\n   24 |     long long\
    \ int xx = 0, yy = 0, zz = 0;\n      |                                   ^~\n\
    /tmp/tmpqk8e3y7t.cpp:20:35: note: \u2018long long int zz\u2019 previously declared\
    \ here\n   20 |     long long int xx = 0, yy = 0, zz = 0;\n      |           \
    \                        ^~\n/tmp/tmpqk8e3y7t.cpp:25:19: error: redeclaration\
    \ of \u2018long long int xy\u2019\n   25 |     long long int xy = 0, yz = 0, zzz\
    \ = 0;\n      |                   ^~\n/tmp/tmpqk8e3y7t.cpp:21:19: note: \u2018\
    long long int xy\u2019 previously declared here\n   21 |     long long int xy\
    \ = 0, yz = 0, zzz = 0;\n      |                   ^~\n/tmp/tmpqk8e3y7t.cpp:25:2"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long a = stoi(value);\n\
    \    long b = ans;\n    long c = a;\n    long d = b;\n    long e = c;\n    long\
    \ f = d;\n    long g = e;\n    long h = f;\n    long i = g;\n    long j = h;\n\
    \    long k = i;\n    long l = j;\n    long m = k;\n    long n = l;\n    long\
    \ o = m;\n    long p = n;\n    long q = o;\n    long r = p;\n    long s = q;\n\
    \    long t = r;\n    long u = s;\n    long v = t;\n    long w = u;\n    long\
    \ x = v;\n    long y = w;\n    long z = x;\n    long a = y;\n    long b = z;\n\
    \    long c = a;\n    long d = b;\n    long e = c;\n    long f = d;\n    long\
    \ g = e;\n    long h = f;\n    long i = g;\n    long j = h;\n    long k = i;\n\
    \    long l = j;\n    long m = k;\n    long n = l;\n    long o = m;\n    long\
    \ p = n;\n    long q = o;\n    long r = p;\n    long s = q;\n    long t = r;\n\
    \    long u = s;\n    long v = t;\n    long w = u;\n    long x = v;\n    long\
    \ y = w;\n    long z = x;\n    long a = y;\n    long b = z;\n    long c = a;\n\
    \    long d = b;\n    long e = c;\n    long f = d;\n    long g = e;\n    long\
    \ h = f;\n    long i = g;\n    long j = h;\n    long k = i;\n    long l = j;\n\
    \    long m = k;\n    long n = l;\n    long o = m;\n    long p = n;\n    long\
    \ q = o;\n    long r = p;\n    long s = q;\n    long t = r;\n    long u = s;\n\
    \    long v = t;\n    long w = u;\n    long x = v;\n    long y = w;\n    long\
    \ z = x;\n    long a = y;\n    long b = z;\n    long c = a;\n    long d = b;\n\
    \    long e = c;\n    long f = d;\n    long g = e;\n    long h = f;\n    long\
    \ i = g;\n    long j = h;\n    long k = i;\n    long l = j;\n    long m = k;\n\
    \    long n = l;\n    long o = m;\n    long p = n;\n    long q = o;\n\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9shetq47.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9shetq47.cpp:45:10: error: redeclaration of \u2018long int a\u2019\n\
    \   45 |     long a = y;\n      |          ^\n/tmp/tmp9shetq47.cpp:19:10: note:\
    \ \u2018long int a\u2019 previously declared here\n   19 |     long a = stoi(value);\n\
    \      |          ^\n/tmp/tmp9shetq47.cpp:46:10: error: redeclaration of \u2018\
    long int b\u2019\n   46 |     long b = z;\n      |          ^\n/tmp/tmp9shetq47.cpp:20:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   20 |     long b =\
    \ ans;\n      |          ^\n/tmp/tmp9shetq47.cpp:47:10: error: redeclaration of\
    \ \u2018long int c\u2019\n   47 |     long c = a;\n      |          ^\n/tmp/tmp9shetq47.cpp:21:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   21 |     long c =\
    \ a;\n      |          ^\n/tmp/tmp9shetq47.cpp:48:10: error: redeclaration of\
    \ \u2018long int d\u2019\n   48 |     long d = b;\n      |          ^\n/tmp/tmp9shetq47.cpp:22:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   22 |     long d =\
    \ b;\n      |          ^\n/tmp/tmp9shetq47.cpp:49:10: error: redeclaration of\
    \ \u2018long int e\u2019\n   49 |     long e = c;\n      |          ^\n/tmp/tmp9shetq47.cpp:23:10:\
    \ note: \u2018long int e\u2019 previously declared here\n   23 |     long e =\
    \ c;\n      |          ^\n/tmp/tmp9shetq47.cpp:50:10: error: redeclaration of\
    \ \u2018long int f\u2019\n   50 |     long f = d;\n      |          ^\n/tmp/tmp9shetq47.cpp:24:10:\
    \ note: \u2018long int f\u2019 previously declared here\n   24 |     long f =\
    \ d;\n      |          ^\n/tmp/tmp9shetq47.cpp:51:10: error: redeclaration of\
    \ \u2018long int g\u2019\n   51 |     long g = e;\n      |          ^\n/tmp/tmp9shetq47.cpp:25:10:\
    \ note: \u2018long int g\u2019 previously declared here\n   25 |     long g =\
    \ e;\n      |          ^\n/tmp/tmp9shetq47.cpp:52:10: error: redeclaration of\
    \ \u2018long int h\u2019\n   52 |     long h = f;\n      |          ^\n/tmp/tmp9shetq47.cpp:26:10:\
    \ note: \u2018long int h\u2019 previously declared here\n   26 |     long h =\
    \ f;\n      |          ^\n/tmp/tmp9shetq47.cpp:53:10: error: redeclaration of\
    \ \u2018long int i\u2019\n   53 |     long i = g;\n      |          ^\n/tmp/tmp9shetq47.cpp:27:10:\
    \ note: \u2018long int i\u2019 previously declared he"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long x = atoi(value.c_str());\n    long y =\
    \ atoi(value.c_str());\n    long diff = abs(x - y);\n    if (diff > 1) {\n   \
    \     diff = diff - 1;\n    }\n    ans = x;\n    if (diff > 0) {\n        ans\
    \ = x + diff;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpf8axtbil: /tmp/tmpf8axtbil.cpp:33: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long temp = 0;\n   \
    \ long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 =\
    \ 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long\
    \ temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n\
    \    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppdq24ym6.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppdq24ym6.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmppdq24ym6.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0, sign = 1;\n   \
    \ long long num;\n    long long temp;\n    temp = stoi(value);\n    num = temp;\n\
    \    while(num != 0){\n        diff = num % 10;\n        ans = ans + diff * sign;\n\
    \        sign *= -1;\n        num /= 10;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpluq80vc6: /tmp/tmpluq80vc6.cpp:33: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long num =\
    \ std::stoll(value);\n    long diff = abs(num - ans);\n    long mid = diff / 2;\n\
    \    if (num == ans) {\n        return num;\n    }\n    if (num < ans) {\n   \
    \     ans = num;\n    }\n    if (num > ans) {\n        ans = num;\n    }\n   \
    \ if (mid == 0) {\n        return ans;\n    }\n    if (num < ans) {\n        ans\
    \ = num;\n    }\n    if (num > ans) {\n        ans = num;\n    }\n    if (num\
    \ < ans) {\n        ans = num;\n    }\n    if (num > ans) {\n        ans = num;\n\
    \    }\n    if (num < ans) {\n        ans = num;\n    }\n    if (num > ans) {\n\
    \        ans = num;\n    }\n    if (num < ans) {\n        ans = num;\n    }\n\
    \    if (num > ans) {\n        ans = num;\n    }\n    if (num < ans) {\n     \
    \   ans = num;\n    }\n    if (num > ans) {\n        ans = num;\n    }\n    if\
    \ (num < ans) {\n        ans = num;\n    }\n    if (num > ans) {\n        ans\
    \ = num;\n    }\n    if (num < ans) {\n        ans = num;\n    }\n    if (num\
    \ > ans) {\n        ans = num;\n    }\n    if (num < ans) {\n        ans = num;\n\
    \    }\n    if (num > ans) {\n        ans = num;\n    }\n    if (num < ans) {\n\
    \        ans = num;\n    }\n    if (num > ans) {\n        ans = num;\n    }\n\
    \    if (num < ans) {\n        ans = num;\n    }\n    if (num > ans) {\n     \
    \   ans = num;\n    }\n    if (num < ans) {\n        ans = num;\n    }\n    if\
    \ (num > ans) {\n        ans = num;\n    }\n    if (num < ans) {\n        ans\
    \ = num;\n    }\n    if (num > ans) {\n        ans = num;\n    }\n    if (num\
    \ < ans) {\n        ans = num;\n    }\n    if (num > ans) {\n        ans = num;\n\
    \    }\n    if (num < ans) {\n        ans = num;\n    }\n    if (num > ans) {\n\
    \        ans = num;\n    }\n    if (num < ans) {\n        ans = num;\n    }\n\
    \    if (num > ans) {\n        ans = num;\n    }\n    if (num\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphhxviod3.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphhxviod3.cpp:20:10: error: redeclaration of \u2018long int diff\u2019\
    \n   20 |     long diff = abs(num - ans);\n      |          ^~~~\n/tmp/tmphhxviod3.cpp:18:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmphhxviod3.cpp:124:12:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n  124 |     if (num\n\
    \      |        ~   ^\n      |            )\n  125 | }\n      | ~           \n\
    /tmp/tmphhxviod3.cpp:125:1: error: expected primary-expression before \u2018}\u2019\
    \ token\n  125 | }\n      | ^\n/tmp/tmphhxviod3.cpp:125:1: warning: control reaches\
    \ end of non-void function [-Wreturn-type]\n  125 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int lower = 0, upper = std::numeric_limits<long long\
    \ int>::max();\n    long long int mid = 0;\n    long long int closest = 0;\n \
    \   long long int diff = 0;\n    long long int diff2 = 0;\n    long long int diff3\
    \ = 0;\n    long long int diff4 = 0;\n    long long int diff5 = 0;\n    long long\
    \ int diff6 = 0;\n    long long int diff7 = 0;\n    long long int diff8 = 0;\n\
    \    long long int diff9 = 0;\n    long long int diff10 = 0;\n    long long int\
    \ diff11 = 0;\n    long long int diff12 = 0;\n    long long int diff13 = 0;\n\
    \    long long int diff14 = 0;\n    long long int diff15 = 0;\n    long long int\
    \ diff16 = 0;\n    long long int diff17 = 0;\n    long long int diff18 = 0;\n\
    \    long long int diff19 = 0;\n    long long int diff20 = 0;\n    long long int\
    \ diff21 = 0;\n    long long int diff22 = 0;\n    long long int diff23 = 0;\n\
    \    long long int diff24 = 0;\n    long long int diff25 = 0;\n    long long int\
    \ diff26 = 0;\n    long long int diff27 = 0;\n    long long int diff28 = 0;\n\
    \    long long int diff29 = 0;\n    long long int diff30 = 0;\n    long long int\
    \ diff31 = 0;\n    long long int diff32 = 0;\n    long long int diff33 = 0;\n\
    \    long long int diff34 = 0;\n    long long int diff35 = 0;\n    long long int\
    \ diff36 = 0;\n    long long int diff37 = 0;\n    long long int diff38 = 0;\n\
    \    long long int diff39 = 0;\n    long long int diff40 = 0;\n    long long int\
    \ diff41 = 0;\n    long long int diff42 = 0;\n    long long int diff43 = 0;\n\
    \    long long int diff44 = 0;\n    long long int diff45 = 0;\n    long long int\
    \ diff46 = 0;\n    long long int diff47 = 0;\n    long long int diff48 = 0;\n\
    \    long long int diff49 = 0;\n    long long int diff50 = 0;\n    long long int\
    \ diff51 = 0;\n    long long int diff52 = 0;\n    long long int diff53 = 0;\n\
    \    long long int diff54 = 0;\n    long long int diff55 = 0;\n    long long int\
    \ diff56 = 0;\n    long long int diff57 = 0;\n    long long int diff58 = 0;\n\
    \    long long int diff59 = 0;\n    long long int diff60 = 0;\n    long long \n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu5cddxnb.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpu5cddxnb.cpp:81:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   81 | }\n      | ^\n/tmp/tmpu5cddxnb.cpp:81:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ temp;\n    temp = atof(value.c_str());\n    diff = temp - ans;\n    ans = temp;\n\
    \    while(diff > 0){\n        diff /= 10;\n        ans++;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpblot4lk0: /tmp/tmpblot4lk0.cpp:31: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = abs(atoi(value.c_str()));\n   \
    \ long maxDiff = abs(ans);\n    long minDiff = abs(ans);\n    long mid = diff\
    \ / 2;\n    long mid2 = diff / 2;\n    long mid3 = diff / 2;\n    long mid4 =\
    \ diff / 2;\n    long mid5 = diff / 2;\n    long mid6 = diff / 2;\n    long mid7\
    \ = diff / 2;\n    long mid8 = diff / 2;\n    long mid9 = diff / 2;\n    long\
    \ mid10 = diff / 2;\n    long mid11 = diff / 2;\n    long mid12 = diff / 2;\n\
    \    long mid13 = diff / 2;\n    long mid14 = diff / 2;\n    long mid15 = diff\
    \ / 2;\n    long mid16 = diff / 2;\n    long mid17 = diff / 2;\n    long mid18\
    \ = diff / 2;\n    long mid19 = diff / 2;\n    long mid20 = diff / 2;\n    long\
    \ mid21 = diff / 2;\n    long mid22 = diff / 2;\n    long mid23 = diff / 2;\n\
    \    long mid24 = diff / 2;\n    long mid25 = diff / 2;\n    long mid26 = diff\
    \ / 2;\n    long mid27 = diff / 2;\n    long mid28 = diff / 2;\n    long mid29\
    \ = diff / 2;\n    long mid30 = diff / 2;\n    long mid31 = diff / 2;\n    long\
    \ mid32 = diff / 2;\n    long mid33 = diff / 2;\n    long mid34 = diff / 2;\n\
    \    long mid35 = diff / 2;\n    long mid36 = diff / 2;\n    long mid37 = diff\
    \ / 2;\n    long mid38 = diff / 2;\n    long mid39 = diff / 2;\n    long mid40\
    \ = diff / 2;\n    long mid41 = diff / 2;\n    long mid42 = diff / 2;\n    long\
    \ mid43 = diff / 2;\n    long mid44 = diff / 2;\n    long mid45 = diff / 2;\n\
    \    long mid46 = diff / 2;\n    long mid47 = diff / 2;\n    long mid48 = diff\
    \ / 2;\n    long mid49 = diff / 2;\n    long mid50 = diff / 2;\n    long mid51\
    \ = diff / 2;\n    long mid52 = diff / 2;\n    long mid53 = diff / 2;\n    long\
    \ mid54 = diff / 2;\n    long mid55\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkozy_6a5.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpkozy_6a5.cpp:76:1: error: expected initializer before \u2018}\u2019\
    \ token\n   76 | }\n      | ^\n/tmp/tmpkozy_6a5.cpp:76:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long diff = num - ans;\n    long mod = diff % 10;\n    long diff = diff /\
    \ 10;\n    if (diff > 0 && mod < 5) {\n        ans += diff;\n    } else if (diff\
    \ > 0 && mod < 3) {\n        ans += diff + 1;\n    } else if (diff > 0 && mod\
    \ < 1) {\n        ans += diff + 2;\n    } else if (diff > 0 && mod < 2) {\n  \
    \      ans += diff + 3;\n    } else if (diff > 0 && mod < 4) {\n        ans +=\
    \ diff + 4;\n    } else if (diff > 0 && mod < 5) {\n        ans += diff + 5;\n\
    \    } else if (diff > 0 && mod < 6) {\n        ans += diff + 6;\n    } else if\
    \ (diff > 0 && mod < 7) {\n        ans += diff + 7;\n    } else if (diff > 0 &&\
    \ mod < 8) {\n        ans += diff + 8;\n    } else if (diff > 0 && mod < 9) {\n\
    \        ans += diff + 9;\n    } else if (diff > 0 && mod < 10) {\n        ans\
    \ += diff + 10;\n    } else if (diff > 0 && mod < 11) {\n        ans += diff +\
    \ 11;\n    } else if (diff > 0 && mod < 12) {\n        ans += diff + 12;\n   \
    \ } else if (diff > 0 && mod < 13) {\n        ans += diff + 13;\n    } else if\
    \ (diff > 0 && mod < 14) {\n        ans += diff + 14;\n    } else if (diff > 0\
    \ && mod < 15) {\n        ans += diff + 15;\n    } else if (diff > 0 && mod <\
    \ 16) {\n        ans += diff + 16;\n    } else if (diff > 0 && mod < 17) {\n \
    \       ans += diff + 17;\n    } else if (diff > 0 && mod < 18) {\n        ans\
    \ += diff + 18;\n    } else if (diff > 0 && mod < 19) {\n        ans += diff +\
    \ 19;\n    } else if (diff > 0 && mod < 20) {\n        ans += diff + 20;\n   \
    \ } else if (diff > 0 && mod < 21) {\n        ans += diff + 21;\n    } else if\
    \ (diff > 0 && mod < 22) {\n        ans += diff + 22;\n    } else if (diff > 0\
    \ && mod < 23) {\n        ans += diff + 23;\n    } else if (diff > 0 && mod <\
    \ 24) {\n        ans += diff + 24;\n    } else if (diff > 0 && mod < 25) {\n \
    \       ans += diff + 25;\n    } else if (diff > 0 && mod < 26) {\n        ans\
    \ += diff + 26;\n    } else if (diff > 0 && mod < 27) {\n        ans += diff +\
    \ 27;\n    } else if (diff > 0 && mod < 28) {\n        ans += diff + 28;\n   \
    \ } else if (diff > \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpokmzl4ah.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpokmzl4ah.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = num - ans;\n      |          ^~~~\n/tmp/tmpokmzl4ah.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n/tmp/tmpokmzl4ah.cpp:21:10:\
    \ error: redeclaration of \u2018long int diff\u2019\n   21 |     long diff = diff\
    \ / 10;\n      |          ^~~~\n/tmp/tmpokmzl4ah.cpp:17:19: note: \u2018long int\
    \ diff\u2019 previously declared here\n   17 |     long ans = 0, diff = 0;\n \
    \     |                   ^~~~\n/tmp/tmpokmzl4ah.cpp:81:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   81 | }\n      | ^\n/tmp/tmpokmzl4ah.cpp:80:22:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   80 |     } else\
    \ if (diff >\n      |               ~      ^\n      |                      )\n\
    \   81 | }\n      | ~                     \n/tmp/tmpokmzl4ah.cpp:81:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   81 | }\n      | ^\n\
    /tmp/tmpokmzl4ah.cpp:81:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long num =\
    \ std::stoll(value);\n    long num2 = num;\n    long num3 = num;\n    long num4\
    \ = num;\n    long num5 = num;\n    long num6 = num;\n    long num7 = num;\n \
    \   long num8 = num;\n    long num9 = num;\n    long num10 = num;\n    long num11\
    \ = num;\n    long num12 = num;\n    long num13 = num;\n    long num14 = num;\n\
    \    long num15 = num;\n    long num16 = num;\n    long num17 = num;\n    long\
    \ num18 = num;\n    long num19 = num;\n    long num20 = num;\n    long num21 =\
    \ num;\n    long num22 = num;\n    long num23 = num;\n    long num24 = num;\n\
    \    long num25 = num;\n    long num26 = num;\n    long num27 = num;\n    long\
    \ num28 = num;\n    long num29 = num;\n    long num30 = num;\n    long num31 =\
    \ num;\n    long num32 = num;\n    long num33 = num;\n    long num34 = num;\n\
    \    long num35 = num;\n    long num36 = num;\n    long num37 = num;\n    long\
    \ num38 = num;\n    long num39 = num;\n    long num40 = num;\n    long num41 =\
    \ num;\n    long num42 = num;\n    long num43 = num;\n    long num44 = num;\n\
    \    long num45 = num;\n    long num46 = num;\n    long num47 = num;\n    long\
    \ num48 = num;\n    long num49 = num;\n    long num50 = num;\n    long num51 =\
    \ num;\n    long num52 = num;\n    long num53 = num;\n    long num54 = num;\n\
    \    long num55 = num;\n    long num56 = num;\n    long num57 = num;\n    long\
    \ num58 = num;\n    long num59 = num;\n    long num60 = num;\n    long num61 =\
    \ num;\n    long num62 = num;\n    long num63 = num;\n    long num64 = \n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk93d9lmw.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpk93d9lmw.cpp:83:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   83 | }\n      | ^\n/tmp/tmpk93d9lmw.cpp:83:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n  \
    \  long mid = 0;\n    long diff = 0;\n    long diff2 = 0;\n    long diff3 = 0;\n\
    \    long diff4 = 0;\n    long diff5 = 0;\n    long diff6 = 0;\n    long diff7\
    \ = 0;\n    long diff8 = 0;\n    long diff9 = 0;\n    long diff10 = 0;\n    long\
    \ diff11 = 0;\n    long diff12 = 0;\n    long diff13 = 0;\n    long diff14 = 0;\n\
    \    long diff15 = 0;\n    long diff16 = 0;\n    long diff17 = 0;\n    long diff18\
    \ = 0;\n    long diff19 = 0;\n    long diff20 = 0;\n    long diff21 = 0;\n   \
    \ long diff22 = 0;\n    long diff23 = 0;\n    long diff24 = 0;\n    long diff25\
    \ = 0;\n    long diff26 = 0;\n    long diff27 = 0;\n    long diff28 = 0;\n   \
    \ long diff29 = 0;\n    long diff30 = 0;\n    long diff31 = 0;\n    long diff32\
    \ = 0;\n    long diff33 = 0;\n    long diff34 = 0;\n    long diff35 = 0;\n   \
    \ long diff36 = 0;\n    long diff37 = 0;\n    long diff38 = 0;\n    long diff39\
    \ = 0;\n    long diff40 = 0;\n    long diff41 = 0;\n    long diff42 = 0;\n   \
    \ long diff43 = 0;\n    long diff44 = 0;\n    long diff45 = 0;\n    long diff46\
    \ = 0;\n    long diff47 = 0;\n    long diff48 = 0;\n    long diff49 = 0;\n   \
    \ long diff50 = 0;\n    long diff51 = 0;\n    long diff52 = 0;\n    long diff53\
    \ = 0;\n    long diff54 = 0;\n    long diff55 = 0;\n    long diff56 = 0;\n   \
    \ long diff57 = 0;\n    long diff58 = 0;\n    long diff59 = 0;\n    long diff60\
    \ = 0;\n    long diff61 = 0;\n    long diff62 = 0;\n    long diff63 = 0;\n   \
    \ long diff64 = 0;\n    long diff65 = 0;\n    long diff66 = 0;\n    long diff67\
    \ = 0;\n    long diff68 = 0;\n    long diff69 = 0;\n    long diff70 = 0;\n   \
    \ long diff71 = 0;\n    long diff72 = 0;\n    long diff73 = 0;\n    long diff74\
    \ = 0;\n    long diff75 = 0;\n    long diff76 = 0;\n    long diff77 = 0;\n   \
    \ long diff78 = 0;\n    long diff79 = 0;\n    long diff80 = 0;\n    long diff81\
    \ = 0;\n    long diff82 = 0;\n    long diff83\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp64upgbjq.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp64upgbjq.cpp:102:1: error: expected initializer before \u2018}\u2019\
    \ token\n  102 | }\n      | ^\n/tmp/tmp64upgbjq.cpp:102:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int n = 0;\n    long long int m = 0;\n    long long\
    \ int max = 0;\n    long long int min = 0;\n    long long int diff = 0;\n    long\
    \ long int mid = 0;\n    long long int diff2 = 0;\n    long long int mid2 = 0;\n\
    \    long long int diff3 = 0;\n    long long int mid3 = 0;\n    long long int\
    \ diff4 = 0;\n    long long int mid4 = 0;\n    long long int diff5 = 0;\n    long\
    \ long int mid5 = 0;\n    long long int diff6 = 0;\n    long long int mid6 = 0;\n\
    \    long long int diff7 = 0;\n    long long int mid7 = 0;\n    long long int\
    \ diff8 = 0;\n    long long int mid8 = 0;\n    long long int diff9 = 0;\n    long\
    \ long int mid9 = 0;\n    long long int diff10 = 0;\n    long long int mid10 =\
    \ 0;\n    long long int diff11 = 0;\n    long long int mid11 = 0;\n    long long\
    \ int diff12 = 0;\n    long long int mid12 = 0;\n    long long int diff13 = 0;\n\
    \    long long int mid13 = 0;\n    long long int diff14 = 0;\n    long long int\
    \ mid14 = 0;\n    long long int diff15 = 0;\n    long long int mid15 = 0;\n  \
    \  long long int diff16 = 0;\n    long long int mid16 = 0;\n    long long int\
    \ diff17 = 0;\n    long long int mid17 = 0;\n    long long int diff18 = 0;\n \
    \   long long int mid18 = 0;\n    long long int diff19 = 0;\n    long long int\
    \ mid19 = 0;\n    long long int diff20 = 0;\n    long long int mid20 = 0;\n  \
    \  long long int diff21 = 0;\n    long long int mid21 = 0;\n    long long int\
    \ diff22 = 0;\n    long long int mid22 = 0;\n    long long int diff23 = 0;\n \
    \   long long int mid23 = 0;\n    long long int diff24 = 0;\n    long long int\
    \ mid24 = 0;\n    long long int diff25 = 0;\n    long long int mid25 = 0;\n  \
    \  long long int diff26 = 0;\n    long long int mid26 = 0;\n    long long int\
    \ diff27 = 0;\n    long long int mid27 = 0;\n    long long int diff28 = 0;\n \
    \   long long int mid28 = 0;\n    long long int diff29 = 0;\n    long long int\
    \ mid29 = 0;\n    long long int diff30 = 0;\n    long long int mid30 = 0;\n  \
    \  long long int diff31 = 0;\n    long long int mid31\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppv3_t_77.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppv3_t_77.cpp:83:1: error: expected initializer before \u2018}\u2019\
    \ token\n   83 | }\n      | ^\n/tmp/tmppv3_t_77.cpp:83:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    long diff = upper\
    \ - lower;\n    if (diff == 0) {\n        return lower;\n    }\n    long mid =\
    \ (lower + upper) / 2;\n    if (mid * 2 == diff) {\n        return mid;\n    }\n\
    \    if (diff % 2 == 1) {\n        return mid + 1;\n    }\n    return mid - 1;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpqu93s6kp: /tmp/tmpqu93s6kp.cpp:33: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ int num;\n    num = std::stoll(value);\n    diff = num - ans;\n    if (diff\
    \ < 0) {\n        diff += num;\n    }\n    if (diff == 0) {\n        return ans;\n\
    \    }\n    if (diff > num) {\n        diff = num - ans;\n    }\n    return ans\
    \ + diff;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpkd74z6e3: /tmp/tmpkd74z6e3.cpp:36: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    while (upper -\
    \ lower > 1) {\n        long mid = (lower + upper) / 2;\n        if (mid * mid\
    \ > value) {\n            upper = mid;\n        } else {\n            lower =\
    \ mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptzmc3gck.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptzmc3gck.cpp:20:23: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   20 |         if (mid * mid > value) {\n      |             ~~~~~~~~~ ^\
    \ ~~~~~\n      |                 |       |\n      |                 |       std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                 long int\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptzmc3gck.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptzmc3gck.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   20 |         if (mid * mid > value) {\n      |\
    \                         ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptzmc3gck.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bit"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long mid\
    \ = (n + ans) >> 1;\n    long mid2 = mid * mid;\n    long mid3 = mid2 * mid;\n\
    \    long mid4 = mid3 * mid;\n    long mid5 = mid4 * mid;\n    long mid6 = mid5\
    \ * mid;\n    long mid7 = mid6 * mid;\n    long mid8 = mid7 * mid;\n    long mid9\
    \ = mid8 * mid;\n    long mid10 = mid9 * mid;\n    long mid11 = mid10 * mid;\n\
    \    long mid12 = mid11 * mid;\n    long mid13 = mid12 * mid;\n    long mid14\
    \ = mid13 * mid;\n    long mid15 = mid14 * mid;\n    long mid16 = mid15 * mid;\n\
    \    long mid17 = mid16 * mid;\n    long mid18 = mid17 * mid;\n    long mid19\
    \ = mid18 * mid;\n    long mid20 = mid19 * mid;\n    long mid21 = mid20 * mid;\n\
    \    long mid22 = mid21 * mid;\n    long mid23 = mid22 * mid;\n    long mid24\
    \ = mid23 * mid;\n    long mid25 = mid24 * mid;\n    long mid26 = mid25 * mid;\n\
    \    long mid27 = mid26 * mid;\n    long mid28 = mid27 * mid;\n    long mid29\
    \ = mid28 * mid;\n    long mid30 = mid29 * mid;\n    long mid31 = mid30 * mid;\n\
    \    long mid32 = mid31 * mid;\n    long mid33 = mid32 * mid;\n    long mid34\
    \ = mid33 * mid;\n    long mid35 = mid34 * mid;\n    long mid36 = mid35 * mid;\n\
    \    long mid37 = mid36 * mid;\n    long mid38 = mid37 * mid;\n    long mid39\
    \ = mid38 * mid;\n    long mid40 = mid39 * mid;\n    long mid41 = mid40 * mid;\n\
    \    long mid42 = mid41 * mid;\n    long mid43 = mid42 * mid;\n    long mid44\
    \ = mid43 * mid;\n    long mid45 = mid44 * mid;\n    long mid46 = mid45 * mid;\n\
    \    long mid47 = mid46 * mid\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8vsb33xr.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp8vsb33xr.cpp:66:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   66 | }\n      | ^\n/tmp/tmp8vsb33xr.cpp:66:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long mid;\n\
    \    while (lower < upper) {\n        mid = (lower + upper) / 2;\n        if (mid\
    \ * mid > value) {\n            upper = mid;\n        } else {\n            lower\
    \ = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptnwxk6e3.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptnwxk6e3.cpp:21:23: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   21 |         if (mid * mid > value) {\n      |             ~~~~~~~~~ ^\
    \ ~~~~~\n      |                 |       |\n      |                 |       std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                 long int\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptnwxk6e3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptnwxk6e3.cpp:21:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   21 |         if (mid * mid > value) {\n      |\
    \                         ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmptnwxk6e3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bit"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), mid;\n    while (upper\
    \ - lower > 1) {\n        mid = (upper + lower) / 2;\n        if (mid * mid >\
    \ upper * lower) {\n            upper = mid;\n        } else {\n            lower\
    \ = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpbx32a342: /tmp/tmpbx32a342.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    while (lower <=\
    \ upper) {\n        long mid = (lower + upper) / 2;\n        if (mid * mid > value)\
    \ {\n            upper = mid - 1;\n        } else {\n            lower = mid +\
    \ 1;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmves0n2l.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpmves0n2l.cpp:20:23: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   20 |         if (mid * mid > value) {\n      |             ~~~~~~~~~ ^\
    \ ~~~~~\n      |                 |       |\n      |                 |       std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                 long int\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmves0n2l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpmves0n2l.cpp:20:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   20 |         if (mid * mid > value) {\n      |\
    \                         ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpmves0n2l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bit"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long d = std::stoll(value);\n\
    \    long x = std::stoll(value);\n    long y = std::stoll(value);\n    long z\
    \ = std::stoll(value);\n    long w = std::stoll(value);\n    long a = std::stoll(value);\n\
    \    long b = std::stoll(value);\n    long c = std::stoll(value);\n    long d\
    \ = std::stoll(value);\n    long e = std::stoll(value);\n    long f = std::stoll(value);\n\
    \    long g = std::stoll(value);\n    long h = std::stoll(value);\n    long i\
    \ = std::stoll(value);\n    long j = std::stoll(value);\n    long k = std::stoll(value);\n\
    \    long l = std::stoll(value);\n    long m = std::stoll(value);\n    long n\
    \ = std::stoll(value);\n    long o = std::stoll(value);\n    long p = std::stoll(value);\n\
    \    long q = std::stoll(value);\n    long r = std::stoll(value);\n    long s\
    \ = std::stoll(value);\n    long t = std::stoll(value);\n    long u = std::stoll(value);\n\
    \    long v = std::stoll(value);\n    long w = std::stoll(value);\n    long x\
    \ = std::stoll(value);\n    long y = std::stoll(value);\n    long z = std::stoll(value);\n\
    \    long a = std::stoll(value);\n    long b = std::stoll(value);\n    long c\
    \ = std::stoll(value);\n    long d = std::stoll(value);\n    long e = std::stoll(value);\n\
    \    long f = std::stoll(value);\n    long g = std::stoll(value);\n    long h\
    \ = std::stoll(value);\n    long i = std::stoll(value);\n    long j = std::stoll(value);\n\
    \    long k = std::stoll(value);\n    long l = std::stoll(value);\n    long m\
    \ = std::stoll(value);\n    long n = std::stoll(value);\n    long o = std::stoll(value);\n\
    \    long p = std::stoll(value);\n    long q = std::stoll(value);\n    long r\
    \ = std::stoll(value);\n    long s = std::stoll(value);\n    long t = std::stoll(value);\n\
    \    long u = std::stoll(value);\n    long v = std::stoll(value);\n    long w\
    \ = std::stoll(value);\n    long x = std::stoll(value);\n    long y = std::stoll\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd146a_am.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpd146a_am.cpp:27:10: error: redeclaration of \u2018long int d\u2019\n\
    \   27 |     long d = std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:19:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   19 |     long d =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:46:10: error: redeclaration\
    \ of \u2018long int w\u2019\n   46 |     long w = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpd146a_am.cpp:23:10: note: \u2018long int w\u2019 previously\
    \ declared here\n   23 |     long w = std::stoll(value);\n      |          ^\n\
    /tmp/tmpd146a_am.cpp:47:10: error: redeclaration of \u2018long int x\u2019\n \
    \  47 |     long x = std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:20:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   20 |     long x =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:48:10: error: redeclaration\
    \ of \u2018long int y\u2019\n   48 |     long y = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpd146a_am.cpp:21:10: note: \u2018long int y\u2019 previously\
    \ declared here\n   21 |     long y = std::stoll(value);\n      |          ^\n\
    /tmp/tmpd146a_am.cpp:49:10: error: redeclaration of \u2018long int z\u2019\n \
    \  49 |     long z = std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:22:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   22 |     long z =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:50:10: error: redeclaration\
    \ of \u2018long int a\u2019\n   50 |     long a = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpd146a_am.cpp:24:10: note: \u2018long int a\u2019 previously\
    \ declared here\n   24 |     long a = std::stoll(value);\n      |          ^\n\
    /tmp/tmpd146a_am.cpp:51:10: error: redeclaration of \u2018long int b\u2019\n \
    \  51 |     long b = std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:25:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   25 |     long b =\
    \ std::stoll(value);\n      |          ^\n/tmp/tmpd146a_am.cpp:52:10: error: redeclaration\
    \ of \u2018long int c\u2019\n   52 |     long c = std::stoll(value);\n      |\
    \          ^\n/tmp/tmpd146a_am.cpp:26:10: note: \u2018long int c\u2019 previously\
    \ declar"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long diff = num - ans;\n    long mod = diff % 10;\n    long diff2 = diff /\
    \ 10;\n    long diff3 = diff / 100;\n    long diff4 = diff / 1000;\n    long diff5\
    \ = diff / 100000;\n    long diff6 = diff / 1000000;\n    long diff7 = diff /\
    \ 10000000;\n    long diff8 = diff / 1000000000;\n    long diff9 = diff / 100000000000;\n\
    \    long diff10 = diff / 1000000000000000;\n    long diff11 = diff / 100000000000000000;\n\
    \    long diff12 = diff / 100000000000000000L;\n    long diff13 = diff / 1000000000000000000L;\n\
    \    long diff14 = diff / 10000000000000000000L;\n    long diff15 = diff / 100000000000000000000L;\n\
    \    long diff16 = diff / 1000000000000000000000L;\n    long diff17 = diff / 10000000000000000000000L;\n\
    \    long diff18 = diff / 100000000000000000000000L;\n    long diff19 = diff /\
    \ 1000000000000000000000000L;\n    long diff20 = diff / 10000000000000000000000000L;\n\
    \    long diff21 = diff / 100000000000000000000000000L;\n    long diff22 = diff\
    \ / 1000000000000000000000000000L;\n    long diff23 = diff / 10000000000000000000000000000L;\n\
    \    long diff24 = diff / 100000000000000000000000000000L;\n    long diff25 =\
    \ diff / 1000000000000000000000000000000L;\n    long diff26 = diff / 10000000000000000000000000000000L;\n\
    \    long diff27 = diff / 100000000000000000000000000000000L;\n    long diff28\
    \ = diff / 1000000000000000000000000000000000L;\n    long diff29 = diff / 10000000000000000000000000000000000L;\n\
    \    long diff30 = diff / 100000000000000000000000000000000000L;\n    long diff31\
    \ = diff / 1000000000000000000000000000000000000L;\n    long diff32 = diff / 10000000000000000000000000000000000000L;\n\
    \    long diff33 = diff / 100000000000000000000000000000000000000L;\n    long\
    \ diff34 = diff / 1000000000000000000000000000000000000000L;\n    long diff35\
    \ = diff / 10000000000000000000000000000000000000000L;\n    long diff36 = diff\
    \ / 100000000000000000000000000000000000000000L;\n    long diff37 = diff / 1000000000000000000000000000000000000000000L;\n\
    \    long diff38 = diff / 10000000000000000000000000000000000000000000L;\n   \
    \ long diff39 = diff / 100000000000000000000000000\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ukxoek9.cpp:33:26: warning: integer constant is so large that\
    \ it is unsigned\n   33 |     long diff14 = diff / 10000000000000000000L;\n  \
    \    |                          ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7ukxoek9.cpp:34:26:\
    \ warning: integer constant is too large for its type\n   34 |     long diff15\
    \ = diff / 100000000000000000000L;\n      |                          ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ukxoek9.cpp:35:26: warning: integer constant is too large for its type\n\
    \   35 |     long diff16 = diff / 1000000000000000000000L;\n      |          \
    \                ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7ukxoek9.cpp:36:26: warning:\
    \ integer constant is too large for its type\n   36 |     long diff17 = diff /\
    \ 10000000000000000000000L;\n      |                          ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ukxoek9.cpp:37:26: warning: integer constant is too large for its type\n\
    \   37 |     long diff18 = diff / 100000000000000000000000L;\n      |        \
    \                  ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7ukxoek9.cpp:38:26: warning:\
    \ integer constant is too large for its type\n   38 |     long diff19 = diff /\
    \ 1000000000000000000000000L;\n      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ukxoek9.cpp:39:26: warning: integer constant is too large for its type\n\
    \   39 |     long diff20 = diff / 10000000000000000000000000L;\n      |      \
    \                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7ukxoek9.cpp:40:26:\
    \ warning: integer constant is too large for its type\n   40 |     long diff21\
    \ = diff / 100000000000000000000000000L;\n      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ukxoek9.cpp:41:26: warning: integer constant is too large for its type\n\
    \   41 |     long diff22 = diff / 1000000000000000000000000000L;\n      |    \
    \                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp7ukxoek9.cpp:42:26:\
    \ warning: integer constant is too large for its type\n   42 |     long diff23\
    \ = diff / 10000000000000000000000000000L;\n      |                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp7ukxoek9.cpp:43:26: warning: integ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n\
    \    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long\
    \ r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n\
    \    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long\
    \ b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n\
    \    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long\
    \ k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n\
    \    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long\
    \ t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n\
    \    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long\
    \ C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n\
    \    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long\
    \ L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n\
    \    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long\
    \ U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n\
    \    long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long\
    \ d = 0;\n    long e\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk86zl8a1.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpk86zl8a1.cpp:72:10: error: redeclaration of \u2018long int i\u2019\n\
    \   72 |     long i = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:20:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   20 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpk86zl8a1.cpp:73:10: error: redeclaration of \u2018\
    long int j\u2019\n   73 |     long j = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:21:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   21 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:74:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   74 |     long k = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:22:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   22 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:75:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   75 |     long l = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:23:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   23 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:76:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   76 |     long m = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:24:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   24 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:77:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   77 |     long n = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:25:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   25 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:78:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   78 |     long o = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:26:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   26 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:79:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   79 |     long p = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:27:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   27 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:80:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   80 |     long q = 0;\n      |          ^\n/tmp/tmpk86zl8a1.cpp:28:10:\
    \ note: \u2018long int q\u2019 previously declared here\n   28 |  "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    temp = std::stoll(value);\n\
    \    diff = temp - ans;\n    if (diff > 0) {\n        ans = temp;\n    }\n   \
    \ else if (diff < 0) {\n        ans = ans + 1;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpm4t2yqne: /tmp/tmpm4t2yqne.cpp:32: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0, diff = 0;\n    long\
    \ long int num;\n    long long int num2;\n    long long int num3;\n    long long\
    \ int num4;\n    long long int num5;\n    long long int num6;\n    long long int\
    \ num7;\n    long long int num8;\n    long long int num9;\n    long long int num10;\n\
    \    long long int num11;\n    long long int num12;\n    long long int num13;\n\
    \    long long int num14;\n    long long int num15;\n    long long int num16;\n\
    \    long long int num17;\n    long long int num18;\n    long long int num19;\n\
    \    long long int num20;\n    long long int num21;\n    long long int num22;\n\
    \    long long int num23;\n    long long int num24;\n    long long int num25;\n\
    \    long long int num26;\n    long long int num27;\n    long long int num28;\n\
    \    long long int num29;\n    long long int num30;\n    long long int num31;\n\
    \    long long int num32;\n    long long int num33;\n    long long int num34;\n\
    \    long long int num35;\n    long long int num36;\n    long long int num37;\n\
    \    long long int num38;\n    long long int num39;\n    long long int num40;\n\
    \    long long int num41;\n    long long int num42;\n    long long int num43;\n\
    \    long long int num44;\n    long long int num45;\n    long long int num46;\n\
    \    long long int num47;\n    long long int num48;\n    long long int num49;\n\
    \    long long int num50;\n    long long int num51;\n    long long int num52;\n\
    \    long long int num53;\n    long long int num54;\n    long long int num55;\n\
    \    long long int num56;\n    long long int num57;\n    long long int num58;\n\
    \    long long int num59;\n    long long int num60;\n    long long int num61;\n\
    \    long long int num62;\n    long long int num63;\n    long long int num64;\n\
    \    long long int num65;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpg131px4u: /tmp/tmpg131px4u.cpp:87: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long power =\
    \ 1;\n    long temp2 = 0;\n    long power2 = 1;\n    long temp3 = 0;\n    long\
    \ power3 = 1;\n    long temp4 = 0;\n    long power4 = 1;\n    long temp5 = 0;\n\
    \    long power5 = 1;\n    long temp6 = 0;\n    long power6 = 0;\n    long temp7\
    \ = 0;\n    long power7 = 1;\n    long temp8 = 0;\n    long power8 = 1;\n    long\
    \ temp9 = 0;\n    long power9 = 1;\n    long temp10 = 0;\n    long power10 = 1;\n\
    \    long temp11 = 0;\n    long power11 = 1;\n    long temp12 = 0;\n    long power12\
    \ = 1;\n    long temp13 = 0;\n    long power13 = 1;\n    long temp14 = 0;\n  \
    \  long power14 = 1;\n    long temp15 = 0;\n    long power15 = 1;\n    long temp16\
    \ = 0;\n    long power16 = 1;\n    long temp17 = 0;\n    long power17 = 1;\n \
    \   long temp18 = 0;\n    long power18 = 1;\n    long temp19 = 0;\n    long power19\
    \ = 1;\n    long temp20 = 0;\n    long power20 = 1;\n    long temp21 = 0;\n  \
    \  long power21 = 0;\n    long temp22 = 0;\n    long power22 = 1;\n    long temp23\
    \ = 0;\n    long power23 = 1;\n    long temp24 = 0;\n    long power24 = 1;\n \
    \   long temp25 = 0;\n    long power25 = 1;\n    long temp26 = 0;\n    long power26\
    \ = 1;\n    long temp27 = 0;\n    long power27 = 1;\n    long temp28 = 0;\n  \
    \  long power28 = 1;\n    long temp29 = 0;\n    long power29 = 1;\n    long temp30\
    \ = 0;\n    long power30 = 1;\n    long temp31 = 0;\n    long power31 = 0;\n \
    \   long temp32 = 0;\n    long power32 = 1;\n    long temp33 = 0;\n    long power33\
    \ = 1;\n    long temp34 = 0;\n    long power34 = 1;\n    long temp35 = 0;\n  \
    \  long power35 = 1;\n    long temp36 = 0;\n    long power36 = 1;\n    long temp37\
    \ = 0;\n    long power37 = 1;\n    long temp38 = 0;\n    long power38 = 1;\n \
    \   long temp39 = 0;\n    long power39 = 1;\n    long temp40 = 0;\n    long power40\
    \ = 1;\n    long temp41 = 0;\n    long power41 = 1;\n    long temp42 = 0;\n  \
    \  long power42 = 1;\n    long temp43 = 0;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp6111gqd9: /tmp/tmp6111gqd9.cpp:106: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int int_value = std::stoll(value);\n    if (int_value\
    \ == 0) {\n        throw std::invalid_argument(\"The given value cannot be converted\
    \ to a long long\");\n    }\n    long long int closest_integer = int_value;\n\
    \    long long int closest_integer_to_zero = int_value;\n    long long int closest_integer_to_two\
    \ = int_value;\n    long long int closest_integer_to_three = int_value;\n    long\
    \ long int closest_integer_to_four = int_value;\n    long long int closest_integer_to_five\
    \ = int_value;\n    long long int closest_integer_to_six = int_value;\n    long\
    \ long int closest_integer_to_seven = int_value;\n    long long int closest_integer_to_eight\
    \ = int_value;\n    long long int closest_integer_to_nine = int_value;\n    long\
    \ long int closest_integer_to_ten = int_value;\n    long long int closest_integer_to_eleven\
    \ = int_value;\n    long long int closest_integer_to_twelve = int_value;\n   \
    \ long long int closest_integer_to_thirteen = int_value;\n    long long int closest_integer_to_fourteen\
    \ = int_value;\n    long long int closest_integer_to_fifteen = int_value;\n  \
    \  long long int closest_integer_to_sixteen = int_value;\n    long long int closest_integer_to_seventeen\
    \ = int_value;\n    long long int closest_integer_to_eighteen = int_value;\n \
    \   long long int closest_integer_to_nineteen = int_value;\n    long long int\
    \ closest_integer_to_twenty = int_value;\n    long long int closest_integer_to_twenty_one\
    \ = int_value;\n    long long int closest_integer_to_twenty_two = int_value;\n\
    \    long long int closest_integer_to_twenty_three = int_value;\n    long long\
    \ int closest_integer_to_twenty_four = int_value;\n    long long int closest_integer_to_twenty_five\
    \ = int_value;\n    long long int closest_integer_to_twenty_six = int_value;\n\
    \    long long int closest_integer_to_twenty_seven = int_value;\n    long long\
    \ int closest_integer_to_twenty_eight = int_value;\n    long long int closest_integer_to_twenty_nine\
    \ = int_value;\n    long long int closest_integer_to_thirty = int_value;\n   \
    \ long long int closest_integer_to_thirty_one = int_value;\n    long long int\
    \ closest_integer_to_thirty_two = int_value;\n    long long int closest_integer_to_thirty_three\
    \ = int_value;\n    long long int closest_integer_to_thirty_four = int_value;\n\
    \    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpvt1zd2f2: /tmp/tmpvt1zd2f2.cpp:61: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    if (upper > lower)\
    \ {\n        long mid = (lower + upper) / 2;\n        if (mid > upper) {\n   \
    \         mid = upper;\n        }\n        if (mid < lower) {\n            mid\
    \ = lower;\n        }\n        long diff = abs(mid - value);\n        if (diff\
    \ < abs(mid - upper)) {\n            upper = mid;\n        } else {\n        \
    \    lower = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfn7u_xvb.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpfn7u_xvb.cpp:26:29: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   26 |         long diff = abs(mid - value);\n      |                   \
    \      ~~~ ^ ~~~~~\n      |                         |     |\n      |         \
    \                |     std::string {aka std::__cxx11::basic_string<char>}\n  \
    \    |                         long int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpfn7u_xvb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpfn7u_xvb.cpp:26:31:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   26 |         long diff = abs(mid - value);\n  \
    \    |                               ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_alg"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n\
    \    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long\
    \ r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n\
    \    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long AA = 0;\n    long\
    \ AB = 0;\n    long AC = 0;\n    long AD = 0;\n    long AE = 0;\n    long AF =\
    \ 0;\n    long AG = 0;\n    long AH = 0;\n    long AI = 0;\n    long AJ = 0;\n\
    \    long AK = 0;\n    long AL = 0;\n    long AM = 0;\n    long AN = 0;\n    long\
    \ AO = 0;\n    long AP = 0;\n    long AQ = 0;\n    long AR = 0;\n    long AS =\
    \ 0;\n    long AT = 0;\n    long AU = 0;\n    long AV = 0;\n    long AW = 0;\n\
    \    long AX = 0;\n    long AY = 0;\n    long AZ = 0;\n    long BA = 0;\n    long\
    \ BB = 0;\n    long BC = 0;\n    long BD = 0;\n    long BE = 0;\n    long BF =\
    \ 0;\n    long BG = 0;\n    long BH = 0;\n    long BI = 0;\n    long BJ = 0;\n\
    \    long BK = 0;\n    long BL = 0;\n    long BM = 0;\n    long BN = 0;\n    long\
    \ BO = 0;\n    long BP = 0;\n    long BQ = 0;\n    long BR = 0;\n    long BS =\
    \ 0;\n    long BT = 0;\n    long BU = 0;\n    long BV = 0;\n    long BW = 0;\n\
    \    long BX = 0;\n    long BY = 0;\n    long BZ = 0;\n    long CA = 0;\n    long\
    \ CB = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpogi28281: /tmp/tmpogi28281.cpp:122: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    long diff = upper\
    \ - lower;\n    long mid = (lower + upper) / 2;\n    if (diff == 0) {\n      \
    \  return mid;\n    }\n    if (diff < 0) {\n        lower = mid;\n        upper\
    \ = std::stoll(value);\n        diff = upper - lower;\n        mid = (lower +\
    \ upper) / 2;\n    }\n    if (diff > 0) {\n        lower = mid;\n        upper\
    \ = std::stoll(value);\n        diff = upper - lower;\n        mid = (lower +\
    \ upper) / 2;\n    }\n    return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpktifmfzm: /tmp/tmpktifmfzm.cpp:39: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = abs(atoi(value.c_str()));\n   \
    \ long mid = diff / 2;\n    long left = atoi(value.substr(0, value.size() - 1).c_str());\n\
    \    long right = atoi(value.substr(value.size() - 1).c_str());\n    long diff\
    \ = right - left;\n    if (diff > mid) {\n        ans = left;\n    } else if (diff\
    \ < mid) {\n        ans = right;\n    } else {\n        ans = left + mid;\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3hxl1fay.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp3hxl1fay.cpp:22:10: error: redeclaration of \u2018long int diff\u2019\
    \n   22 |     long diff = right - left;\n      |          ^~~~\n/tmp/tmp3hxl1fay.cpp:18:10:\
    \ note: \u2018long int diff\u2019 previously declared here\n   18 |     long diff\
    \ = abs(atoi(value.c_str()));\n      |          ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = abs(atoi(value.c_str()));\n   \
    \ long min = diff;\n    long max = diff;\n    long mid = 0;\n    long count =\
    \ 0;\n    long pos = 0;\n    long neg = 0;\n    long temp = 0;\n    long temp2\
    \ = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long \n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg9651ej0.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpg9651ej0.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpg9651ej0.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    if (lower > upper)\
    \ {\n        std::swap(lower, upper);\n    }\n    long mid = (lower + upper) /\
    \ 2;\n    if (mid > upper) {\n        mid = upper;\n    }\n    if (mid < lower)\
    \ {\n        mid = lower;\n    }\n    if (mid - std::stoll(value) < 0) {\n   \
    \     mid = std::stoll(value);\n    }\n    return mid;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp_apfqiar: /tmp/tmp_apfqiar.cpp:36: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ int num;\n    long long int num2;\n    long long int num3;\n    long long int\
    \ num4;\n    long long int num5;\n    long long int num6;\n    long long int num7;\n\
    \    long long int num8;\n    long long int num9;\n    long long int num10;\n\
    \    long long int num11;\n    long long int num12;\n    long long int num13;\n\
    \    long long int num14;\n    long long int num15;\n    long long int num16;\n\
    \    long long int num17;\n    long long int num18;\n    long long int num19;\n\
    \    long long int num20;\n    long long int num21;\n    long long int num22;\n\
    \    long long int num23;\n    long long int num24;\n    long long int num25;\n\
    \    long long int num26;\n    long long int num27;\n    long long int num28;\n\
    \    long long int num29;\n    long long int num30;\n    long long int num31;\n\
    \    long long int num32;\n    long long int num33;\n    long long int num34;\n\
    \    long long int num35;\n    long long int num36;\n    long long int num37;\n\
    \    long long int num38;\n    long long int num39;\n    long long int num40;\n\
    \    long long int num41;\n    long long int num42;\n    long long int num43;\n\
    \    long long int num44;\n    long long int num45;\n    long long int num46;\n\
    \    long long int num47;\n    long long int num48;\n    long long int num49;\n\
    \    long long int num50;\n    long long int num51;\n    long long int num52;\n\
    \    long long int num53;\n    long long int num54;\n    long long int num55;\n\
    \    long long int num56;\n    long long int num57;\n    long long int num58;\n\
    \    long long int num59;\n    long long int num60;\n    long long int num61;\n\
    \    long long int num62;\n    long long int num63;\n    long long int num64;\n\
    \    long long int num65;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpsv03r5bd: /tmp/tmpsv03r5bd.cpp:87: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp;\n    long digit = stoi(value);\n\
    \    temp = digit;\n    while (temp != 0) {\n        temp = temp / 10;\n     \
    \   diff++;\n    }\n    temp = digit;\n    while (temp != 0) {\n        temp =\
    \ temp / 10;\n        ans++;\n    }\n    if (diff > ans) {\n        ans = diff;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp4zgmhgem: /tmp/tmp4zgmhgem.cpp:37: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), mid;\n    while (upper\
    \ - lower > 1) {\n        mid = (upper + lower) / 2;\n        if (mid * mid >\
    \ upper * upper) {\n            upper = mid;\n        } else {\n            lower\
    \ = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpa94kp25s: /tmp/tmpa94kp25s.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long mid =\
    \ (lower + upper) / 2;\n    long diff = std::abs(value - mid);\n    if (diff <\
    \ lower) {\n        lower = mid;\n    } else if (diff < upper) {\n        upper\
    \ = mid;\n    } else {\n        mid = (lower + upper) / 2;\n        diff = std::abs(value\
    \ - mid);\n        if (diff < lower) {\n            lower = mid;\n        } else\
    \ if (diff < upper) {\n            upper = mid;\n        } else {\n          \
    \  mid = (lower + upper) / 2;\n            diff = std::abs(value - mid);\n   \
    \         if (diff < lower) {\n                lower = mid;\n            } else\
    \ if (diff < upper) {\n                upper = mid;\n            }\n        }\n\
    \    }\n    return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiq0ohpnl.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpiq0ohpnl.cpp:19:32: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   19 |     long diff = std::abs(value - mid);\n\
    \      |                          ~~~~~ ^ ~~~\n      |                       \
    \   |       |\n      |                          |       long int\n      |    \
    \                      std::string {aka std::__cxx11::basic_string<char>}\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpiq0ohpnl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpiq0ohpnl.cpp:19:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   19\
    \ |     long diff = std::abs(value - mid);\n      |                          \
    \        ^~~\nIn file included from /shared/ce"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0, diff = 0, temp = 0;\n\
    \    long long int n = stoi(value);\n    long long int m = stoi(value);\n    long\
    \ long int d = n - m;\n    long long int r = d % 10;\n    long long int x = d\
    \ / 10;\n    long long int y = n - x;\n    long long int z = n - y;\n    long\
    \ long int a = n - z;\n    long long int b = n - a;\n    long long int c = n -\
    \ b;\n    long long int d = n - c;\n    long long int e = n - d;\n    long long\
    \ int f = n - e;\n    long long int g = n - f;\n    long long int h = n - g;\n\
    \    long long int i = n - h;\n    long long int j = n - i;\n    long long int\
    \ k = n - j;\n    long long int l = n - k;\n    long long int m = n - l;\n   \
    \ long long int n = n - m;\n    long long int o = n - n;\n    long long int p\
    \ = n - o;\n    long long int q = n - p;\n    long long int r = n - q;\n    long\
    \ long int s = n - r;\n    long long int t = n - s;\n    long long int u = n -\
    \ t;\n    long long int v = n - u;\n    long long int w = n - v;\n    long long\
    \ int x = n - w;\n    long long int y = n - x;\n    long long int z = n - y;\n\
    \    long long int a = n - z;\n    long long int b = n - a;\n    long long int\
    \ c = n - b;\n    long long int d = n - c;\n    long long int e = n - d;\n   \
    \ long long int f = n - e;\n    long long int g = n - f;\n    long long int h\
    \ = n - g;\n    long long int i = n - h;\n    long long int j = n - i;\n    long\
    \ long int k = n - j;\n    long long int l = n - k;\n    long long int m = n -\
    \ l;\n    long long int n = n - m;\n    long long int o = n - n;\n    long long\
    \ int p = n - o;\n    long long int q = n - p;\n    long long int r = n - q;\n\
    \    long long int s = n - r;\n    long long int t = n - s;\n    long long int\
    \ u = n - t;\n    long long int v = n - u;\n    long long int w = n - v;\n   \
    \ long long int x = n - w;\n    long long int y = n - x;\n    long long int z\
    \ = n - y;\n    long long int a = n - z;\n    \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpraw74iue.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpraw74iue.cpp:29:19: error: redeclaration of \u2018long long int d\u2019\
    \n   29 |     long long int d = n - c;\n      |                   ^\n/tmp/tmpraw74iue.cpp:21:19:\
    \ note: \u2018long long int d\u2019 previously declared here\n   21 |     long\
    \ long int d = n - m;\n      |                   ^\n/tmp/tmpraw74iue.cpp:38:19:\
    \ error: redeclaration of \u2018long long int m\u2019\n   38 |     long long int\
    \ m = n - l;\n      |                   ^\n/tmp/tmpraw74iue.cpp:20:19: note: \u2018\
    long long int m\u2019 previously declared here\n   20 |     long long int m =\
    \ stoi(value);\n      |                   ^\n/tmp/tmpraw74iue.cpp:39:19: error:\
    \ redeclaration of \u2018long long int n\u2019\n   39 |     long long int n =\
    \ n - m;\n      |                   ^\n/tmp/tmpraw74iue.cpp:19:19: note: \u2018\
    long long int n\u2019 previously declared here\n   19 |     long long int n =\
    \ stoi(value);\n      |                   ^\n/tmp/tmpraw74iue.cpp:43:19: error:\
    \ redeclaration of \u2018long long int r\u2019\n   43 |     long long int r =\
    \ n - q;\n      |                   ^\n/tmp/tmpraw74iue.cpp:22:19: note: \u2018\
    long long int r\u2019 previously declared here\n   22 |     long long int r =\
    \ d % 10;\n      |                   ^\n/tmp/tmpraw74iue.cpp:49:19: error: redeclaration\
    \ of \u2018long long int x\u2019\n   49 |     long long int x = n - w;\n     \
    \ |                   ^\n/tmp/tmpraw74iue.cpp:23:19: note: \u2018long long int\
    \ x\u2019 previously declared here\n   23 |     long long int x = d / 10;\n  \
    \    |                   ^\n/tmp/tmpraw74iue.cpp:50:19: error: redeclaration of\
    \ \u2018long long int y\u2019\n   50 |     long long int y = n - x;\n      | \
    \                  ^\n/tmp/tmpraw74iue.cpp:24:19: note: \u2018long long int y\u2019\
    \ previously declared here\n   24 |     long long int y = n - x;\n      |    \
    \               ^\n/tmp/tmpraw74iue.cpp:51:19: error: redeclaration of \u2018\
    long long int z\u2019\n   51 |     long long int z = n - y;\n      |         \
    \          ^\n/tmp/tmpraw74iue.cpp:25:19: note: \u2018long long int z\u2019 previously\
    \ declared here\n   25 |     long long int z = n - y;\n      |               \
    \    ^\n/tmp/tmpraw74iue.cpp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    while (lower <=\
    \ upper) {\n        long mid = (lower + upper) / 2;\n        long midValue = std::stoll(value);\n\
    \        if (midValue < mid) {\n            lower = mid + 1;\n        } else if\
    \ (midValue > mid) {\n            upper = mid - 1;\n        } else {\n       \
    \     return mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp48aa1jdy: /tmp/tmp48aa1jdy.cpp:33: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = atoi(value.c_str());\n    if (ans < 0)\n        ans\
    \ = -ans;\n    long diff = ans - ans % 10;\n    if (diff > 0)\n        ans +=\
    \ 10;\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp4g7ku6aw: /tmp/tmp4g7ku6aw.cpp:27: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = std::stoi(value);\n    if (ans < 0) {\n        ans\
    \ = -ans;\n    }\n    long diff = ans - std::stoi(value);\n    if (diff < 0 &&\
    \ ans > 0) {\n        ans = ans - 1;\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpxvcw5a95: /tmp/tmpxvcw5a95.cpp:30: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long temp\
    \ = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long\
    \ temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n\
    \    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12\
    \ = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n   \
    \ long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpmjo1hz8_: /tmp/tmpmjo1hz8_.cpp:107: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    long long temp2;\n\
    \    long long temp3;\n    long long temp4;\n    long long temp5;\n    long long\
    \ temp6;\n    long long temp7;\n    long long temp8;\n    long long temp9;\n \
    \   long long temp10;\n    long long temp11;\n    long long temp12;\n    long\
    \ long temp13;\n    long long temp14;\n    long long temp15;\n    long long temp16;\n\
    \    long long temp17;\n    long long temp18;\n    long long temp19;\n    long\
    \ long temp20;\n    long long temp21;\n    long long temp22;\n    long long temp23;\n\
    \    long long temp24;\n    long long temp25;\n    long long temp26;\n    long\
    \ long temp27;\n    long long temp28;\n    long long temp29;\n    long long temp30;\n\
    \    long long temp31;\n    long long temp32;\n    long long temp33;\n    long\
    \ long temp34;\n    long long temp35;\n    long long temp36;\n    long long temp37;\n\
    \    long long temp38;\n    long long temp39;\n    long long temp40;\n    long\
    \ long temp41;\n    long long temp42;\n    long long temp43;\n    long long temp44;\n\
    \    long long temp45;\n    long long temp46;\n    long long temp47;\n    long\
    \ long temp48;\n    long long temp49;\n    long long temp50;\n    long long temp51;\n\
    \    long long temp52;\n    long long temp53;\n    long long temp54;\n    long\
    \ long temp55;\n    long long temp56;\n    long long temp57;\n    long long temp58;\n\
    \    long long temp59;\n    long long temp60;\n    long long temp61;\n    long\
    \ long temp62;\n    long long temp63;\n    long long temp64;\n    long long temp65;\n\
    \    long long temp66;\n    long long temp67;\n    long long temp68;\n    long\
    \ long temp69;\n    long long temp70;\n    long long temp71;\n    long long temp72;\n\
    \    long long temp73;\n    long long temp74;\n    long long temp75;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpopv_w7xj: /tmp/tmpopv_w7xj.cpp:96: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n  \
    \  long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ diff2 = 0;\n    long diff3 = 0;\n    long diff4 = 0;\n    long diff5 = 0;\n\
    \    long diff6 = 0;\n    long diff7 = 0;\n    long diff8 = 0;\n    long diff9\
    \ = 0;\n    long diff10 = 0;\n    long diff11 = 0;\n    long diff12 = 0;\n   \
    \ long diff13 = 0;\n    long diff14 = 0;\n    long diff15 = 0;\n    long diff16\
    \ = 0;\n    long diff17 = 0;\n    long diff18 = 0;\n    long diff19 = 0;\n   \
    \ long diff20 = 0;\n    long diff21 = 0;\n    long diff22 = 0;\n    long diff23\
    \ = 0;\n    long diff24 = 0;\n    long diff25 = 0;\n    long diff26 = 0;\n   \
    \ long diff27 = 0;\n    long diff28 = 0;\n    long diff29 = 0;\n    long diff30\
    \ = 0;\n    long diff31 = 0;\n    long diff32 = 0;\n    long diff33 = 0;\n   \
    \ long diff34 = 0;\n    long diff35 = 0;\n    long diff36 = 0;\n    long diff37\
    \ = 0;\n    long diff38 = 0;\n    long diff39 = 0;\n    long diff40 = 0;\n   \
    \ long diff41 = 0;\n    long diff42 = 0;\n    long diff43 = 0;\n    long diff44\
    \ = 0;\n    long diff45 = 0;\n    long diff46 = 0;\n    long diff47 = 0;\n   \
    \ long diff48 = 0;\n    long diff49 = 0;\n    long diff50 = 0;\n    long diff51\
    \ = 0;\n    long diff52 = 0;\n    long diff53 = 0;\n    long diff54 = 0;\n   \
    \ long diff55 = 0;\n    long diff56 = 0;\n    long diff57 = 0;\n    long diff58\
    \ = 0;\n    long diff59 = 0;\n    long diff60 = 0;\n    long diff61 = 0;\n   \
    \ long diff62 = 0;\n    long diff63 = 0;\n    long diff64 = 0;\n    long diff65\
    \ = 0;\n    long diff66 = 0;\n    long diff67 = 0;\n    long diff68 = 0;\n   \
    \ long diff69 = 0;\n    long diff70 = 0;\n    long diff71 = 0;\n    long diff72\
    \ = 0;\n    long diff73 = 0;\n    long diff74 = 0;\n    long diff75 = 0;\n   \
    \ long diff76 = 0;\n    long diff77 = 0;\n    long diff78 = 0;\n    long diff79\
    \ = 0;\n    long diff80 = 0;\n    long diff81 = 0;\n    long diff\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn_er01h7.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpn_er01h7.cpp:101:1: error: expected initializer before \u2018}\u2019\
    \ token\n  101 | }\n      | ^\n/tmp/tmpn_er01h7.cpp:101:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long mid =\
    \ (lower + upper) / 2;\n    long diff = std::abs(value - mid);\n    if (diff <\
    \ std::numeric_limits<long>::epsilon()) {\n        return mid;\n    }\n    if\
    \ (diff > std::numeric_limits<long>::max()) {\n        return mid;\n    }\n  \
    \  if (diff < std::numeric_limits<long>::min()) {\n        return mid;\n    }\n\
    \    if (diff < std::numeric_limits<long>::max() / 2) {\n        return mid;\n\
    \    }\n    if (diff > std::numeric_limits<long>::max() / 2) {\n        return\
    \ mid;\n    }\n    if (diff < std::numeric_limits<long>::max() / 4) {\n      \
    \  return mid;\n    }\n    if (diff > std::numeric_limits<long>::max() / 4) {\n\
    \        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max() /\
    \ 8) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 8) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 16) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 16) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 32) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 32) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 64) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 64) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 128) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 128) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 256) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 256) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 512) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 512) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 1024) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long>::max()\
    \ / 1024) {\n        return mid;\n    }\n    if (diff < std::numeric_limits<long>::max()\
    \ / 2048) {\n        return mid;\n    }\n    if (diff > std::numeric_limits<long\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpalw2ni2g.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpalw2ni2g.cpp:19:32: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   19 |     long diff = std::abs(value - mid);\n\
    \      |                          ~~~~~ ^ ~~~\n      |                       \
    \   |       |\n      |                          |       long int\n      |    \
    \                      std::string {aka std::__cxx11::basic_string<char>}\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpalw2ni2g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpalw2ni2g.cpp:19:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   19\
    \ |     long diff = std::abs(value - mid);\n      |                          \
    \        ^~~\nIn file included from /shared/ce"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    long diff = upper\
    \ - lower;\n    if (diff == 0) {\n        return lower;\n    }\n    long mid =\
    \ (lower + upper) / 2;\n    if (mid * 2 == upper) {\n        return mid;\n   \
    \ }\n    if (mid * 2 == lower) {\n        return mid + 1;\n    }\n    if (diff\
    \ < 0)\n        return closest_integer(value - std::to_string(lower));\n    return\
    \ closest_integer(std::to_string(mid));\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_efnx9sf.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_efnx9sf.cpp:30:38: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   30 |         return closest_integer(value - std::to_string(lower));\n \
    \     |                                ~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~\n      |\
    \                                |                     |\n      |            \
    \                    basic_string<[...]>   basic_string<[...]>\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_efnx9sf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp_efnx9sf.cpp:30:60:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   30\
    \ |         return closest_integer(value - std::to_string(low"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long temp = 0;\n    long diff = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n\
    \    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long\
    \ r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n\
    \    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long aa = 0;\n    long\
    \ bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff =\
    \ 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n\
    \    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long\
    \ oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss =\
    \ 0;\n    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n\
    \    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long Aa = 0;\n    long\
    \ Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long Ee = 0;\n    long Ff =\
    \ 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii = 0;\n    long Jj = 0;\n\
    \    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n    long Nn = 0;\n    long\
    \ Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long Rr = 0;\n    long Ss =\
    \ 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv = 0;\n    long Ww = 0;\n\
    \    long Xx = 0;\n    long Yy = 0;\n    long Z\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcft14y3u.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpcft14y3u.cpp:116:1: error: expected initializer before \u2018}\u2019\
    \ token\n  116 | }\n      | ^\n/tmp/tmpcft14y3u.cpp:116:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int int_value = std::stoll(value);\n    long long int\
    \ int_min = (int_value - int_value % 10);\n    long long int int_max = (int_value\
    \ + int_value % 10);\n    if (int_min == int_max) {\n        return int_value;\n\
    \    }\n    if (int_min < int_max) {\n        return int_min;\n    }\n    return\
    \ int_max;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpzbi5q3kr: /tmp/tmpzbi5q3kr.cpp:31: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long\
    \ temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n\
    \    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10\
    \ = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n   \
    \ long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17\
    \ = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n   \
    \ long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24\
    \ = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n   \
    \ long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31\
    \ = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n   \
    \ long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38\
    \ = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n   \
    \ long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45\
    \ = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n   \
    \ long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52\
    \ = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n   \
    \ long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59\
    \ = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n   \
    \ long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n    long temp66\
    \ = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n   \
    \ long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n    long temp73\
    \ = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n   \
    \ long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n    long temp80\
    \ = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83 = 0;\n   \
    \ long temp84 = 0;\n    long temp85 = 0;\n    long \n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6x3n_ldl.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6x3n_ldl.cpp:104:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmp6x3n_ldl.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, x = 0, y = 0, z = 0;\n  \
    \  long long int temp = 0;\n    long long int temp2 = 0;\n    long long int temp3\
    \ = 0;\n    long long int temp4 = 0;\n    long long int temp5 = 0;\n    long long\
    \ int temp6 = 0;\n    long long int temp7 = 0;\n    long long int temp8 = 0;\n\
    \    long long int temp9 = 0;\n    long long int temp10 = 0;\n    long long int\
    \ temp11 = 0;\n    long long int temp12 = 0;\n    long long int temp13 = 0;\n\
    \    long long int temp14 = 0;\n    long long int temp15 = 0;\n    long long int\
    \ temp16 = 0;\n    long long int temp17 = 0;\n    long long int temp18 = 0;\n\
    \    long long int temp19 = 0;\n    long long int temp20 = 0;\n    long long int\
    \ temp21 = 0;\n    long long int temp22 = 0;\n    long long int temp23 = 0;\n\
    \    long long int temp24 = 0;\n    long long int temp25 = 0;\n    long long int\
    \ temp26 = 0;\n    long long int temp27 = 0;\n    long long int temp28 = 0;\n\
    \    long long int temp29 = 0;\n    long long int temp30 = 0;\n    long long int\
    \ temp31 = 0;\n    long long int temp32 = 0;\n    long long int temp33 = 0;\n\
    \    long long int temp34 = 0;\n    long long int temp35 = 0;\n    long long int\
    \ temp36 = 0;\n    long long int temp37 = 0;\n    long long int temp38 = 0;\n\
    \    long long int temp39 = 0;\n    long long int temp40 = 0;\n    long long int\
    \ temp41 = 0;\n    long long int temp42 = 0;\n    long long int temp43 = 0;\n\
    \    long long int temp44 = 0;\n    long long int temp45 = 0;\n    long long int\
    \ temp46 = 0;\n    long long int temp47 = 0;\n    long long int temp48 = 0;\n\
    \    long long int temp49 = 0;\n    long long int temp50 = 0;\n    long long int\
    \ temp51 = 0;\n    long long int temp52 = 0;\n    long long int temp53 = 0;\n\
    \    long long int temp54 = 0;\n    long long int temp55 = 0;\n    long long int\
    \ temp56 = 0;\n    long long int temp57 = 0;\n    long long int temp58 = 0;\n\
    \    long long int temp59 = 0;\n    long long int temp60 = 0;\n    long long int\
    \ temp61 = 0;\n    long long int temp62 = 0;\n    long long int \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgbp0jq3b.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpgbp0jq3b.cpp:82:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   82 | }\n      | ^\n/tmp/tmpgbp0jq3b.cpp:82:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long n = stoi(value);\n    long m\
    \ = stoi(value);\n    long d = abs(n - m);\n    long r = abs(n - d);\n    if (r\
    \ > d) {\n        diff = n - m;\n    } else {\n        diff = n - d;\n    }\n\
    \    if (diff > ans) {\n        ans = diff;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp5nc6n0f8: /tmp/tmp5nc6n0f8.cpp:34: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, power = 0, temp = 0;\n  \
    \  long n = stoi(value);\n    temp = n;\n    while(temp != 0){\n        power++;\n\
    \        temp = temp / 10;\n    }\n    power = power-2;\n    while(power >= 0){\n\
    \        ans = ans + temp*pow(10, power);\n        power--;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp58p79p29: /tmp/tmp58p79p29.cpp:34: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long mid =\
    \ (lower + upper) / 2;\n    long diff = std::abs(value - mid);\n    if (diff <\
    \ lower) {\n        lower = mid;\n    } else if (diff < upper) {\n        upper\
    \ = mid;\n    }\n    return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe0cztwjl.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpe0cztwjl.cpp:19:32: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   19 |     long diff = std::abs(value - mid);\n\
    \      |                          ~~~~~ ^ ~~~\n      |                       \
    \   |       |\n      |                          |       long int\n      |    \
    \                      std::string {aka std::__cxx11::basic_string<char>}\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpe0cztwjl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpe0cztwjl.cpp:19:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   19\
    \ |     long diff = std::abs(value - mid);\n      |                          \
    \        ^~~\nIn file included from /shared/ce"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value), closest;\n    while\
    \ (upper - lower > 1) {\n        closest = (lower + upper) / 2;\n        if (closest\
    \ == std::stoll(value))\n            return closest;\n        else if (closest\
    \ < std::stoll(value))\n            upper = closest;\n        else\n         \
    \   lower = closest;\n    }\n    return lower;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpvnntfity: /tmp/tmpvnntfity.cpp:31: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpom7q2s4r.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpom7q2s4r.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmpom7q2s4r.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp;\n    long long temp2;\n\
    \    long long temp3;\n    long long temp4;\n    long long temp5;\n    long long\
    \ temp6;\n    long long temp7;\n    long long temp8;\n    long long temp9;\n \
    \   long long temp10;\n    long long temp11;\n    long long temp12;\n    long\
    \ long temp13;\n    long long temp14;\n    long long temp15;\n    long long temp16;\n\
    \    long long temp17;\n    long long temp18;\n    long long temp19;\n    long\
    \ long temp20;\n    long long temp21;\n    long long temp22;\n    long long temp23;\n\
    \    long long temp24;\n    long long temp25;\n    long long temp26;\n    long\
    \ long temp27;\n    long long temp28;\n    long long temp29;\n    long long temp30;\n\
    \    long long temp31;\n    long long temp32;\n    long long temp33;\n    long\
    \ long temp34;\n    long long temp35;\n    long long temp36;\n    long long temp37;\n\
    \    long long temp38;\n    long long temp39;\n    long long temp40;\n    long\
    \ long temp41;\n    long long temp42;\n    long long temp43;\n    long long temp44;\n\
    \    long long temp45;\n    long long temp46;\n    long long temp47;\n    long\
    \ long temp48;\n    long long temp49;\n    long long temp50;\n    long long temp51;\n\
    \    long long temp52;\n    long long temp53;\n    long long temp54;\n    long\
    \ long temp55;\n    long long temp56;\n    long long temp57;\n    long long temp58;\n\
    \    long long temp59;\n    long long temp60;\n    long long temp61;\n    long\
    \ long temp62;\n    long long temp63;\n    long long temp64;\n    long long temp65;\n\
    \    long long temp66;\n    long long temp67;\n    long long temp68;\n    long\
    \ long temp69;\n    long long temp70;\n    long long temp71;\n    long long temp72;\n\
    \    long long temp73;\n    long long temp74;\n    long long temp75;\n\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpdfghmfqh: /tmp/tmpdfghmfqh.cpp:97: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, x = 0, y = 0, z = 0;\n  \
    \  long long int temp = 0;\n    long long int temp2 = 0;\n    long long int temp3\
    \ = 0;\n    long long int temp4 = 0;\n    long long int temp5 = 0;\n    long long\
    \ int temp6 = 0;\n    long long int temp7 = 0;\n    long long int temp8 = 0;\n\
    \    long long int temp9 = 0;\n    long long int temp10 = 0;\n    long long int\
    \ temp11 = 0;\n    long long int temp12 = 0;\n    long long int temp13 = 0;\n\
    \    long long int temp14 = 0;\n    long long int temp15 = 0;\n    long long int\
    \ temp16 = 0;\n    long long int temp17 = 0;\n    long long int temp18 = 0;\n\
    \    long long int temp19 = 0;\n    long long int temp20 = 0;\n    long long int\
    \ temp21 = 0;\n    long long int temp22 = 0;\n    long long int temp23 = 0;\n\
    \    long long int temp24 = 0;\n    long long int temp25 = 0;\n    long long int\
    \ temp26 = 0;\n    long long int temp27 = 0;\n    long long int temp28 = 0;\n\
    \    long long int temp29 = 0;\n    long long int temp30 = 0;\n    long long int\
    \ temp31 = 0;\n    long long int temp32 = 0;\n    long long int temp33 = 0;\n\
    \    long long int temp34 = 0;\n    long long int temp35 = 0;\n    long long int\
    \ temp36 = 0;\n    long long int temp37 = 0;\n    long long int temp38 = 0;\n\
    \    long long int temp39 = 0;\n    long long int temp40 = 0;\n    long long int\
    \ temp41 = 0;\n    long long int temp42 = 0;\n    long long int temp43 = 0;\n\
    \    long long int temp44 = 0;\n    long long int temp45 = 0;\n    long long int\
    \ temp46 = 0;\n    long long int temp47 = 0;\n    long long int temp48 = 0;\n\
    \    long long int temp49 = 0;\n    long long int temp50 = 0;\n    long long int\
    \ temp51 = 0;\n    long long int temp52 = 0;\n    long long int temp53 = 0;\n\
    \    long long int temp54 = 0;\n    long long int temp55 = 0;\n    long long int\
    \ temp56 = 0;\n    long long int temp57 = 0;\n    long long int temp58 = 0;\n\
    \    long long int temp59 = 0;\n    long long int temp60 = 0;\n    long long int\
    \ temp61 = 0;\n    long long int temp62 = 0;\n    long long int \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe58_49bx.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpe58_49bx.cpp:82:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   82 | }\n      | ^\n/tmp/tmpe58_49bx.cpp:82:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpppu_u2d2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpppu_u2d2.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmpppu_u2d2.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long n = stoi(value);\n\
    \    long d = n - 1;\n    long m = n;\n    long r = n;\n    long s = n;\n    long\
    \ t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n\
    \    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n    long\
    \ c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n\
    \    long h = n;\n    long i = n;\n    long j = n;\n    long k = n;\n    long\
    \ l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n\
    \    long q = n;\n    long r = n;\n    long s = n;\n    long t = n;\n    long\
    \ u = n;\n    long v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiduspiye.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpiduspiye.cpp:34:10: error: redeclaration of \u2018long int d\u2019\n\
    \   34 |     long d = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:20:10: note:\
    \ \u2018long int d\u2019 previously declared here\n   20 |     long d = n - 1;\n\
    \      |          ^\n/tmp/tmpiduspiye.cpp:43:10: error: redeclaration of \u2018\
    long int m\u2019\n   43 |     long m = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:21:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   21 |     long m =\
    \ n;\n      |          ^\n/tmp/tmpiduspiye.cpp:44:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   44 |     long n = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:19:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   19 |     long n =\
    \ stoi(value);\n      |          ^\n/tmp/tmpiduspiye.cpp:48:10: error: redeclaration\
    \ of \u2018long int r\u2019\n   48 |     long r = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:22:10:\
    \ note: \u2018long int r\u2019 previously declared here\n   22 |     long r =\
    \ n;\n      |          ^\n/tmp/tmpiduspiye.cpp:49:10: error: redeclaration of\
    \ \u2018long int s\u2019\n   49 |     long s = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:23:10:\
    \ note: \u2018long int s\u2019 previously declared here\n   23 |     long s =\
    \ n;\n      |          ^\n/tmp/tmpiduspiye.cpp:50:10: error: redeclaration of\
    \ \u2018long int t\u2019\n   50 |     long t = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:24:10:\
    \ note: \u2018long int t\u2019 previously declared here\n   24 |     long t =\
    \ n;\n      |          ^\n/tmp/tmpiduspiye.cpp:51:10: error: redeclaration of\
    \ \u2018long int u\u2019\n   51 |     long u = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:25:10:\
    \ note: \u2018long int u\u2019 previously declared here\n   25 |     long u =\
    \ n;\n      |          ^\n/tmp/tmpiduspiye.cpp:52:10: error: redeclaration of\
    \ \u2018long int v\u2019\n   52 |     long v = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:26:10:\
    \ note: \u2018long int v\u2019 previously declared here\n   26 |     long v =\
    \ n;\n      |          ^\n/tmp/tmpiduspiye.cpp:53:10: error: redeclaration of\
    \ \u2018long int w\u2019\n   53 |     long w = n;\n      |          ^\n/tmp/tmpiduspiye.cpp:27:10:\
    \ note: \u2018long int w\u2019 previously declared "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9db2tsqd.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9db2tsqd.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp9db2tsqd.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long count = 0;\n    long pos = 0;\n    long neg = 0;\n\
    \    long count = 0;\n    long pos = 0;\n    long neg = 0;\n    long count = 0;\n\
    \    long pos = 0;\n    long neg = 0;\n    long \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw1_ioq66.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpw1_ioq66.cpp:24:10: error: redeclaration of \u2018long int count\u2019\
    \n   24 |     long count = 0;\n      |          ^~~~~\n/tmp/tmpw1_ioq66.cpp:21:10:\
    \ note: \u2018long int count\u2019 previously declared here\n   21 |     long\
    \ count = 0;\n      |          ^~~~~\n/tmp/tmpw1_ioq66.cpp:25:10: error: redeclaration\
    \ of \u2018long int pos\u2019\n   25 |     long pos = 0;\n      |          ^~~\n\
    /tmp/tmpw1_ioq66.cpp:22:10: note: \u2018long int pos\u2019 previously declared\
    \ here\n   22 |     long pos = 0;\n      |          ^~~\n/tmp/tmpw1_ioq66.cpp:26:10:\
    \ error: redeclaration of \u2018long int neg\u2019\n   26 |     long neg = 0;\n\
    \      |          ^~~\n/tmp/tmpw1_ioq66.cpp:23:10: note: \u2018long int neg\u2019\
    \ previously declared here\n   23 |     long neg = 0;\n      |          ^~~\n\
    /tmp/tmpw1_ioq66.cpp:27:10: error: redeclaration of \u2018long int count\u2019\
    \n   27 |     long count = 0;\n      |          ^~~~~\n/tmp/tmpw1_ioq66.cpp:21:10:\
    \ note: \u2018long int count\u2019 previously declared here\n   21 |     long\
    \ count = 0;\n      |          ^~~~~\n/tmp/tmpw1_ioq66.cpp:28:10: error: redeclaration\
    \ of \u2018long int pos\u2019\n   28 |     long pos = 0;\n      |          ^~~\n\
    /tmp/tmpw1_ioq66.cpp:22:10: note: \u2018long int pos\u2019 previously declared\
    \ here\n   22 |     long pos = 0;\n      |          ^~~\n/tmp/tmpw1_ioq66.cpp:29:10:\
    \ error: redeclaration of \u2018long int neg\u2019\n   29 |     long neg = 0;\n\
    \      |          ^~~\n/tmp/tmpw1_ioq66.cpp:23:10: note: \u2018long int neg\u2019\
    \ previously declared here\n   23 |     long neg = 0;\n      |          ^~~\n\
    /tmp/tmpw1_ioq66.cpp:30:10: error: redeclaration of \u2018long int count\u2019\
    \n   30 |     long count = 0;\n      |          ^~~~~\n/tmp/tmpw1_ioq66.cpp:21:10:\
    \ note: \u2018long int count\u2019 previously declared here\n   21 |     long\
    \ count = 0;\n      |          ^~~~~\n/tmp/tmpw1_ioq66.cpp:31:10: error: redeclaration\
    \ of \u2018long int pos\u2019\n   31 |     long pos = 0;\n      |          ^~~\n\
    /tmp/tmpw1_ioq66.cpp:22:10: note: \u2018long int pos\u2019 previously declared\
    \ here\n   22 |     long pos = 0;\n      |          ^~~\n/tmp/tmpw1_ioq66.cpp:32:10:\
    \ error: redeclaration of \u2018long"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int closest;\n    long long int diff;\n    long long\
    \ int diff2;\n    long long int diff3;\n    long long int diff4;\n    long long\
    \ int diff5;\n    long long int diff6;\n    long long int diff7;\n    long long\
    \ int diff8;\n    long long int diff9;\n    long long int diff10;\n    long long\
    \ int diff11;\n    long long int diff12;\n    long long int diff13;\n    long\
    \ long int diff14;\n    long long int diff15;\n    long long int diff16;\n   \
    \ long long int diff17;\n    long long int diff18;\n    long long int diff19;\n\
    \    long long int diff20;\n    long long int diff21;\n    long long int diff22;\n\
    \    long long int diff23;\n    long long int diff24;\n    long long int diff25;\n\
    \    long long int diff26;\n    long long int diff27;\n    long long int diff28;\n\
    \    long long int diff29;\n    long long int diff30;\n    long long int diff31;\n\
    \    long long int diff32;\n    long long int diff33;\n    long long int diff34;\n\
    \    long long int diff35;\n    long long int diff36;\n    long long int diff37;\n\
    \    long long int diff38;\n    long long int diff39;\n    long long int diff40;\n\
    \    long long int diff41;\n    long long int diff42;\n    long long int diff43;\n\
    \    long long int diff44;\n    long long int diff45;\n    long long int diff46;\n\
    \    long long int diff47;\n    long long int diff48;\n    long long int diff49;\n\
    \    long long int diff50;\n    long long int diff51;\n    long long int diff52;\n\
    \    long long int diff53;\n    long long int diff54;\n    long long int diff55;\n\
    \    long long int diff56;\n    long long int diff57;\n    long long int diff58;\n\
    \    long long int diff59;\n    long long int diff60;\n    long long int diff61;\n\
    \    long long int diff62;\n    long long int diff63;\n    long long int diff64;\n\
    \    long long int diff65;\n    long long int diff\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgfo2tliy.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpgfo2tliy.cpp:84:1: error: expected initializer before \u2018}\u2019\
    \ token\n   84 | }\n      | ^\n/tmp/tmpgfo2tliy.cpp:84:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = std::stoi(value);\n    if (ans < 0)\n        ans =\
    \ ans * -1;\n    long diff = 0;\n    for (int i = 0; i < 10; i++) {\n        diff\
    \ = ans - i;\n        if (diff < 0)\n            diff = diff * -1;\n        if\
    \ (diff == 0)\n            return i;\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmprtrhgwez: /tmp/tmprtrhgwez.cpp:33: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ int num;\n    long long int num2;\n    long long int num3;\n    long long int\
    \ num4;\n    long long int num5;\n    long long int num6;\n    long long int num7;\n\
    \    long long int num8;\n    long long int num9;\n    long long int num10;\n\
    \    long long int num11;\n    long long int num12;\n    long long int num13;\n\
    \    long long int num14;\n    long long int num15;\n    long long int num16;\n\
    \    long long int num17;\n    long long int num18;\n    long long int num19;\n\
    \    long long int num20;\n    long long int num21;\n    long long int num22;\n\
    \    long long int num23;\n    long long int num24;\n    long long int num25;\n\
    \    long long int num26;\n    long long int num27;\n    long long int num28;\n\
    \    long long int num29;\n    long long int num30;\n    long long int num31;\n\
    \    long long int num32;\n    long long int num33;\n    long long int num34;\n\
    \    long long int num35;\n    long long int num36;\n    long long int num37;\n\
    \    long long int num38;\n    long long int num39;\n    long long int num40;\n\
    \    long long int num41;\n    long long int num42;\n    long long int num43;\n\
    \    long long int num44;\n    long long int num45;\n    long long int num46;\n\
    \    long long int num47;\n    long long int num48;\n    long long int num49;\n\
    \    long long int num50;\n    long long int num51;\n    long long int num52;\n\
    \    long long int num53;\n    long long int num54;\n    long long int num55;\n\
    \    long long int num56;\n    long long int num57;\n    long long int num58;\n\
    \    long long int num59;\n    long long int num60;\n    long long int num61;\n\
    \    long long int num62;\n    long long int num63;\n    long long int num64;\n\
    \    long long int num65;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpdiog1z8h: /tmp/tmpdiog1z8h.cpp:87: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int num;\n    long long int min;\n    long long int\
    \ max;\n    long long int mid;\n    long long int diff;\n    long long int diff2;\n\
    \    long long int diff3;\n    long long int diff4;\n    long long int diff5;\n\
    \    long long int diff6;\n    long long int diff7;\n    long long int diff8;\n\
    \    long long int diff9;\n    long long int diff10;\n    long long int diff11;\n\
    \    long long int diff12;\n    long long int diff13;\n    long long int diff14;\n\
    \    long long int diff15;\n    long long int diff16;\n    long long int diff17;\n\
    \    long long int diff18;\n    long long int diff19;\n    long long int diff20;\n\
    \    long long int diff21;\n    long long int diff22;\n    long long int diff23;\n\
    \    long long int diff24;\n    long long int diff25;\n    long long int diff26;\n\
    \    long long int diff27;\n    long long int diff28;\n    long long int diff29;\n\
    \    long long int diff30;\n    long long int diff31;\n    long long int diff32;\n\
    \    long long int diff33;\n    long long int diff34;\n    long long int diff35;\n\
    \    long long int diff36;\n    long long int diff37;\n    long long int diff38;\n\
    \    long long int diff39;\n    long long int diff40;\n    long long int diff41;\n\
    \    long long int diff42;\n    long long int diff43;\n    long long int diff44;\n\
    \    long long int diff45;\n    long long int diff46;\n    long long int diff47;\n\
    \    long long int diff48;\n    long long int diff49;\n    long long int diff50;\n\
    \    long long int diff51;\n    long long int diff52;\n    long long int diff53;\n\
    \    long long int diff54;\n    long long int diff55;\n    long long int diff56;\n\
    \    long long int diff57;\n    long long int diff58;\n    long long int diff59;\n\
    \    long long int diff60;\n    long long int diff61;\n    long long int diff62;\n\
    \    long long int diff63;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpcbwzye23: /tmp/tmpcbwzye23.cpp:88: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long mid =\
    \ (lower + upper) / 2;\n    long diff = std::abs(value - mid);\n    if (diff <\
    \ std::abs(value - lower)) {\n        lower = mid;\n    }\n    if (diff < std::abs(value\
    \ - upper)) {\n        upper = mid;\n    }\n    return mid;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe2rj09f2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpe2rj09f2.cpp:19:32: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   19 |     long diff = std::abs(value - mid);\n\
    \      |                          ~~~~~ ^ ~~~\n      |                       \
    \   |       |\n      |                          |       long int\n      |    \
    \                      std::string {aka std::__cxx11::basic_string<char>}\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpe2rj09f2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpe2rj09f2.cpp:19:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   19\
    \ |     long diff = std::abs(value - mid);\n      |                          \
    \        ^~~\nIn file included from /shared/ce"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    while (upper -\
    \ lower > 1) {\n        long mid = (lower + upper) / 2;\n        if (mid * mid\
    \ > value * value) {\n            upper = mid;\n        } else {\n           \
    \ lower = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv9ume581.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpv9ume581.cpp:20:31: error: no match for \u2018operator*\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   20 |         if (mid * mid > value * value) {\n      |                \
    \         ~~~~~ ^ ~~~~~\n      |                         |       |\n      |  \
    \                       |       basic_string<[...]>\n      |                 \
    \        basic_string<[...]>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpv9ume581.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:387:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator*(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  387 |     operator*(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:387:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpv9ume581.cpp:20:33:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   20 |         if\
    \ (mid * mid > value * value) {\n      |                                 ^~~~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpv9ume581.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:396:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator*(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  396 |     operator*(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:396:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpv9ume58"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp063xprwc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp063xprwc.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp063xprwc.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long num;\n    long long num2;\n\
    \    long long num3;\n    long long num4;\n    long long num5;\n    long long\
    \ num6;\n    long long num7;\n    long long num8;\n    long long num9;\n    long\
    \ long num10;\n    long long num11;\n    long long num12;\n    long long num13;\n\
    \    long long num14;\n    long long num15;\n    long long num16;\n    long long\
    \ num17;\n    long long num18;\n    long long num19;\n    long long num20;\n \
    \   long long num21;\n    long long num22;\n    long long num23;\n    long long\
    \ num24;\n    long long num25;\n    long long num26;\n    long long num27;\n \
    \   long long num28;\n    long long num29;\n    long long num30;\n    long long\
    \ num31;\n    long long num32;\n    long long num33;\n    long long num34;\n \
    \   long long num35;\n    long long num36;\n    long long num37;\n    long long\
    \ num38;\n    long long num39;\n    long long num40;\n    long long num41;\n \
    \   long long num42;\n    long long num43;\n    long long num44;\n    long long\
    \ num45;\n    long long num46;\n    long long num47;\n    long long num48;\n \
    \   long long num49;\n    long long num50;\n    long long num51;\n    long long\
    \ num52;\n    long long num53;\n    long long num54;\n    long long num55;\n \
    \   long long num56;\n    long long num57;\n    long long num58;\n    long long\
    \ num59;\n    long long num60;\n    long long num61;\n    long long num62;\n \
    \   long long num63;\n    long long num64;\n    long long num65;\n    long long\
    \ num66;\n    long long num67;\n    long long num68;\n    long long num69;\n \
    \   long long num70;\n    long long num71;\n    long long num72;\n    long long\
    \ num73;\n    long long num74;\n    long long num75;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpzxaavp9o: /tmp/tmpzxaavp9o.cpp:96: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = abs(atoi(value.c_str()));\n   \
    \ long min = diff;\n    long max = diff;\n    long mid = 0;\n    long mid2 = 0;\n\
    \    long mid3 = 0;\n    long mid4 = 0;\n    long mid5 = 0;\n    long mid6 = 0;\n\
    \    long mid7 = 0;\n    long mid8 = 0;\n    long mid9 = 0;\n    long mid10 =\
    \ 0;\n    long mid11 = 0;\n    long mid12 = 0;\n    long mid13 = 0;\n    long\
    \ mid14 = 0;\n    long mid15 = 0;\n    long mid16 = 0;\n    long mid17 = 0;\n\
    \    long mid18 = 0;\n    long mid19 = 0;\n    long mid20 = 0;\n    long mid21\
    \ = 0;\n    long mid22 = 0;\n    long mid23 = 0;\n    long mid24 = 0;\n    long\
    \ mid25 = 0;\n    long mid26 = 0;\n    long mid27 = 0;\n    long mid28 = 0;\n\
    \    long mid29 = 0;\n    long mid30 = 0;\n    long mid31 = 0;\n    long mid32\
    \ = 0;\n    long mid33 = 0;\n    long mid34 = 0;\n    long mid35 = 0;\n    long\
    \ mid36 = 0;\n    long mid37 = 0;\n    long mid38 = 0;\n    long mid39 = 0;\n\
    \    long mid40 = 0;\n    long mid41 = 0;\n    long mid42 = 0;\n    long mid43\
    \ = 0;\n    long mid44 = 0;\n    long mid45 = 0;\n    long mid46 = 0;\n    long\
    \ mid47 = 0;\n    long mid48 = 0;\n    long mid49 = 0;\n    long mid50 = 0;\n\
    \    long mid51 = 0;\n    long mid52 = 0;\n    long mid53 = 0;\n    long mid54\
    \ = 0;\n    long mid55 = 0;\n    long mid56 = 0;\n    long mid57 = 0;\n    long\
    \ mid58 = 0;\n    long mid59 = 0;\n    long mid60 = 0;\n    long mid61 = 0;\n\
    \    long mid62 = 0;\n    long mid63 = 0;\n    long mid64 = 0;\n    long mid65\
    \ = 0;\n    long mid66 = 0;\n    long mid67 = 0;\n    long mid68 = 0;\n    long\
    \ mid69 = 0;\n    long mid70 = 0;\n    long mid71 = 0;\n    long mid72 = 0;\n\
    \    long mid73 = 0;\n    long mid74 = 0;\n    long mid75 = 0;\n    long mid76\
    \ = 0;\n    long mid77 = 0;\n    long mid78 = 0;\n    long mid79 = 0;\n    long\
    \ mid80 = 0;\n    long mid81 = 0;\n    long mid\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps8gt42di.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmps8gt42di.cpp:103:1: error: expected initializer before \u2018}\u2019\
    \ token\n  103 | }\n      | ^\n/tmp/tmps8gt42di.cpp:103:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n  \
    \  long mid = 0;\n    long diff = 0;\n    long diff2 = 0;\n    long diff3 = 0;\n\
    \    long diff4 = 0;\n    long diff5 = 0;\n    long diff6 = 0;\n    long diff7\
    \ = 0;\n    long diff8 = 0;\n    long diff9 = 0;\n    long diff10 = 0;\n    long\
    \ diff11 = 0;\n    long diff12 = 0;\n    long diff13 = 0;\n    long diff14 = 0;\n\
    \    long diff15 = 0;\n    long diff16 = 0;\n    long diff17 = 0;\n    long diff18\
    \ = 0;\n    long diff19 = 0;\n    long diff20 = 0;\n    long diff21 = 0;\n   \
    \ long diff22 = 0;\n    long diff23 = 0;\n    long diff24 = 0;\n    long diff25\
    \ = 0;\n    long diff26 = 0;\n    long diff27 = 0;\n    long diff28 = 0;\n   \
    \ long diff29 = 0;\n    long diff30 = 0;\n    long diff31 = 0;\n    long diff32\
    \ = 0;\n    long diff33 = 0;\n    long diff34 = 0;\n    long diff35 = 0;\n   \
    \ long diff36 = 0;\n    long diff37 = 0;\n    long diff38 = 0;\n    long diff39\
    \ = 0;\n    long diff40 = 0;\n    long diff41 = 0;\n    long diff42 = 0;\n   \
    \ long diff43 = 0;\n    long diff44 = 0;\n    long diff45 = 0;\n    long diff46\
    \ = 0;\n    long diff47 = 0;\n    long diff48 = 0;\n    long diff49 = 0;\n   \
    \ long diff50 = 0;\n    long diff51 = 0;\n    long diff52 = 0;\n    long diff53\
    \ = 0;\n    long diff54 = 0;\n    long diff55 = 0;\n    long diff56 = 0;\n   \
    \ long diff57 = 0;\n    long diff58 = 0;\n    long diff59 = 0;\n    long diff60\
    \ = 0;\n    long diff61 = 0;\n    long diff62 = 0;\n    long diff63 = 0;\n   \
    \ long diff64 = 0;\n    long diff65 = 0;\n    long diff66 = 0;\n    long diff67\
    \ = 0;\n    long diff68 = 0;\n    long diff69 = 0;\n    long diff70 = 0;\n   \
    \ long diff71 = 0;\n    long diff72 = 0;\n    long diff73 = 0;\n    long diff74\
    \ = 0;\n    long diff75 = 0;\n    long diff76 = 0;\n    long diff77 = 0;\n   \
    \ long diff78 = 0;\n    long diff79 = 0;\n    long diff80 = 0;\n    long diff81\
    \ = 0;\n    long diff82 = 0;\n    long diff83\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp61afq8cv.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp61afq8cv.cpp:102:1: error: expected initializer before \u2018}\u2019\
    \ token\n  102 | }\n      | ^\n/tmp/tmp61afq8cv.cpp:102:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    long long temp2;\n\
    \    long long temp3;\n    long long temp4;\n    long long temp5;\n    long long\
    \ temp6;\n    long long temp7;\n    long long temp8;\n    long long temp9;\n \
    \   long long temp10;\n    long long temp11;\n    long long temp12;\n    long\
    \ long temp13;\n    long long temp14;\n    long long temp15;\n    long long temp16;\n\
    \    long long temp17;\n    long long temp18;\n    long long temp19;\n    long\
    \ long temp20;\n    long long temp21;\n    long long temp22;\n    long long temp23;\n\
    \    long long temp24;\n    long long temp25;\n    long long temp26;\n    long\
    \ long temp27;\n    long long temp28;\n    long long temp29;\n    long long temp30;\n\
    \    long long temp31;\n    long long temp32;\n    long long temp33;\n    long\
    \ long temp34;\n    long long temp35;\n    long long temp36;\n    long long temp37;\n\
    \    long long temp38;\n    long long temp39;\n    long long temp40;\n    long\
    \ long temp41;\n    long long temp42;\n    long long temp43;\n    long long temp44;\n\
    \    long long temp45;\n    long long temp46;\n    long long temp47;\n    long\
    \ long temp48;\n    long long temp49;\n    long long temp50;\n    long long temp51;\n\
    \    long long temp52;\n    long long temp53;\n    long long temp54;\n    long\
    \ long temp55;\n    long long temp56;\n    long long temp57;\n    long long temp58;\n\
    \    long long temp59;\n    long long temp60;\n    long long temp61;\n    long\
    \ long temp62;\n    long long temp63;\n    long long temp64;\n    long long temp65;\n\
    \    long long temp66;\n    long long temp67;\n    long long temp68;\n    long\
    \ long temp69;\n    long long temp70;\n    long long temp71;\n    long long temp72;\n\
    \    long long temp73;\n    long long temp74;\n    long long temp75;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp0wg7loz0: /tmp/tmp0wg7loz0.cpp:96: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long val = std::stoll(value);\n \
    \   long mod = val;\n    while (mod != 0) {\n        mod = mod + val;\n      \
    \  ans = ans + 1;\n        diff = diff + 1;\n    }\n    if (diff == 0) {\n   \
    \     return val;\n    }\n    if (diff > 0) {\n        return ans;\n    }\n  \
    \  return -ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int l=atoll(value.c_str());\n    long long int r=atoll(value.c_str());\n\
    \    long long int diff=r-l;\n    if(diff<0){\n        diff*=-1;\n    }\n    return\
    \ diff;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpb18gra4r: /tmp/tmpb18gra4r.cpp:27: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    temp = std::stoll(value);\n\
    \    diff = temp - ans;\n    ans = temp;\n    if (diff < 0) {\n        diff =\
    \ diff * -1;\n    }\n    return ans + diff;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpbats53rd: /tmp/tmpbats53rd.cpp:29: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ temp;\n    temp = atof(value.c_str());\n    diff = abs(temp - ans);\n    if\
    \ (diff > 1) {\n        diff = diff - 1;\n        ans = temp + 1;\n    }\n   \
    \ else if (diff < -1) {\n        diff = diff + 1;\n        ans = temp - 1;\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpn0muhndn: /tmp/tmpn0muhndn.cpp:34: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0, temp = 0;\n    long\
    \ n = stoi(value);\n    long m = stoi(value);\n    long d = n - m;\n    long r\
    \ = n / d;\n    long s = m / d;\n    if (r > s) {\n        temp = d;\n       \
    \ d = r;\n        r = temp;\n    }\n    ans = (r + d) / 2;\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value) + 1;\n    long mid =\
    \ 0;\n    while (lower <= upper) {\n        mid = (lower + upper) / 2;\n     \
    \   if (mid * mid > value) {\n            upper = mid - 1;\n        } else if\
    \ (mid * mid < value) {\n            lower = mid + 1;\n        } else {\n    \
    \        return mid;\n        }\n    }\n    return lower;\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkc0sf8s8.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpkc0sf8s8.cpp:21:23: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   21 |         if (mid * mid > value) {\n      |             ~~~~~~~~~ ^\
    \ ~~~~~\n      |                 |       |\n      |                 |       std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                 long int\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpkc0sf8s8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpkc0sf8s8.cpp:21:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   21 |         if (mid * mid > value) {\n      |\
    \                         ^~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpkc0sf8s8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bit"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n  \
    \  long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ diff2 = std::numeric_limits<long>::max();\n    long diff3 = std::numeric_limits<long>::max();\n\
    \    long diff4 = std::numeric_limits<long>::max();\n    long diff5 = std::numeric_limits<long>::max();\n\
    \    long diff6 = std::numeric_limits<long>::max();\n    long diff7 = std::numeric_limits<long>::max();\n\
    \    long diff8 = std::numeric_limits<long>::max();\n    long diff9 = std::numeric_limits<long>::max();\n\
    \    long diff10 = std::numeric_limits<long>::max();\n    long diff11 = std::numeric_limits<long>::max();\n\
    \    long diff12 = std::numeric_limits<long>::max();\n    long diff13 = std::numeric_limits<long>::max();\n\
    \    long diff14 = std::numeric_limits<long>::max();\n    long diff15 = std::numeric_limits<long>::max();\n\
    \    long diff16 = std::numeric_limits<long>::max();\n    long diff17 = std::numeric_limits<long>::max();\n\
    \    long diff18 = std::numeric_limits<long>::max();\n    long diff19 = std::numeric_limits<long>::max();\n\
    \    long diff20 = std::numeric_limits<long>::max();\n    long diff21 = std::numeric_limits<long>::max();\n\
    \    long diff22 = std::numeric_limits<long>::max();\n    long diff23 = std::numeric_limits<long>::max();\n\
    \    long diff24 = std::numeric_limits<long>::max();\n    long diff25 = std::numeric_limits<long>::max();\n\
    \    long diff26 = std::numeric_limits<long>::max();\n    long diff27 = std::numeric_limits<long>::max();\n\
    \    long diff28 = std::numeric_limits<long>::max();\n    long diff29 = std::numeric_limits<long>::max();\n\
    \    long diff30 = std::numeric_limits<long>::max();\n    long diff31 = std::numeric_limits<long>::max();\n\
    \    long diff32 = std::numeric_limits<long>::max();\n    long diff33 = std::numeric_limits<long>::max();\n\
    \    long diff34 = std::numeric_limits<long>::max();\n    long diff35 = std::numeric_limits<long>::max();\n\
    \    long diff36 = std::numeric_limits<long>::max();\n\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpvnopxu3_: /tmp/tmpvnopxu3_.cpp:59: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long lower = 0, upper = std::stoll(value);\n    long diff = upper\
    \ - lower;\n    if (diff > 0) {\n        lower = upper;\n        upper = std::stoll(value);\n\
    \        diff = upper - lower;\n    }\n    if (diff == 0) {\n        return lower;\n\
    \    }\n    long mid = lower + (diff / 2);\n    long mid2 = std::stoll(value);\n\
    \    if (mid > mid2) {\n        mid = mid2;\n    }\n    return mid;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpj2a0n4dd: /tmp/tmpj2a0n4dd.cpp:37: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0;\n    long x = atoi(value.c_str());\n\
    \    long y = atoi(value.c_str());\n    long diff = abs(x - y);\n    if (diff\
    \ < 1) {\n        ans = x;\n    }\n    else if (diff < 2) {\n        ans = y;\n\
    \    }\n    else {\n        ans = x - y;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpzkoflmak: /tmp/tmpzkoflmak.cpp:36: int main(): Assertion `candidate((\"\
    14.5\")) == (15)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Write your code here\n    long ans = 0, power = 1;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    while(temp != 0) {\n        ans\
    \ = temp;\n        temp = temp * power;\n        power *= 10;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpxkk6rguz: /tmp/tmpxkk6rguz.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, sign = 1;\n    long temp = 0;\n    long diff = 0;\n\
    \    long power = 1;\n    long i = 0;\n    long count = 0;\n    long max = 0;\n\
    \    long min = 0;\n    long mid = 0;\n    long diff2 = 0;\n    long diff3 = 0;\n\
    \    long diff4 = 0;\n    long diff5 = 0;\n    long diff6 = 0;\n    long diff7\
    \ = 0;\n    long diff8 = 0;\n    long diff9 = 0;\n    long diff10 = 0;\n    long\
    \ diff11 = 0;\n    long diff12 = 0;\n    long diff13 = 0;\n    long diff14 = 0;\n\
    \    long diff15 = 0;\n    long diff16 = 0;\n    long diff17 = 0;\n    long diff18\
    \ = 0;\n    long diff19 = 0;\n    long diff20 = 0;\n    long diff21 = 0;\n   \
    \ long diff22 = 0;\n    long diff23 = 0;\n    long diff24 = 0;\n    long diff25\
    \ = 0;\n    long diff26 = 0;\n    long diff27 = 0;\n    long diff28 = 0;\n   \
    \ long diff29 = 0;\n    long diff30 = 0;\n    long diff31 = 0;\n    long diff32\
    \ = 0;\n    long diff33 = 0;\n    long diff34 = 0;\n    long diff35 = 0;\n   \
    \ long diff36 = 0;\n    long diff37 = 0;\n    long diff38 = 0;\n    long diff39\
    \ = 0;\n    long diff40 = 0;\n    long diff41 = 0;\n    long diff42 = 0;\n   \
    \ long diff43 = 0;\n    long diff44 = 0;\n    long diff45 = 0;\n    long diff46\
    \ = 0;\n    long diff47 = 0;\n    long diff48 = 0;\n    long diff49 = 0;\n   \
    \ long diff50 = 0;\n    long diff51 = 0;\n    long diff52 = 0;\n    long diff53\
    \ = 0;\n    long diff54 = 0;\n    long diff55 = 0;\n    long diff56 = 0;\n   \
    \ long diff57 = 0;\n    long diff58 = 0;\n    long diff59 = 0;\n    long diff60\
    \ = 0;\n    long diff61 = 0;\n    long diff62 = 0;\n    long diff63 = 0;\n   \
    \ long diff64 = 0;\n    long diff65 = 0;\n    long diff66 = 0;\n    long diff67\
    \ = 0;\n    long diff68 = 0;\n    long diff69 = 0;\n    long diff70 = 0;\n   \
    \ long diff71 = 0;\n    long diff72 = 0;\n    long diff73 = 0;\n    long diff74\
    \ = 0;\n    long diff75 = 0;\n    long diff76 = 0;\n    long diff77 = 0;\n   \
    \ long diff78 = 0;\n    long diff79 = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpm5v9xi1a: /tmp/tmpm5v9xi1a.cpp:108: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = std::abs(atoi(value.c_str()));\n\
    \    long mod = diff % 10;\n    long diff2 = diff / 10;\n    long diff3 = diff\
    \ / 100;\n    long diff4 = diff / 1000;\n    long diff5 = diff / 10000;\n    long\
    \ diff6 = diff / 100000;\n    long diff7 = diff / 1000000;\n    long diff8 = diff\
    \ / 10000000;\n    long diff9 = diff / 100000000;\n    long diff10 = diff / 1000000000;\n\
    \    long diff11 = diff / 10000000000;\n    long diff12 = diff / 100000000000;\n\
    \    long diff13 = diff / 1000000000000;\n    long diff14 = diff / 10000000000000;\n\
    \    long diff15 = diff / 100000000000000;\n    long diff16 = diff / 1000000000000000;\n\
    \    long diff17 = diff / 10000000000000000L;\n    long diff18 = diff / 100000000000000000;\n\
    \    long diff19 = diff / 10000000000000000L;\n    long diff20 = diff / 10000000000000000L;\n\
    \    long diff21 = diff / 10000000000000000L;\n    long diff22 = diff / 10000000000000000L;\n\
    \    long diff23 = diff / 10000000000000000L;\n    long diff24 = diff / 10000000000000000L;\n\
    \    long diff25 = diff / 10000000000000000L;\n    long diff26 = diff / 10000000000000000L;\n\
    \    long diff27 = diff / 10000000000000000L;\n    long diff28 = diff / 10000000000000000L;\n\
    \    long diff29 = diff / 10000000000000000L;\n    long diff30 = diff / 10000000000000000L;\n\
    \    long diff31 = diff / 10000000000000000L;\n    long diff32 = diff / 10000000000000000L;\n\
    \    long diff33 = diff / 10000000000000000L;\n    long diff34 = diff / 10000000000000000L;\n\
    \    long diff35 = diff / 10000000000000000L;\n    long diff36 = diff / 10000000000000000L;\n\
    \    long diff37 = diff / 10000000000000000L;\n    long diff38 = diff / 10000000000000000L;\n\
    \    long diff39 = diff / 10000000000000000L;\n    long diff40 = diff / 10000000000000000L;\n\
    \    long diff41 = diff / 10000000000000000L;\n    long diff42 = diff / 10000000000000000L;\n\
    \    long diff4\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe5938xhv.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpe5938xhv.cpp:62:1: error: expected initializer before \u2018}\u2019\
    \ token\n   62 | }\n      | ^\n/tmp/tmpe5938xhv.cpp:62:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n\
    \    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9\
    \ = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n   \
    \ long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpoap8hpp5.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpoap8hpp5.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmpoap8hpp5.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp89kphxky.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp89kphxky.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp89kphxky.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long long int lower = 0, upper = std::stoll(value);\n    long\
    \ long int mid = (lower + upper) / 2;\n    long long int diff = upper - lower;\n\
    \    long long int middiff = diff / 2;\n    if (diff % 2 == 0) {\n        if (middiff\
    \ < diff) {\n            return mid;\n        } else {\n            return mid-1;\n\
    \        }\n    } else {\n        if (middiff < diff) {\n            return mid+1;\n\
    \        } else {\n            return mid;\n        }\n    }\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpshlfwk14: /tmp/tmpshlfwk14.cpp:37: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long temp = 0;\n    long temp2 =\
    \ 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmp_ge65gix: /tmp/tmp_ge65gix.cpp:106: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3uy8hlib.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp3uy8hlib.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmp3uy8hlib.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, x = 0, y = 0;\n    long long\
    \ temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long long\
    \ temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long long\
    \ temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long long\
    \ temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n    long\
    \ long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n   \
    \ long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 = 0;\n\
    \    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21 =\
    \ 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphbnmkxh2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmphbnmkxh2.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmphbnmkxh2.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long temp\
    \ = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long\
    \ temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n\
    \    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12\
    \ = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n   \
    \ long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpjrdx8g7u: /tmp/tmpjrdx8g7u.cpp:107: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    // Your code here\n    long ans = 0, diff = 0;\n    long long\
    \ int num;\n    num = std::stoi(value);\n    diff = abs(num - ans);\n    while\
    \ (diff > 1) {\n        ans += 1;\n        diff = abs(num - ans);\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpgq8tnoc6: /tmp/tmpgq8tnoc6.cpp:30: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp = 0;\n    long long\
    \ temp2 = 0;\n    long long temp3 = 0;\n    long long temp4 = 0;\n    long long\
    \ temp5 = 0;\n    long long temp6 = 0;\n    long long temp7 = 0;\n    long long\
    \ temp8 = 0;\n    long long temp9 = 0;\n    long long temp10 = 0;\n    long long\
    \ temp11 = 0;\n    long long temp12 = 0;\n    long long temp13 = 0;\n    long\
    \ long temp14 = 0;\n    long long temp15 = 0;\n    long long temp16 = 0;\n   \
    \ long long temp17 = 0;\n    long long temp18 = 0;\n    long long temp19 = 0;\n\
    \    long long temp20 = 0;\n    long long temp21 = 0;\n    long long temp22 =\
    \ 0;\n    long long temp23 = 0;\n    long long temp24 = 0;\n    long long temp25\
    \ = 0;\n    long long temp26 = 0;\n    long long temp27 = 0;\n    long long temp28\
    \ = 0;\n    long long temp29 = 0;\n    long long temp30 = 0;\n    long long temp31\
    \ = 0;\n    long long temp32 = 0;\n    long long temp33 = 0;\n    long long temp34\
    \ = 0;\n    long long temp35 = 0;\n    long long temp36 = 0;\n    long long temp37\
    \ = 0;\n    long long temp38 = 0;\n    long long temp39 = 0;\n    long long temp40\
    \ = 0;\n    long long temp41 = 0;\n    long long temp42 = 0;\n    long long temp43\
    \ = 0;\n    long long temp44 = 0;\n    long long temp45 = 0;\n    long long temp46\
    \ = 0;\n    long long temp47 = 0;\n    long long temp48 = 0;\n    long long temp49\
    \ = 0;\n    long long temp50 = 0;\n    long long temp51 = 0;\n    long long temp52\
    \ = 0;\n    long long temp53 = 0;\n    long long temp54 = 0;\n    long long temp55\
    \ = 0;\n    long long temp56 = 0;\n    long long temp57 = 0;\n    long long temp58\
    \ = 0;\n    long long temp59 = 0;\n    long long temp60 = 0;\n    long long temp61\
    \ = 0;\n    long long temp62 = 0;\n    long long temp63 = 0;\n    long long temp64\
    \ = 0;\n    long long temp65 = 0;\n    long long temp66 = 0;\n    long long temp67\
    \ = 0;\n    long long temp68 = 0;\n    long long temp69 = 0;\n    long long temp70\
    \ = 0;\n    long long temp71 = 0;\n    long long temp72 = 0;\n    long long temp73\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw0iyw7bq.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpw0iyw7bq.cpp:91:1: error: expected initializer before \u2018}\u2019\
    \ token\n   91 | }\n      | ^\n/tmp/tmpw0iyw7bq.cpp:91:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long long temp;\n    long long temp2;\n\
    \    long long temp3;\n    long long temp4;\n    long long temp5;\n    long long\
    \ temp6;\n    long long temp7;\n    long long temp8;\n    long long temp9;\n \
    \   long long temp10;\n    long long temp11;\n    long long temp12;\n    long\
    \ long temp13;\n    long long temp14;\n    long long temp15;\n    long long temp16;\n\
    \    long long temp17;\n    long long temp18;\n    long long temp19;\n    long\
    \ long temp20;\n    long long temp21;\n    long long temp22;\n    long long temp23;\n\
    \    long long temp24;\n    long long temp25;\n    long long temp26;\n    long\
    \ long temp27;\n    long long temp28;\n    long long temp29;\n    long long temp30;\n\
    \    long long temp31;\n    long long temp32;\n    long long temp33;\n    long\
    \ long temp34;\n    long long temp35;\n    long long temp36;\n    long long temp37;\n\
    \    long long temp38;\n    long long temp39;\n    long long temp40;\n    long\
    \ long temp41;\n    long long temp42;\n    long long temp43;\n    long long temp44;\n\
    \    long long temp45;\n    long long temp46;\n    long long temp47;\n    long\
    \ long temp48;\n    long long temp49;\n    long long temp50;\n    long long temp51;\n\
    \    long long temp52;\n    long long temp53;\n    long long temp54;\n    long\
    \ long temp55;\n    long long temp56;\n    long long temp57;\n    long long temp58;\n\
    \    long long temp59;\n    long long temp60;\n    long long temp61;\n    long\
    \ long temp62;\n    long long temp63;\n    long long temp64;\n    long long temp65;\n\
    \    long long temp66;\n    long long temp67;\n    long long temp68;\n    long\
    \ long temp69;\n    long long temp70;\n    long long temp71;\n    long long temp72;\n\
    \    long long temp73;\n    long long temp74;\n    long long temp75;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "tmpltu6b3n4: /tmp/tmpltu6b3n4.cpp:96: int main(): Assertion `candidate((\"\
    10\")) == (10)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long num = std::stoll(value);\n \
    \   long diff = abs(num - ans);\n    long mod = num % ans;\n    if (mod != 0)\
    \ {\n        diff = diff + 1;\n    }\n    if (diff > 1) {\n        diff = diff\
    \ - 1;\n    }\n    ans = num - diff;\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1xkyuzpw.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp1xkyuzpw.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = abs(num - ans);\n      |          ^~~~\n/tmp/tmp1xkyuzpw.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0, diff = 0;\n    long val = std::stoll(value);\n \
    \   long diff = val - ans;\n    if (diff < 0) {\n        diff = diff * -1;\n \
    \   }\n    if (diff > 100) {\n        diff = diff / 100;\n    }\n    if (diff\
    \ < 10) {\n        diff = diff * 10;\n    }\n    ans = val + diff;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprx2q1rmq.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmprx2q1rmq.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = val - ans;\n      |          ^~~~\n/tmp/tmprx2q1rmq.cpp:17:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   17 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"\
    15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number\
    \ is equidistant\n// from two integers, the one you should return is the one that\
    \ is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n\
    // return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string\
    \ value) {\n    long ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long\
    \ temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n\
    \    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9\
    \ = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n   \
    \ long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16\
    \ = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n   \
    \ long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23\
    \ = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n   \
    \ long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30\
    \ = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n   \
    \ long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37\
    \ = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n   \
    \ long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44\
    \ = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n   \
    \ long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51\
    \ = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n   \
    \ long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58\
    \ = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n   \
    \ long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65\
    \ = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n   \
    \ long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72\
    \ = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n   \
    \ long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79\
    \ = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n   \
    \ long temp83 = 0;\n    long temp84 = 0;\n    long temp\n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppd18nm7u.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppd18nm7u.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmppd18nm7u.cpp:104:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
