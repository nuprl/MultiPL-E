name: HumanEval_93_encode
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += tolower(c);\n        }\n    }\n    for(int i = 0; i < ans.length(); i++)\
    \ {\n        char c = ans[i];\n        if(c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u') {\n            ans[i] = tolower(ans[i+1]);\n        }\n\
    \    }\n    for(int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n    \
    \        ans[i] = toupper(ans[i+1]);\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp2vj5op51: /tmp/tmp2vj5op51.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c: message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c: ans) {\n        if (c != 'A' && c !=\
    \ 'E' && c != 'I' && c != 'O' && c != 'U' && c != 'Y') {\n            ans[ans.find(c)]\
    \ = tolower(ans[ans.find(c)]);\n        }\n    }\n    for (auto &c: ans) {\n \
    \       if (c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u' && c != 'y')\
    \ {\n            ans[ans.find(c)] = toupper(ans[ans.find(c)]);\n        }\n  \
    \  }\n    for (auto &c: ans) {\n        if (c != 'A' && c != 'E' && c != 'I' &&\
    \ c != 'O' && c != 'U' && c != 'Y') {\n            ans[ans.find(c)] = tolower(ans[ans.find(c)]);\n\
    \        }\n    }\n    for (auto &c: ans) {\n        if (c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u' && c != 'y') {\n            ans[ans.find(c)]\
    \ = toupper(ans[ans.find(c)]);\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpvxf1v7si: /tmp/tmpvxf1v7si.cpp:42: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            ans += tolower(c);\n        }\n    }\n    for(int\
    \ i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = tolower(ans[i+1]);\n\
    \        }\n        else if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c\
    \ == 'U') {\n            ans[i] = toupper(ans[i+1]);\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpmtq1xe8l: /tmp/tmpmtq1xe8l.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c + 2 : c));\n\
    \    }\n    for (auto &c : ans) {\n        ans[ans.find(c)] = ans[ans.find(c)\
    \ + 2];\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp9dni8loz: /tmp/tmp9dni8loz.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (char c : message) {\n        switch (c) {\n      \
    \      case 'A':\n                encoded += \"U\";\n                break;\n\
    \            case 'B':\n                encoded += \"V\";\n                break;\n\
    \            case 'C':\n                encoded += \"W\";\n                break;\n\
    \            case 'D':\n                encoded += \"X\";\n                break;\n\
    \            case 'E':\n                encoded += \"Y\";\n                break;\n\
    \            case 'F':\n                encoded += \"Z\";\n                break;\n\
    \            case 'G':\n                encoded += \"0\";\n                break;\n\
    \            case 'H':\n                encoded += \"1\";\n                break;\n\
    \            case 'I':\n                encoded += \"2\";\n                break;\n\
    \            case 'J':\n                encoded += \"3\";\n                break;\n\
    \            case 'K':\n                encoded += \"4\";\n                break;\n\
    \            case 'L':\n                encoded += \"5\";\n                break;\n\
    \            case 'M':\n                encoded += \"6\";\n                break;\n\
    \            case 'N':\n                encoded += \"7\";\n                break;\n\
    \            case 'O':\n                encoded += \"8\";\n                break;\n\
    \            case 'P':\n                encoded += \"9\";\n                break;\n\
    \            case 'Q':\n                encoded += \"Q\";\n                break;\n\
    \            case 'R':\n                encoded += \"R\";\n                break;\n\
    \            case 'S':\n                encoded += \"S\";\n                break;\n\
    \            case 'T':\n                encoded += \"T\";\n                break;\n\
    \            case 'U':\n                encoded += \"U\";\n                break;\n\
    \            case 'V':\n                encoded += \"V\";\n                break;\n\
    \            case 'W':\n                encoded += \"W\";\n                break;\n\
    \            case 'X':\n                encoded += \"X\";\n                break;\n\
    \            case 'Y':\n                encoded += \"Y\";\n                break;\n\
    \            case 'Z':\n                encoded += \"Z\";\n                break;\n\
    \            default:\n                encoded += c;\n                break;\n\
    \        }\n    }\n    return encoded;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpj7b2vvu1: /tmp/tmpj7b2vvu1.cpp:104: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isalpha(c) ? toupper(c)\
    \ : c);\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i]\
    \ == 'A') {\n            ans[i] = 'B';\n        } else if (ans[i] == 'E') {\n\
    \            ans[i] = 'F';\n        } else if (ans[i] == 'I') {\n            ans[i]\
    \ = 'J';\n        } else if (ans[i] == 'O') {\n            ans[i] = 'M';\n   \
    \     } else if (ans[i] == 'U') {\n            ans[i] = 'N';\n        } else if\
    \ (ans[i] == 'Y') {\n            ans[i] = 'R';\n        } else if (ans[i] == 'a')\
    \ {\n            ans[i] = 'b';\n        } else if (ans[i] == 'e') {\n        \
    \    ans[i] = 'f';\n        } else if (ans[i] == 'i') {\n            ans[i] =\
    \ 'j';\n        } else if (ans[i] == 'o') {\n            ans[i] = 'm';\n     \
    \   } else if (ans[i] == 'u') {\n            ans[i] = 'n';\n        } else if\
    \ (ans[i] == 'y') {\n            ans[i] = 'r';\n        }\n    }\n    for (int\
    \ i = 0; i < ans.size(); i++) {\n        if (ans[i] == 'A') {\n            ans[i]\
    \ = 'B';\n        } else if (ans[i] == 'E') {\n            ans[i] = 'F';\n   \
    \     } else if (ans[i] == 'I') {\n            ans[i] = 'J';\n        } else if\
    \ (ans[i] == 'O') {\n            ans[i] = 'M';\n        } else if (ans[i] == 'U')\
    \ {\n            ans[i] = 'N';\n        } else if (ans[i] == 'Y') {\n        \
    \    ans[i] = 'R';\n        } else if (ans[i] == 'a') {\n            ans[i] =\
    \ 'b';\n        } else if (ans[i] == 'e') {\n            ans[i] = 'f';\n     \
    \   } else if (ans[i] == 'i') {\n            ans[i] = 'j';\n        } else if\
    \ (ans[i] == 'o') {\n            ans[i] = 'm';\n        } else if (ans[i] == 'u')\
    \ {\n            ans[i] = 'n';\n        } else if (ans[i] == 'y') {\n        \
    \    ans[i] = 'r';\n        }\n    }\n    for (int i = 0; i < ans.size(); i++)\
    \ {\n        if (ans[i] == 'A') {\n            ans[i] = 'B';\n        } else if\
    \ (ans[i] == 'E') {\n            ans[i] = 'F';\n        } else if (ans[i] == 'I')\
    \ {\n            ans[i] = 'J';\n        } else if (ans[i] == 'O') {\n        \
    \    ans[i] = 'M';\n        } else if (ans[i] == 'U') {\n            ans[i] =\
    \ 'N';\n        } else if (ans[i] == 'Y') {\n            ans[i] = 'R';\n     \
    \   } else if (ans[i] == 'a') {\n            ans[i] = 'b';\n        } else if\
    \ (ans[i] == 'e') {\n            ans[i] = 'f';\n        } else if (ans[i] == 'i')\
    \ {\n            \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt0ad66fu.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpt0ad66fu.cpp:92:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   92 | int main() {\n      |            ^\n/tmp/tmpt0ad66fu.cpp:99:1:\
    \ error: expected \u2018}\u2019 at end of input\n   99 | }\n      | ^\n/tmp/tmpt0ad66fu.cpp:72:42:\
    \ note: to match this \u2018{\u2019\n   72 |     for (int i = 0; i < ans.size();\
    \ i++) {\n      |                                          ^\n/tmp/tmpt0ad66fu.cpp:99:1:\
    \ error: expected \u2018}\u2019 at end of input\n   99 | }\n      | ^\n/tmp/tmpt0ad66fu.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpt0ad66fu.cpp:99:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   99 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            ans += c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans += 'A';\n        } else if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            ans += 'a';\n        } else {\n\
    \            ans += c;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('a' <= c && c <= 'z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U') {\n            ans[i] = 'A';\n        } else if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n\
    \        } else {\n            ans[i] = c;\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if ('a' <= c\
    \ && c <= 'z') {\n            ans[i] = c;\n        } else if (c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'A';\n    \
    \    } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \            ans[i] = 'a';\n        } else {\n            ans[i] = c;\n      \
    \  }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if ('a' <= c && c <= 'z') {\n            ans[i] = c;\n        } else\
    \ if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n          \
    \  ans[i] = 'A';\n        } else if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') {\n            ans[i] = 'a';\n        } else {\n          \
    \  ans[i] = c;\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if ('a' <= c && c <= 'z') {\n            ans[i]\
    \ = c;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c ==\
    \ 'U') {\n            ans[i] = 'A';\n        } else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n        } else\
    \ {\n            ans[i] = c;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = an\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy12xow6n.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpy12xow6n.cpp:76:18: error: \u2018an\u2019 was not declared in this\
    \ scope; did you mean \u2018ans\u2019?\n   76 |         char c = an\n      | \
    \                 ^~\n      |                  ans\n/tmp/tmpy12xow6n.cpp:78:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   78 | int main() {\n      |            ^\n/tmp/tmpy12xow6n.cpp:85:1: error:\
    \ expected \u2018}\u2019 at end of input\n   85 | }\n      | ^\n/tmp/tmpy12xow6n.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpy12xow6n.cpp:85:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   85 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            ans += c;\n\
    \        } else if (c >= 'A' && c <= 'Z') {\n            ans += c;\n        }\
    \ else if (c >= '0' && c <= '9') {\n            ans += c;\n        } else if (c\
    \ == '.' || c == '!' || c == '?' || c == '-' || c == '_' || c == '/' || c == '\\\
    \\' || c == '(' || c == ')' || c == '{' || c == '}' || c == '[' || c == ']' ||\
    \ c == '<' || c == '>' || c == '|' || c == '~') {\n            ans += c;\n   \
    \     } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \            ans += 'A';\n        } else if (c == 'b' || c == 'c' || c == 'd'\
    \ || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c\
    \ == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't'\
    \ || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c == 'z') {\n           \
    \ ans += 'B';\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U') {\n            ans += 'a';\n        } else if (c == 'B' || c ==\
    \ 'C' || c == 'D' || c == 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K'\
    \ || c == 'L' || c == 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c\
    \ == 'S' || c == 'T' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z')\
    \ {\n            ans += 'b';\n        } else if (c == '0' || c == '1' || c ==\
    \ '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8'\
    \ || c == '9') {\n            ans += '0';\n        } else if (c == '!' || c ==\
    \ '?' || c == '-' || c == '_' || c == '/' || c == '\\\\' || c == '(' || c == ')'\
    \ || c == '{' || c == '}' || c == '[' || c == ']' || c == '<' || c == '>' || c\
    \ == '|' || c == '~') {\n            ans += '!';\n        } else if (c == 'a'\
    \ || \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppq93995h.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmppq93995h.cpp:38:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   38 | }\n      | ^\n/tmp/tmppq93995h.cpp:37:31: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   37 |         } else if (c == 'a'\
    \ ||\n      |                   ~           ^\n      |                       \
    \        )\n   38 | }\n      | ~                              \n/tmp/tmppq93995h.cpp:38:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   38 | }\n \
    \     | ^\n/tmp/tmppq93995h.cpp:39:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   39 | int main() {\n      |            ^\n\
    /tmp/tmppq93995h.cpp:46:1: error: expected \u2018}\u2019 at end of input\n   46\
    \ | }\n      | ^\n/tmp/tmppq93995h.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmppq93995h.cpp:46:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   46 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++){\n        if(message[i]=='A'||message[i]=='E'||message[i]=='I'||message[i]=='O'||message[i]=='U'){\n\
    \            ans+=\"T\";\n        }\n        else if(message[i]=='B'){\n     \
    \       ans+=\"G\";\n        }\n        else if(message[i]=='C'){\n          \
    \  ans+=\"K\";\n        }\n        else if(message[i]=='D'){\n            ans+=\"\
    S\";\n        }\n        else if(message[i]=='F'){\n            ans+=\"C\";\n\
    \        }\n        else if(message[i]=='G'){\n            ans+=\"G\";\n     \
    \   }\n        else if(message[i]=='H'){\n            ans+=\"K\";\n        }\n\
    \        else if(message[i]=='J'){\n            ans+=\"C\";\n        }\n     \
    \   else if(message[i]=='K'){\n            ans+=\"K\";\n        }\n        else\
    \ if(message[i]=='L'){\n            ans+=\"K\";\n        }\n        else if(message[i]=='M'){\n\
    \            ans+=\"G\";\n        }\n        else if(message[i]=='N'){\n     \
    \       ans+=\"G\";\n        }\n        else if(message[i]=='P'){\n          \
    \  ans+=\"C\";\n        }\n        else if(message[i]=='Q'){\n            ans+=\"\
    G\";\n        }\n        else if(message[i]=='R'){\n            ans+=\"G\";\n\
    \        }\n        else if(message[i]=='S'){\n            ans+=\"G\";\n     \
    \   }\n        else if(message[i]=='T'){\n            ans+=\"G\";\n        }\n\
    \        else if(message[i]=='V'){\n            ans+=\"G\";\n        }\n     \
    \   else if(message[i]=='W'){\n            ans+=\"G\";\n        }\n        else\
    \ if(message[i]=='Y'){\n            ans+=\"G\";\n        }\n        else if(message[i]=='Z'){\n\
    \            ans+=\"G\";\n        }\n        else if(message[i]=='a'){\n     \
    \       ans+=\"A\";\n        }\n        else if(message[i]=='b'){\n          \
    \  ans+=\"B\";\n        }\n        else if(message[i]=='c'){\n            ans+=\"\
    C\";\n        }\n        else if(message[i]=='d'){\n            ans+=\"D\";\n\
    \        }\n        else if(message[i]=='e'){\n            ans+=\"E\";\n     \
    \   }\n        else if(message[i]=='f'){\n            an\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7mfzjc16.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp7mfzjc16.cpp:95:13: error: \u2018an\u2019 was not declared in this\
    \ scope; did you mean \u2018ans\u2019?\n   95 |             an\n      |      \
    \       ^~\n      |             ans\n/tmp/tmp7mfzjc16.cpp:97:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   97 | int main() {\n     \
    \ |            ^\n/tmp/tmp7mfzjc16.cpp:104:1: error: expected \u2018}\u2019 at\
    \ end of input\n  104 | }\n      | ^\n/tmp/tmp7mfzjc16.cpp:15:40: note: to match\
    \ this \u2018{\u2019\n   15 |     for(int i=0;i<message.length();i++){\n     \
    \ |                                        ^\n/tmp/tmp7mfzjc16.cpp:104:1: error:\
    \ expected \u2018}\u2019 at end of input\n  104 | }\n      | ^\n/tmp/tmp7mfzjc16.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp7mfzjc16.cpp:104:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  104 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        if (c >= 'a' && c <= 'z')\
    \ {\n            ans += (c + 2);\n        } else if (c >= 'A' && c <= 'Z') {\n\
    \            ans += (c + 2);\n        } else if (c >= '0' && c <= '9') {\n   \
    \         ans += (c + 2);\n        } else if (c == '.') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '!') {\n            ans += (c + 2);\n    \
    \    } else if (c == '?') {\n            ans += (c + 2);\n        } else if (c\
    \ == '-') {\n            ans += (c + 2);\n        } else if (c == '_') {\n   \
    \         ans += (c + 2);\n        } else if (c == '/') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '(') {\n            ans += (c + 2);\n    \
    \    } else if (c == ')') {\n            ans += (c + 2);\n        } else if (c\
    \ == '+') {\n            ans += (c + 2);\n        } else if (c == '=') {\n   \
    \         ans += (c + 2);\n        } else if (c == '[') {\n            ans +=\
    \ (c + 2);\n        } else if (c == ']') {\n            ans += (c + 2);\n    \
    \    } else if (c == '{') {\n            ans += (c + 2);\n        } else if (c\
    \ == '}') {\n            ans += (c + 2);\n        } else if (c == '%') {\n   \
    \         ans += (c + 2);\n        } else if (c == '*') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '&') {\n            ans += (c + 2);\n    \
    \    } else if (c == '|') {\n            ans += (c + 2);\n        } else if (c\
    \ == '^') {\n            ans += (c + 2);\n        } else if (c == '~') {\n   \
    \         ans += (c + 2);\n        } else if (c == '<') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '>') {\n            ans += (c + 2);\n    \
    \    } else if (c == '(') {\n            ans += (c + 2);\n        } else if (c\
    \ == ')') {\n            ans += (c + 2);\n        } else if (c == '[') {\n   \
    \         ans += (c + 2);\n        } else if (c == ']') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '{') {\n            ans += (c + 2);\n    \
    \    } else if (c == '}') {\n            ans += (c + 2);\n        } else if (c\
    \ == '%') {\n            ans += (c + 2);\n        } else if (c == '*') {\n   \
    \         ans += (c + 2);\n        } else if (c == '&') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '|') {\n            ans += (c + 2);\n    \
    \    } else if (c == '^') {\n            ans += (c + 2);\n        } else if (c\
    \ == '~') {\n            ans += (c + 2);\n        } else if (c == '\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpti2guwac.cpp:90:25: warning: missing terminating ' character\n\
    \   90 |         } else if (c == '\n      |                         ^\n/tmp/tmpti2guwac.cpp:90:25:\
    \ error: missing terminating ' character\n/tmp/tmpti2guwac.cpp: In function \u2018\
    std::string encode(std::string)\u2019:\n/tmp/tmpti2guwac.cpp:91:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   91 | }\n      | ^\n/tmp/tmpti2guwac.cpp:90:24:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   90 |         }\
    \ else if (c == '\n      |                   ~    ^\n      |                 \
    \       )\n   91 | }\n      | ~                       \n/tmp/tmpti2guwac.cpp:91:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   91 | }\n \
    \     | ^\n/tmp/tmpti2guwac.cpp:92:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   92 | int main() {\n      |            ^\n\
    /tmp/tmpti2guwac.cpp:99:1: error: expected \u2018}\u2019 at end of input\n   99\
    \ | }\n      | ^\n/tmp/tmpti2guwac.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpti2guwac.cpp:99:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   99 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpdgwxav_g: /tmp/tmpdgwxav_g.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        char temp = c;\n       \
    \ if (temp >= 'a' && temp <= 'z') {\n            temp = temp - 'a' + 'A';\n  \
    \      }\n        ans += temp;\n    }\n    for (auto &c : ans) {\n        if (c\
    \ >= 'a' && c <= 'z') {\n            char temp = c;\n            ans[ans.find(c)]\
    \ = ans[ans.find(c) + 2];\n            ans[ans.find(c) + 2] = temp;\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpaeapqdoa: /tmp/tmpaeapqdoa.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c : ans) {\n        switch (c) {\n   \
    \     case 'A':\n            ans += 'B';\n            break;\n        case 'B':\n\
    \            ans += 'C';\n            break;\n        case 'C':\n            ans\
    \ += 'D';\n            break;\n        case 'D':\n            ans += 'E';\n  \
    \          break;\n        case 'E':\n            ans += 'F';\n            break;\n\
    \        case 'F':\n            ans += 'G';\n            break;\n        case\
    \ 'G':\n            ans += 'H';\n            break;\n        case 'H':\n     \
    \       ans += 'I';\n            break;\n        case 'I':\n            ans +=\
    \ 'J';\n            break;\n        case 'J':\n            ans += 'K';\n     \
    \       break;\n        case 'K':\n            ans += 'L';\n            break;\n\
    \        case 'L':\n            ans += 'M';\n            break;\n        case\
    \ 'M':\n            ans += 'N';\n            break;\n        case 'N':\n     \
    \       ans += 'O';\n            break;\n        case 'O':\n            ans +=\
    \ 'P';\n            break;\n        case 'P':\n            ans += 'Q';\n     \
    \       break;\n        case 'Q':\n            ans += 'R';\n            break;\n\
    \        case 'R':\n            ans += 'S';\n            break;\n        case\
    \ 'S':\n            ans += 'T';\n            break;\n        case 'T':\n     \
    \       ans += 'U';\n            break;\n        case 'U':\n            ans +=\
    \ 'V';\n            break;\n        case 'V':\n            ans += 'W';\n     \
    \       break;\n        case 'W':\n            ans += 'X';\n            break;\n\
    \        case 'X':\n            ans += 'Y';\n            break;\n        case\
    \ 'Y':\n            ans += 'Z';\n            break;\n        case 'Z':\n     \
    \       ans += 'a';\n            break;\n        case 'a':\n            ans +=\
    \ 'b';\n            break;\n        case 'b':\n            ans += 'c';\n     \
    \       break;\n        case 'c':\n            ans += 'd';\n            break;\n\
    \        case 'd':\n            ans += 'e';\n            break;\n        case\
    \ 'e':\n            ans += 'f';\n            break;\n        case 'f':\n     \
    \       ans += 'g';\n            break;\n        case 'g':\n            ans +=\
    \ 'h';\n            break;\n        case 'h':\n            ans += 'i';\n     \
    \       break;\n        case 'i':\n            ans += 'j';\n            break;\n\
    \        case 'j':\n            ans += 'k';\n            break;\n\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvthcesqr.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpvthcesqr.cpp:130:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  130 | int main() {\n      |            ^\n/tmp/tmpvthcesqr.cpp:137:1:\
    \ error: expected \u2018}\u2019 at end of input\n  137 | }\n      | ^\n/tmp/tmpvthcesqr.cpp:18:25:\
    \ note: to match this \u2018{\u2019\n   18 |     for (auto &c : ans) {\n     \
    \ |                         ^\n/tmp/tmpvthcesqr.cpp:137:1: error: expected \u2018\
    }\u2019 at end of input\n  137 | }\n      | ^\n/tmp/tmpvthcesqr.cpp:13:41: note:\
    \ to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpvthcesqr.cpp:137:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  137 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            ans += c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans += 'A';\n        } else if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            ans += 'a';\n        } else {\n\
    \            ans += c;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('a' <= c && c <= 'z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U') {\n            ans[i] = 'A';\n        } else if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n\
    \        } else {\n            ans[i] = c;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpdf362kts: /tmp/tmpdf362kts.cpp:43: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += c;\n        if(c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n        if(c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans +=\
    \ 'a';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpmpt2_f22: /tmp/tmpmpt2_f22.cpp:29: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &i : message) {\n        switch (i) {\n         \
    \   case 'a':\n            case 'e':\n            case 'i':\n            case\
    \ 'o':\n            case 'u':\n                ans += 'A';\n                break;\n\
    \            case 'b':\n            case 'f':\n            case 'n':\n       \
    \     case 'r':\n            case 't':\n                ans += 'B';\n        \
    \        break;\n            case 'c':\n            case 'g':\n            case\
    \ 'j':\n            case 'k':\n            case 'm':\n                ans += 'C';\n\
    \                break;\n            case 'd':\n            case 'h':\n      \
    \      case 'j':\n            case 'k':\n            case 'n':\n             \
    \   ans += 'D';\n                break;\n            case 'e':\n            case\
    \ 'h':\n            case 'k':\n            case 'n':\n                ans += 'E';\n\
    \                break;\n            case 'f':\n            case 'h':\n      \
    \      case 'j':\n            case 'k':\n            case 'n':\n             \
    \   ans += 'F';\n                break;\n            case 'g':\n            case\
    \ 'h':\n            case 'j':\n            case 'k':\n            case 'n':\n\
    \                ans += 'G';\n                break;\n            case 'h':\n\
    \            case 'j':\n            case 'k':\n            case 'n':\n       \
    \         ans += 'H';\n                break;\n            case 'i':\n       \
    \     case 'j':\n            case 'k':\n            case 'n':\n              \
    \  ans += 'I';\n                break;\n            case 'j':\n            case\
    \ 'k':\n            case 'n':\n                ans += 'J';\n                break;\n\
    \            case 'k':\n            case 'n':\n                ans += 'K';\n \
    \               break;\n            case 'l':\n            case 'm':\n       \
    \     case 'n':\n                ans += 'L';\n                break;\n       \
    \     case 'm':\n            case 'n':\n                ans += 'M';\n        \
    \        break;\n            case 'n':\n                ans += 'N';\n        \
    \        break;\n            case 'o':\n            case 'p':\n            case\
    \ 'q':\n            case 'r':\n            case 's':\n                ans += 'O';\n\
    \                break;\n            case 'p':\n            case 'q':\n      \
    \      case 'r':\n            case 's':\n                ans += 'P';\n       \
    \         break;\n            case 'q':\n            case 'r':\n            case\
    \ 's':\n                ans += 'Q';\n                break;\n            case\
    \ 'r':\n            case 's':\n                ans += 'R';\n                break;\n\
    \            case 's':\n                ans += 'S';\n                break;\n\
    \            case 't':\n            case 'u':\n            case 'v':\n       \
    \     case 'w':\n            case 'x':\n                ans += 'T';\n        \
    \        break;\n            case 'u':\n            case 'v':\n            case\
    \ 'w':\n            case 'x':\n                ans += 'U';\n                break;\n\
    \            case 'v':\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0mh5lc17.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp0mh5lc17.cpp:40:13: error: duplicate case value\n   40 |          \
    \   case 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:33:13: note: previously\
    \ used here\n   33 |             case 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:41:13:\
    \ error: duplicate case value\n   41 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:42:13: error:\
    \ duplicate case value\n   42 |             case 'n':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:26:13: note: previously used here\n   26 |             case\
    \ 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:45:13: error: duplicate\
    \ case value\n   45 |             case 'e':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:18:13:\
    \ note: previously used here\n   18 |             case 'e':\n      |         \
    \    ^~~~\n/tmp/tmp0mh5lc17.cpp:46:13: error: duplicate case value\n   46 |  \
    \           case 'h':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:39:13: note:\
    \ previously used here\n   39 |             case 'h':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:47:13: error: duplicate case value\n   47 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13: note: previously\
    \ used here\n   34 |             case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:48:13:\
    \ error: duplicate case value\n   48 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:51:13: error:\
    \ duplicate case value\n   51 |             case 'f':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:25:13: note: previously used here\n   25 |             case\
    \ 'f':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:52:13: error: duplicate\
    \ case value\n   52 |             case 'h':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:39:13:\
    \ note: previously used here\n   39 |             case 'h':\n      |         \
    \    ^~~~\n/tmp/tmp0mh5lc17.cpp:53:13: error: duplicate case value\n   53 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:33:13: note:\
    \ previously used here\n   33 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:54:13: error: duplicate case value\n   54 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13: note: previously\
    \ used here\n   34 |             case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:55:13:\
    \ error: duplicate case value\n   55 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:58:13: error:\
    \ duplicate case value\n   58 |             case 'g':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:32:13: note: previously used here\n   32 |             case\
    \ 'g':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:59:13: error: duplicate\
    \ case value\n   59 |             case 'h':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:39:13:\
    \ note: previously used here\n   39 |             case 'h':\n      |         \
    \    ^~~~\n/tmp/tmp0mh5lc17.cpp:60:13: error: duplicate case value\n   60 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:33:13: note:\
    \ previously used here\n   33 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:61:13: error: duplicate case value\n   61 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13: note: previously\
    \ used here\n   34 |             case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:62:13:\
    \ error: duplicate case value\n   62 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:65:13: error:\
    \ duplicate case value\n   65 |             case 'h':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:39:13: note: previously used here\n   39 |             case\
    \ 'h':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:66:13: error: duplicate\
    \ case value\n   66 |             case 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:33:13:\
    \ note: previously used here\n   33 |             case 'j':\n      |         \
    \    ^~~~\n/tmp/tmp0mh5lc17.cpp:67:13: error: duplicate case value\n   67 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13: note:\
    \ previously used here\n   34 |             case 'k':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:68:13: error: duplicate case value\n   68 |             case\
    \ 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note: previously\
    \ used here\n   26 |             case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:71:13:\
    \ error: duplicate case value\n   71 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:72:13: error:\
    \ duplicate case value\n   72 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:33:13: note: previously used here\n   33 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:73:13: error: duplicate\
    \ case value\n   73 |             case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13:\
    \ note: previously used here\n   34 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp0mh5lc17.cpp:74:13: error: duplicate case value\n   74 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note:\
    \ previously used here\n   26 |             case 'n':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:77:13: error: duplicate case value\n   77 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:33:13: note: previously\
    \ used here\n   33 |             case 'j':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:78:13:\
    \ error: duplicate case value\n   78 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:79:13: error:\
    \ duplicate case value\n   79 |             case 'n':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:26:13: note: previously used here\n   26 |             case\
    \ 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:82:13: error: duplicate\
    \ case value\n   82 |             case 'k':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:34:13:\
    \ note: previously used here\n   34 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp0mh5lc17.cpp:83:13: error: duplicate case value\n   83 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note:\
    \ previously used here\n   26 |             case 'n':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:87:13: error: duplicate case value\n   87 |             case\
    \ 'm':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:35:13: note: previously\
    \ used here\n   35 |             case 'm':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:88:13:\
    \ error: duplicate case value\n   88 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:91:13: error:\
    \ duplicate case value\n   91 |             case 'm':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:35:13: note: previously used here\n   35 |             case\
    \ 'm':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:92:13: error: duplicate\
    \ case value\n   92 |             case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13:\
    \ note: previously used here\n   26 |             case 'n':\n      |         \
    \    ^~~~\n/tmp/tmp0mh5lc17.cpp:95:13: error: duplicate case value\n   95 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:26:13: note:\
    \ previously used here\n   26 |             case 'n':\n      |             ^~~~\n\
    /tmp/tmp0mh5lc17.cpp:98:13: error: duplicate case value\n   98 |             case\
    \ 'o':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:20:13: note: previously\
    \ used here\n   20 |             case 'o':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:101:13:\
    \ error: duplicate case value\n  101 |             case 'r':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'r':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:105:13:\
    \ error: duplicate case value\n  105 |             case 'p':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:99:13: note: previously used here\n   99 |  \
    \           case 'p':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:106:13:\
    \ error: duplicate case value\n  106 |             case 'q':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:100:13: note: previously used here\n  100 | \
    \            case 'q':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:107:13:\
    \ error: duplicate case value\n  107 |             case 'r':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'r':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:108:13:\
    \ error: duplicate case value\n  108 |             case 's':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:102:13: note: previously used here\n  102 | \
    \            case 's':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:111:13:\
    \ error: duplicate case value\n  111 |             case 'q':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:100:13: note: previously used here\n  100 | \
    \            case 'q':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:112:13:\
    \ error: duplicate case value\n  112 |             case 'r':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'r':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:113:13:\
    \ error: duplicate case value\n  113 |             case 's':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:102:13: note: previously used here\n  102 | \
    \            case 's':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:116:13:\
    \ error: duplicate case value\n  116 |             case 'r':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'r':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:117:13:\
    \ error: duplicate case value\n  117 |             case 's':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:102:13: note: previously used here\n  102 | \
    \            case 's':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:120:13:\
    \ error: duplicate case value\n  120 |             case 's':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:102:13: note: previously used here\n  102 | \
    \            case 's':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:123:13:\
    \ error: duplicate case value\n  123 |             case 't':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:28:13: note: previously used here\n   28 |  \
    \           case 't':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:124:13:\
    \ error: duplicate case value\n  124 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:130:13:\
    \ error: duplicate case value\n  130 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:131:13:\
    \ error: duplicate case value\n  131 |             case 'v':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:125:13: note: previously used here\n  125 | \
    \            case 'v':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:132:13:\
    \ error: duplicate case value\n  132 |             case 'w':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:126:13: note: previously used here\n  126 | \
    \            case 'w':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:133:13:\
    \ error: duplicate case value\n  133 |             case 'x':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:127:13: note: previously used here\n  127 | \
    \            case 'x':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:136:13:\
    \ error: duplicate case value\n  136 |             case 'v':\n      |        \
    \     ^~~~\n/tmp/tmp0mh5lc17.cpp:125:13: note: previously used here\n  125 | \
    \            case 'v':\n      |             ^~~~\n/tmp/tmp0mh5lc17.cpp:137:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  137 | }\n \
    \     | ^\n/tmp/tmp0mh5lc17.cpp:138:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  138 | int main() {\n      |            ^\n\
    /tmp/tmp0mh5lc17.cpp:145:1: error: expected \u2018}\u2019 at end of input\n  145\
    \ | }\n      | ^\n/tmp/tmp0mh5lc17.cpp:15:29: note: to match this \u2018{\u2019\
    \n   15 |     for (auto &i : message) {\n      |                             ^\n\
    /tmp/tmp0mh5lc17.cpp:145:1: error: expected \u2018}\u2019 at end of input\n  145\
    \ | }\n      | ^\n/tmp/tmp0mh5lc17.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmp0mh5lc17.cpp:145:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n  145 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        } else if (c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U') {\n            ans += c + 1;\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   \
    \         ans[i] = 'A';\n        } else if (c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U') {\n            ans[i] = 'a';\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c\
    \ == 'U') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'A';\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans[i] = 'A';\n        } else if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i]\
    \ = 'a';\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n   \
    \     char c = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') {\n            ans[i] = 'A';\n        } else if (c == 'A' || c\
    \ == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'a';\n \
    \       }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        char c\
    \ = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n            ans[i] = 'A';\n        } else if (c == 'A' || c == 'E' ||\
    \ c == 'I' || c == 'O' || \n}\nint main() {\n    auto candidate = encode;\n  \
    \  assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt3ubtl8t.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpt3ubtl8t.cpp:68:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   68 | }\n      | ^\n/tmp/tmpt3ubtl8t.cpp:67:67: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   67 |         } else if (c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' ||\n      |                   ~        \
    \                                       ^\n      |                           \
    \                                        )\n   68 | }\n      | ~             \
    \                                                     \n/tmp/tmpt3ubtl8t.cpp:68:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   68 | }\n \
    \     | ^\n/tmp/tmpt3ubtl8t.cpp:69:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n\
    /tmp/tmpt3ubtl8t.cpp:76:1: error: expected \u2018}\u2019 at end of input\n   76\
    \ | }\n      | ^\n/tmp/tmpt3ubtl8t.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpt3ubtl8t.cpp:76:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   76 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i]\
    \ >= 'a' && ans[i] <= 'z') {\n            ans[i] = ans[i] - 'a' + 'A';\n     \
    \   }\n        else if (ans[i] >= 'A' && ans[i] <= 'Z') {\n            ans[i]\
    \ = ans[i] - 'A' + 'a';\n        }\n        else if (ans[i] == 'a' || ans[i] ==\
    \ 'A') {\n            ans[i] = ans[i] + 'A';\n        }\n        else if (ans[i]\
    \ == 'e' || ans[i] == 'E') {\n            ans[i] = ans[i] + 'E';\n        }\n\
    \        else if (ans[i] == 'i' || ans[i] == 'I') {\n            ans[i] = ans[i]\
    \ + 'I';\n        }\n        else if (ans[i] == 'o' || ans[i] == 'O') {\n    \
    \        ans[i] = ans[i] + 'O';\n        }\n        else if (ans[i] == 'u' ||\
    \ ans[i] == 'U') {\n            ans[i] = ans[i] + 'U';\n        }\n        else\
    \ if (ans[i] == 'y' || ans[i] == 'Y') {\n            ans[i] = ans[i] + 'Y';\n\
    \        }\n        else if (ans[i] == 'o' || ans[i] == 'O') {\n            ans[i]\
    \ = ans[i] + 'O';\n        }\n        else if (ans[i] == 'u' || ans[i] == 'U')\
    \ {\n            ans[i] = ans[i] + 'U';\n        }\n        else if (ans[i] ==\
    \ 'y' || ans[i] == 'Y') {\n            ans[i] = ans[i] + 'Y';\n        }\n   \
    \     else if (ans[i] == 'i' || ans[i] == 'I') {\n            ans[i] = ans[i]\
    \ + 'I';\n        }\n        else if (ans[i] == 'e' || ans[i] == 'E') {\n    \
    \        ans[i] = ans[i] + 'E';\n        }\n        else if (ans[i] == 'a' ||\
    \ ans[i] == 'A') {\n            ans[i] = ans[i] + 'A';\n        }\n        else\
    \ if (ans[i] == 'e' || ans[i] == 'E') {\n            ans[i] = ans[i] + 'E';\n\
    \        }\n        else if (ans[i] == 'i' || ans[i] == 'I') {\n            ans[i]\
    \ = ans[i] + 'I';\n        }\n        else if (ans[i] == 'o' || ans[i] == 'O')\
    \ {\n            ans[i] = ans[i] + 'O';\n        }\n        else if (ans[i] ==\
    \ 'u' || ans[i] == 'U') {\n            ans[i] = ans[i] + 'U';\n        }\n   \
    \     else if (ans[i] == 'y' || ans[i] == 'Y') {\n            ans[i] = ans[i]\
    \ + 'Y';\n        }\n        else if (ans[i] == 'o' || ans[i] == 'O') {\n    \
    \        ans[i] = ans[i] + 'O';\n        }\n        else if (ans[i] == 'u' ||\
    \ ans[i] == 'U') {\n            ans[i] = ans[i] + 'U';\n        }\n        else\
    \ if (ans[i] == 'y' || \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0s2_1ymm.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp0s2_1ymm.cpp:80:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   80 | }\n      | ^\n/tmp/tmp0s2_1ymm.cpp:79:34: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   79 |         else if (ans[i] ==\
    \ 'y' ||\n      |                 ~                ^\n      |                \
    \                  )\n   80 | }\n      | ~                                 \n\
    /tmp/tmp0s2_1ymm.cpp:80:1: error: expected primary-expression before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmp0s2_1ymm.cpp:81:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   81 | int main() {\n     \
    \ |            ^\n/tmp/tmp0s2_1ymm.cpp:88:1: error: expected \u2018}\u2019 at\
    \ end of input\n   88 | }\n      | ^\n/tmp/tmp0s2_1ymm.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmp0s2_1ymm.cpp:88:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   88 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        } else {\n            ans += 'A'\
    \ + (c - 'a');\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if (c == 'a') {\n            ans[i] = 'A';\n        } else if\
    \ (c == 'a') {\n            ans[i] = 'a';\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpwldi2ha_: /tmp/tmpwldi2ha_.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += (tolower(c) - 'a' + 2) % 26 + 'a';\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp6x4yhwso: /tmp/tmp6x4yhwso.cpp:23: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        switch(c) {\n            case 'a':\n            case\
    \ 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n\
    \                ans += c;\n                break;\n            case 'A':\n  \
    \          case 'E':\n            case 'I':\n            case 'O':\n         \
    \   case 'U':\n                ans += c;\n                break;\n           \
    \ default:\n                ans += 'A';\n                break;\n        }\n \
    \   }\n    for(int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        for(int j = i; j < ans.length(); j++) {\n            char d = ans[j];\n\
    \            if(c == d) {\n                ans[j] = ans[j + 1];\n            \
    \    ans[j + 1] = c;\n            }\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp6dss1sij: /tmp/tmp6dss1sij.cpp:51: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        if(message[i] == 'a')\
    \ {\n            ans += 'A';\n        }\n        else if(message[i] == 'b') {\n\
    \            ans += 'B';\n        }\n        else if(message[i] == 'c') {\n  \
    \          ans += 'C';\n        }\n        else if(message[i] == 'd') {\n    \
    \        ans += 'D';\n        }\n        else if(message[i] == 'e') {\n      \
    \      ans += 'E';\n        }\n        else if(message[i] == 'f') {\n        \
    \    ans += 'F';\n        }\n        else if(message[i] == 'g') {\n          \
    \  ans += 'G';\n        }\n        else if(message[i] == 'h') {\n            ans\
    \ += 'H';\n        }\n        else if(message[i] == 'i') {\n            ans +=\
    \ 'I';\n        }\n        else if(message[i] == 'j') {\n            ans += 'J';\n\
    \        }\n        else if(message[i] == 'k') {\n            ans += 'K';\n  \
    \      }\n        else if(message[i] == 'l') {\n            ans += 'L';\n    \
    \    }\n        else if(message[i] == 'm') {\n            ans += 'M';\n      \
    \  }\n        else if(message[i] == 'n') {\n            ans += 'N';\n        }\n\
    \        else if(message[i] == 'o') {\n            ans += 'O';\n        }\n  \
    \      else if(message[i] == 'p') {\n            ans += 'P';\n        }\n    \
    \    else if(message[i] == 'q') {\n            ans += 'Q';\n        }\n      \
    \  else if(message[i] == 'r') {\n            ans += 'R';\n        }\n        else\
    \ if(message[i] == 's') {\n            ans += 'S';\n        }\n        else if(message[i]\
    \ == 't') {\n            ans += 'T';\n        }\n        else if(message[i] ==\
    \ 'u') {\n            ans += 'U';\n        }\n        else if(message[i] == 'v')\
    \ {\n            ans += 'V';\n        }\n        else if(message[i] == 'w') {\n\
    \            ans += 'W';\n        }\n        else if(message[i] == 'x') {\n  \
    \          ans += 'X';\n        }\n        else if(message[i] == 'y') {\n    \
    \        ans += 'Y';\n        }\n        else if(message[i] == 'z') {\n      \
    \      ans += 'Z';\n        }\n        else if(message[i] == 'A') {\n        \
    \    ans += 'a';\n        }\n        else if(message[i] == 'B') {\n          \
    \  ans += 'b';\n        }\n        else if(message[i] == 'C') {\n            ans\
    \ += 'c';\n        }\n        else if(message[i] == '\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwpfai5o1.cpp:103:31: warning: missing terminating ' character\n\
    \  103 |         else if(message[i] == '\n      |                            \
    \   ^\n/tmp/tmpwpfai5o1.cpp:103:31: error: missing terminating ' character\n/tmp/tmpwpfai5o1.cpp:\
    \ In function \u2018std::string encode(std::string)\u2019:\n/tmp/tmpwpfai5o1.cpp:104:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  104 | }\n \
    \     | ^\n/tmp/tmpwpfai5o1.cpp:103:30: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n  103 |         else if(message[i] == '\n      |              \
    \  ~             ^\n      |                              )\n  104 | }\n      |\
    \ ~                             \n/tmp/tmpwpfai5o1.cpp:104:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n  104 | }\n      | ^\n/tmp/tmpwpfai5o1.cpp:105:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  105 | int main() {\n      |            ^\n/tmp/tmpwpfai5o1.cpp:112:1: error:\
    \ expected \u2018}\u2019 at end of input\n  112 | }\n      | ^\n/tmp/tmpwpfai5o1.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpwpfai5o1.cpp:112:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  112 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('a' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans += 'A';\n        } else if (c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans += 'a';\n\
    \        } else {\n            ans += c;\n        }\n    }\n    for (char c :\
    \ ans) {\n        if ('a' <= c && c <= 'z') {\n            ans[ans.find(c)] =\
    \ ans[ans.find(c) + 2];\n        } else if (c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U') {\n            ans[ans.find(c)] = ans[ans.find(c) + 1];\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[ans.find(c)] = ans[ans.find(c) - 1];\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp9eokyx3a: /tmp/tmp9eokyx3a.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c : ans) {\n        if (c != 'A' && c\
    \ != 'E' && c != 'I'\n            && c != 'O' && c != 'U' && c != 'Y') {\n   \
    \         ans[ans.find(c) + 1] = tolower(ans[ans.find(c) + 1]);\n        }\n \
    \   }\n    for (auto &c : ans) {\n        if (c == 'A' || c == 'E' || c == 'I'\n\
    \            || c == 'O' || c == 'U' || c == 'Y') {\n            ans[ans.find(c)\
    \ + 1] = toupper(ans[ans.find(c) + 1]);\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpwrjpo6h9: /tmp/tmpwrjpo6h9.cpp:34: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        char nextC = message[i+1];\n        char nextNextC =\
    \ message[i+2];\n        char nextNextNextC = message[i+3];\n        char nextNextNextNextC\
    \ = message[i+4];\n        char nextNextNextNextNextC = message[i+5];\n      \
    \  char nextNextNextNextNextNextC = message[i+6];\n        char nextNextNextNextNextNextNextC\
    \ = message[i+7];\n        char nextNextNextNextNextNextNextNextC = message[i+8];\n\
    \        char nextNextNextNextNextNextNextNextC = message[i+9];\n        char\
    \ nextNextNextNextNextNextNextNextNextC = message[i+10];\n        char nextNextNextNextNextNextNextNextNextC\
    \ = message[i+11];\n        char nextNextNextNextNextNextNextNextNextNextC = message[i+12];\n\
    \        char nextNextNextNextNextNextNextNextNextNextC = message[i+13];\n   \
    \     char nextNextNextNextNextNextNextNextNextNextC = message[i+14];\n      \
    \  char nextNextNextNextNextNextNextNextNextNextC = message[i+15];\n        char\
    \ nextNextNextNextNextNextNextNextNextNextC = message[i+16];\n        char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+17];\n        char nextNextNextNextNextNextNextNextNextNextC = message[i+18];\n\
    \        char nextNextNextNextNextNextNextNextNextNextC = message[i+19];\n   \
    \     char nextNextNextNextNextNextNextNextNextNextC = message[i+20];\n      \
    \  char nextNextNextNextNextNextNextNextNextNextNextC = message[i+21];\n     \
    \   char nextNextNextNextNextNextNextNextNextNextNextC = message[i+22];\n    \
    \    char nextNextNextNextNextNextNextNextNextNextNextC = message[i+23];\n   \
    \     char nextNextNextNextNextNextNextNextNextNextNextC = message[i+24];\n  \
    \      char nextNextNextNextNextNextNextNextNextNextNextC = message[i+25];\n \
    \       char nextNextNextNextNextNextNextNextNextNextNextC = message[i+26];\n\
    \        char nextNextNextNextNextNextNextNextNextNextNextC = message[i+27];\n\
    \        char nextNextNextNextNextNextNextNextNextNextNextC = message[i+28];\n\
    \        char nextNextNextNextNextNextNextNextNextNextNextC = message[i+29];\n\
    \        char nextNextNextNextNextNextNextNextNext\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpii8ajmbc.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpii8ajmbc.cpp:25:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextC\u2019\
    \n   25 |         char nextNextNextNextNextNextNextNextC = message[i+9];\n   \
    \   |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:24:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextC\u2019 previously declared\
    \ here\n   24 |         char nextNextNextNextNextNextNextNextC = message[i+8];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:27:14:\
    \ error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextC\u2019\
    \n   27 |         char nextNextNextNextNextNextNextNextNextC = message[i+11];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:26:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextC\u2019 previously declared\
    \ here\n   26 |         char nextNextNextNextNextNextNextNextNextC = message[i+10];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:29:14:\
    \ error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   29 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+13];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:30:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   30 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+14];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:31:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   31 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+15];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:32:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   32 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+16];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:33:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   33 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+17];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:34:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   34 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+18];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:35:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   35 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+19];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:36:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   36 |         char nextNextNextNextNextNextNextNextNextNextC = message[i+20];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:28:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   28 |         char nextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+12];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:38:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   38 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+22];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:39:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   39 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+23];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:40:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   40 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+24];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:41:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   41 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+25];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:42:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   42 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+26];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:43:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   43 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+27];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:44:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   44 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+28];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:45:14: error: redeclaration of \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019\
    \n   45 |         char nextNextNextNextNextNextNextNextNextNextNextC = message[i+29];\n\
    \      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpii8ajmbc.cpp:37:14:\
    \ note: \u2018char nextNextNextNextNextNextNextNextNextNextNextC\u2019 previously\
    \ declared here\n   37 |         char nextNextNextNextNextNextNextNextNextNextNextC\
    \ = message[i+21];\n      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpii8ajmbc.cpp:47:1: error: expected initializer before \u2018}\u2019 token\n\
    \   47 | }\n      | ^\n/tmp/tmpii8ajmbc.cpp:48:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   48 | int main() {\n     \
    \ |            ^\n/tmp/tmpii8ajmbc.cpp:55:1: error: expected \u2018}\u2019 at\
    \ end of input\n   55 | }\n      | ^\n/tmp/tmpii8ajmbc.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmpii8ajmbc.cpp:55:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   55 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        if(message[i]\
    \ >= 'a' && message[i] <= 'z') {\n            ans += message[i];\n        }\n\
    \        else if(message[i] >= 'A' && message[i] <= 'Z') {\n            ans +=\
    \ message[i];\n        }\n        else if(message[i] == 'a' || message[i] == 'e'\
    \ || message[i] == 'i' || message[i] == 'o' || message[i] == 'u' || message[i]\
    \ == 'y') {\n            ans += message[i];\n        }\n        else if(message[i]\
    \ == 'A' || message[i] == 'E' || message[i] == 'I' || message[i] == 'O' || message[i]\
    \ == 'U' || message[i] == 'Y') {\n            ans += message[i];\n        }\n\
    \        else {\n            ans += 'A';\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1gjn2iqg: /tmp/tmp1gjn2iqg.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        char c = message[i];\n\
    \        if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += (char)(c-32);\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += (char)(c+32);\n\
    \        }\n        else if(c>='a' && c<='z') {\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmbm_0s5z.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpmbm_0s5z.cpp:79:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   79 | int main() {\n      |            ^\n/tmp/tmpmbm_0s5z.cpp:86:1:\
    \ error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpmbm_0s5z.cpp:15:41:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i=0;i<message.length();i++)\
    \ {\n      |                                         ^\n/tmp/tmpmbm_0s5z.cpp:86:1:\
    \ error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpmbm_0s5z.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpmbm_0s5z.cpp:86:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   86 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += (tolower(c) - 'a' + 2) % 26 + 'a';\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp28e4aesv: /tmp/tmp28e4aesv.cpp:23: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        ans += c;\n        ans += ((i + 1) % 2 == 0) ? toupper(c)\
    \ : tolower(c);\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpf26_qedf: /tmp/tmpf26_qedf.cpp:24: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp4pks8znw: /tmp/tmp4pks8znw.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (std::tolower(c)\
    \ == c) ? std::toupper(c) : c;\n    }\n    for (auto &c : ans) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = std::tolower(ans[ans.find(c) + 2]);\n        }\n    }\n    for (auto\
    \ &c : ans) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n            ans[ans.find(c) + 2] = std::toupper(ans[ans.find(c) + 2]);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp23yob3y2: /tmp/tmp23yob3y2.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        if (std::toupper(c) != c)\
    \ {\n            ans += std::toupper(c);\n        } else {\n            ans +=\
    \ std::tolower(c);\n        }\n    }\n    for (auto &c : ans) {\n        if (std::isalpha(c))\
    \ {\n            ans[ans.find(c) + 1] = std::toupper(ans[ans.find(c) + 1]);\n\
    \        }\n    }\n    for (auto &c : ans) {\n        if (std::isalpha(c)) {\n\
    \            ans[ans.find(c) + 1] = std::tolower(ans[ans.find(c) + 1]);\n    \
    \    }\n    }\n    for (auto &c : ans) {\n        if (std::isalpha(c)) {\n   \
    \         ans[ans.find(c) + 1] = std::toupper(ans[ans.find(c) + 1]);\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpsjkvuh54: /tmp/tmpsjkvuh54.cpp:41: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        } else {\n            ans += 'A'\
    \ + (c - 'a');\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if (c == 'a') {\n            ans[i] = 'A';\n        } else if\
    \ (c == 'a') {\n            ans[i] = 'a';\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpttzf9ayw: /tmp/tmpttzf9ayw.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ c - 'a';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp0ngwq4uv: /tmp/tmp0ngwq4uv.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += (tolower(c) - 'a' + 2) % 26 + 'a';\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmprfaqn1up: /tmp/tmprfaqn1up.cpp:23: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if (std::isalpha(c)) {\n\
    \            ans += std::toupper(c);\n        }\n        else if (std::isupper(c))\
    \ {\n            ans += std::tolower(c);\n        }\n        else if (std::islower(c))\
    \ {\n            ans += c;\n        }\n        else if (std::isspace(c)) {\n \
    \           ans += ' ';\n        }\n        else {\n            ans += '?';\n\
    \        }\n    }\n    for (char c : ans) {\n        if (std::isalpha(c)) {\n\
    \            ans[ans.find(c)] = std::toupper(c);\n        }\n        else if (std::isupper(c))\
    \ {\n            ans[ans.find(c)] = std::tolower(c);\n        }\n        else\
    \ if (std::islower(c)) {\n            ans[ans.find(c)] = c;\n        }\n     \
    \   else if (std::isspace(c)) {\n            ans[ans.find(c)] = ' ';\n       \
    \ }\n        else {\n            ans[ans.find(c)] = '?';\n        }\n    }\n \
    \   return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp9bh80qj3: /tmp/tmp9bh80qj3.cpp:53: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if (c >= 'a' && c <= 'z')\
    \ {\n            ans += c;\n        } else if (c >= 'A' && c <= 'Z') {\n     \
    \       ans += c;\n        } else if (c >= '0' && c <= '9') {\n            ans\
    \ += c;\n        } else if (c == '.' || c == '-' || c == '_' || c == '/' || c\
    \ == '\\\\' || c == '!' || c == '@' || c == '#' || c == '$' || c == '%' || c ==\
    \ '^' || c == '&' || c == '*' || c == '(' || c == ')' || c == '_' || c == '+'\
    \ || c == '=' || c == '{' || c == '}' || c == ':' || c == '<' || c == '>' || c\
    \ == '/' || c == '?' || c == '|' || c == '\\\\' || c == '\"' || c == '~') {\n\
    \            ans += c;\n        } else {\n            ans += 'A' + c - 'a';\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmptx6uutzs: /tmp/tmptx6uutzs.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        switch (c) {\n        case\
    \ 'A':\n        case 'a':\n            ans += 'A';\n            break;\n     \
    \   case 'B':\n        case 'b':\n            ans += 'B';\n            break;\n\
    \        case 'C':\n        case 'c':\n            ans += 'C';\n            break;\n\
    \        case 'D':\n        case 'd':\n            ans += 'D';\n            break;\n\
    \        case 'E':\n        case 'e':\n            ans += 'E';\n            break;\n\
    \        case 'F':\n        case 'f':\n            ans += 'F';\n            break;\n\
    \        case 'G':\n        case 'g':\n            ans += 'G';\n            break;\n\
    \        case 'H':\n        case 'h':\n            ans += 'H';\n            break;\n\
    \        case 'I':\n        case 'i':\n            ans += 'I';\n            break;\n\
    \        case 'J':\n        case 'j':\n            ans += 'J';\n            break;\n\
    \        case 'K':\n        case 'k':\n            ans += 'K';\n            break;\n\
    \        case 'L':\n        case 'l':\n            ans += 'L';\n            break;\n\
    \        case 'M':\n        case 'm':\n            ans += 'M';\n            break;\n\
    \        case 'N':\n        case 'n':\n            ans += 'N';\n            break;\n\
    \        case 'O':\n        case 'o':\n            ans += 'O';\n            break;\n\
    \        case 'P':\n        case 'p':\n            ans += 'P';\n            break;\n\
    \        case 'Q':\n        case 'q':\n            ans += 'Q';\n            break;\n\
    \        case 'R':\n        case 'r':\n            ans += 'R';\n            break;\n\
    \        case 'S':\n        case 's':\n            ans += 'S';\n            break;\n\
    \        case 'T':\n        case 't':\n            ans += 'T';\n            break;\n\
    \        case 'U':\n        case 'u':\n            ans += 'U';\n            break;\n\
    \        case 'V':\n        case 'v':\n            ans += 'V';\n            break;\n\
    \        case 'W':\n        case 'w':\n            ans += 'W';\n            break;\n\
    \        case 'X':\n        case 'x':\n            ans += 'X';\n            break;\n\
    \        case 'Y':\n        case 'y':\n            ans += 'Y';\n            break;\n\
    \        case 'Z':\n        case 'z':\n            ans += 'Z';\n            break;\n\
    \        default:\n            ans += c;\n        }\n    }\n    for (auto &c :\
    \ ans) {\n        switch (c) {\n        case 'A':\n        case 'a':\n       \
    \     ans += 'a';\n            break;\n        case 'B':\n        case 'b':\n\
    \            ans += 'b\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0ob658ep.cpp:133:20: warning: missing terminating ' character\n\
    \  133 |             ans += 'b\n      |                    ^\n/tmp/tmp0ob658ep.cpp:133:20:\
    \ error: missing terminating ' character\n  133 |             ans += 'b\n    \
    \  |                    ^~\n/tmp/tmp0ob658ep.cpp: In function \u2018std::string\
    \ encode(std::string)\u2019:\n/tmp/tmp0ob658ep.cpp:134:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  134 | }\n      | ^\n/tmp/tmp0ob658ep.cpp:135:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  135 | int main() {\n      |            ^\n/tmp/tmp0ob658ep.cpp:142:1: error:\
    \ expected \u2018}\u2019 at end of input\n  142 | }\n      | ^\n/tmp/tmp0ob658ep.cpp:125:25:\
    \ note: to match this \u2018{\u2019\n  125 |     for (auto &c : ans) {\n     \
    \ |                         ^\n/tmp/tmp0ob658ep.cpp:142:1: error: expected \u2018\
    }\u2019 at end of input\n  142 | }\n      | ^\n/tmp/tmp0ob658ep.cpp:13:41: note:\
    \ to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp0ob658ep.cpp:142:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  142 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if('a' <= c && c <= 'z') {\n            ans += c;\n \
    \       } else if('A' <= c && c <= 'Z') {\n            ans += c;\n        } else\
    \ if('0' <= c && c <= '9') {\n            ans += c;\n        } else if('!' <=\
    \ c && c <= '@') {\n            ans += c;\n        } else if('?' <= c && c <=\
    \ '[') {\n            ans += c;\n        } else if('*' <= c && c <= '^') {\n \
    \           ans += c;\n        } else if('_' <= c && c <= '`') {\n           \
    \ ans += c;\n        } else if('{' <= c && c <= '}') {\n            ans += c;\n\
    \        } else if('|' <= c && c <= '~') {\n            ans += c;\n        } else\
    \ if('\\\\' <= c && c <= '/') {\n            ans += c;\n        } else if('>'\
    \ <= c && c <= '<') {\n            ans += c;\n        } else if('>' <= c && c\
    \ <= '<') {\n            ans += c;\n        } else if('>' <= c && c <= '<') {\n\
    \            ans += c;\n        } else if('>' <= c && c <= '<') {\n          \
    \  ans += c;\n        } else if('>' <= c && c <= '<') {\n            ans += c;\n\
    \        } else if('>' <= c && c <= '<') {\n            ans += c;\n        } else\
    \ if('>' <= c && c <= '<') {\n            ans += c;\n        } else if('>' <=\
    \ c && c <= '<') {\n            ans += c;\n        } else if('>' <= c && c <=\
    \ '<') {\n            ans += c;\n        } else if('>' <= c && c <= '<') {\n \
    \           ans += c;\n        } else if('>' <= c && c <= '<') {\n           \
    \ ans += c;\n        } else if('>' <= c && c <= '<') {\n            ans += c;\n\
    \        } else if('>' <= c && c <= '<') {\n            ans += c;\n        } else\
    \ if('>' <= c && c <= '<') {\n            ans += c;\n        } else if('>' <=\
    \ c && c <= '<') {\n            ans += c;\n\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpslmyxo0e.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpslmyxo0e.cpp:69:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n/tmp/tmpslmyxo0e.cpp:76:1:\
    \ error: expected \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpslmyxo0e.cpp:15:47:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i = 0; i < message.length();\
    \ i++) {\n      |                                               ^\n/tmp/tmpslmyxo0e.cpp:76:1:\
    \ error: expected \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpslmyxo0e.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpslmyxo0e.cpp:76:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   76 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++){\n        char c = message[i];\n\
    \        switch(c){\n            case 'a':\n            case 'e':\n          \
    \  case 'i':\n            case 'o':\n            case 'u':\n                ans\
    \ += 'A';\n                break;\n            case 'b':\n            case 'f':\n\
    \            case 'n':\n            case 'r':\n            case 't':\n       \
    \         ans += 'B';\n                break;\n            case 'c':\n       \
    \     case 'd':\n            case 'g':\n            case 'h':\n            case\
    \ 'j':\n                ans += 'C';\n                break;\n            case\
    \ 'e':\n            case 'f':\n            case 'h':\n            case 'k':\n\
    \            case 'l':\n                ans += 'D';\n                break;\n\
    \            case 'f':\n            case 'g':\n            case 'j':\n       \
    \     case 'k':\n            case 'l':\n                ans += 'E';\n        \
    \        break;\n            case 'g':\n            case 'h':\n            case\
    \ 'j':\n            case 'k':\n            case 'l':\n                ans += 'F';\n\
    \                break;\n            case 'h':\n            case 'j':\n      \
    \      case 'k':\n            case 'l':\n                ans += 'G';\n       \
    \         break;\n            case 'i':\n            case 'j':\n            case\
    \ 'k':\n            case 'l':\n                ans += 'H';\n                break;\n\
    \            case 'i':\n            case 'j':\n            case 'k':\n       \
    \     case 'l':\n                ans += 'I';\n                break;\n       \
    \     case 'j':\n            case 'k':\n            case 'l':\n              \
    \  ans += 'J';\n                break;\n            case 'k':\n            case\
    \ 'l':\n                ans += 'K';\n                break;\n            case\
    \ 'l':\n                ans += 'L';\n                break;\n            case\
    \ 'm':\n                ans += 'M';\n                break;\n            case\
    \ 'n':\n                ans += 'N';\n                break;\n            case\
    \ 'o':\n                ans += 'O';\n                break;\n            case\
    \ 'p':\n                ans += 'P';\n                break;\n            case\
    \ 'q':\n                ans += 'Q';\n                break;\n            case\
    \ 'r':\n                ans += 'R';\n                break;\n            case\
    \ 's':\n                ans += 'S';\n                break;\n            case\
    \ 't':\n                ans += 'T';\n                break;\n            case\
    \ 'u':\n                ans += 'U';\n                break;\n            case\
    \ 'v':\n                ans += 'V';\n                break;\n            case\
    \ 'w':\n                ans += 'W';\n                break;\n            case\
    \ 'x':\n                ans += 'X';\n                break;\n            case\
    \ 'y':\n                ans += 'Y';\n                break;\n            case\
    \ 'z':\n                ans += 'Z';\n                break;\n            default:\n\
    \                an\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpawbmf07i.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpawbmf07i.cpp:39:13: error: duplicate case value\n   39 |          \
    \   case 'e':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:19:13: note: previously\
    \ used here\n   19 |             case 'e':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:40:13:\
    \ error: duplicate case value\n   40 |             case 'f':\n      |        \
    \     ^~~~\n/tmp/tmpawbmf07i.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'f':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:41:13: error:\
    \ duplicate case value\n   41 |             case 'h':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:35:13: note: previously used here\n   35 |             case\
    \ 'h':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:46:13: error: duplicate\
    \ case value\n   46 |             case 'f':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:26:13:\
    \ note: previously used here\n   26 |             case 'f':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:47:13: error: duplicate case value\n   47 |  \
    \           case 'g':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:34:13: note:\
    \ previously used here\n   34 |             case 'g':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:48:13: error: duplicate case value\n   48 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:36:13: note: previously\
    \ used here\n   36 |             case 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:49:13:\
    \ error: duplicate case value\n   49 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmpawbmf07i.cpp:42:13: note: previously used here\n   42 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:50:13: error:\
    \ duplicate case value\n   50 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:43:13: note: previously used here\n   43 |             case\
    \ 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:53:13: error: duplicate\
    \ case value\n   53 |             case 'g':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:34:13:\
    \ note: previously used here\n   34 |             case 'g':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:54:13: error: duplicate case value\n   54 |  \
    \           case 'h':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:35:13: note:\
    \ previously used here\n   35 |             case 'h':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:55:13: error: duplicate case value\n   55 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:36:13: note: previously\
    \ used here\n   36 |             case 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:56:13:\
    \ error: duplicate case value\n   56 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmpawbmf07i.cpp:42:13: note: previously used here\n   42 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:57:13: error:\
    \ duplicate case value\n   57 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:43:13: note: previously used here\n   43 |             case\
    \ 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:60:13: error: duplicate\
    \ case value\n   60 |             case 'h':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:35:13:\
    \ note: previously used here\n   35 |             case 'h':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:61:13: error: duplicate case value\n   61 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:36:13: note:\
    \ previously used here\n   36 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:62:13: error: duplicate case value\n   62 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:42:13: note: previously\
    \ used here\n   42 |             case 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:63:13:\
    \ error: duplicate case value\n   63 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmpawbmf07i.cpp:43:13: note: previously used here\n   43 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:66:13: error:\
    \ duplicate case value\n   66 |             case 'i':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:20:13: note: previously used here\n   20 |             case\
    \ 'i':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:67:13: error: duplicate\
    \ case value\n   67 |             case 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:36:13:\
    \ note: previously used here\n   36 |             case 'j':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:68:13: error: duplicate case value\n   68 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:42:13: note:\
    \ previously used here\n   42 |             case 'k':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:69:13: error: duplicate case value\n   69 |             case\
    \ 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:43:13: note: previously\
    \ used here\n   43 |             case 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:72:13:\
    \ error: duplicate case value\n   72 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmpawbmf07i.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:73:13: error:\
    \ duplicate case value\n   73 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:36:13: note: previously used here\n   36 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:74:13: error: duplicate\
    \ case value\n   74 |             case 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:42:13:\
    \ note: previously used here\n   42 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:75:13: error: duplicate case value\n   75 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:43:13: note:\
    \ previously used here\n   43 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:78:13: error: duplicate case value\n   78 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:36:13: note: previously\
    \ used here\n   36 |             case 'j':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:79:13:\
    \ error: duplicate case value\n   79 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmpawbmf07i.cpp:42:13: note: previously used here\n   42 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:80:13: error:\
    \ duplicate case value\n   80 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:43:13: note: previously used here\n   43 |             case\
    \ 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:83:13: error: duplicate\
    \ case value\n   83 |             case 'k':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:42:13:\
    \ note: previously used here\n   42 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:84:13: error: duplicate case value\n   84 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:43:13: note:\
    \ previously used here\n   43 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:87:13: error: duplicate case value\n   87 |             case\
    \ 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:43:13: note: previously\
    \ used here\n   43 |             case 'l':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:93:13:\
    \ error: duplicate case value\n   93 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmpawbmf07i.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:96:13: error:\
    \ duplicate case value\n   96 |             case 'o':\n      |             ^~~~\n\
    /tmp/tmpawbmf07i.cpp:21:13: note: previously used here\n   21 |             case\
    \ 'o':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:105:13: error: duplicate\
    \ case value\n  105 |             case 'r':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:28:13:\
    \ note: previously used here\n   28 |             case 'r':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:111:13: error: duplicate case value\n  111 | \
    \            case 't':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:29:13:\
    \ note: previously used here\n   29 |             case 't':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:114:13: error: duplicate case value\n  114 | \
    \            case 'u':\n      |             ^~~~\n/tmp/tmpawbmf07i.cpp:22:13:\
    \ note: previously used here\n   22 |             case 'u':\n      |         \
    \    ^~~~\n/tmp/tmpawbmf07i.cpp:133:17: error: \u2018an\u2019 was not declared\
    \ in this scope; did you mean \u2018ans\u2019?\n  133 |                 an\n \
    \     |                 ^~\n      |                 ans\n/tmp/tmpawbmf07i.cpp:135:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  135 | int main() {\n      |            ^\n/tmp/tmpawbmf07i.cpp:142:1: error:\
    \ expected \u2018}\u2019 at end of input\n  142 | }\n      | ^\n/tmp/tmpawbmf07i.cpp:15:40:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i=0;i<message.length();i++){\n\
    \      |                                        ^\n/tmp/tmpawbmf07i.cpp:142:1:\
    \ error: expected \u2018}\u2019 at end of input\n  142 | }\n      | ^\n/tmp/tmpawbmf07i.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpawbmf07i.cpp:142:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  142 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans += 'A';\n        } else if (c ==\
    \ 'y' || c == 'u' || c == 'i' || c == 'o' || c == 'a') {\n            ans += 'Y';\n\
    \        } else if (c == 'o' || c == 'e' || c == 'i' || c == 'u') {\n        \
    \    ans += 'O';\n        } else if (c == 'h' || c == 'a' || c == 'u' || c ==\
    \ 'e' || c == 'r' || c == 'd') {\n            ans += 'H';\n        } else if (c\
    \ == 'c' || c == 'g' || c == 'h' || c == 'k' || c == 'm' || c == 's' || c == 't'\
    \ || c == 'g' || c == 'g' || c == 's') {\n            ans += 'C';\n        } else\
    \ if (c == 'b' || c == 'o' || c == 'o' || c == 'u' || c == 'e' || c == 'r' ||\
    \ c == 'd') {\n            ans += 'B';\n        } else if (c == 'f' || c == 'l'\
    \ || c == 'o' || c == 'r' || c == 'u' || c == 'e' || c == 'r' || c == 'd' || c\
    \ == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e'\
    \ || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c\
    \ == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r'\
    \ || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c\
    \ == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd'\
    \ || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c\
    \ == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e'\
    \ || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c\
    \ == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r'\
    \ || c == 'd' || c == 'e' || c == 'r\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplv4iur5k.cpp:30:853: warning: missing terminating ' character\n\
    \   30 |         } else if (c == 'f' || c == 'l' || c == 'o' || c == 'r' || c\
    \ == 'u' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd'\
    \ || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c\
    \ == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e'\
    \ || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c\
    \ == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r'\
    \ || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c\
    \ == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd'\
    \ || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c\
    \ == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e'\
    \ || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c\
    \ == 'r\n      |                                                             \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                ^\n/tmp/tmplv4iur5k.cpp:30:853: error: missing\
    \ terminating ' character\n   30 |         } else if (c == 'f' || c == 'l' ||\
    \ c == 'o' || c == 'r' || c == 'u' || c == 'e' || c == 'r' || c == 'd' || c ==\
    \ 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e'\
    \ || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c\
    \ == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r'\
    \ || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c\
    \ == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd'\
    \ || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c\
    \ == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e'\
    \ || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c\
    \ == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r'\
    \ || c == 'd' || c == 'e' || c == 'r\n      |                                \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                             ^~\n/tmp/tmplv4iur5k.cpp:\
    \ In function \u2018std::string encode(std::string)\u2019:\n/tmp/tmplv4iur5k.cpp:31:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   31 | }\n \
    \     | ^\n/tmp/tmplv4iur5k.cpp:30:852: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n   30 |         } else if (c == 'f' || c == 'l' || c == 'o' ||\
    \ c == 'r' || c == 'u' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c ==\
    \ 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r'\
    \ || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c\
    \ == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd'\
    \ || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c\
    \ == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e'\
    \ || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c\
    \ == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r'\
    \ || c == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c\
    \ == 'd' || c == 'e' || c == 'r' || c == 'd' || c == 'e' || c == 'r' || c == 'd'\
    \ || c == 'e' || c == 'r\n      |                   ~                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                ^\n      |                  \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                          )\n\
    \   31 | }\n      | ~                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                   \n/tmp/tmplv4iur5k.cpp:31:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   31 | }\n      | ^\n/tmp/tmplv4iur5k.cpp:32:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   32 | int main() {\n      |            ^\n/tmp/tmplv4iur5k.cpp:39:1: error:\
    \ expected \u2018}\u2019 at end of input\n   39 | }\n      | ^\n/tmp/tmplv4iur5k.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmplv4iur5k.cpp:39:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   39 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp2zjilk7t: /tmp/tmp2zjilk7t.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isalpha(c)) ? toupper(c)\
    \ : c;\n    }\n    for (char c : ans) {\n        ans.replace(ans.find(c), 2, toupper(ans.at(c)));\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7b4dxhq3.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp7b4dxhq3.cpp:19:55: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::replace(std::__cxx11::basic_string<char>::size_type,\
    \ int, int)\u2019\n   19 |         ans.replace(ans.find(c), 2, toupper(ans.at(c)));\n\
    \      |                                                       ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp7b4dxhq3.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1965:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _CharT*)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019 <near match>\n 1965 |       replace(size_type __pos, size_type __n1,\
    \ const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note:   conversion of argument 3 would be ill-formed:\n/tmp/tmp7b4dxhq3.cpp:19:44:\
    \ error: invalid conversion from \u2018int\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   19 |         ans.replace(ans.find(c), 2, toupper(ans.at(c)));\n      |   \
    \                                  ~~~~~~~^~~~~~~~~~~\n      |               \
    \                             |\n      |                                     \
    \       int\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp7b4dxhq3.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type = long unsigned int]\u2019\n 1893 |       replace(size_type\
    \ __pos, size_type __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:67:\
    \ note:   no known conversion for argument 3 from \u2018int\u2019 to \u2018const\
    \ std::__cxx11::basic_string<char>&\u2019\n 1893 |       replace(size_type __pos,\
    \ size_type __n, const basic_string& __str)\n      |                         \
    \                      ~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1915 |       replace(size_type __pos1, size_type __n1, const basic_string&\
    \ __str,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note:   candidate expects 5 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1940 |       replace(size_type __pos, size_type __n1, const _CharT*\
    \ __s,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note:   candidate expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1989 |       replace(size_type __pos, size_type __n1, size_type\
    \ __n2, _CharT __c)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note:   candidate expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2007 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2007:32:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018std::__cxx11::basic_string<char>::__const_iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019}\n 2007 |       replace(__const_iterator __i1, __const_iterator __i2,\n\
    \      |               ~~~~~~~~~~~~~~~~~^~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2027 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note:   candidate expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*]\u2019\n 2049 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2049:32:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018std::__cxx11::basic_string<char>::__const_iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019}\n 2049 |       replace(__const_iterator __i1, __const_iterator __i2,\
    \ const _CharT* __s)\n      |               ~~~~~~~~~~~~~~~~~^~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n 2070 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, size_type __n,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note:   candidate expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2097:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, _InputIterator, _InputIterator) [with _InputIterator\
    \ = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 2097 |         replace(const_iterator __i1, const_iterator __i2,\n      | \
    \        ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2097:9: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp7b4dxhq3.cpp:19:55: note: \
    \  candidate expects 4 arguments, 3 provided\n   19 |         ans.replace(ans.find(c),\
    \ 2, toupper(ans.at(c)));\n      |                                           \
    \            ^\nIn file included from /usr/include/c++/9/string:55,\n        \
    \         from /usr/include/c++/9/bits/locale_classes.h:40,\n                \
    \ from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp7b4dxhq3.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, _CharT*, _CharT*) [with _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2127 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note:   candidate expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, const _CharT*) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2138 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note:   candidate expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2149:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer = char*]\u2019\
    \n 2149 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2149:7: note:   candidate\
    \ expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2160:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator =\
    \ __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char> >]\u2019\
    \n 2160 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2160:7: note:   candidate\
    \ expects 4 arguments, 3 provided\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, std::initializer_list<_Tp>) [with _CharT = char; _Traits\
    \ = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                     ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2185:44:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018std::__cxx11::basic_string<char>::const_iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019}\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                             ~~~~~~~~~~~~~~~^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        char a = c;\n        char b = c;\n        char d = c;\n\
    \        char e = c;\n        char f = c;\n        char g = c;\n        char h\
    \ = c;\n        char i = c;\n        char j = c;\n        char k = c;\n      \
    \  char l = c;\n        char m = c;\n        char n = c;\n        char o = c;\n\
    \        char p = c;\n        char q = c;\n        char r = c;\n        char s\
    \ = c;\n        char t = c;\n        char u = c;\n        char v = c;\n      \
    \  char w = c;\n        char x = c;\n        char y = c;\n        char z = c;\n\
    \        char A = c;\n        char B = c;\n        char C = c;\n        char D\
    \ = c;\n        char E = c;\n        char F = c;\n        char G = c;\n      \
    \  char H = c;\n        char I = c;\n        char J = c;\n        char K = c;\n\
    \        char L = c;\n        char M = c;\n        char N = c;\n        char O\
    \ = c;\n        char P = c;\n        char Q = c;\n        char R = c;\n      \
    \  char S = c;\n        char T = c;\n        char U = c;\n        char V = c;\n\
    \        char W = c;\n        char X = c;\n        char Y = c;\n        char Z\
    \ = c;\n        char a1 = c;\n        char a2 = c;\n        char a3 = c;\n   \
    \     char a4 = c;\n        char a5 = c;\n        char a6 = c;\n        char a7\
    \ = c;\n        char a8 = c;\n        char a9 = c;\n        char a10 = c;\n  \
    \      char a11 = c;\n        char a12 = c;\n        char a13 = c;\n        char\
    \ a14 = c;\n        char a15 = c;\n        char a16 = c;\n        char a17 = c;\n\
    \        char a18 = c;\n        char a19 = c;\n        char a20 = c;\n       \
    \ char a21 = c;\n        char a22 = c;\n        char a23 = c;\n        char a24\
    \ = c;\n        char a25 = c;\n        char a26 = c;\n        char a27 = c;\n\
    \        char a28 = c;\n        char a29 = c;\n        char a30 = c;\n       \
    \ char a31 = c;\n        char a32 = c;\n        char a33 = c;\n        char a34\
    \ = c;\n        char a\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpypez9etk.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpypez9etk.cpp:24:14: error: redeclaration of \u2018char i\u2019\n  \
    \ 24 |         char i = c;\n      |              ^\n/tmp/tmpypez9etk.cpp:15:13:\
    \ note: \u2018int i\u2019 previously declared here\n   15 |     for(int i = 0;\
    \ i < message.length(); i++) {\n      |             ^\n/tmp/tmpypez9etk.cpp:103:1:\
    \ error: expected initializer before \u2018}\u2019 token\n  103 | }\n      | ^\n\
    /tmp/tmpypez9etk.cpp:104:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  104 | int main() {\n      |            ^\n/tmp/tmpypez9etk.cpp:111:1:\
    \ error: expected \u2018}\u2019 at end of input\n  111 | }\n      | ^\n/tmp/tmpypez9etk.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpypez9etk.cpp:111:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  111 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        char temp = c;\n       \
    \ temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp\
    \ - '0' + 1;\n        temp = temp - '9' + 1;\n        ans += temp;\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp3slh05zl: /tmp/tmp3slh05zl.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('a' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans += 'A';\n        } else if (c ==\
    \ 'O' || c == 'U') {\n            ans += 'O';\n        } else if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n \
    \       } else if (c == 'o' || c == 'u') {\n            ans += 'O';\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'A')\
    \ {\n            ans[i] = 'a';\n        } else if (ans[i] == 'O') {\n        \
    \    ans[i] = 'o';\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] == 'a') {\n            ans[i] = 'A';\n        } else if\
    \ (ans[i] == 'o') {\n            ans[i] = 'O';\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'A') {\n            ans[i]\
    \ = 'a';\n        } else if (ans[i] == 'O') {\n            ans[i] = 'o';\n   \
    \     }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'a') {\n            ans[i] = 'A';\n        } else if (ans[i] == 'o') {\n\
    \            ans[i] = 'O';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == 'A') {\n            ans[i] = 'a';\n        } else\
    \ if (ans[i] == 'O') {\n            ans[i] = 'o';\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'a') {\n            ans[i]\
    \ = 'A';\n        } else if (ans[i] == 'o') {\n            ans[i] = 'O';\n   \
    \     }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'A') {\n            ans[i] = 'a';\n        } else if (ans[i] == 'O') {\n\
    \            ans[i] = 'o';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == 'a') {\n            ans[i] = 'A';\n        } else\
    \ if (ans[i] == 'o') {\n            ans[i] = 'O';\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'A') {\n            ans[i]\
    \ = 'a';\n        } else if (ans[i] == 'O') {\n            ans[i] = 'o';\n   \
    \     }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'a') {\n            ans[i] = 'A';\n        } else if (ans[i] == 'o') {\n\
    \            ans[i] = 'O';\n\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppj5q78gu.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmppj5q78gu.cpp:98:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   98 | int main() {\n      |            ^\n/tmp/tmppj5q78gu.cpp:105:1:\
    \ error: expected \u2018}\u2019 at end of input\n  105 | }\n      | ^\n/tmp/tmppj5q78gu.cpp:91:44:\
    \ note: to match this \u2018{\u2019\n   91 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmppj5q78gu.cpp:105:1:\
    \ error: expected \u2018}\u2019 at end of input\n  105 | }\n      | ^\n/tmp/tmppj5q78gu.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmppj5q78gu.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  105 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c: message) {\n        ans += (std::toupper(c) -\
    \ 'A' + 2) % 26 + 'A';\n    }\n    for (auto &c: ans) {\n        ans[ans.find(c)]\
    \ = std::tolower(c);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp20doax61: /tmp/tmp20doax61.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c: message) {\n        ans += (std::tolower(c) -\
    \ 'a' + 2) % 26 + 'a';\n    }\n    for (auto &c: ans) {\n        ans[ans.find(c)\
    \ - 1] = (std::tolower(c) - 'a' + 1) % 26 + 'a';\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpj1nwl8fg: /tmp/tmpj1nwl8fg.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            ans += 'A' + (c - 'a' + 2);\n        }\n    }\n \
    \   return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp7xdqnrfc: /tmp/tmp7xdqnrfc.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            ans += c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\
    \ c == 'Y') {\n            ans += 'A';\n        } else if (c == 'B' || c == 'C'\
    \ || c == 'D' || c == 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c\
    \ == 'L' || c == 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c == 'S'\
    \ || c == 'T' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n\
    \            ans += 'B';\n        } else if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y') {\n            ans += 'a';\n        } else\
    \ if (c == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' ||\
    \ c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c ==\
    \ 'q' || c == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x'\
    \ || c == 'y' || c == 'z') {\n            ans += 'b';\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if ('a'\
    \ <= c && c <= 'z') {\n            ans[i] = c;\n        } else if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U' || c == 'Y') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'B' || c == 'C' || c == 'D' || c == 'F' || c\
    \ == 'G' || c == 'H' || c == 'J' || c == 'K' || c == 'L' || c == 'M' || c == 'N'\
    \ || c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c == 'T' || c == 'V' || c\
    \ == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n            ans[i] = 'B';\n \
    \       } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\
    \ c == 'y') {\n            ans[i] = 'a';\n        } else if (c == 'b' || c ==\
    \ 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == '\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpde4n38io.cpp:39:109: warning: missing terminating ' character\n\
    \   39 |         } else if (c == 'b' || c == 'c' || c == 'd' || c == 'f' || c\
    \ == 'g' || c == 'h' || c == 'j' || c == '\n      |                          \
    \                                                                            \
    \       ^\n/tmp/tmpde4n38io.cpp:39:109: error: missing terminating ' character\n\
    /tmp/tmpde4n38io.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpde4n38io.cpp:40:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   40 | }\n      | ^\n/tmp/tmpde4n38io.cpp:39:108: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   39 |         } else if (c == 'b'\
    \ || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c\
    \ == '\n      |                   ~                                          \
    \                                              ^\n      |                    \
    \                                                                            \
    \            )\n   40 | }\n      | ~                                         \
    \                                                                  \n/tmp/tmpde4n38io.cpp:40:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   40 | }\n \
    \     | ^\n/tmp/tmpde4n38io.cpp:41:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   41 | int main() {\n      |            ^\n\
    /tmp/tmpde4n38io.cpp:48:1: error: expected \u2018}\u2019 at end of input\n   48\
    \ | }\n      | ^\n/tmp/tmpde4n38io.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpde4n38io.cpp:48:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   48 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encodedMessage = \"\";\n    for(char c : message) {\n        encodedMessage\
    \ += toupper(c);\n    }\n    for(char c : message) {\n        encodedMessage +=\
    \ tolower(c);\n    }\n    for(char c : message) {\n        if(c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += tolower(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += toupper(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += toupper(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += tolower(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += tolower(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += toupper(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += toupper(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += tolower(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += tolower(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += toupper(c);\n\
    \        }\n    }\n    for(char c : message) {\n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            encodedMessage += toupper(c);\n\
    \        }\n    }\n    for(char c : message) {\n\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgrq9a2iq.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpgrq9a2iq.cpp:79:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   79 | int main() {\n      |            ^\n/tmp/tmpgrq9a2iq.cpp:86:1:\
    \ error: expected \u2018}\u2019 at end of input\n   86 | }\n      | ^\n/tmp/tmpgrq9a2iq.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpgrq9a2iq.cpp:86:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   86 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isalpha(c)) ? toupper(c)\
    \ : c;\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        ans[i] = tolower(ans[i]);\n\
    \    }\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i] == 'a'\
    \ || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n   \
    \         ans[i] = ans[i - 1];\n        }\n    }\n    for (int i = 0; i < ans.size();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[i - 2];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i] == 'a' ||\
    \ ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n      \
    \      ans[i] = ans[i - 3];\n        }\n    }\n    for (int i = 0; i < ans.size();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[i - 4];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i] == 'a' ||\
    \ ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n      \
    \      ans[i] = ans[i - 5];\n        }\n    }\n    for (int i = 0; i < ans.size();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[i - 6];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i] == 'a' ||\
    \ ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n      \
    \      ans[i] = ans[i - 7];\n        }\n    }\n    for (int i = 0; i < ans.size();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[i - 8];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i] == 'a' ||\
    \ ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n      \
    \      ans[i] = ans[i - 9];\n        }\n    }\n    for (int i = 0; i < ans.size();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[i - 10];\n        }\n \
    \   }\n    for (int i = 0; i < ans.size(); i++) {\n        if (\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqsxe6p4m.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpqsxe6p4m.cpp:73:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   73 | }\n      | ^\n/tmp/tmpqsxe6p4m.cpp:72:13: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   72 |         if (\n      |    \
    \        ~^\n      |             )\n   73 | }\n      | ~            \n/tmp/tmpqsxe6p4m.cpp:73:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   73 | }\n \
    \     | ^\n/tmp/tmpqsxe6p4m.cpp:74:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   74 | int main() {\n      |            ^\n\
    /tmp/tmpqsxe6p4m.cpp:81:1: error: expected \u2018}\u2019 at end of input\n   81\
    \ | }\n      | ^\n/tmp/tmpqsxe6p4m.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpqsxe6p4m.cpp:81:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   81 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        char temp = c;\n       \
    \ temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp\
    \ - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n\
    \        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp\
    \ = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A'\
    \ + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n     \
    \   temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp\
    \ - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n\
    \        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp\
    \ = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A'\
    \ + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n     \
    \   temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp\
    \ - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n\
    \        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp\
    \ = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A'\
    \ + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n     \
    \   temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp\
    \ - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n\
    \        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp\
    \ = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A'\
    \ + 1;\n        temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n     \
    \   temp = temp - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp\
    \ - 'a' + 1;\n        temp = temp - 'A' + 1;\n        temp = temp - 'a' + 1;\n\
    \        temp = temp - 'A' + 1;\n        temp = temp - 'a' + \n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw52n2gum.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpw52n2gum.cpp:72:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   72 | }\n      | ^\n/tmp/tmpw52n2gum.cpp:73:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   73 | int main() {\n     \
    \ |            ^\n/tmp/tmpw52n2gum.cpp:80:1: error: expected \u2018}\u2019 at\
    \ end of input\n   80 | }\n      | ^\n/tmp/tmpw52n2gum.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmpw52n2gum.cpp:80:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   80 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += tolower(c);\n\
    \        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n        char c\
    \ = ans[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[i] = tolower(ans[i+1]);\n        }\n    }\n    for(int i\
    \ = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = toupper(ans[i+1]);\n\
    \        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n        char c\
    \ = ans[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[i] = toupper(ans[i+1]);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpvtijik3w: /tmp/tmpvtijik3w.cpp:45: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'A' + (c - 'A'\
    \ + 1) % 2 + 'a';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp82fp0fi5: /tmp/tmp82fp0fi5.cpp:26: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for(int i = 0; i < ans.size(); i++) {\n        if(ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for(int i = 0; i\
    \ < ans.size(); i++) {\n        if(ans[i] == 'A' || ans[i] == 'E' || ans[i] ==\
    \ 'I' || ans[i] == 'O' || ans[i] == 'U') {\n            ans[i] = ans[i - 1];\n\
    \        }\n    }\n    for(int i = 0; i < ans.size(); i++) {\n        if(ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for(int i = 0; i\
    \ < ans.size(); i++) {\n        if(ans[i] == 'A' || ans[i] == 'E' || ans[i] ==\
    \ 'I' || ans[i] == 'O' || ans[i] == 'U') {\n            ans[i] = ans[i - 1];\n\
    \        }\n    }\n    for(int i = 0; i < ans.size(); i++) {\n        if(ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for(int i = 0; i\
    \ < ans.size(); i++) {\n        if(ans[i] == 'A' || ans[i] == 'E' || ans[i] ==\
    \ 'I' || ans[i] == 'O' || ans[i] == 'U') {\n            ans[i] = ans[i - 1];\n\
    \        }\n    }\n    for(int i = 0; i < ans.size(); i++) {\n        if(ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for(int i = 0; i\
    \ < ans.size(); i++) {\n        if(ans[i] == 'A' || ans[i] == 'E' || ans[i] ==\
    \ 'I' || ans[i] == 'O' || ans[i] == 'U') {\n            ans[i] = ans[i - 1];\n\
    \        }\n    }\n    for(int i = 0; i < ans.size(); i++) {\n        if(ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for(int i = 0; i\
    \ < ans.size(); i++) {\n        if(ans[i] == 'A' || ans[i] == 'E' || ans[i] ==\
    \ 'I' || ans[i] == 'O' || ans[i] == 'U') {\n            ans[i] = ans[i - 1];\n\
    \        }\n    }\n    for(int i = 0; i < ans.size(); i++) {\n        if(ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('a' <= c && c <= 'z')\
    \ {\n            ans += c;\n        }\n        else if (c == 'A' || c == 'E' ||\
    \ c == 'I' || c == 'O' || c == 'U') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'B' || c == 'C' ||\
    \ c == 'D' || c == 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c ==\
    \ 'L' || c == 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c == 'S'\
    \ || c == 'T' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n\
    \            ans += 'B';\n        }\n        else if (c == 'b' || c == 'c' ||\
    \ c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == 'k' || c ==\
    \ 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's'\
    \ || c == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y' || c == 'z') {\n\
    \            ans += 'b';\n        }\n        else if (c == 'C' || c == 'D' ||\
    \ c == 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c == 'L' || c ==\
    \ 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c == 'T'\
    \ || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n           \
    \ ans += 'C';\n        }\n        else if (c == 'c' || c == 'd' || c == 'f' ||\
    \ c == 'g' || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c == 'm' || c ==\
    \ 'n' || c == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't' || c == 'v'\
    \ || c == 'w' || c == 'x' || c == 'y' || c == 'z') {\n            ans += 'c';\n\
    \        }\n        else if (c == 'D' || c == 'F' || c == 'G' || c == 'H' || c\
    \ == 'J' || c == 'K' || c == 'L' || c == 'M' || c == 'N' || c == 'P' || c == 'Q'\
    \ || c\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7riojl0f.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp7riojl0f.cpp:37:151: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   37 |         else if (c == 'D' || c == 'F' || c == 'G' || c == 'H'\
    \ || c == 'J' || c == 'K' || c == 'L' || c == 'M' || c == 'N' || c == 'P' || c\
    \ == 'Q' || c\n      |                 ~                                     \
    \                                                                            \
    \                    ^\n      |                                              \
    \                                                                            \
    \                             )\n   38 | }\n      | ~                        \
    \                                                                            \
    \                                                  \n/tmp/tmp7riojl0f.cpp:38:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   38 | }\n \
    \     | ^\n/tmp/tmp7riojl0f.cpp:39:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   39 | int main() {\n      |            ^\n\
    /tmp/tmp7riojl0f.cpp:46:1: error: expected \u2018}\u2019 at end of input\n   46\
    \ | }\n      | ^\n/tmp/tmp7riojl0f.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmp7riojl0f.cpp:46:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   46 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        if(message[i]\
    \ >= 'a' && message[i] <= 'z') {\n            ans += message[i];\n        }\n\
    \        else if(message[i] >= 'A' && message[i] <= 'Z') {\n            ans +=\
    \ message[i];\n        }\n        else if(message[i] == 'a' || message[i] == 'e'\
    \ || message[i] == 'i' || message[i] == 'o' || message[i] == 'u' || message[i]\
    \ == 'y') {\n            ans += message[i];\n        }\n        else if(message[i]\
    \ == 'A' || message[i] == 'E' || message[i] == 'I' || message[i] == 'O' || message[i]\
    \ == 'U' || message[i] == 'Y') {\n            ans += message[i];\n        }\n\
    \        else {\n            ans += 'a';\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpn3_q389h: /tmp/tmpn3_q389h.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'A' + (c - 'A');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'A' + (c - 'A');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('a' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'a' + (c - 'a');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('e' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'e' + (c - 'e');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('i' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'i' + (c - 'i');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('o' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'o' + (c - 'o');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('u' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'u' + (c - 'u');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('E' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'E' + (c - 'E');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('E' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'E' + (c - 'E');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('e' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'e' + (c - 'e');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('i' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'i' + (c - 'i');\n\
    \        }\n    }\n    for (char c : ans) {\n        if ('o' <= c && c <= 'z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'o' + (c - 'o');\n\
    \        }\n    }\n    for (char c : ans) {\n\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsi7hqvp1.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpsi7hqvp1.cpp:102:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  102 | int main() {\n      |            ^\n/tmp/tmpsi7hqvp1.cpp:109:1:\
    \ error: expected \u2018}\u2019 at end of input\n  109 | }\n      | ^\n/tmp/tmpsi7hqvp1.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpsi7hqvp1.cpp:109:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  109 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans += 'A';\n        } else if (c ==\
    \ 'y' || c == 'a' || c == 'o' || c == 'u') {\n            ans += 'Y';\n      \
    \  } else if (c == 'h' || c == 'k' || c == 's' || c == 't') {\n            ans\
    \ += 'H';\n        } else if (c == 'c' || c == 'g' || c == 'm' || c == 'g' ||\
    \ c == 's') {\n            ans += 'C';\n        } else if (c == 'g' || c == 'g'\
    \ || c == 'g' || c == 's') {\n            ans += 'G';\n        } else if (c ==\
    \ 'm' || c == 's' || c == 's') {\n            ans += 'M';\n        } else if (c\
    \ == 's' || c == 's') {\n            ans += 'S';\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp2pkc7quz: /tmp/tmp2pkc7quz.cpp:38: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (char c : ans) {\n        if (c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c) + 2]\
    \ = tolower(c);\n        }\n    }\n    for (char c : ans) {\n        if (c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp04fh7hnu: /tmp/tmp04fh7hnu.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        char c = message[i];\n\
    \        if(c>='a' && c<='z') {\n            ans += (char)((c-'a')+26);\n    \
    \    } else if(c>='A' && c<='Z') {\n            ans += (char)((c-'A')+26);\n \
    \       } else if(c>='0' && c<='9') {\n            ans += (char)((c-'0')+10);\n\
    \        } else {\n            ans += c;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpnhu2req3: /tmp/tmpnhu2req3.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('A' <= c && c <= 'Z') {\n            ans += c;\n\
    \        } else {\n            ans += 'A' + (c - 'A' + 2) % 26 + 'a';\n      \
    \  }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp18wyplq6: /tmp/tmp18wyplq6.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &i : message) {\n        if (i == 'a' || i == 'e'\
    \ || i == 'i' || i == 'o' || i == 'u') {\n            ans += 'A';\n        } else\
    \ if (i == 'A' || i == 'E' || i == 'I' || i == 'O' || i == 'U') {\n          \
    \  ans += 'a';\n        } else if (i == 'b' || i == 'c' || i == 'd' || i == 'f'\
    \ || i == 'g' || i == 'h' || i == 'j' || i == 'k' || i == 'l' || i == 'm' || i\
    \ == 'n' || i == 'p' || i == 'q' || i == 'r' || i == 's' || i == 't' || i == 'v'\
    \ || i == 'w' || i == 'x' || i == 'y' || i == 'z') {\n            ans += 'B';\n\
    \        } else if (i == 'B' || i == 'C' || i == 'D' || i == 'F' || i == 'G' ||\
    \ i == 'H' || i == 'J' || i == 'K' || i == 'L' || i == 'M' || i == 'N' || i ==\
    \ 'P' || i == 'Q' || i == 'R' || i == 'S' || i == 'T' || i == 'V' || i == 'W'\
    \ || i == 'X' || i == 'Y' || i == 'Z') {\n            ans += 'b';\n        } else\
    \ if (i == 'c' || i == 'd' || i == 'f' || i == 'g' || i == 'h' || i == 'j' ||\
    \ i == 'k' || i == 'l' || i == 'm' || i == 'n' || i == 'p' || i == 'q' || i ==\
    \ 'r' || i == 's' || i == 't' || i == 'v' || i == 'w' || i == 'x' || i == 'y'\
    \ || i == 'z') {\n            ans += 'C';\n        } else if (i == 'D' || i ==\
    \ 'F' || i == 'G' || i == 'H' || i == 'J' || i == 'K' || i == 'L' || i == 'M'\
    \ || i == 'N' || i == 'P' || i == 'Q' || i == 'R' || i == 'S' || i == 'T' || i\
    \ == 'V' || i == 'W' || i == 'X' || i == 'Y' || i == 'Z') {\n            ans +=\
    \ 'd';\n        } else if (i == 'f' || i == 'g' || i == 'h' || i == 'j' || i ==\
    \ 'k' || i == 'l' || i == 'm' || i == 'n' || i == 'p' || i == 'q' || i == 'r'\
    \ || i == 's' || i == 't' || i == 'v' || i == 'w' || i == 'x' || i == 'y' || i\
    \ == 'z') {\n            ans += 'F';\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn8cbmw91.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpn8cbmw91.cpp:31:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   31 | int main() {\n      |            ^\n/tmp/tmpn8cbmw91.cpp:38:1:\
    \ error: expected \u2018}\u2019 at end of input\n   38 | }\n      | ^\n/tmp/tmpn8cbmw91.cpp:15:29:\
    \ note: to match this \u2018{\u2019\n   15 |     for (auto &i : message) {\n \
    \     |                             ^\n/tmp/tmpn8cbmw91.cpp:38:1: error: expected\
    \ \u2018}\u2019 at end of input\n   38 | }\n      | ^\n/tmp/tmpn8cbmw91.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpn8cbmw91.cpp:38:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   38 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpvpa80dtz: /tmp/tmpvpa80dtz.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (auto &c : message) {\n        switch (c) {\n     \
    \       case 'a':\n                encoded += 'A';\n                break;\n \
    \           case 'b':\n                encoded += 'B';\n                break;\n\
    \            case 'c':\n                encoded += 'C';\n                break;\n\
    \            case 'd':\n                encoded += 'D';\n                break;\n\
    \            case 'e':\n                encoded += 'E';\n                break;\n\
    \            case 'f':\n                encoded += 'F';\n                break;\n\
    \            case 'g':\n                encoded += 'G';\n                break;\n\
    \            case 'h':\n                encoded += 'H';\n                break;\n\
    \            case 'i':\n                encoded += 'I';\n                break;\n\
    \            case 'j':\n                encoded += 'J';\n                break;\n\
    \            case 'k':\n                encoded += 'K';\n                break;\n\
    \            case 'l':\n                encoded += 'L';\n                break;\n\
    \            case 'm':\n                encoded += 'M';\n                break;\n\
    \            case 'n':\n                encoded += 'N';\n                break;\n\
    \            case 'o':\n                encoded += 'O';\n                break;\n\
    \            case 'p':\n                encoded += 'P';\n                break;\n\
    \            case 'q':\n                encoded += 'Q';\n                break;\n\
    \            case 'r':\n                encoded += 'R';\n                break;\n\
    \            case 's':\n                encoded += 'S';\n                break;\n\
    \            case 't':\n                encoded += 'T';\n                break;\n\
    \            case 'u':\n                encoded += 'U';\n                break;\n\
    \            case 'v':\n                encoded += 'V';\n                break;\n\
    \            case 'w':\n                encoded += 'W';\n                break;\n\
    \            case 'x':\n                encoded += 'X';\n                break;\n\
    \            case 'y':\n                encoded += 'Y';\n                break;\n\
    \            case 'z':\n                encoded += 'Z';\n                break;\n\
    \            case 'A':\n                encoded += 'a';\n                break;\n\
    \            case 'B':\n                encoded += 'b';\n                break;\n\
    \            case 'C':\n                encoded += 'c';\n                break;\n\
    \            case 'D':\n                encoded += 'd';\n                break;\n\
    \            case 'E':\n                encoded += 'e';\n                break;\n\
    \            case 'F':\n                encoded += 'f';\n                break;\n\
    \            case 'G':\n                encoded += 'g';\n                break;\n\
    \            case 'H':\n                encoded += 'h';\n                break;\n\
    \            case 'I':\n                encoded += 'i';\n                break;\n\
    \            case 'J':\n                encoded += 'j';\n                break;\n\
    \            case 'K':\n                encoded += 'k';\n                break;\n\
    \            case 'L':\n                encoded += 'l';\n                break;\n\
    \            case 'M':\n                encoded += 'm';\n                break;\n\
    \            case 'N':\n                encoded += 'n';\n                break;\n\
    \            case 'O':\n                encoded += 'o';\n                break;\n\
    \            case 'P':\n\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw1lufanx.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpw1lufanx.cpp:142:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  142 | }\n      | ^\n/tmp/tmpw1lufanx.cpp:143:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  143 | int main() {\n     \
    \ |            ^\n/tmp/tmpw1lufanx.cpp:150:1: error: expected \u2018}\u2019 at\
    \ end of input\n  150 | }\n      | ^\n/tmp/tmpw1lufanx.cpp:15:29: note: to match\
    \ this \u2018{\u2019\n   15 |     for (auto &c : message) {\n      |         \
    \                    ^\n/tmp/tmpw1lufanx.cpp:150:1: error: expected \u2018}\u2019\
    \ at end of input\n  150 | }\n      | ^\n/tmp/tmpw1lufanx.cpp:13:41: note: to\
    \ match this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n\
    \      |                                         ^\n/tmp/tmpw1lufanx.cpp:150:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  150 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            ans += 'A';\n        }\n    }\n    for(int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'A') {\n\
    \            ans[i] = 'a';\n        }\n        else if(c == 'a') {\n         \
    \   ans[i] = 'A';\n        }\n        else if(c == 'E') {\n            ans[i]\
    \ = 'e';\n        }\n        else if(c == 'e') {\n            ans[i] = 'E';\n\
    \        }\n        else if(c == 'I') {\n            ans[i] = 'i';\n        }\n\
    \        else if(c == 'i') {\n            ans[i] = 'I';\n        }\n        else\
    \ if(c == 'O') {\n            ans[i] = 'o';\n        }\n        else if(c == 'o')\
    \ {\n            ans[i] = 'O';\n        }\n        else if(c == 'U') {\n     \
    \       ans[i] = 'u';\n        }\n        else if(c == 'u') {\n            ans[i]\
    \ = 'U';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpg0_io6od: /tmp/tmpg0_io6od.cpp:64: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ c - 'a';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpsrpkmonj: /tmp/tmpsrpkmonj.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            ans += toupper(c);\n        }\n    }\n    for(int\
    \ i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'a';\n\
    \        }\n        else if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans[i] = 'A';\n        }\n    }\n    for(int i = 0; i\
    \ < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'A';\n    \
    \    }\n        else if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans[i] = 'a';\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpotxu7xw6: /tmp/tmpotxu7xw6.cpp:49: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        char c = message[i];\n\
    \        if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvs2xz1_c.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpvs2xz1_c.cpp:91:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   91 | int main() {\n      |            ^\n/tmp/tmpvs2xz1_c.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpvs2xz1_c.cpp:15:41:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i=0;i<message.length();i++)\
    \ {\n      |                                         ^\n/tmp/tmpvs2xz1_c.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpvs2xz1_c.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpvs2xz1_c.cpp:98:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   98 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c : ans) {\n        if (isalpha(c)) {\n\
    \            ans[ans.find(c) + 2] = tolower(c);\n        }\n    }\n    for (auto\
    \ &c : ans) {\n        if (isalpha(c)) {\n            ans[ans.find(c) + 2] = toupper(c);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpxi1k7cei: /tmp/tmpxi1k7cei.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            ans += c;\n        } else\
    \ {\n            ans += std::tolower(c);\n        }\n    }\n    for (char c :\
    \ ans) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans += c;\n        } else {\n            ans += std::toupper(c);\n\
    \        }\n    }\n    for (char c : ans) {\n        if (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            ans += c;\n        } else\
    \ {\n            ans += std::tolower(c);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmprb25rawc: /tmp/tmprb25rawc.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if('a' <= c && c <= 'z') {\n            ans += c;\n \
    \       }\n        else if('A' <= c && c <= 'Z') {\n            ans += c;\n  \
    \      }\n        else if('0' <= c && c <= '9') {\n            ans += c;\n   \
    \     }\n        else if('!' <= c && c <= '@') {\n            ans += c;\n    \
    \    }\n        else if('?' <= c && c <= '@') {\n            ans += c;\n     \
    \   }\n        else if('*' <= c && c <= '(') {\n            ans += c;\n      \
    \  }\n        else if(')' <= c && c <= '*') {\n            ans += c;\n       \
    \ }\n        else if('+' <= c && c <= '=') {\n            ans += c;\n        }\n\
    \        else if('-' <= c && c <= '=') {\n            ans += c;\n        }\n \
    \       else if('/' <= c && c <= '=') {\n            ans += c;\n        }\n  \
    \      else if('%' <= c && c <= '=') {\n            ans += c;\n        }\n   \
    \     else if('&' <= c && c <= '=') {\n            ans += c;\n        }\n    \
    \    else if('|' <= c && c <= '=') {\n            ans += c;\n        }\n     \
    \   else if('^' <= c && c <= '=') {\n            ans += c;\n        }\n      \
    \  else if('_' <= c && c <= '=') {\n            ans += c;\n        }\n       \
    \ else if('+' <= c && c <= '=') {\n            ans += c;\n        }\n        else\
    \ if('*' <= c && c <= '=') {\n            ans += c;\n        }\n        else if('?'\
    \ <= c && c <= '=') {\n            ans += c;\n        }\n        else if('!' <=\
    \ c && c <= '=') {\n            ans += c;\n        }\n        else if('/' <= c\
    \ && c <= '=') {\n            ans += c;\n        }\n        else if('%' <= c &&\
    \ c <= '=') {\n            ans += c;\n        }\n        else if('&' <= c && c\
    \ <= '=') {\n            ans += c;\n        }\n        else if('|' <= c && c <=\
    \ '=') {\n            ans += c;\n        }\n        else if('^' <= c && c <= '=')\
    \ {\n            ans += c;\n        }\n        else \n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5mm_oupm.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp5mm_oupm.cpp:90:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   90 | }\n      | ^\n/tmp/tmp5mm_oupm.cpp:91:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   91 | int main() {\n     \
    \ |            ^\n/tmp/tmp5mm_oupm.cpp:98:1: error: expected \u2018}\u2019 at\
    \ end of input\n   98 | }\n      | ^\n/tmp/tmp5mm_oupm.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmp5mm_oupm.cpp:98:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   98 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            ans += c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\
    \ c == 'Y') {\n            ans += 'A';\n        } else if (c == 'B' || c == 'C'\
    \ || c == 'D' || c == 'F' || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c\
    \ == 'L' || c == 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R' || c == 'S'\
    \ || c == 'T' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n\
    \            ans += 'B';\n        } else if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y') {\n            ans += 'a';\n        } else\
    \ if (c == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' ||\
    \ c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c ==\
    \ 'q' || c == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x'\
    \ || c == 'y' || c == 'z') {\n            ans += 'b';\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if ('a'\
    \ <= c && c <= 'z') {\n            ans[i] = c;\n        } else if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U' || c == 'Y') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'B' || c == 'C' || c == 'D' || c == 'F' || c\
    \ == 'G' || c == 'H' || c == 'J' || c == 'K' || c == 'L' || c == 'M' || c == 'N'\
    \ || c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c == 'T' || c == 'V' || c\
    \ == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n            ans[i] = 'B';\n \
    \       } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\
    \ c == 'y') {\n            ans[i] = 'a';\n        } else if (c == 'b' || c ==\
    \ 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c == '\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp83hz67zh.cpp:39:109: warning: missing terminating ' character\n\
    \   39 |         } else if (c == 'b' || c == 'c' || c == 'd' || c == 'f' || c\
    \ == 'g' || c == 'h' || c == 'j' || c == '\n      |                          \
    \                                                                            \
    \       ^\n/tmp/tmp83hz67zh.cpp:39:109: error: missing terminating ' character\n\
    /tmp/tmp83hz67zh.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp83hz67zh.cpp:40:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   40 | }\n      | ^\n/tmp/tmp83hz67zh.cpp:39:108: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   39 |         } else if (c == 'b'\
    \ || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j' || c\
    \ == '\n      |                   ~                                          \
    \                                              ^\n      |                    \
    \                                                                            \
    \            )\n   40 | }\n      | ~                                         \
    \                                                                  \n/tmp/tmp83hz67zh.cpp:40:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   40 | }\n \
    \     | ^\n/tmp/tmp83hz67zh.cpp:41:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   41 | int main() {\n      |            ^\n\
    /tmp/tmp83hz67zh.cpp:48:1: error: expected \u2018}\u2019 at end of input\n   48\
    \ | }\n      | ^\n/tmp/tmp83hz67zh.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmp83hz67zh.cpp:48:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   48 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        ans += (tolower(c) - 'a' + 2) % 26 + 'a';\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpk010wuk6: /tmp/tmpk010wuk6.cpp:23: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == '\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprg1p6k06.cpp:64:59: warning: missing terminating ' character\n\
    \   64 |         else if (c == 'A' || c == 'E' || c == 'I' || c == '\n      |\
    \                                                           ^\n/tmp/tmprg1p6k06.cpp:64:59:\
    \ error: missing terminating ' character\n/tmp/tmprg1p6k06.cpp: In function \u2018\
    std::string encode(std::string)\u2019:\n/tmp/tmprg1p6k06.cpp:65:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   65 | }\n      | ^\n/tmp/tmprg1p6k06.cpp:64:58:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   64 |         else\
    \ if (c == 'A' || c == 'E' || c == 'I' || c == '\n      |                 ~  \
    \                                      ^\n      |                            \
    \                              )\n   65 | }\n      | ~                       \
    \                                  \n/tmp/tmprg1p6k06.cpp:65:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   65 | }\n      | ^\n/tmp/tmprg1p6k06.cpp:66:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   66 | int main() {\n      |            ^\n/tmp/tmprg1p6k06.cpp:73:1: error:\
    \ expected \u2018}\u2019 at end of input\n   73 | }\n      | ^\n/tmp/tmprg1p6k06.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmprg1p6k06.cpp:73:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   73 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else {\n            ans += 'A' + (c - 'A');\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'A') {\n            ans[i] = 'a';\n        } else if (ans[i] == 'a') {\n\
    \            ans[i] = 'A';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'A') {\n            ans[i] =\
    \ ans[i - 1];\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        if (ans[i] == 'A' || ans[i] == 'a') {\n            ans[i] = ans[i - 1];\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'a' || ans[i] == 'A') {\n            ans[i] = ans[i - 1];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'A'\
    \ || ans[i] == 'a') {\n            ans[i] = ans[i - 1];\n        }\n    }\n  \
    \  for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'a' || ans[i]\
    \ == 'A') {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'A' || ans[i] == 'a')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for (int i = 0; i\
    \ < ans.length(); i++) {\n        if (ans[i] == 'a' || ans[i] == 'A') {\n    \
    \        ans[i] = ans[i - 1];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == 'A' || ans[i] == 'a') {\n            ans[i] =\
    \ ans[i - 1];\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        if (ans[i] == 'a' || ans[i] == 'A') {\n            ans[i] = ans[i - 1];\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'A' || ans[i] == 'a') {\n            ans[i] = ans[i - 1];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'a'\
    \ || ans[i] == 'A') {\n            ans[i] = ans[i - 1];\n        }\n    }\n  \
    \  for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'A' || ans[i]\
    \ == 'a') {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'a' || ans[i] == 'A')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for (int i = 0; i\
    \ < ans.length(); i++) {\n        if (ans[i] == 'A' || ans[i] == 'a') {\n    \
    \        ans[i] = an\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8s_vckyw.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp8s_vckyw.cpp:96:22: error: \u2018an\u2019 was not declared in this\
    \ scope; did you mean \u2018ans\u2019?\n   96 |             ans[i] = an\n    \
    \  |                      ^~\n      |                      ans\n/tmp/tmp8s_vckyw.cpp:98:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   98 | int main() {\n      |            ^\n/tmp/tmp8s_vckyw.cpp:105:1: error:\
    \ expected \u2018}\u2019 at end of input\n  105 | }\n      | ^\n/tmp/tmp8s_vckyw.cpp:94:44:\
    \ note: to match this \u2018{\u2019\n   94 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmp8s_vckyw.cpp:105:1:\
    \ error: expected \u2018}\u2019 at end of input\n  105 | }\n      | ^\n/tmp/tmp8s_vckyw.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp8s_vckyw.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  105 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        char c = message[i];\n\
    \        if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk0fcg4jd.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpk0fcg4jd.cpp:91:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   91 | int main() {\n      |            ^\n/tmp/tmpk0fcg4jd.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpk0fcg4jd.cpp:15:41:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i=0;i<message.length();i++)\
    \ {\n      |                                         ^\n/tmp/tmpk0fcg4jd.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpk0fcg4jd.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpk0fcg4jd.cpp:98:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   98 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (std::tolower(c)\
    \ == c) ? std::toupper(c) : c;\n    }\n    for (auto &c : ans) {\n        if (std::tolower(c)\
    \ == 'a' || std::tolower(c) == 'e' || std::tolower(c) == 'i' || std::tolower(c)\
    \ == 'o' || std::tolower(c) == 'u') {\n            ans[ans.find(c) + 2] = std::tolower(ans[ans.find(c)\
    \ + 2]);\n        }\n    }\n    for (auto &c : ans) {\n        if (std::tolower(c)\
    \ == 'a' || std::tolower(c) == 'e' || std::tolower(c) == 'i' || std::tolower(c)\
    \ == 'o' || std::tolower(c) == 'u') {\n            ans[ans.find(c) + 2] = std::toupper(ans[ans.find(c)\
    \ + 2]);\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmppz4cvo9t: /tmp/tmppz4cvo9t.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            ans += c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans += 'A';\n        } else if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            ans += 'a';\n        } else {\n\
    \            ans += c;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('a' <= c && c <= 'z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U') {\n            ans[i] = 'A';\n        } else if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        char\
    \ c = ans[i];\n        if ('a' <= c && c <= 'z') {\n            ans[i] = c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans[i] = 'A';\n        } else if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if ('a' <= c && c <= 'z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        if ('a' <= c &&\
    \ c <= 'z') {\n            ans[i] = c;\n        } else if (c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'A';\n        }\
    \ else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n     \
    \       ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('a' <= c && c <= 'z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'A' || c == 'E' || \n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl6fp1t8k.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpl6fp1t8k.cpp:72:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   72 | }\n      | ^\n/tmp/tmpl6fp1t8k.cpp:71:43: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   71 |         } else if (c == 'A'\
    \ || c == 'E' ||\n      |                   ~                       ^\n      |\
    \                                           )\n   72 | }\n      | ~          \
    \                                \n/tmp/tmpl6fp1t8k.cpp:72:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmpl6fp1t8k.cpp:73:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   73 | int main() {\n      |            ^\n/tmp/tmpl6fp1t8k.cpp:80:1: error:\
    \ expected \u2018}\u2019 at end of input\n   80 | }\n      | ^\n/tmp/tmpl6fp1t8k.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpl6fp1t8k.cpp:80:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   80 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for (auto &c : ans) {\n        c = toupper(c);\n    }\n\
    \    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i] == 'A' || ans[i]\
    \ == 'E' || ans[i] == 'I' || ans[i] == 'O' || ans[i] == 'U') {\n            ans[i]\
    \ = 'A';\n        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n     \
    \   if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i]\
    \ == 'u') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0;\
    \ i < ans.size(); i++) {\n        if (ans[i] == 'B' || ans[i] == 'G' || ans[i]\
    \ == 'K' || ans[i] == 'M' || ans[i] == 'O' || ans[i] == 'R' || ans[i] == 'S' ||\
    \ ans[i] == 'T' || ans[i] == 'W' || ans[i] == 'Y') {\n            ans[i] = 'B';\n\
    \        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        if (ans[i]\
    \ == 'b' || ans[i] == 'g' || ans[i] == 'k' || ans[i] == 'm' || ans[i] == 'o' ||\
    \ ans[i] == 'r' || ans[i] == 's' || ans[i] == 't' || ans[i] == 'w' || ans[i] ==\
    \ 'y') {\n            ans[i] = 'b';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.size(); i++) {\n        if (ans[i] == 'C' || ans[i] == 'D' || ans[i] ==\
    \ 'F' || ans[i] == 'G' || ans[i] == 'H' || ans[i] == 'J' || ans[i] == 'K' || ans[i]\
    \ == 'L' || ans[i] == 'M' || ans[i] == 'N' || ans[i] == 'P' || ans[i] == 'R' ||\
    \ ans[i] == 'S' || ans[i] == 'T' || ans[i] == 'V' || ans[i] == 'W' || ans[i] ==\
    \ 'Y') {\n            ans[i] = 'C';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.size(); i++) {\n        if (ans[i] == 'c' || ans[i] == 'd' || ans[i] ==\
    \ 'f' || ans[i] == 'g' || ans[i] == 'h' || ans[i] == 'j' || ans[i] == 'k' || ans[i]\
    \ == 'l' || ans[i] == 'm' || ans[i] == 'n' || ans[i] == 'p' || ans[i] == 'r' ||\
    \ ans[i] == 's' || ans[i] == 't' || ans[i] == 'v' || ans[i] == 'w' || ans[i] ==\
    \ 'y') {\n            ans[i] = 'c';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.size(); i++) {\n        if (ans[i] == 'D' || ans[i] == 'G' || ans[i] ==\
    \ 'J' || ans[i] == 'K' || ans[i] == 'M' || ans[i] == 'O' || ans[i] == 'P' || ans[i]\
    \ == 'R' || ans[i] == 'S' || ans[i] == 'T\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg92q818d.cpp:49:176: warning: missing terminating ' character\n\
    \   49 |         if (ans[i] == 'D' || ans[i] == 'G' || ans[i] == 'J' || ans[i]\
    \ == 'K' || ans[i] == 'M' || ans[i] == 'O' || ans[i] == 'P' || ans[i] == 'R' ||\
    \ ans[i] == 'S' || ans[i] == 'T\n      |                                     \
    \                                                                            \
    \                                                               ^\n/tmp/tmpg92q818d.cpp:49:176:\
    \ error: missing terminating ' character\n   49 |         if (ans[i] == 'D' ||\
    \ ans[i] == 'G' || ans[i] == 'J' || ans[i] == 'K' || ans[i] == 'M' || ans[i] ==\
    \ 'O' || ans[i] == 'P' || ans[i] == 'R' || ans[i] == 'S' || ans[i] == 'T\n   \
    \   |                                                                        \
    \                                                                            \
    \                            ^~\n/tmp/tmpg92q818d.cpp: In function \u2018std::string\
    \ encode(std::string)\u2019:\n/tmp/tmpg92q818d.cpp:50:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   50 | }\n      | ^\n/tmp/tmpg92q818d.cpp:49:175:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   49 |         if\
    \ (ans[i] == 'D' || ans[i] == 'G' || ans[i] == 'J' || ans[i] == 'K' || ans[i]\
    \ == 'M' || ans[i] == 'O' || ans[i] == 'P' || ans[i] == 'R' || ans[i] == 'S' ||\
    \ ans[i] == 'T\n      |            ~                                         \
    \                                                                            \
    \                                             ^\n      |                     \
    \                                                                            \
    \                                                                            \
    \  )\n   50 | }\n      | ~                                                   \
    \                                                                            \
    \                                               \n/tmp/tmpg92q818d.cpp:50:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   50 | }\n      | ^\n\
    /tmp/tmpg92q818d.cpp:51:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   51 | int main() {\n      |            ^\n/tmp/tmpg92q818d.cpp:58:1:\
    \ error: expected \u2018}\u2019 at end of input\n   58 | }\n      | ^\n/tmp/tmpg92q818d.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpg92q818d.cpp:58:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   58 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        } else {\n            ans += 'A'\
    \ + (c - 'a');\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if (c == 'a') {\n            ans[i] = 'A';\n        } else if\
    \ (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n  \
    \          ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i] =\
    \ 'a';\n        } else if (c == 'a') {\n            ans[i] = 'a';\n        } else\
    \ if (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n\
    \            ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i]\
    \ = 'a';\n        } else if (c == 'a') {\n            ans[i] = 'a';\n        }\
    \ else if (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a')\
    \ {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i]\
    \ = 'a';\n        } else if (c == 'a') {\n            ans[i] = 'a';\n        }\
    \ else if (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a')\
    \ {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i]\
    \ = 'a';\n        } else if (c == 'a') {\n            ans[i] = 'a';\n        }\
    \ else if (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a')\
    \ {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i]\
    \ = 'a';\n        } else if (c == 'a') {\n            ans[i] = 'a';\n        }\
    \ else if (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a')\
    \ {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i]\
    \ = 'a';\n        } else if (c == 'a') {\n            ans[i] = 'a';\n        }\
    \ else if (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a')\
    \ {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i]\
    \ = 'a';\n        } else if (c == 'a') {\n            ans[i] = 'a';\n        }\
    \ else if (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'a')\
    \ {\n            ans[i] = 'a';\n        } else if (c == 'a') {\n            ans[i]\
    \ = 'a';\n        } else if (c == 'a') {\n            \n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy4pcovfe.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpy4pcovfe.cpp:94:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   94 | int main() {\n      |            ^\n/tmp/tmpy4pcovfe.cpp:101:1:\
    \ error: expected \u2018}\u2019 at end of input\n  101 | }\n      | ^\n/tmp/tmpy4pcovfe.cpp:23:44:\
    \ note: to match this \u2018{\u2019\n   23 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmpy4pcovfe.cpp:101:1:\
    \ error: expected \u2018}\u2019 at end of input\n  101 | }\n      | ^\n/tmp/tmpy4pcovfe.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpy4pcovfe.cpp:101:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  101 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (auto &c : message) {\n        if (c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u') {\n            encoded += c;\n    \
    \    } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            encoded += c;\n        } else {\n            char temp = c;\n   \
    \         int index = c - 'a';\n            int index2 = c - 'A';\n          \
    \  int index3 = c - 'e';\n            int index4 = c - 'E';\n            int index5\
    \ = c - 'i';\n            int index6 = c - 'I';\n            int index7 = c -\
    \ 'o';\n            int index8 = c - 'O';\n            int index9 = c - 'u';\n\
    \            int index10 = c - 'U';\n            int index11 = c - 'A';\n    \
    \        int index12 = c - 'E';\n            int index13 = c - 'I';\n        \
    \    int index14 = c - 'O';\n            int index15 = c - 'U';\n            int\
    \ index16 = c - 'a';\n            int index17 = c - 'e';\n            int index18\
    \ = c - 'i';\n            int index19 = c - 'o';\n            int index20 = c\
    \ - 'u';\n            int index21 = c - 'A';\n            int index22 = c - 'E';\n\
    \            int index23 = c - 'I';\n            int index24 = c - 'O';\n    \
    \        int index25 = c - 'U';\n            int index26 = c - 'a';\n        \
    \    int index27 = c - 'e';\n            int index28 = c - 'i';\n            int\
    \ index29 = c - 'o';\n            int index30 = c - 'u';\n            int index31\
    \ = c - 'A';\n            int index32 = c - 'E';\n            int index33 = c\
    \ - 'I';\n            int index34 = c - 'O';\n            int index35 = c - 'U';\n\
    \            int index36 = c - 'a';\n            int index37 = c - 'e';\n    \
    \        int index38 = c - 'i';\n            int index39 = c - 'o';\n        \
    \    int index40 = c - 'u';\n            int index41 = c - 'A';\n            int\
    \ index42 = c - 'E';\n            int index43 = c - 'I';\n            int index44\
    \ = c - 'O';\n            int index45 = c - 'U';\n\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy2jueezh.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpy2jueezh.cpp:69:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n/tmp/tmpy2jueezh.cpp:76:1:\
    \ error: expected \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpy2jueezh.cpp:15:29:\
    \ note: to match this \u2018{\u2019\n   15 |     for (auto &c : message) {\n \
    \     |                             ^\n/tmp/tmpy2jueezh.cpp:76:1: error: expected\
    \ \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpy2jueezh.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpy2jueezh.cpp:76:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   76 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (tolower(c) - 'a'\
    \ + 2) % 26 + 'a';\n    }\n    for (char c : ans) {\n        ans[ans.find(c)]\
    \ = tolower(c);\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpylatso5g: /tmp/tmpylatso5g.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for (auto &c : ans) {\n        if (c >= 'a' && c <= 'z')\
    \ {\n            c = tolower(c);\n        } else if (c >= 'A' && c <= 'Z') {\n\
    \            c = toupper(c);\n        } else if (c >= '0' && c <= '9') {\n   \
    \         c = c + 2;\n        }\n    }\n    for (auto &c : ans) {\n        if\
    \ (c >= 'a' && c <= 'z') {\n            c = tolower(c);\n        } else if (c\
    \ >= 'A' && c <= 'Z') {\n            c = toupper(c);\n        } else if (c >=\
    \ '0' && c <= '9') {\n            c = c + 2;\n        }\n    }\n    for (auto\
    \ &c : ans) {\n        if (c >= 'a' && c <= 'z') {\n            c = tolower(c);\n\
    \        } else if (c >= 'A' && c <= 'Z') {\n            c = toupper(c);\n   \
    \     } else if (c >= '0' && c <= '9') {\n            c = c + 2;\n        }\n\
    \    }\n    for (auto &c : ans) {\n        if (c >= 'a' && c <= 'z') {\n     \
    \       c = tolower(c);\n        } else if (c >= 'A' && c <= 'Z') {\n        \
    \    c = toupper(c);\n        } else if (c >= '0' && c <= '9') {\n           \
    \ c = c + 2;\n        }\n    }\n    for (auto &c : ans) {\n        if (c >= 'a'\
    \ && c <= 'z') {\n            c = tolower(c);\n        } else if (c >= 'A' &&\
    \ c <= 'Z') {\n            c = toupper(c);\n        } else if (c >= '0' && c <=\
    \ '9') {\n            c = c + 2;\n        }\n    }\n    for (auto &c : ans) {\n\
    \        if (c >= 'a' && c <= 'z') {\n            c = tolower(c);\n        } else\
    \ if (c >= 'A' && c <= 'Z') {\n            c = toupper(c);\n        } else if\
    \ (c >= '0' && c <= '9') {\n            c = c + 2;\n        }\n    }\n    for\
    \ (auto &c : ans) {\n        if (c >= 'a' && c <= 'z') {\n            c = tolower(c);\n\
    \        } else if (c >= 'A' && c <= 'Z') {\n            c = toupper(c);\n   \
    \     } else if (c >= '0' && c <= '9') {\n            c = c + 2;\n        }\n\
    \    }\n    for (auto &c : ans) {\n        if (c >= 'a' && c <= 'z') {\n     \
    \       c = tolower(c);\n        } else if (c >= 'A' && c <= 'Z') {\n        \
    \    c = toupper(c);\n        } else if (c >= '0' && c <= '9') {\n           \
    \ c = c + 2;\n        }\n    }\n    for (auto &c : ans) {\n        if (\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa436n1o8.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpa436n1o8.cpp:89:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   89 | }\n      | ^\n/tmp/tmpa436n1o8.cpp:88:13: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   88 |         if (\n      |    \
    \        ~^\n      |             )\n   89 | }\n      | ~            \n/tmp/tmpa436n1o8.cpp:89:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   89 | }\n \
    \     | ^\n/tmp/tmpa436n1o8.cpp:90:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   90 | int main() {\n      |            ^\n\
    /tmp/tmpa436n1o8.cpp:97:1: error: expected \u2018}\u2019 at end of input\n   97\
    \ | }\n      | ^\n/tmp/tmpa436n1o8.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpa436n1o8.cpp:97:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   97 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isalpha(c) ? toupper(c)\
    \ : c);\n    }\n    for (auto &c : ans) {\n        switch (c) {\n            case\
    \ 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n\
    \            case 'U':\n                ans[ans.find(c) + 1] = toupper(ans[ans.find(c)\
    \ + 1]);\n                break;\n            case 'a':\n            case 'e':\n\
    \            case 'i':\n            case 'o':\n            case 'u':\n       \
    \         ans[ans.find(c) + 1] = tolower(ans[ans.find(c) + 1]);\n            \
    \    break;\n            default:\n                break;\n        }\n    }\n\
    \    for (auto &c : ans) {\n        switch (c) {\n            case 'A':\n    \
    \        case 'E':\n            case 'I':\n            case 'O':\n           \
    \ case 'U':\n                ans[ans.find(c) - 1] = tolower(ans[ans.find(c) -\
    \ 1]);\n                break;\n            case 'a':\n            case 'e':\n\
    \            case 'i':\n            case 'o':\n            case 'u':\n       \
    \         ans[ans.find(c) - 1] = toupper(ans[ans.find(c) - 1]);\n            \
    \    break;\n            default:\n                break;\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp823msh1o: /tmp/tmp823msh1o.cpp:62: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encodedMessage;\n    for(int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        switch(c) {\n            case 'a':\n            case\
    \ 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n\
    \                encodedMessage += c;\n                break;\n            case\
    \ 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n\
    \            case 'U':\n                encodedMessage += c;\n               \
    \ break;\n            default:\n                encodedMessage += toupper(c);\n\
    \        }\n    }\n    for(int i = 0; i < encodedMessage.length(); i++) {\n  \
    \      char c = encodedMessage[i];\n        if(c == 'A') {\n            encodedMessage[i]\
    \ = 'a';\n        } else if(c == 'E') {\n            encodedMessage[i] = 'e';\n\
    \        } else if(c == 'I') {\n            encodedMessage[i] = 'i';\n       \
    \ } else if(c == 'O') {\n            encodedMessage[i] = 'o';\n        } else\
    \ if(c == 'U') {\n            encodedMessage[i] = 'u';\n        }\n    }\n   \
    \ return encodedMessage;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpvr2y0q29: /tmp/tmpvr2y0q29.cpp:54: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        char c = message[i];\n\
    \        if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc3masrdr.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpc3masrdr.cpp:91:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   91 | int main() {\n      |            ^\n/tmp/tmpc3masrdr.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpc3masrdr.cpp:15:41:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i=0;i<message.length();i++)\
    \ {\n      |                                         ^\n/tmp/tmpc3masrdr.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpc3masrdr.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpc3masrdr.cpp:98:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   98 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        if(message[i]\
    \ >= 'a' && message[i] <= 'z') {\n            ans += message[i];\n        }\n\
    \        else if(message[i] >= 'A' && message[i] <= 'Z') {\n            ans +=\
    \ message[i];\n        }\n        else if(message[i] >= '0' && message[i] <= '9')\
    \ {\n            ans += message[i];\n        }\n        else if(message[i] ==\
    \ '.' || message[i] == '!' || message[i] == '?' || message[i] == '-' || message[i]\
    \ == '_' || message[i] == '*' || message[i] == '/' || message[i] == '(' || message[i]\
    \ == ')' || message[i] == '+' || message[i] == '=' || message[i] == '&' || message[i]\
    \ == '|' || message[i] == '<' || message[i] == '>' || message[i] == '$' || message[i]\
    \ == '@' || message[i] == '^' || message[i] == '~' || message[i] == '`' || message[i]\
    \ == '{' || message[i] == '}' || message[i] == '[' || message[i] == ']' || message[i]\
    \ == '|' || message[i] == '\\\\' || message[i] == '\"' || message[i] == '\\''\
    \ || message[i] == '<' || message[i] == '>' || message[i] == '?' || message[i]\
    \ == '!' || message[i] == '.' || message[i] == '-' || message[i] == '_' || message[i]\
    \ == '*' || message[i] == '/' || message[i] == '(' || message[i] == ')' || message[i]\
    \ == '+' || message[i] == '=' || message[i] == '&' || message[i] == '|' || message[i]\
    \ == '<' || message[i] == '>' || message[i] == '$' || message[i] == '@' || message[i]\
    \ == '^' || message[i] == '~' || message[i] == '`' || message[i] == '{' || message[i]\
    \ == '}' || message[i] == '[' || message[i] == ']' || message[i] == '|' || message[i]\
    \ == '\\\\' || message[i] == '\"' || message[i] == '\\'' || message[i] == '<'\
    \ || message[i] == '>' || message[i] == '?' || message[i] == '!' || message[i]\
    \ == '.' || message[i] == '-' || message[i] == '_' || message[i] == '*' || message[i]\
    \ == '/' || message[i] == '(' || message[i] == ')' || message[i] == '+' || message[i]\
    \ == '=' || message[i] == '&' || message[i] == '|' || message[i] == '<' || message[i]\
    \ == '>' || message[i] == '$' || message[i] == '@' || message[i] == '^' || message[i]\
    \ == '~' || message[i] == '`' || message[i] == '{' || message[i] == '}' || message[i]\
    \ == '[' || message[i] == ']' || message[i] == '|' || message[i] == '\\\\' ||\
    \ message[i] == '\"\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9mkh4pj0.cpp:25:1842: warning: missing terminating ' character\n\
    \   25 |         else if(message[i] == '.' || message[i] == '!' || message[i]\
    \ == '?' || message[i] == '-' || message[i] == '_' || message[i] == '*' || message[i]\
    \ == '/' || message[i] == '(' || message[i] == ')' || message[i] == '+' || message[i]\
    \ == '=' || message[i] == '&' || message[i] == '|' || message[i] == '<' || message[i]\
    \ == '>' || message[i] == '$' || message[i] == '@' || message[i] == '^' || message[i]\
    \ == '~' || message[i] == '`' || message[i] == '{' || message[i] == '}' || message[i]\
    \ == '[' || message[i] == ']' || message[i] == '|' || message[i] == '\\\\' ||\
    \ message[i] == '\"' || message[i] == '\\'' || message[i] == '<' || message[i]\
    \ == '>' || message[i] == '?' || message[i] == '!' || message[i] == '.' || message[i]\
    \ == '-' || message[i] == '_' || message[i] == '*' || message[i] == '/' || message[i]\
    \ == '(' || message[i] == ')' || message[i] == '+' || message[i] == '=' || message[i]\
    \ == '&' || message[i] == '|' || message[i] == '<' || message[i] == '>' || message[i]\
    \ == '$' || message[i] == '@' || message[i] == '^' || message[i] == '~' || message[i]\
    \ == '`' || message[i] == '{' || message[i] == '}' || message[i] == '[' || message[i]\
    \ == ']' || message[i] == '|' || message[i] == '\\\\' || message[i] == '\"' ||\
    \ message[i] == '\\'' || message[i] == '<' || message[i] == '>' || message[i]\
    \ == '?' || message[i] == '!' || message[i] == '.' || message[i] == '-' || message[i]\
    \ == '_' || message[i] == '*' || message[i] == '/' || message[i] == '(' || message[i]\
    \ == ')' || message[i] == '+' || message[i] == '=' || message[i] == '&' || message[i]\
    \ == '|' || message[i] == '<' || message[i] == '>' || message[i] == '$' || message[i]\
    \ == '@' || message[i] == '^' || message[i] == '~' || message[i] == '`' || message[i]\
    \ == '{' || message[i] == '}' || message[i] == '[' || message[i] == ']' || message[i]\
    \ == '|' || message[i] == '\\\\' || message[i] == '\"\n      |               \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \   ^\n/tmp/tmp9mkh4pj0.cpp:25:1842: error: missing terminating ' character\n\
    \   25 |         else if(message[i] == '.' || message[i] == '!' || message[i]\
    \ == '?' || message[i] == '-' || message[i] == '_' || message[i] == '*' || message[i]\
    \ == '/' || message[i] == '(' || message[i] == ')' || message[i] == '+' || message[i]\
    \ == '=' || message[i] == '&' || message[i] == '|' || message[i] == '<' || message[i]\
    \ == '>' || message[i] == '$' || message[i] == '@' || message[i] == '^' || message[i]\
    \ == '~' || message[i] == '`' || message[i] == '{' || message[i] == '}' || message[i]\
    \ == '[' || message[i] == ']' || message[i] == '|' || message[i] == '\\\\' ||\
    \ message[i] == '\"' || message[i] == '\\'' || message[i] == '<' || message[i]\
    \ == '>' || message[i] == '?' || message[i] == '!' || message[i] == '.' || message[i]\
    \ == '-' || message[i] == '_' || message[i] == '*' || message[i] == '/' || message[i]\
    \ == '(' || message[i] == ')' || message[i] == '+' || message[i] == '=' || message[i]\
    \ == '&' || message[i] == '|' || message[i] == '<' || message[i] == '>' || message[i]\
    \ == '$' || message[i] == '@' || message[i] == '^' || message[i] == '~' || message[i]\
    \ == '`' || message[i] == '{' || message[i] == '}' || message[i] == '[' || message[i]\
    \ == ']' || message[i] == '|' || message[i] == '\\\\' || message[i] == '\"' ||\
    \ message[i] == '\\'' || message[i] == '<' || message[i] == '>' || message[i]\
    \ == '?' || message[i] == '!' || message[i] == '.' || message[i] == '-' || message[i]\
    \ == '_' || message[i] == '*' || message[i] == '/' || message[i] == '(' || message[i]\
    \ == ')' || message[i] == '+' || message[i] == '=' || message[i] == '&' || message[i]\
    \ == '|' || message[i] == '<' || message[i] == '>' || message[i] == '$' || message[i]\
    \ == '@' || message[i] == '^' || message[i] == '~' || message[i] == '`' || message[i]\
    \ == '{' || message[i] == '}' || message[i] == '[' || message[i] == ']' || message[i]\
    \ == '|' || message[i] == '\\\\' || message[i] == '\"\n      |               \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \   ^~\n/tmp/tmp9mkh4pj0.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp9mkh4pj0.cpp:26:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   26 | }\n      | ^\n/tmp/tmp9mkh4pj0.cpp:25:1841: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   25 |         else if(message[i]\
    \ == '.' || message[i] == '!' || message[i] == '?' || message[i] == '-' || message[i]\
    \ == '_' || message[i] == '*' || message[i] == '/' || message[i] == '(' || message[i]\
    \ == ')' || message[i] == '+' || message[i] == '=' || message[i] == '&' || message[i]\
    \ == '|' || message[i] == '<' || message[i] == '>' || message[i] == '$' || message[i]\
    \ == '@' || message[i] == '^' || message[i] == '~' || message[i] == '`' || message[i]\
    \ == '{' || message[i] == '}' || message[i] == '[' || message[i] == ']' || message[i]\
    \ == '|' || message[i] == '\\\\' || message[i] == '\"' || message[i] == '\\''\
    \ || message[i] == '<' || message[i] == '>' || message[i] == '?' || message[i]\
    \ == '!' || message[i] == '.' || message[i] == '-' || message[i] == '_' || message[i]\
    \ == '*' || message[i] == '/' || message[i] == '(' || message[i] == ')' || message[i]\
    \ == '+' || message[i] == '=' || message[i] == '&' || message[i] == '|' || message[i]\
    \ == '<' || message[i] == '>' || message[i] == '$' || message[i] == '@' || message[i]\
    \ == '^' || message[i] == '~' || message[i] == '`' || message[i] == '{' || message[i]\
    \ == '}' || message[i] == '[' || message[i] == ']' || message[i] == '|' || message[i]\
    \ == '\\\\' || message[i] == '\"' || message[i] == '\\'' || message[i] == '<'\
    \ || message[i] == '>' || message[i] == '?' || message[i] == '!' || message[i]\
    \ == '.' || message[i] == '-' || message[i] == '_' || message[i] == '*' || message[i]\
    \ == '/' || message[i] == '(' || message[i] == ')' || message[i] == '+' || message[i]\
    \ == '=' || message[i] == '&' || message[i] == '|' || message[i] == '<' || message[i]\
    \ == '>' || message[i] == '$' || message[i] == '@' || message[i] == '^' || message[i]\
    \ == '~' || message[i] == '`' || message[i] == '{' || message[i] == '}' || message[i]\
    \ == '[' || message[i] == ']' || message[i] == '|' || message[i] == '\\\\' ||\
    \ message[i] == '\"\n      |                ~                                \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                            ^\n      |                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                       )\n  \
    \ 26 | }\n      | ~                                                          \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                  \n/tmp/tmp9mkh4pj0.cpp:26:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   26 | }\n      | ^\n/tmp/tmp9mkh4pj0.cpp:27:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   27 | int main() {\n      |            ^\n/tmp/tmp9mkh4pj0.cpp:34:1: error:\
    \ expected \u2018}\u2019 at end of input\n   34 | }\n      | ^\n/tmp/tmp9mkh4pj0.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp9mkh4pj0.cpp:34:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   34 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        }\n        else if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n   \
    \     }\n        else if (c == 'y' || c == 'Y') {\n            ans += 'Y';\n \
    \       }\n        else if (c == 'i' || c == 'I') {\n            ans += 'I';\n\
    \        }\n        else if (c == 'o' || c == 'O') {\n            ans += 'O';\n\
    \        }\n        else if (c == 'u' || c == 'U') {\n            ans += 'U';\n\
    \        }\n        else if (c == 'o' || c == 'u') {\n            ans += 'u';\n\
    \        }\n        else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c\
    \ == 'U') {\n            ans += 'A';\n        }\n        else if (c == 'y' ||\
    \ c == 'Y') {\n            ans += 'Y';\n        }\n        else if (c == 'i' ||\
    \ c == 'I') {\n            ans += 'I';\n        }\n        else if (c == 'o' ||\
    \ c == 'O') {\n            ans += 'O';\n        }\n        else if (c == 'u' ||\
    \ c == 'U') {\n            ans += 'U';\n        }\n        else if (c == 'o' ||\
    \ c == 'u') {\n            ans += 'u';\n        }\n        else if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans += 'a';\n \
    \       }\n        else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c\
    \ == 'U') {\n            ans += 'A';\n        }\n        else if (c == 'y' ||\
    \ c == 'Y') {\n            ans += 'Y';\n        }\n        else if (c == 'i' ||\
    \ c == 'I') {\n            ans += 'I';\n        }\n        else if (c == 'o' ||\
    \ c == 'O') {\n            ans += 'O';\n        }\n        else if (c == 'u' ||\
    \ c == 'U') {\n            ans += 'U';\n        }\n        else if (c == 'o' ||\
    \ c == 'u') {\n            ans += 'u';\n        }\n        else if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += 'A';\n \
    \       }\n        else if (c == 'y' || c == 'Y') {\n            ans += 'Y';\n\
    \        }\n        else if (c == 'i' || c == '\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb4lfhz87.cpp:83:35: warning: missing terminating ' character\n\
    \   83 |         else if (c == 'i' || c == '\n      |                        \
    \           ^\n/tmp/tmpb4lfhz87.cpp:83:35: error: missing terminating ' character\n\
    /tmp/tmpb4lfhz87.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpb4lfhz87.cpp:84:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   84 | }\n      | ^\n/tmp/tmpb4lfhz87.cpp:83:34: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   83 |         else if (c == 'i'\
    \ || c == '\n      |                 ~                ^\n      |             \
    \                     )\n   84 | }\n      | ~                                \
    \ \n/tmp/tmpb4lfhz87.cpp:84:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   84 | }\n      | ^\n/tmp/tmpb4lfhz87.cpp:85:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   85 | int main() {\n     \
    \ |            ^\n/tmp/tmpb4lfhz87.cpp:92:1: error: expected \u2018}\u2019 at\
    \ end of input\n   92 | }\n      | ^\n/tmp/tmpb4lfhz87.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmpb4lfhz87.cpp:92:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   92 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans += 'A';\n        } else if (c ==\
    \ 'y' || c == 'i' || c == 'o' || c == 'u') {\n            ans += 'Y';\n      \
    \  } else if (c == 'o' || c == 'u' || c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'y') {\n            ans += 'O';\n        } else if (c == 'h' || c == 'k' ||\
    \ c == 's' || c == 'c' || c == 'g' || c == 'g' || c == 's') {\n            ans\
    \ += 'H';\n        } else if (c == 'm' || c == 'g' || c == 's' || c == 'c' ||\
    \ c == 'g' || c == 'g' || c == 's') {\n            ans += 'M';\n        } else\
    \ if (c == 't' || c == 'h' || c == 'k' || c == 's' || c == 'c' || c == 'g' ||\
    \ c == 'g' || c == 's') {\n            ans += 'T';\n        } else if (c == 'r'\
    \ || c == 'e' || c == 'e' || c == 'r' || c == 't' || c == 'h' || c == 'k' || c\
    \ == 's' || c == 'c' || c == 'g' || c == 'g' || c == 's') {\n            ans +=\
    \ 'R';\n        } else if (c == 'p' || c == 'a' || c == 't' || c == 'h' || c ==\
    \ 'k' || c == 's' || c == 'c' || c == 'g' || c == 'g' || c == 's') {\n       \
    \     ans += 'P';\n        } else if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') {\n            ans += 'A';\n        } else if (c == 'y' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'Y';\n        } else\
    \ if (c == 'o' || c == 'u' || c == 'a' || c == 'e' || c == 'i' || c == 'y') {\n\
    \            ans += 'O';\n        } else if (c == 'h' || c == 'k' || c == 's'\
    \ || c == 'c' || c == 'g' || c == 'g' || c == 's') {\n            ans += 'H';\n\
    \        } else if (c == 'm' || c == 'g' || c == 's' || c == 'c' || c == 'g' ||\
    \ c == 'g' || c == 's') {\n            ans += 'M';\n        } else if (c == 't'\
    \ || c == 'h' || c == 'k' || \n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbqod6b1b.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpbqod6b1b.cpp:45:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   45 | }\n      | ^\n/tmp/tmpbqod6b1b.cpp:44:55: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   44 |         } else if (c == 't'\
    \ || c == 'h' || c == 'k' ||\n      |                   ~                    \
    \               ^\n      |                                                   \
    \    )\n   45 | }\n      | ~                                                 \
    \     \n/tmp/tmpbqod6b1b.cpp:45:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   45 | }\n      | ^\n/tmp/tmpbqod6b1b.cpp:46:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   46 | int main() {\n     \
    \ |            ^\n/tmp/tmpbqod6b1b.cpp:53:1: error: expected \u2018}\u2019 at\
    \ end of input\n   53 | }\n      | ^\n/tmp/tmpbqod6b1b.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmpbqod6b1b.cpp:53:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   53 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        char\
    \ c = ans[i];\n        if (isalpha(c)) {\n            int index = c - 'A';\n \
    \           char next = ans[(i + 1) % ans.size()];\n            if (isupper(next))\
    \ {\n                ans[i] = tolower(next);\n                ans[(i + 1) % ans.size()]\
    \ = toupper(c);\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpz_q0kya4: /tmp/tmpz_q0kya4.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++){\n        if(message[i]=='a' ||\
    \ message[i]=='e' || message[i]=='i' || message[i]=='o' || message[i]=='u'){\n\
    \            ans += message[i];\n        }\n        else if(message[i]=='A' ||\
    \ message[i]=='E' || message[i]=='I' || message[i]=='O' || message[i]=='U'){\n\
    \            ans += message[i];\n        }\n        else if(message[i]=='b'){\n\
    \            ans += 'f';\n        }\n        else if(message[i]=='c'){\n     \
    \       ans += 'g';\n        }\n        else if(message[i]=='d'){\n          \
    \  ans += 'h';\n        }\n        else if(message[i]=='e'){\n            ans\
    \ += 'j';\n        }\n        else if(message[i]=='f'){\n            ans += 'k';\n\
    \        }\n        else if(message[i]=='g'){\n            ans += 'l';\n     \
    \   }\n        else if(message[i]=='h'){\n            ans += 'm';\n        }\n\
    \        else if(message[i]=='i'){\n            ans += 'n';\n        }\n     \
    \   else if(message[i]=='j'){\n            ans += 'o';\n        }\n        else\
    \ if(message[i]=='k'){\n            ans += 'p';\n        }\n        else if(message[i]=='l'){\n\
    \            ans += 'q';\n        }\n        else if(message[i]=='m'){\n     \
    \       ans += 'r';\n        }\n        else if(message[i]=='n'){\n          \
    \  ans += 's';\n        }\n        else if(message[i]=='o'){\n            ans\
    \ += 't';\n        }\n        else if(message[i]=='p'){\n            ans += 'u';\n\
    \        }\n        else if(message[i]=='q'){\n            ans += 'v';\n     \
    \   }\n        else if(message[i]=='r'){\n            ans += 'w';\n        }\n\
    \        else if(message[i]=='s'){\n            ans += 'x';\n        }\n     \
    \   else if(message[i]=='t'){\n            ans += 'y';\n        }\n        else\
    \ if(message[i]=='u'){\n            ans += 'z';\n        }\n        else if(message[i]=='v'){\n\
    \            ans += 'A';\n        }\n        else if(message[i]=='w'){\n     \
    \       ans += 'B';\n        }\n        else if(message[i]=='x'){\n          \
    \  ans += 'C';\n        }\n        else if(message[i]=='y'){\n            ans\
    \ += 'D';\n        }\n        else if(\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0ccydi51.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp0ccydi51.cpp:95:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   95 | }\n      | ^\n/tmp/tmp0ccydi51.cpp:94:17: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   94 |         else if(\n      |\
    \                ~^\n      |                 )\n   95 | }\n      | ~         \
    \       \n/tmp/tmp0ccydi51.cpp:95:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n   95 | }\n      | ^\n/tmp/tmp0ccydi51.cpp:96:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   96\
    \ | int main() {\n      |            ^\n/tmp/tmp0ccydi51.cpp:103:1: error: expected\
    \ \u2018}\u2019 at end of input\n  103 | }\n      | ^\n/tmp/tmp0ccydi51.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp0ccydi51.cpp:103:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  103 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpk5g1mop0: /tmp/tmpk5g1mop0.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (std::toupper(c) -\
    \ 'A' + 2) % 26 + 'A';\n    }\n    for (char c : ans) {\n        ans[ans.find(c)]\
    \ = std::toupper(c);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmplzn9tbon: /tmp/tmplzn9tbon.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        char a = tolower(c);\n        char b = tolower(message[i+1]);\n\
    \        if(a=='a' || a=='e' || a=='i' || a=='o' || a=='u') {\n            ans\
    \ += b;\n        }\n        else if(b=='a' || b=='e' || b=='i' || b=='o' || b=='u')\
    \ {\n            ans += a;\n        }\n        else {\n            ans += c;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpypey_oxw: /tmp/tmpypey_oxw.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if (c >= 'a' && c <= 'z')\
    \ {\n            ans += c;\n        } else if (c >= 'A' && c <= 'Z') {\n     \
    \       ans += c;\n        } else if (c >= '0' && c <= '9') {\n            ans\
    \ += c;\n        } else if (c == '.' || c == '!' || c == '?') {\n            ans\
    \ += c;\n        } else if (c == '_' || c == '-' || c == '+') {\n            ans\
    \ += c;\n        } else if (c == '/' || c == '\\\\') {\n            ans += c;\n\
    \        } else if (c == '@') {\n            ans += c;\n        } else if (c ==\
    \ '*') {\n            ans += c;\n        } else if (c == '&') {\n            ans\
    \ += c;\n        } else if (c == '(') {\n            ans += c;\n        } else\
    \ if (c == ')') {\n            ans += c;\n        } else if (c == '[') {\n   \
    \         ans += c;\n        } else if (c == ']') {\n            ans += c;\n \
    \       } else if (c == '{') {\n            ans += c;\n        } else if (c ==\
    \ '}') {\n            ans += c;\n        } else if (c == '<') {\n            ans\
    \ += c;\n        } else if (c == '>') {\n            ans += c;\n        } else\
    \ if (c == '%') {\n            ans += c;\n        } else if (c == '^') {\n   \
    \         ans += c;\n        } else if (c == '~') {\n            ans += c;\n \
    \       } else if (c == '|') {\n            ans += c;\n        } else if (c ==\
    \ '\"') {\n            ans += c;\n        } else if (c == '$') {\n           \
    \ ans += c;\n        } else if (c == '!') {\n            ans += c;\n        }\
    \ else if (c == '~') {\n            ans += c;\n        } else if (c == '=') {\n\
    \            ans += c;\n        } else if (c == '+') {\n            ans += c;\n\
    \        } else if (c == '.') {\n            ans += c;\n        } else if (c ==\
    \ '*') {\n            ans += c;\n        } else if (c == '&') {\n            ans\
    \ += c;\n        } else if (c == '(') {\n            ans += c;\n        } else\
    \ if (c == ')') {\n            ans += c;\n        } else if (c == '[') {\n   \
    \         ans += c;\n        } else if (c == ']') {\n            ans += c;\n \
    \       } else if (c == '{') {\n            ans += c;\n        } else if (c ==\
    \ '}') {\n            ans += c;\n        } else if (c == '<') {\n            ans\
    \ += c;\n        } else if (c == '>') {\n            ans += c;\n        } else\
    \ if (c == '%') {\n            ans += c;\n        } else if (c == '^') {\n   \
    \         ans += c;\n        } else if (c == '~') {\n            ans += c;\n \
    \       } else if (c == '|') {\n            ans += c;\n        } else if (c ==\
    \ '\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvqjm7wb1.cpp:100:25: warning: missing terminating ' character\n\
    \  100 |         } else if (c == '\n      |                         ^\n/tmp/tmpvqjm7wb1.cpp:100:25:\
    \ error: missing terminating ' character\n/tmp/tmpvqjm7wb1.cpp: In function \u2018\
    std::string encode(std::string)\u2019:\n/tmp/tmpvqjm7wb1.cpp:101:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n  101 | }\n      | ^\n/tmp/tmpvqjm7wb1.cpp:100:24:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n  100 |         }\
    \ else if (c == '\n      |                   ~    ^\n      |                 \
    \       )\n  101 | }\n      | ~                       \n/tmp/tmpvqjm7wb1.cpp:101:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  101 | }\n \
    \     | ^\n/tmp/tmpvqjm7wb1.cpp:102:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  102 | int main() {\n      |            ^\n\
    /tmp/tmpvqjm7wb1.cpp:109:1: error: expected \u2018}\u2019 at end of input\n  109\
    \ | }\n      | ^\n/tmp/tmpvqjm7wb1.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpvqjm7wb1.cpp:109:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n  109 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if('a' <= c && c <= 'z') {\n            ans += c;\n \
    \       } else if('A' <= c && c <= 'Z') {\n            ans += c;\n        } else\
    \ if('0' <= c && c <= '9') {\n            ans += c;\n        } else if(c == '.'\
    \ || c == '!' || c == '?' || c == '-' || c == '_' || c == '/' || c == '\\\\' ||\
    \ c == '*' || c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c ==\
    \ '}' || c == '$' || c == '%' || c == '^' || c == '&' || c == '*' || c == '+'\
    \ || c == ',') {\n            ans += c;\n        } else {\n            ans +=\
    \ 'A' + message[i] - 'a';\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpao8t3mq4: /tmp/tmpao8t3mq4.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isalpha(c) ? toupper(c)\
    \ : tolower(c));\n    }\n    for (int i = 0; i < ans.length(); i++) {\n      \
    \  if (isalpha(ans[i])) {\n            ans[i] = toupper(ans[i]);\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isupper(ans[i]))\
    \ {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (isupper(ans[i]) && islower(ans[i -\
    \ 1])) {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp5rk00b9a: /tmp/tmp5rk00b9a.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            ans += 'A' + tolower(message[i] - 'a');\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpezcy8mlf: /tmp/tmpezcy8mlf.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        }\n        else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n            ans += 'A';\n        }\n  \
    \      else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans += 'a';\n        }\n    }\n    for (char c : ans) {\n       \
    \ if ('A' <= c && c <= 'Z') {\n            ans[ans.find(c)] = c;\n        }\n\
    \        else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \            ans[ans.find(c)] = 'A';\n        }\n        else if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)]\
    \ = 'a';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpr2zp501c: /tmp/tmpr2zp501c.cpp:41: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (char)(c + 1);\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   \
    \         ans[i] = 'A';\n        }\n        if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans[i] = 'a';\n        }\n    }\n  \
    \  for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n      \
    \  if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n         \
    \   ans[i] = 'a';\n        }\n        if (c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u') {\n            ans[i] = 'A';\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i]\
    \ = 'a';\n        }\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U') {\n            ans[i] = 'A';\n        }\n    }\n    for (int i\
    \ = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n\
    \        }\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans[i] = 'A';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n        }\n        if\
    \ (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i]\
    \ = 'A';\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n   \
    \     char c = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') {\n            ans[i] = 'a';\n        }\n        if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'A';\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        char\
    \ c = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzlgxy1pn.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpzlgxy1pn.cpp:74:50: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   74 |         if (c == 'a' || c == 'e' || c == 'i' || c\n      |  \
    \          ~                                     ^\n      |                  \
    \                                )\n   75 | }\n      | ~                     \
    \                            \n/tmp/tmpzlgxy1pn.cpp:75:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   75 | }\n      | ^\n/tmp/tmpzlgxy1pn.cpp:76:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   76 | int main() {\n      |            ^\n/tmp/tmpzlgxy1pn.cpp:83:1: error:\
    \ expected \u2018}\u2019 at end of input\n   83 | }\n      | ^\n/tmp/tmpzlgxy1pn.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpzlgxy1pn.cpp:83:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   83 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ (c - 'a');\n        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if(c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if(c == 'a') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmphhukf2ut: /tmp/tmphhukf2ut.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        } else {\n            ans += 'A'\
    \ + (c - 'a');\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if (c == 'a') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if (c == 'a' || c == 'A') {\n            ans[i] = 'a';\n        } else if\
    \ (c == 'e' || c == 'E') {\n            ans[i] = 'e';\n        } else if (c ==\
    \ 'i' || c == 'I') {\n            ans[i] = 'i';\n        } else if (c == 'o' ||\
    \ c == 'O') {\n            ans[i] = 'o';\n        } else if (c == 'u' || c ==\
    \ 'U') {\n            ans[i] = 'u';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'A';\n        } else if (c == 'e' || c == 'E')\
    \ {\n            ans[i] = 'E';\n        } else if (c == 'i' || c == 'I') {\n \
    \           ans[i] = 'I';\n        } else if (c == 'o' || c == 'O') {\n      \
    \      ans[i] = 'O';\n        } else if (c == 'u' || c == 'U') {\n           \
    \ ans[i] = 'U';\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        char c = ans[i];\n        if (c == 'a' || c == 'A') {\n         \
    \   ans[i] = 'a';\n        } else if (c == 'e' || c == 'E') {\n            ans[i]\
    \ = 'e';\n        } else if (c == 'i' || c == 'I') {\n            ans[i] = 'i';\n\
    \        } else if (c == 'o' || c == 'O') {\n            ans[i] = 'o';\n     \
    \   } else if (c == 'u' || c == 'U') {\n            ans[i] = 'u';\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if (c == 'a' || c == 'A') {\n            ans[i] = 'A';\n        } else\
    \ if (c == 'e' || c == 'E') {\n            ans[i] = 'E';\n        } else if (c\
    \ == 'i' || c == 'I') {\n            ans[i] = 'I';\n        } else if (c == 'o'\
    \ || c == 'O') {\n            ans[i] = 'O';\n        } else if (c == 'u' || c\
    \ == 'U') {\n            ans[i] = 'U';\n        }\n\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbsc8425s.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpbsc8425s.cpp:88:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   88 | int main() {\n      |            ^\n/tmp/tmpbsc8425s.cpp:95:1:\
    \ error: expected \u2018}\u2019 at end of input\n   95 | }\n      | ^\n/tmp/tmpbsc8425s.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpbsc8425s.cpp:95:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   95 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (std::tolower(c) ==\
    \ c) ? std::toupper(c) : c;\n    }\n    for (char c : ans) {\n        if (c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = std::toupper(c);\n        }\n    }\n    for (char c : ans) {\n      \
    \  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n         \
    \   ans[ans.find(c) + 2] = std::tolower(c);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpr_wnf_nz: /tmp/tmpr_wnf_nz.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c: message) {\n        if (c >= 'a' && c <= 'z')\
    \ {\n            ans += c;\n        } else if (c >= 'A' && c <= 'Z') {\n     \
    \       ans += c;\n        } else if (c >= '0' && c <= '9') {\n            ans\
    \ += c;\n        } else if (c == '.') {\n            ans += c;\n        } else\
    \ if (c == '!') {\n            ans += c;\n        } else if (c == '?') {\n   \
    \         ans += c;\n        } else if (c == '-') {\n            ans += c;\n \
    \       } else if (c == '_') {\n            ans += c;\n        } else if (c ==\
    \ '/') {\n            ans += c;\n        } else if (c == '\\\\') {\n         \
    \   ans += c;\n        } else if (c == '(') {\n            ans += c;\n       \
    \ } else if (c == ')') {\n            ans += c;\n        } else if (c == '+')\
    \ {\n            ans += c;\n        } else if (c == '=') {\n            ans +=\
    \ c;\n        } else if (c == '[') {\n            ans += c;\n        } else if\
    \ (c == ']') {\n            ans += c;\n        } else if (c == '{') {\n      \
    \      ans += c;\n        } else if (c == '}') {\n            ans += c;\n    \
    \    } else if (c == '<') {\n            ans += c;\n        } else if (c == '>')\
    \ {\n            ans += c;\n        } else if (c == '%') {\n            ans +=\
    \ c;\n        } else if (c == '!') {\n            ans += c;\n        } else if\
    \ (c == '@') {\n            ans += c;\n        } else if (c == '#') {\n      \
    \      ans += c;\n        } else if (c == '$') {\n            ans += c;\n    \
    \    } else if (c == '%') {\n            ans += c;\n        } else if (c == '^')\
    \ {\n            ans += c;\n        } else if (c == '&') {\n            ans +=\
    \ c;\n        } else if (c == '*') {\n            ans += c;\n        } else if\
    \ (c == '(') {\n            ans += c;\n        } else if (c == ')') {\n      \
    \      ans += c;\n        } else if (c == '+') {\n            ans += c;\n    \
    \    } else if (c == '=') {\n            ans += c;\n        } else if (c == '[')\
    \ {\n            ans += c;\n        } else if (c == ']') {\n            ans +=\
    \ c;\n        } else if (c == '{') {\n            ans += c;\n        } else if\
    \ (c == '}') {\n            ans += c;\n        } else if (c == '<') {\n      \
    \      ans += c;\n        } else if (c == '>') {\n            ans += c;\n    \
    \    } else if (c == '%') {\n            ans += c;\n        } else if (c == '!')\
    \ {\n            ans += c;\n        } else if (c == '@') {\n            ans +=\
    \ c;\n        } else if (c == '#') {\n            ans += c;\n        } else if\
    \ (c == '$') {\n            ans += c;\n        } else if (\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxp8891q6.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpxp8891q6.cpp:105:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  105 | }\n      | ^\n/tmp/tmpxp8891q6.cpp:104:20: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n  104 |         } else if (\n    \
    \  |                   ~^\n      |                    )\n  105 | }\n      | ~\
    \                   \n/tmp/tmpxp8891q6.cpp:105:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmpxp8891q6.cpp:106:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  106 | int main() {\n      |            ^\n/tmp/tmpxp8891q6.cpp:113:1: error:\
    \ expected \u2018}\u2019 at end of input\n  113 | }\n      | ^\n/tmp/tmpxp8891q6.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpxp8891q6.cpp:113:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  113 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c : ans) {\n        if (c != 'A' && c\
    \ != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            ans[ans.find(c) +\
    \ 2] = tolower(ans[ans.find(c) + 2]);\n        }\n    }\n    for (auto &c : ans)\
    \ {\n        if (c != 'A' && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n\
    \            ans[ans.find(c) + 1] = toupper(ans[ans.find(c) + 1]);\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmputd_oh87: /tmp/tmputd_oh87.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c : ans) {\n        switch (c) {\n   \
    \     case 'A':\n        case 'E':\n        case 'I':\n        case 'O':\n   \
    \     case 'U':\n            ans[ans.find(c) + 1] = tolower(ans[ans.find(c) +\
    \ 1]);\n            break;\n        case 'a':\n        case 'e':\n        case\
    \ 'i':\n        case 'o':\n        case 'u':\n            ans[ans.find(c) + 1]\
    \ = toupper(ans[ans.find(c) + 1]);\n            break;\n        default:\n   \
    \         break;\n        }\n    }\n    for (auto &c : ans) {\n        if (c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 1] = tolower(ans[ans.find(c) + 1]);\n        }\n    }\n    for (auto &c :\
    \ ans) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[ans.find(c) + 1] = toupper(ans[ans.find(c) + 1]);\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp8gyahez4: /tmp/tmp8gyahez4.cpp:52: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isalpha(c) ? toupper(c)\
    \ : c);\n    }\n    for (auto &c : ans) {\n        switch (c) {\n        case\
    \ 'A':\n        case 'E':\n        case 'I':\n        case 'O':\n        case\
    \ 'U':\n            ans[ans.find(c) + 1] = tolower(c);\n            break;\n \
    \       default:\n            ans[ans.find(c) + 1] = toupper(c);\n           \
    \ break;\n        }\n    }\n    for (auto &c : ans) {\n        switch (c) {\n\
    \        case 'A':\n        case 'E':\n        case 'I':\n        case 'O':\n\
    \        case 'U':\n            ans[ans.find(c) + 1] = tolower(c);\n         \
    \   break;\n        default:\n            ans[ans.find(c) + 1] = toupper(c);\n\
    \            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp2tgd3k6y: /tmp/tmp2tgd3k6y.cpp:50: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            ans += 'A' + (c - 'a');\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpsb4qouq6: /tmp/tmpsb4qouq6.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isalpha(c)) ? toupper(c)\
    \ : c;\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isalpha(ans[i]))\
    \ {\n            ans[i] = toupper(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (isupper(ans[i])) {\n            ans[i]\
    \ = tolower(ans[i]);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isupper(ans[i]))\
    \ {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (isupper(ans[i])) {\n            ans[i]\
    \ = tolower(ans[i]);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isupper(ans[i]))\
    \ {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (isupper(ans[i])) {\n            ans[i]\
    \ = tolower(ans[i]);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isupper(ans[i]))\
    \ {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (isupper(ans[i])) {\n            ans[i]\
    \ = tolower(ans[i]);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isupper(ans[i]))\
    \ {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (isupper(ans[i])) {\n            ans[i]\
    \ = tolower(ans[i]);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isupper(ans[i]))\
    \ {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (isupper(ans[i])) {\n            ans[i]\
    \ = tolower(ans[i]);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (isupper(ans[i]))\
    \ {\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5cfkmhr3.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp5cfkmhr3.cpp:111:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  111 | int main() {\n      |            ^\n/tmp/tmp5cfkmhr3.cpp:118:1:\
    \ error: expected \u2018}\u2019 at end of input\n  118 | }\n      | ^\n/tmp/tmp5cfkmhr3.cpp:108:44:\
    \ note: to match this \u2018{\u2019\n  108 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmp5cfkmhr3.cpp:118:1:\
    \ error: expected \u2018}\u2019 at end of input\n  118 | }\n      | ^\n/tmp/tmp5cfkmhr3.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp5cfkmhr3.cpp:118:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  118 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c + 2 : c));\n\
    \    }\n    for (auto &c : ans) {\n        ans[ans.find(c) + 2] = ans[ans.find(c)\
    \ + 1] + c;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpbp80mjko: /tmp/tmpbp80mjko.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    for(int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if(c == 'A') {\n            ans[i]\
    \ = 'a';\n        }\n        else if(c == 'a') {\n            ans[i] = 'A';\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp_kdx59me: /tmp/tmp_kdx59me.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encodedMessage = \"\";\n    for (int i = 0; i < message.length(); i++) {\n \
    \       if (message[i] >= 'a' && message[i] <= 'z') {\n            encodedMessage\
    \ += message[i];\n        }\n        else if (message[i] >= 'A' && message[i]\
    \ <= 'Z') {\n            encodedMessage += message[i];\n        }\n        else\
    \ if (message[i] >= '0' && message[i] <= '9') {\n            encodedMessage +=\
    \ message[i];\n        }\n        else if (message[i] == '.' || message[i] ==\
    \ '!' || message[i] == '?') {\n            encodedMessage += message[i];\n   \
    \     }\n        else if (message[i] == '_' || message[i] == '-' || message[i]\
    \ == '+') {\n            encodedMessage += message[i];\n        }\n        else\
    \ if (message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || message[i]\
    \ == 'o' || message[i] == 'u') {\n            encodedMessage += message[i];\n\
    \        }\n        else if (message[i] == 'A' || message[i] == 'E' || message[i]\
    \ == 'I' || message[i] == 'O' || message[i] == 'U') {\n            encodedMessage\
    \ += message[i];\n        }\n        else if (message[i] == '0' || message[i]\
    \ == '1') {\n            encodedMessage += message[i];\n        }\n        else\
    \ if (message[i] == '2' || message[i] == '3') {\n            encodedMessage +=\
    \ message[i];\n        }\n        else if (message[i] == '4' || message[i] ==\
    \ '5') {\n            encodedMessage += message[i];\n        }\n        else if\
    \ (message[i] == '6' || message[i] == '7') {\n            encodedMessage += message[i];\n\
    \        }\n        else if (message[i] == '8' || message[i] == '9') {\n     \
    \       encodedMessage += message[i];\n        }\n        else if (message[i]\
    \ == '.' || message[i] == '!' || message[i] == '?') {\n            encodedMessage\
    \ += message[i];\n        }\n        else if (message[i] == '_' || message[i]\
    \ == '-' || message[i] == '+') {\n            encodedMessage += message[i];\n\
    \        }\n        else if (message[i] == 'a' || message[i] == 'e' || message[i]\
    \ == 'i' || message[i] == 'o' || message[i] == 'u') {\n            encodedMessage\
    \ += message[i];\n        }\n        else if (message[i] == 'A' || message[i]\
    \ == 'E' || message[i] == 'I' || message[i] == 'O' || message[i] == 'U') {\n \
    \           encodedMessage += message[i];\n        }\n        else if (message[i]\
    \ == '0' || message[i] == '1') {\n            encodedMessage += message[i];\n\
    \        }\n        else if (message[i] == '2' || message[i] == '3') {\n     \
    \       encodedMessage += message[i];\n        }\n        else if (message[i]\
    \ == '4' || message[i] == '5') {\n            encodedMessage += message[i];\n\
    \        }\n        else if (message[i] == '6' || message[i] == '7') {\n     \
    \       encoded\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg3_dg90l.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpg3_dg90l.cpp:74:13: error: \u2018encoded\u2019 was not declared in\
    \ this scope; did you mean \u2018encode\u2019?\n   74 |             encoded\n\
    \      |             ^~~~~~~\n      |             encode\n/tmp/tmpg3_dg90l.cpp:76:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   76 | int main() {\n      |            ^\n/tmp/tmpg3_dg90l.cpp:83:1: error:\
    \ expected \u2018}\u2019 at end of input\n   83 | }\n      | ^\n/tmp/tmpg3_dg90l.cpp:15:48:\
    \ note: to match this \u2018{\u2019\n   15 |     for (int i = 0; i < message.length();\
    \ i++) {\n      |                                                ^\n/tmp/tmpg3_dg90l.cpp:83:1:\
    \ error: expected \u2018}\u2019 at end of input\n   83 | }\n      | ^\n/tmp/tmpg3_dg90l.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpg3_dg90l.cpp:83:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   83 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        switch (c) {\n         \
    \   case 'A':\n            case 'a':\n                ans += 'A';\n          \
    \      break;\n            case 'B':\n            case 'b':\n                ans\
    \ += 'B';\n                break;\n            case 'C':\n            case 'c':\n\
    \                ans += 'C';\n                break;\n            case 'D':\n\
    \            case 'd':\n                ans += 'D';\n                break;\n\
    \            case 'E':\n            case 'e':\n                ans += 'E';\n \
    \               break;\n            case 'F':\n            case 'f':\n       \
    \         ans += 'F';\n                break;\n            case 'G':\n       \
    \     case 'g':\n                ans += 'G';\n                break;\n       \
    \     case 'H':\n            case 'h':\n                ans += 'H';\n        \
    \        break;\n            case 'I':\n            case 'i':\n              \
    \  ans += 'I';\n                break;\n            case 'J':\n            case\
    \ 'j':\n                ans += 'J';\n                break;\n            case\
    \ 'K':\n            case 'k':\n                ans += 'K';\n                break;\n\
    \            case 'L':\n            case 'l':\n                ans += 'L';\n \
    \               break;\n            case 'M':\n            case 'm':\n       \
    \         ans += 'M';\n                break;\n            case 'N':\n       \
    \     case 'n':\n                ans += 'N';\n                break;\n       \
    \     case 'O':\n            case 'o':\n                ans += 'O';\n        \
    \        break;\n            case 'P':\n            case 'p':\n              \
    \  ans += 'P';\n                break;\n            case 'Q':\n            case\
    \ 'q':\n                ans += 'Q';\n                break;\n            case\
    \ 'R':\n            case 'r':\n                ans += 'R';\n                break;\n\
    \            case 'S':\n            case 's':\n                ans += 'S';\n \
    \               break;\n            case 'T':\n            case 't':\n       \
    \         ans += 'T';\n                break;\n            case 'U':\n       \
    \     case 'u':\n                ans += 'U';\n                break;\n       \
    \     case 'V':\n            case 'v':\n                ans += 'V';\n        \
    \        break;\n            case 'W':\n            case 'w':\n              \
    \  ans += 'W';\n                break;\n            case 'X':\n            case\
    \ 'x':\n                ans += 'X';\n                break;\n            case\
    \ 'Y':\n            case 'y':\n                ans += 'Y';\n                break;\n\
    \            case 'Z':\n            case 'z':\n                ans += 'Z';\n \
    \               break;\n            default:\n                ans += c;\n    \
    \    }\n    }\n    for (auto &c : ans) {\n        switch (c) {\n            case\
    \ 'A':\n            case 'a':\n                ans += 'a';\n                break;\n\
    \            case 'B':\n            case 'b':\n                ans += 'b\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaemtx4c_.cpp:133:24: warning: missing terminating ' character\n\
    \  133 |                 ans += 'b\n      |                        ^\n/tmp/tmpaemtx4c_.cpp:133:24:\
    \ error: missing terminating ' character\n  133 |                 ans += 'b\n\
    \      |                        ^~\n/tmp/tmpaemtx4c_.cpp: In function \u2018std::string\
    \ encode(std::string)\u2019:\n/tmp/tmpaemtx4c_.cpp:134:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  134 | }\n      | ^\n/tmp/tmpaemtx4c_.cpp:135:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  135 | int main() {\n      |            ^\n/tmp/tmpaemtx4c_.cpp:142:1: error:\
    \ expected \u2018}\u2019 at end of input\n  142 | }\n      | ^\n/tmp/tmpaemtx4c_.cpp:125:25:\
    \ note: to match this \u2018{\u2019\n  125 |     for (auto &c : ans) {\n     \
    \ |                         ^\n/tmp/tmpaemtx4c_.cpp:142:1: error: expected \u2018\
    }\u2019 at end of input\n  142 | }\n      | ^\n/tmp/tmpaemtx4c_.cpp:13:41: note:\
    \ to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpaemtx4c_.cpp:142:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  142 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? tolower(c) : c;\n    }\n    for (char c : ans) {\n        ans += (c >=\
    \ 'a' && c <= 'z') ? toupper(c) : c;\n    }\n    for (char c : ans) {\n      \
    \  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n         \
    \   ans += 'A';\n        }\n        if (c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += 'E';\n        }\n        if (c == 'i' || c ==\
    \ 'o' || c == 'u') {\n            ans += 'I';\n        }\n        if (c == 'o'\
    \ || c == 'u') {\n            ans += 'O';\n        }\n        if (c == 'u') {\n\
    \            ans += 'U';\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpyq4kbhfr: /tmp/tmpyq4kbhfr.cpp:42: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        switch(c) {\n            case 'a':\n            case\
    \ 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n\
    \                ans += c;\n                break;\n            case 'A':\n  \
    \          case 'E':\n            case 'I':\n            case 'O':\n         \
    \   case 'U':\n                ans += c;\n                break;\n           \
    \ default:\n                ans += 'A';\n        }\n    }\n    for(int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        for(int j = 0; j\
    \ < i; j++) {\n            char d = ans[j];\n            if(d == c) {\n      \
    \          ans[j] = ans[j+1];\n                ans[j+1] = c;\n            }\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmplvuln0dk: /tmp/tmplvuln0dk.cpp:50: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (auto &c : message) {\n        if (c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u') {\n            encoded += c;\n    \
    \    } else {\n            char a = c;\n            char b = c;\n            char\
    \ c = c;\n            char d = c;\n            char e = c;\n            char f\
    \ = c;\n            char g = c;\n            char h = c;\n            char i =\
    \ c;\n            char j = c;\n            char k = c;\n            char l = c;\n\
    \            char m = c;\n            char n = c;\n            char o = c;\n \
    \           char p = c;\n            char q = c;\n            char r = c;\n  \
    \          char s = c;\n            char t = c;\n            char u = c;\n   \
    \         char v = c;\n            char w = c;\n            char x = c;\n    \
    \        char y = c;\n            char z = c;\n            char A = c;\n     \
    \       char B = c;\n            char C = c;\n            char D = c;\n      \
    \      char E = c;\n            char F = c;\n            char G = c;\n       \
    \     char H = c;\n            char I = c;\n            char J = c;\n        \
    \    char K = c;\n            char L = c;\n            char M = c;\n         \
    \   char N = c;\n            char O = c;\n            char P = c;\n          \
    \  char Q = c;\n            char R = c;\n            char S = c;\n           \
    \ char T = c;\n            char U = c;\n            char V = c;\n            char\
    \ W = c;\n            char X = c;\n            char Y = c;\n            char Z\
    \ = c;\n            char a = c;\n            char b = c;\n            char c =\
    \ c;\n            char d = c;\n            char e = c;\n            char f = c;\n\
    \            char g = c;\n            char h = c;\n            char i = c;\n \
    \           char j = c;\n            char k = c;\n            char l = c;\n  \
    \          char m = c;\n            char n = c;\n            char o = c;\n   \
    \         char p = c;\n            char q = c;\n            char r = c;\n    \
    \        char s = c;\n            char t = c;\n            char u = c;\n     \
    \       char v = c;\n            char w = c;\n            char x = c;\n      \
    \      char y = c;\n            char z = c;\n            char A = c;\n       \
    \     char B = c;\n            char C = c;\n            char D = c;\n        \
    \    char E = c;\n            char F = c;\n            char G = c;\n         \
    \   char H = c;\n            char I = c;\n            char J = c;\n          \
    \  char K = c;\n            char L = c;\n            char M = c;\n\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw3mliy6d.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpw3mliy6d.cpp:71:18: error: redeclaration of \u2018char a\u2019\n  \
    \ 71 |             char a = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:19:18:\
    \ note: \u2018char a\u2019 previously declared here\n   19 |             char\
    \ a = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:72:18: error: redeclaration\
    \ of \u2018char b\u2019\n   72 |             char b = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:20:18: note: \u2018char b\u2019 previously declared\
    \ here\n   20 |             char b = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:73:18:\
    \ error: redeclaration of \u2018char c\u2019\n   73 |             char c = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:21:18: note: \u2018char c\u2019\
    \ previously declared here\n   21 |             char c = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:74:18: error: redeclaration of \u2018char d\u2019\
    \n   74 |             char d = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:22:18:\
    \ note: \u2018char d\u2019 previously declared here\n   22 |             char\
    \ d = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:75:18: error: redeclaration\
    \ of \u2018char e\u2019\n   75 |             char e = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:23:18: note: \u2018char e\u2019 previously declared\
    \ here\n   23 |             char e = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:76:18:\
    \ error: redeclaration of \u2018char f\u2019\n   76 |             char f = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:24:18: note: \u2018char f\u2019\
    \ previously declared here\n   24 |             char f = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:77:18: error: redeclaration of \u2018char g\u2019\
    \n   77 |             char g = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:25:18:\
    \ note: \u2018char g\u2019 previously declared here\n   25 |             char\
    \ g = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:78:18: error: redeclaration\
    \ of \u2018char h\u2019\n   78 |             char h = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:26:18: note: \u2018char h\u2019 previously declared\
    \ here\n   26 |             char h = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:79:18:\
    \ error: redeclaration of \u2018char i\u2019\n   79 |             char i = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:27:18: note: \u2018char i\u2019\
    \ previously declared here\n   27 |             char i = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:80:18: error: redeclaration of \u2018char j\u2019\
    \n   80 |             char j = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:28:18:\
    \ note: \u2018char j\u2019 previously declared here\n   28 |             char\
    \ j = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:81:18: error: redeclaration\
    \ of \u2018char k\u2019\n   81 |             char k = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:29:18: note: \u2018char k\u2019 previously declared\
    \ here\n   29 |             char k = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:82:18:\
    \ error: redeclaration of \u2018char l\u2019\n   82 |             char l = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:30:18: note: \u2018char l\u2019\
    \ previously declared here\n   30 |             char l = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:83:18: error: redeclaration of \u2018char m\u2019\
    \n   83 |             char m = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:31:18:\
    \ note: \u2018char m\u2019 previously declared here\n   31 |             char\
    \ m = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:84:18: error: redeclaration\
    \ of \u2018char n\u2019\n   84 |             char n = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:32:18: note: \u2018char n\u2019 previously declared\
    \ here\n   32 |             char n = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:85:18:\
    \ error: redeclaration of \u2018char o\u2019\n   85 |             char o = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:33:18: note: \u2018char o\u2019\
    \ previously declared here\n   33 |             char o = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:86:18: error: redeclaration of \u2018char p\u2019\
    \n   86 |             char p = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:34:18:\
    \ note: \u2018char p\u2019 previously declared here\n   34 |             char\
    \ p = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:87:18: error: redeclaration\
    \ of \u2018char q\u2019\n   87 |             char q = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:35:18: note: \u2018char q\u2019 previously declared\
    \ here\n   35 |             char q = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:88:18:\
    \ error: redeclaration of \u2018char r\u2019\n   88 |             char r = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:36:18: note: \u2018char r\u2019\
    \ previously declared here\n   36 |             char r = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:89:18: error: redeclaration of \u2018char s\u2019\
    \n   89 |             char s = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:37:18:\
    \ note: \u2018char s\u2019 previously declared here\n   37 |             char\
    \ s = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:90:18: error: redeclaration\
    \ of \u2018char t\u2019\n   90 |             char t = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:38:18: note: \u2018char t\u2019 previously declared\
    \ here\n   38 |             char t = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:91:18:\
    \ error: redeclaration of \u2018char u\u2019\n   91 |             char u = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:39:18: note: \u2018char u\u2019\
    \ previously declared here\n   39 |             char u = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:92:18: error: redeclaration of \u2018char v\u2019\
    \n   92 |             char v = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:40:18:\
    \ note: \u2018char v\u2019 previously declared here\n   40 |             char\
    \ v = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:93:18: error: redeclaration\
    \ of \u2018char w\u2019\n   93 |             char w = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:41:18: note: \u2018char w\u2019 previously declared\
    \ here\n   41 |             char w = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:94:18:\
    \ error: redeclaration of \u2018char x\u2019\n   94 |             char x = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:42:18: note: \u2018char x\u2019\
    \ previously declared here\n   42 |             char x = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:95:18: error: redeclaration of \u2018char y\u2019\
    \n   95 |             char y = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:43:18:\
    \ note: \u2018char y\u2019 previously declared here\n   43 |             char\
    \ y = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:96:18: error: redeclaration\
    \ of \u2018char z\u2019\n   96 |             char z = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:44:18: note: \u2018char z\u2019 previously declared\
    \ here\n   44 |             char z = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:97:18:\
    \ error: redeclaration of \u2018char A\u2019\n   97 |             char A = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:45:18: note: \u2018char A\u2019\
    \ previously declared here\n   45 |             char A = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:98:18: error: redeclaration of \u2018char B\u2019\
    \n   98 |             char B = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:46:18:\
    \ note: \u2018char B\u2019 previously declared here\n   46 |             char\
    \ B = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:99:18: error: redeclaration\
    \ of \u2018char C\u2019\n   99 |             char C = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:47:18: note: \u2018char C\u2019 previously declared\
    \ here\n   47 |             char C = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:100:18:\
    \ error: redeclaration of \u2018char D\u2019\n  100 |             char D = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:48:18: note: \u2018char D\u2019\
    \ previously declared here\n   48 |             char D = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:101:18: error: redeclaration of \u2018char E\u2019\
    \n  101 |             char E = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:49:18:\
    \ note: \u2018char E\u2019 previously declared here\n   49 |             char\
    \ E = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:102:18: error: redeclaration\
    \ of \u2018char F\u2019\n  102 |             char F = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:50:18: note: \u2018char F\u2019 previously declared\
    \ here\n   50 |             char F = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:103:18:\
    \ error: redeclaration of \u2018char G\u2019\n  103 |             char G = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:51:18: note: \u2018char G\u2019\
    \ previously declared here\n   51 |             char G = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:104:18: error: redeclaration of \u2018char H\u2019\
    \n  104 |             char H = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:52:18:\
    \ note: \u2018char H\u2019 previously declared here\n   52 |             char\
    \ H = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:105:18: error: redeclaration\
    \ of \u2018char I\u2019\n  105 |             char I = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:53:18: note: \u2018char I\u2019 previously declared\
    \ here\n   53 |             char I = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:106:18:\
    \ error: redeclaration of \u2018char J\u2019\n  106 |             char J = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:54:18: note: \u2018char J\u2019\
    \ previously declared here\n   54 |             char J = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:107:18: error: redeclaration of \u2018char K\u2019\
    \n  107 |             char K = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:55:18:\
    \ note: \u2018char K\u2019 previously declared here\n   55 |             char\
    \ K = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:108:18: error: redeclaration\
    \ of \u2018char L\u2019\n  108 |             char L = c;\n      |            \
    \      ^\n/tmp/tmpw3mliy6d.cpp:56:18: note: \u2018char L\u2019 previously declared\
    \ here\n   56 |             char L = c;\n      |                  ^\n/tmp/tmpw3mliy6d.cpp:109:18:\
    \ error: redeclaration of \u2018char M\u2019\n  109 |             char M = c;\n\
    \      |                  ^\n/tmp/tmpw3mliy6d.cpp:57:18: note: \u2018char M\u2019\
    \ previously declared here\n   57 |             char M = c;\n      |         \
    \         ^\n/tmp/tmpw3mliy6d.cpp:112:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n  112 | int main() {\n      |     \
    \       ^\n/tmp/tmpw3mliy6d.cpp:119:1: error: expected \u2018}\u2019 at end of\
    \ input\n  119 | }\n      | ^\n/tmp/tmpw3mliy6d.cpp:15:29: note: to match this\
    \ \u2018{\u2019\n   15 |     for (auto &c : message) {\n      |              \
    \               ^\n/tmp/tmpw3mliy6d.cpp:119:1: error: expected \u2018}\u2019 at\
    \ end of input\n  119 | }\n      | ^\n/tmp/tmpw3mliy6d.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmpw3mliy6d.cpp:119:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n  119 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        } else {\n            ans += 'A'\
    \ + (c - 'a');\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if (c == 'a') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if (c == 'a' || c == 'A') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if (c == 'A') {\n            ans[i] = 'a';\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if (c ==\
    \ 'a' || c == 'A') {\n            ans[i] = 'A';\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if (c ==\
    \ 'A') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'A';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'A';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'A';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'A';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c ==\
    \ 'A') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i <\
    \ ans.length(); i++) {\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9own6ywg.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp9own6ywg.cpp:105:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  105 | int main() {\n      |            ^\n/tmp/tmp9own6ywg.cpp:112:1:\
    \ error: expected \u2018}\u2019 at end of input\n  112 | }\n      | ^\n/tmp/tmp9own6ywg.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp9own6ywg.cpp:112:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  112 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char &c: message) {\n        if (c >= 'a' && c <= 'z')\
    \ {\n            ans += (c + 2);\n        } else if (c >= 'A' && c <= 'Z') {\n\
    \            ans += (c + 2);\n        } else if (c >= '0' && c <= '9') {\n   \
    \         ans += (c + 2);\n        } else if (c == '.') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '!') {\n            ans += (c + 2);\n    \
    \    } else if (c == '?') {\n            ans += (c + 2);\n        } else if (c\
    \ == '-') {\n            ans += (c + 2);\n        } else if (c == '_') {\n   \
    \         ans += (c + 2);\n        } else if (c == '/') {\n            ans +=\
    \ (c + 2);\n        } else if (c == '\\\\') {\n            ans += (c + 2);\n \
    \       } else if (c == '(') {\n            ans += (c + 2);\n        } else if\
    \ (c == ')') {\n            ans += (c + 2);\n        } else if (c == '*') {\n\
    \            ans += (c + 2);\n        } else if (c == '+') {\n            ans\
    \ += (c + 2);\n        } else if (c == '=') {\n            ans += (c + 2);\n \
    \       } else if (c == '[') {\n            ans += (c + 2);\n        } else if\
    \ (c == ']') {\n            ans += (c + 2);\n        } else if (c == '{') {\n\
    \            ans += (c + 2);\n        } else if (c == '}') {\n            ans\
    \ += (c + 2);\n        } else if (c == '<') {\n            ans += (c + 2);\n \
    \       } else if (c == '>') {\n            ans += (c + 2);\n        } else if\
    \ (c == '%') {\n            ans += (c + 2);\n        } else if (c == '^') {\n\
    \            ans += (c + 2);\n        } else if (c == '&') {\n            ans\
    \ += (c + 2);\n        } else if (c == '|') {\n            ans += (c + 2);\n \
    \       } else if (c == '~') {\n            ans += (c + 2);\n        } else if\
    \ (c == '`') {\n            ans += (c + 2);\n        } else if (c == '~') {\n\
    \            ans += (c + 2);\n        } else if (c == '@') {\n            ans\
    \ += (c + 2);\n        } else if (c == '#') {\n            ans += (c + 2);\n \
    \       } else if (c == '$') {\n            ans += (c + 2);\n        } else if\
    \ (c == '%') {\n            ans += (c + 2);\n        } else if (c == '^') {\n\
    \            ans += (c + 2);\n        } else if (c == '&') {\n            ans\
    \ += (c + 2);\n        } else if (c == '*') {\n            ans += (c + 2);\n \
    \       } else if (c == '(') {\n            ans += (c + 2);\n        } else if\
    \ (c == ')') {\n            ans += (c + 2);\n        } else if (c == '\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp42l8b40k.cpp:90:25: warning: missing terminating ' character\n\
    \   90 |         } else if (c == '\n      |                         ^\n/tmp/tmp42l8b40k.cpp:90:25:\
    \ error: missing terminating ' character\n/tmp/tmp42l8b40k.cpp: In function \u2018\
    std::string encode(std::string)\u2019:\n/tmp/tmp42l8b40k.cpp:91:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   91 | }\n      | ^\n/tmp/tmp42l8b40k.cpp:90:24:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   90 |         }\
    \ else if (c == '\n      |                   ~    ^\n      |                 \
    \       )\n   91 | }\n      | ~                       \n/tmp/tmp42l8b40k.cpp:91:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   91 | }\n \
    \     | ^\n/tmp/tmp42l8b40k.cpp:92:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   92 | int main() {\n      |            ^\n\
    /tmp/tmp42l8b40k.cpp:99:1: error: expected \u2018}\u2019 at end of input\n   99\
    \ | }\n      | ^\n/tmp/tmp42l8b40k.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmp42l8b40k.cpp:99:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   99 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (std::tolower(c)\
    \ == c) ? std::toupper(c) : c;\n    }\n    for (auto &c : ans) {\n        if (std::tolower(c)\
    \ == 'a' || std::tolower(c) == 'e' || std::tolower(c) == 'i' || std::tolower(c)\
    \ == 'o' || std::tolower(c) == 'u') {\n            ans[ans.find(c) + 2] = std::tolower(ans[ans.find(c)\
    \ + 2]);\n        }\n    }\n    for (auto &c : ans) {\n        if (std::tolower(c)\
    \ == 'a' || std::tolower(c) == 'e' || std::tolower(c) == 'i' || std::tolower(c)\
    \ == 'o' || std::tolower(c) == 'u') {\n            ans[ans.find(c) + 2] = std::toupper(ans[ans.find(c)\
    \ + 2]);\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp0jxeuqrp: /tmp/tmp0jxeuqrp.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        switch (c) {\n         \
    \   case 'A':\n            case 'E':\n            case 'I':\n            case\
    \ 'O':\n            case 'U':\n                ans += 'A';\n                break;\n\
    \            case 'B':\n            case 'F':\n            case 'J':\n       \
    \     case 'K':\n            case 'M':\n            case 'N':\n              \
    \  ans += 'B';\n                break;\n            case 'C':\n            case\
    \ 'G':\n            case 'L':\n            case 'P':\n            case 'Q':\n\
    \            case 'S':\n                ans += 'C';\n                break;\n\
    \            case 'D':\n            case 'H':\n            case 'K':\n       \
    \     case 'N':\n                ans += 'D';\n                break;\n       \
    \     case 'E':\n            case 'J':\n            case 'N':\n              \
    \  ans += 'E';\n                break;\n            case 'F':\n            case\
    \ 'K':\n            case 'O':\n            case 'R':\n                ans += 'F';\n\
    \                break;\n            case 'G':\n            case 'L':\n      \
    \      case 'S':\n                ans += 'G';\n                break;\n      \
    \      case 'H':\n            case 'M':\n            case 'P':\n            case\
    \ 'T':\n                ans += 'H';\n                break;\n            case\
    \ 'I':\n            case 'N':\n                ans += 'I';\n                break;\n\
    \            case 'J':\n            case 'O':\n            case 'R':\n       \
    \         ans += 'J';\n                break;\n            case 'K':\n       \
    \     case 'P':\n            case 'S':\n                ans += 'K';\n        \
    \        break;\n            case 'L':\n            case 'Q':\n            case\
    \ 'T':\n                ans += 'L';\n                break;\n            case\
    \ 'M':\n            case 'Q':\n            case 'U':\n                ans += 'M';\n\
    \                break;\n            case 'N':\n            case 'S':\n      \
    \          ans += 'N';\n                break;\n            case 'O':\n      \
    \      case 'R':\n                ans += 'O';\n                break;\n      \
    \      case 'P':\n            case 'S':\n                ans += 'P';\n       \
    \         break;\n            case 'Q':\n            case 'U':\n             \
    \   ans += 'Q';\n                break;\n            case 'R':\n            case\
    \ 'S':\n                ans += 'R';\n                break;\n            case\
    \ 'S':\n                ans += 'S';\n                break;\n            case\
    \ 'T':\n            case 'U':\n                ans += 'T';\n                break;\n\
    \            case 'U':\n                ans += 'U';\n                break;\n\
    \            default:\n                ans += c;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuowk3dbc.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpuowk3dbc.cpp:42:13: error: duplicate case value\n   42 |          \
    \   case 'K':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:27:13: note: previously\
    \ used here\n   27 |             case 'K':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:43:13:\
    \ error: duplicate case value\n   43 |             case 'N':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:29:13: note: previously used here\n   29 |  \
    \           case 'N':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:46:13: error:\
    \ duplicate case value\n   46 |             case 'E':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:18:13: note: previously used here\n   18 |             case\
    \ 'E':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:47:13: error: duplicate\
    \ case value\n   47 |             case 'J':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:26:13:\
    \ note: previously used here\n   26 |             case 'J':\n      |         \
    \    ^~~~\n/tmp/tmpuowk3dbc.cpp:48:13: error: duplicate case value\n   48 |  \
    \           case 'N':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:29:13: note:\
    \ previously used here\n   29 |             case 'N':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:51:13: error: duplicate case value\n   51 |             case\
    \ 'F':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:25:13: note: previously\
    \ used here\n   25 |             case 'F':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:52:13:\
    \ error: duplicate case value\n   52 |             case 'K':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'K':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:53:13: error:\
    \ duplicate case value\n   53 |             case 'O':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:20:13: note: previously used here\n   20 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:57:13: error: duplicate\
    \ case value\n   57 |             case 'G':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:33:13:\
    \ note: previously used here\n   33 |             case 'G':\n      |         \
    \    ^~~~\n/tmp/tmpuowk3dbc.cpp:58:13: error: duplicate case value\n   58 |  \
    \           case 'L':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:34:13: note:\
    \ previously used here\n   34 |             case 'L':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:59:13: error: duplicate case value\n   59 |             case\
    \ 'S':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:37:13: note: previously\
    \ used here\n   37 |             case 'S':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:62:13:\
    \ error: duplicate case value\n   62 |             case 'H':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:41:13: note: previously used here\n   41 |  \
    \           case 'H':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:63:13: error:\
    \ duplicate case value\n   63 |             case 'M':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:28:13: note: previously used here\n   28 |             case\
    \ 'M':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:64:13: error: duplicate\
    \ case value\n   64 |             case 'P':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:35:13:\
    \ note: previously used here\n   35 |             case 'P':\n      |         \
    \    ^~~~\n/tmp/tmpuowk3dbc.cpp:68:13: error: duplicate case value\n   68 |  \
    \           case 'I':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:19:13: note:\
    \ previously used here\n   19 |             case 'I':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:69:13: error: duplicate case value\n   69 |             case\
    \ 'N':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:29:13: note: previously\
    \ used here\n   29 |             case 'N':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:72:13:\
    \ error: duplicate case value\n   72 |             case 'J':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'J':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:73:13: error:\
    \ duplicate case value\n   73 |             case 'O':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:20:13: note: previously used here\n   20 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:74:13: error: duplicate\
    \ case value\n   74 |             case 'R':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:54:13:\
    \ note: previously used here\n   54 |             case 'R':\n      |         \
    \    ^~~~\n/tmp/tmpuowk3dbc.cpp:77:13: error: duplicate case value\n   77 |  \
    \           case 'K':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:27:13: note:\
    \ previously used here\n   27 |             case 'K':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:78:13: error: duplicate case value\n   78 |             case\
    \ 'P':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:35:13: note: previously\
    \ used here\n   35 |             case 'P':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:79:13:\
    \ error: duplicate case value\n   79 |             case 'S':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:37:13: note: previously used here\n   37 |  \
    \           case 'S':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:82:13: error:\
    \ duplicate case value\n   82 |             case 'L':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:34:13: note: previously used here\n   34 |             case\
    \ 'L':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:83:13: error: duplicate\
    \ case value\n   83 |             case 'Q':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:36:13:\
    \ note: previously used here\n   36 |             case 'Q':\n      |         \
    \    ^~~~\n/tmp/tmpuowk3dbc.cpp:84:13: error: duplicate case value\n   84 |  \
    \           case 'T':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:65:13: note:\
    \ previously used here\n   65 |             case 'T':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:87:13: error: duplicate case value\n   87 |             case\
    \ 'M':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:28:13: note: previously\
    \ used here\n   28 |             case 'M':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:88:13:\
    \ error: duplicate case value\n   88 |             case 'Q':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:36:13: note: previously used here\n   36 |  \
    \           case 'Q':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:89:13: error:\
    \ duplicate case value\n   89 |             case 'U':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:21:13: note: previously used here\n   21 |             case\
    \ 'U':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:92:13: error: duplicate\
    \ case value\n   92 |             case 'N':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:29:13:\
    \ note: previously used here\n   29 |             case 'N':\n      |         \
    \    ^~~~\n/tmp/tmpuowk3dbc.cpp:93:13: error: duplicate case value\n   93 |  \
    \           case 'S':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:37:13: note:\
    \ previously used here\n   37 |             case 'S':\n      |             ^~~~\n\
    /tmp/tmpuowk3dbc.cpp:96:13: error: duplicate case value\n   96 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:20:13: note: previously\
    \ used here\n   20 |             case 'O':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:97:13:\
    \ error: duplicate case value\n   97 |             case 'R':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:54:13: note: previously used here\n   54 |  \
    \           case 'R':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:100:13:\
    \ error: duplicate case value\n  100 |             case 'P':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:35:13: note: previously used here\n   35 |  \
    \           case 'P':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:101:13:\
    \ error: duplicate case value\n  101 |             case 'S':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:37:13: note: previously used here\n   37 |  \
    \           case 'S':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:104:13:\
    \ error: duplicate case value\n  104 |             case 'Q':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:36:13: note: previously used here\n   36 |  \
    \           case 'Q':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:105:13:\
    \ error: duplicate case value\n  105 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'U':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:108:13:\
    \ error: duplicate case value\n  108 |             case 'R':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:54:13: note: previously used here\n   54 |  \
    \           case 'R':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:109:13:\
    \ error: duplicate case value\n  109 |             case 'S':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:37:13: note: previously used here\n   37 |  \
    \           case 'S':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:112:13:\
    \ error: duplicate case value\n  112 |             case 'S':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:37:13: note: previously used here\n   37 |  \
    \           case 'S':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:115:13:\
    \ error: duplicate case value\n  115 |             case 'T':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:65:13: note: previously used here\n   65 |  \
    \           case 'T':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:116:13:\
    \ error: duplicate case value\n  116 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'U':\n      |             ^~~~\n/tmp/tmpuowk3dbc.cpp:119:13:\
    \ error: duplicate case value\n  119 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmpuowk3dbc.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'U':\n      |             ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        switch(c) {\n            case 'a':\n            case\
    \ 'e':\n            case 'i':\n            case 'o':\n            case 'u':\n\
    \                ans += c;\n                break;\n            case 'A':\n  \
    \          case 'E':\n            case 'I':\n            case 'O':\n         \
    \   case 'U':\n                ans += c;\n                break;\n           \
    \ default:\n                ans += 'A';\n        }\n    }\n    for(int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        ans[i] = 'A';\n\
    \        for(int j = 0; j < i; j++) {\n            char d = ans[j];\n        \
    \    ans[j] = c;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpb31vot7u: /tmp/tmpb31vot7u.cpp:48: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char &c : message) {\n        switch (c) {\n         \
    \   case 'A':\n            case 'a':\n                ans += 'A';\n          \
    \      break;\n            case 'B':\n            case 'b':\n                ans\
    \ += 'B';\n                break;\n            case 'C':\n            case 'c':\n\
    \                ans += 'C';\n                break;\n            case 'D':\n\
    \            case 'd':\n                ans += 'D';\n                break;\n\
    \            case 'E':\n            case 'e':\n                ans += 'E';\n \
    \               break;\n            case 'F':\n            case 'f':\n       \
    \         ans += 'F';\n                break;\n            case 'G':\n       \
    \     case 'g':\n                ans += 'G';\n                break;\n       \
    \     case 'H':\n            case 'h':\n                ans += 'H';\n        \
    \        break;\n            case 'I':\n            case 'i':\n              \
    \  ans += 'I';\n                break;\n            case 'J':\n            case\
    \ 'j':\n                ans += 'J';\n                break;\n            case\
    \ 'K':\n            case 'k':\n                ans += 'K';\n                break;\n\
    \            case 'L':\n            case 'l':\n                ans += 'L';\n \
    \               break;\n            case 'M':\n            case 'm':\n       \
    \         ans += 'M';\n                break;\n            case 'N':\n       \
    \     case 'n':\n                ans += 'N';\n                break;\n       \
    \     case 'O':\n            case 'o':\n                ans += 'O';\n        \
    \        break;\n            case 'P':\n            case 'p':\n              \
    \  ans += 'P';\n                break;\n            case 'Q':\n            case\
    \ 'q':\n                ans += 'Q';\n                break;\n            case\
    \ 'R':\n            case 'r':\n                ans += 'R';\n                break;\n\
    \            case 'S':\n            case 's':\n                ans += 'S';\n \
    \               break;\n            case 'T':\n            case 't':\n       \
    \         ans += 'T';\n                break;\n            case 'U':\n       \
    \     case 'u':\n                ans += 'U';\n                break;\n       \
    \     case 'V':\n            case 'v':\n                ans += 'V';\n        \
    \        break;\n            case 'W':\n            case 'w':\n              \
    \  ans += 'W';\n                break;\n            case 'X':\n            case\
    \ 'x':\n                ans += 'X';\n                break;\n            case\
    \ 'Y':\n            case 'y':\n                ans += 'Y';\n                break;\n\
    \            case 'Z':\n            case 'z':\n                ans += 'Z';\n \
    \               break;\n            default:\n                ans += c;\n    \
    \    }\n    }\n    for (char &c : ans) {\n        switch (c) {\n            case\
    \ 'A':\n            case 'a':\n                c = tolower(c);\n             \
    \   break;\n            case 'B':\n            case 'b':\n                c =\
    \ toupper(c);\n\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgag0fm65.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpgag0fm65.cpp:136:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  136 | int main() {\n      |            ^\n/tmp/tmpgag0fm65.cpp:143:1:\
    \ error: expected \u2018}\u2019 at end of input\n  143 | }\n      | ^\n/tmp/tmpgag0fm65.cpp:125:25:\
    \ note: to match this \u2018{\u2019\n  125 |     for (char &c : ans) {\n     \
    \ |                         ^\n/tmp/tmpgag0fm65.cpp:143:1: error: expected \u2018\
    }\u2019 at end of input\n  143 | }\n      | ^\n/tmp/tmpgag0fm65.cpp:13:41: note:\
    \ to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpgag0fm65.cpp:143:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  143 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c + 2 : c));\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] =\
    \ ans[i - 1];\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for (int i = 0; i\
    \ < ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans[i] = ans[i - 1];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] =\
    \ ans[i - 1];\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans[i] = ans[i - 1];\n        }\n    }\n    for (int i = 0; i\
    \ < ans.length(); i++) {\n        char c = ans[i];\n        if (c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans[i] = ans[i - 1];\n        }\n  \
    \  }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c ==\
    \ 'A' || c == 'E' || c == 'I' || c\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfmiotp2j.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpfmiotp2j.cpp:56:110: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   56 |         if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u' || c == 'A' || c == 'E' || c == 'I' || c\n      |            ~      \
    \                                                                            \
    \               ^\n      |                                                   \
    \                                                           )\n   57 | }\n   \
    \   | ~                                                                      \
    \                                       \n/tmp/tmpfmiotp2j.cpp:57:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   57 | }\n      | ^\n/tmp/tmpfmiotp2j.cpp:58:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   58 | int main() {\n      |            ^\n/tmp/tmpfmiotp2j.cpp:65:1: error:\
    \ expected \u2018}\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmpfmiotp2j.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpfmiotp2j.cpp:65:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   65 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded;\n    for(int i = 0; i < message.size(); i++) {\n        char c = message[i];\n\
    \        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n    \
    \        encoded = encoded + c;\n        }\n        else if(c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U') {\n            encoded = encoded + c;\n\
    \        }\n        else {\n            int index = c - 'a';\n            int\
    \ index2 = c - 'A';\n            int index3 = c - 'e';\n            int index4\
    \ = c - 'E';\n            int index5 = c - 'i';\n            int index6 = c -\
    \ 'I';\n            int index7 = c - 'o';\n            int index8 = c - 'O';\n\
    \            int index9 = c - 'u';\n            int index10 = c - 'U';\n     \
    \       int index11 = c - 'A';\n            int index12 = c - 'E';\n         \
    \   int index13 = c - 'I';\n            int index14 = c - 'O';\n            int\
    \ index15 = c - 'U';\n            int index16 = c - 'a';\n            int index17\
    \ = c - 'e';\n            int index18 = c - 'i';\n            int index19 = c\
    \ - 'o';\n            int index20 = c - 'O';\n            int index21 = c - 'u';\n\
    \            int index22 = c - 'U';\n            int index23 = c - 'A';\n    \
    \        int index24 = c - 'E';\n            int index25 = c - 'I';\n        \
    \    int index26 = c - 'O';\n            int index27 = c - 'U';\n            int\
    \ index28 = c - 'a';\n            int index29 = c - 'e';\n            int index30\
    \ = c - 'i';\n            int index31 = c - 'o';\n            int index32 = c\
    \ - 'O';\n            int index33 = c - 'u';\n            int index34 = c - 'U';\n\
    \            int index35 = c - 'a';\n            int index36 = c - 'e';\n    \
    \        int index37 = c - 'i';\n            int index38 = c - 'o';\n        \
    \    int index39 = c - 'O';\n            int index40 = c - 'u';\n            int\
    \ index41 = c - 'U';\n            int index42 = c - 'A';\n            int index43\
    \ = c - 'E';\n            int index44 = c - 'I';\n            int \n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph4qtz48p.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmph4qtz48p.cpp:69:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   69 | }\n      | ^\n/tmp/tmph4qtz48p.cpp:70:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   70 | int main() {\n     \
    \ |            ^\n/tmp/tmph4qtz48p.cpp:77:1: error: expected \u2018}\u2019 at\
    \ end of input\n   77 | }\n      | ^\n/tmp/tmph4qtz48p.cpp:15:45: note: to match\
    \ this \u2018{\u2019\n   15 |     for(int i = 0; i < message.size(); i++) {\n\
    \      |                                             ^\n/tmp/tmph4qtz48p.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmph4qtz48p.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmph4qtz48p.cpp:77:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   77 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        switch(c) {\n            case 'A':\n            case\
    \ 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n\
    \                ans += 'A';\n                break;\n            case 'B':\n\
    \            case 'F':\n            case 'J':\n            case 'K':\n       \
    \     case 'M':\n                ans += 'B';\n                break;\n       \
    \     case 'C':\n            case 'G':\n            case 'K':\n            case\
    \ 'L':\n                ans += 'C';\n                break;\n            case\
    \ 'D':\n            case 'H':\n            case 'J':\n            case 'M':\n\
    \                ans += 'D';\n                break;\n            case 'E':\n\
    \            case 'I':\n            case 'O':\n            case 'U':\n       \
    \         ans += 'E';\n                break;\n            case 'F':\n       \
    \     case 'G':\n            case 'K':\n            case 'L':\n              \
    \  ans += 'F';\n                break;\n            case 'G':\n            case\
    \ 'H':\n            case 'J':\n            case 'M':\n                ans += 'G';\n\
    \                break;\n            case 'H':\n            case 'I':\n      \
    \      case 'O':\n            case 'U':\n                ans += 'H';\n       \
    \         break;\n            case 'I':\n            case 'J':\n            case\
    \ 'K':\n            case 'L':\n                ans += 'I';\n                break;\n\
    \            case 'J':\n            case 'K':\n            case 'L':\n       \
    \         ans += 'J';\n                break;\n            case 'K':\n       \
    \     case 'L':\n                ans += 'K';\n                break;\n       \
    \     case 'L':\n                ans += 'L';\n                break;\n       \
    \     case 'M':\n                ans += 'M';\n                break;\n       \
    \     case 'N':\n                ans += 'N';\n                break;\n       \
    \     case 'O':\n                ans += 'O';\n                break;\n       \
    \     case 'P':\n                ans += 'P';\n                break;\n       \
    \     case 'Q':\n                ans += 'Q';\n                break;\n       \
    \     case 'R':\n                ans += 'R';\n                break;\n       \
    \     case 'S':\n                ans += 'S';\n                break;\n       \
    \     case 'T':\n                ans += 'T';\n                break;\n       \
    \     case 'U':\n                ans += 'U';\n                break;\n       \
    \     case 'V':\n                ans += 'V';\n                break;\n       \
    \     case 'W':\n                ans += 'W';\n                break;\n       \
    \     case 'X':\n                ans += 'X';\n                break;\n       \
    \     case 'Y':\n                ans += 'Y';\n                break;\n       \
    \     case 'Z':\n                ans += 'Z';\n                break;\n       \
    \     default:\n                ans += c;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp610ii4m.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpp610ii4m.cpp:34:13: error: duplicate case value\n   34 |          \
    \   case 'K':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:28:13: note: previously\
    \ used here\n   28 |             case 'K':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:40:13:\
    \ error: duplicate case value\n   40 |             case 'J':\n      |        \
    \     ^~~~\n/tmp/tmpp610ii4m.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'J':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:41:13: error:\
    \ duplicate case value\n   41 |             case 'M':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:29:13: note: previously used here\n   29 |             case\
    \ 'M':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:44:13: error: duplicate\
    \ case value\n   44 |             case 'E':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:19:13:\
    \ note: previously used here\n   19 |             case 'E':\n      |         \
    \    ^~~~\n/tmp/tmpp610ii4m.cpp:45:13: error: duplicate case value\n   45 |  \
    \           case 'I':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:20:13: note:\
    \ previously used here\n   20 |             case 'I':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:46:13: error: duplicate case value\n   46 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:21:13: note: previously\
    \ used here\n   21 |             case 'O':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:47:13:\
    \ error: duplicate case value\n   47 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmpp610ii4m.cpp:22:13: note: previously used here\n   22 |  \
    \           case 'U':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:50:13: error:\
    \ duplicate case value\n   50 |             case 'F':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:26:13: note: previously used here\n   26 |             case\
    \ 'F':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:51:13: error: duplicate\
    \ case value\n   51 |             case 'G':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:33:13:\
    \ note: previously used here\n   33 |             case 'G':\n      |         \
    \    ^~~~\n/tmp/tmpp610ii4m.cpp:52:13: error: duplicate case value\n   52 |  \
    \           case 'K':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:28:13: note:\
    \ previously used here\n   28 |             case 'K':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:53:13: error: duplicate case value\n   53 |             case\
    \ 'L':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:35:13: note: previously\
    \ used here\n   35 |             case 'L':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:56:13:\
    \ error: duplicate case value\n   56 |             case 'G':\n      |        \
    \     ^~~~\n/tmp/tmpp610ii4m.cpp:33:13: note: previously used here\n   33 |  \
    \           case 'G':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:57:13: error:\
    \ duplicate case value\n   57 |             case 'H':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:39:13: note: previously used here\n   39 |             case\
    \ 'H':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:58:13: error: duplicate\
    \ case value\n   58 |             case 'J':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:27:13:\
    \ note: previously used here\n   27 |             case 'J':\n      |         \
    \    ^~~~\n/tmp/tmpp610ii4m.cpp:59:13: error: duplicate case value\n   59 |  \
    \           case 'M':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:29:13: note:\
    \ previously used here\n   29 |             case 'M':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:62:13: error: duplicate case value\n   62 |             case\
    \ 'H':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:39:13: note: previously\
    \ used here\n   39 |             case 'H':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:63:13:\
    \ error: duplicate case value\n   63 |             case 'I':\n      |        \
    \     ^~~~\n/tmp/tmpp610ii4m.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'I':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:64:13: error:\
    \ duplicate case value\n   64 |             case 'O':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:21:13: note: previously used here\n   21 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:65:13: error: duplicate\
    \ case value\n   65 |             case 'U':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:22:13:\
    \ note: previously used here\n   22 |             case 'U':\n      |         \
    \    ^~~~\n/tmp/tmpp610ii4m.cpp:68:13: error: duplicate case value\n   68 |  \
    \           case 'I':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:20:13: note:\
    \ previously used here\n   20 |             case 'I':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:69:13: error: duplicate case value\n   69 |             case\
    \ 'J':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:27:13: note: previously\
    \ used here\n   27 |             case 'J':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:70:13:\
    \ error: duplicate case value\n   70 |             case 'K':\n      |        \
    \     ^~~~\n/tmp/tmpp610ii4m.cpp:28:13: note: previously used here\n   28 |  \
    \           case 'K':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:71:13: error:\
    \ duplicate case value\n   71 |             case 'L':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:35:13: note: previously used here\n   35 |             case\
    \ 'L':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:74:13: error: duplicate\
    \ case value\n   74 |             case 'J':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:27:13:\
    \ note: previously used here\n   27 |             case 'J':\n      |         \
    \    ^~~~\n/tmp/tmpp610ii4m.cpp:75:13: error: duplicate case value\n   75 |  \
    \           case 'K':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:28:13: note:\
    \ previously used here\n   28 |             case 'K':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:76:13: error: duplicate case value\n   76 |             case\
    \ 'L':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:35:13: note: previously\
    \ used here\n   35 |             case 'L':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:79:13:\
    \ error: duplicate case value\n   79 |             case 'K':\n      |        \
    \     ^~~~\n/tmp/tmpp610ii4m.cpp:28:13: note: previously used here\n   28 |  \
    \           case 'K':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:80:13: error:\
    \ duplicate case value\n   80 |             case 'L':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:35:13: note: previously used here\n   35 |             case\
    \ 'L':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:83:13: error: duplicate\
    \ case value\n   83 |             case 'L':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:35:13:\
    \ note: previously used here\n   35 |             case 'L':\n      |         \
    \    ^~~~\n/tmp/tmpp610ii4m.cpp:86:13: error: duplicate case value\n   86 |  \
    \           case 'M':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:29:13: note:\
    \ previously used here\n   29 |             case 'M':\n      |             ^~~~\n\
    /tmp/tmpp610ii4m.cpp:92:13: error: duplicate case value\n   92 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:21:13: note: previously\
    \ used here\n   21 |             case 'O':\n      |             ^~~~\n/tmp/tmpp610ii4m.cpp:110:13:\
    \ error: duplicate case value\n  110 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmpp610ii4m.cpp:22:13: note: previously used here\n   22 |  \
    \           case 'U':\n      |             ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += c;\n        ans += (tolower(c) - 'a' + 1) % 26\
    \ + 'a';\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmps84quuaf: /tmp/tmps84quuaf.cpp:24: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isalpha(c)) ? toupper(c)\
    \ : c;\n    }\n    for (auto &c : ans) {\n        if (isalpha(c)) {\n        \
    \    ans[ans.find(c)] = toupper(ans[ans.find(c)]);\n        }\n    }\n    for\
    \ (auto &c : ans) {\n        if (isalpha(c)) {\n            ans[ans.find(c)] =\
    \ tolower(ans[ans.find(c)]);\n        }\n    }\n    for (auto &c : ans) {\n  \
    \      if (isalpha(c)) {\n            ans[ans.find(c)] = ans[ans.find(c)] + 2;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpf67p86hb: /tmp/tmpf67p86hb.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = message;\n    for (auto &c : message) {\n        switch (c) {\n  \
    \          case 'a':\n            case 'e':\n            case 'i':\n         \
    \   case 'o':\n            case 'u':\n            case 'A':\n            case\
    \ 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n\
    \                encoded = encoded.replace(c, 'A');\n                break;\n\
    \            case 'b':\n            case 'c':\n            case 'd':\n       \
    \     case 'f':\n            case 'g':\n            case 'B':\n            case\
    \ 'C':\n            case 'D':\n            case 'F':\n            case 'G':\n\
    \                encoded = encoded.replace(c, 'B');\n                break;\n\
    \            case 'h':\n            case 'j':\n            case 'k':\n       \
    \     case 'l':\n            case 'm':\n            case 'n':\n            case\
    \ 'H':\n            case 'J':\n            case 'K':\n            case 'L':\n\
    \            case 'M':\n            case 'N':\n                encoded = encoded.replace(c,\
    \ 'H');\n                break;\n            case 'o':\n            case 'p':\n\
    \            case 'q':\n            case 'r':\n            case 's':\n       \
    \     case 'T':\n            case 'P':\n            case 'Q':\n            case\
    \ 'R':\n            case 'S':\n                encoded = encoded.replace(c, 'O');\n\
    \                break;\n            case 'w':\n            case 'x':\n      \
    \      case 'y':\n            case 'z':\n            case 'W':\n            case\
    \ 'X':\n            case 'Y':\n            case 'Z':\n                encoded\
    \ = encoded.replace(c, 'W');\n                break;\n            default:\n \
    \               encoded = encoded.replace(c, 'A');\n                break;\n \
    \       }\n    }\n    return encoded;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqgee59mu.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpqgee59mu.cpp:27:49: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::replace(char&, char)\u2019\n   27 |        \
    \         encoded = encoded.replace(c, 'A');\n      |                        \
    \                         ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type = long unsigned int]\u2019\n 1893 |       replace(size_type\
    \ __pos, size_type __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1915 |       replace(size_type __pos1, size_type __n1, const basic_string&\
    \ __str,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note:   candidate expects 5 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1940 |       replace(size_type __pos, size_type __n1, const _CharT*\
    \ __s,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1965 |       replace(size_type __pos, size_type\
    \ __n1, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1989 |       replace(size_type __pos, size_type __n1, size_type\
    \ __n2, _CharT __c)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2007 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2027 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*]\u2019\n 2049 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n 2070 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, size_type __n,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2097:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, _InputIterator, _InputIterator) [with _InputIterator\
    \ = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 2097 |         replace(const_iterator __i1, const_iterator __i2,\n      | \
    \        ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2097:9: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpqgee59mu.cpp:27:49: note: \
    \  candidate expects 4 arguments, 2 provided\n   27 |                 encoded\
    \ = encoded.replace(c, 'A');\n      |                                        \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, _CharT*, _CharT*) [with _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2127 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, const _CharT*) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2138 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2149:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer = char*]\u2019\
    \n 2149 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2149:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2160:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator =\
    \ __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char> >]\u2019\
    \n 2160 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2160:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, std::initializer_list<_Tp>) [with _CharT = char; _Traits\
    \ = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                     ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note:   candidate expects 3 arguments, 2 provided\n/tmp/tmpqgee59mu.cpp:39:49:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::replace(char&,\
    \ char)\u2019\n   39 |                 encoded = encoded.replace(c, 'B');\n  \
    \    |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1893 |       replace(size_type __pos, size_type\
    \ __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1915 |       replace(size_type __pos1, size_type __n1, const basic_string&\
    \ __str,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note:   candidate expects 5 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1940 |       replace(size_type __pos, size_type __n1, const _CharT*\
    \ __s,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1965 |       replace(size_type __pos, size_type\
    \ __n1, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1989 |       replace(size_type __pos, size_type __n1, size_type\
    \ __n2, _CharT __c)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2007 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2027 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*]\u2019\n 2049 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n 2070 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, size_type __n,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2097:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, _InputIterator, _InputIterator) [with _InputIterator\
    \ = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 2097 |         replace(const_iterator __i1, const_iterator __i2,\n      | \
    \        ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2097:9: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpqgee59mu.cpp:39:49: note: \
    \  candidate expects 4 arguments, 2 provided\n   39 |                 encoded\
    \ = encoded.replace(c, 'B');\n      |                                        \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, _CharT*, _CharT*) [with _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2127 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, const _CharT*) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2138 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2149:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer = char*]\u2019\
    \n 2149 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2149:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2160:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator =\
    \ __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char> >]\u2019\
    \n 2160 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2160:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, std::initializer_list<_Tp>) [with _CharT = char; _Traits\
    \ = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                     ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note:   candidate expects 3 arguments, 2 provided\n/tmp/tmpqgee59mu.cpp:53:49:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::replace(char&,\
    \ char)\u2019\n   53 |                 encoded = encoded.replace(c, 'H');\n  \
    \    |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1893 |       replace(size_type __pos, size_type\
    \ __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1915 |       replace(size_type __pos1, size_type __n1, const basic_string&\
    \ __str,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note:   candidate expects 5 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1940 |       replace(size_type __pos, size_type __n1, const _CharT*\
    \ __s,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1965 |       replace(size_type __pos, size_type\
    \ __n1, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1989 |       replace(size_type __pos, size_type __n1, size_type\
    \ __n2, _CharT __c)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2007 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2027 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*]\u2019\n 2049 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n 2070 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, size_type __n,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2097:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, _InputIterator, _InputIterator) [with _InputIterator\
    \ = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 2097 |         replace(const_iterator __i1, const_iterator __i2,\n      | \
    \        ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2097:9: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpqgee59mu.cpp:53:49: note: \
    \  candidate expects 4 arguments, 2 provided\n   53 |                 encoded\
    \ = encoded.replace(c, 'H');\n      |                                        \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, _CharT*, _CharT*) [with _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2127 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, const _CharT*) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2138 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2149:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer = char*]\u2019\
    \n 2149 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2149:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2160:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator =\
    \ __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char> >]\u2019\
    \n 2160 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2160:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, std::initializer_list<_Tp>) [with _CharT = char; _Traits\
    \ = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                     ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note:   candidate expects 3 arguments, 2 provided\n/tmp/tmpqgee59mu.cpp:55:13:\
    \ error: duplicate case value\n   55 |             case 'o':\n      |        \
    \     ^~~~\n/tmp/tmpqgee59mu.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'o':\n      |             ^~~~\n/tmp/tmpqgee59mu.cpp:65:49: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::replace(char&,\
    \ char)\u2019\n   65 |                 encoded = encoded.replace(c, 'O');\n  \
    \    |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1893 |       replace(size_type __pos, size_type\
    \ __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1915 |       replace(size_type __pos1, size_type __n1, const basic_string&\
    \ __str,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note:   candidate expects 5 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1940 |       replace(size_type __pos, size_type __n1, const _CharT*\
    \ __s,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1965 |       replace(size_type __pos, size_type\
    \ __n1, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1989 |       replace(size_type __pos, size_type __n1, size_type\
    \ __n2, _CharT __c)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2007 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2027 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*]\u2019\n 2049 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n 2070 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, size_type __n,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2097:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, _InputIterator, _InputIterator) [with _InputIterator\
    \ = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 2097 |         replace(const_iterator __i1, const_iterator __i2,\n      | \
    \        ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2097:9: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpqgee59mu.cpp:65:49: note: \
    \  candidate expects 4 arguments, 2 provided\n   65 |                 encoded\
    \ = encoded.replace(c, 'O');\n      |                                        \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, _CharT*, _CharT*) [with _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2127 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, const _CharT*) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2138 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2149:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer = char*]\u2019\
    \n 2149 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2149:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2160:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator =\
    \ __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char> >]\u2019\
    \n 2160 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2160:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, std::initializer_list<_Tp>) [with _CharT = char; _Traits\
    \ = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                     ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note:   candidate expects 3 arguments, 2 provided\n/tmp/tmpqgee59mu.cpp:75:49:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::replace(char&,\
    \ char)\u2019\n   75 |                 encoded = encoded.replace(c, 'W');\n  \
    \    |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1893 |       replace(size_type __pos, size_type\
    \ __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1915 |       replace(size_type __pos1, size_type __n1, const basic_string&\
    \ __str,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note:   candidate expects 5 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1940 |       replace(size_type __pos, size_type __n1, const _CharT*\
    \ __s,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1965 |       replace(size_type __pos, size_type\
    \ __n1, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1989 |       replace(size_type __pos, size_type __n1, size_type\
    \ __n2, _CharT __c)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2007 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2027 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*]\u2019\n 2049 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n 2070 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, size_type __n,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2097:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, _InputIterator, _InputIterator) [with _InputIterator\
    \ = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 2097 |         replace(const_iterator __i1, const_iterator __i2,\n      | \
    \        ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2097:9: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpqgee59mu.cpp:75:49: note: \
    \  candidate expects 4 arguments, 2 provided\n   75 |                 encoded\
    \ = encoded.replace(c, 'W');\n      |                                        \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, _CharT*, _CharT*) [with _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2127 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, const _CharT*) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2138 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2149:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer = char*]\u2019\
    \n 2149 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2149:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2160:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator =\
    \ __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char> >]\u2019\
    \n 2160 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2160:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, std::initializer_list<_Tp>) [with _CharT = char; _Traits\
    \ = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                     ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note:   candidate expects 3 arguments, 2 provided\n/tmp/tmpqgee59mu.cpp:78:49:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::replace(char&,\
    \ char)\u2019\n   78 |                 encoded = encoded.replace(c, 'A');\n  \
    \    |                                                 ^\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1893:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1893 |       replace(size_type __pos, size_type\
    \ __n, const basic_string& __str)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1893:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1915 |       replace(size_type __pos1, size_type __n1, const basic_string&\
    \ __str,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1915:7:\
    \ note:   candidate expects 5 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1940 |       replace(size_type __pos, size_type __n1, const _CharT*\
    \ __s,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1940:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1965 |       replace(size_type __pos, size_type\
    \ __n1, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1965:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1989 |       replace(size_type __pos, size_type __n1, size_type\
    \ __n2, _CharT __c)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1989:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2007 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2007:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 2027 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2027:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer\
    \ = const char*]\u2019\n 2049 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, const _CharT* __s)\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2049:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long\
    \ unsigned int]\u2019\n 2070 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2, size_type __n,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2070:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2097:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, _InputIterator, _InputIterator) [with _InputIterator\
    \ = _InputIterator; <template-parameter-2-2> = <template-parameter-1-2>; _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \n 2097 |         replace(const_iterator __i1, const_iterator __i2,\n      | \
    \        ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2097:9: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpqgee59mu.cpp:78:49: note: \
    \  candidate expects 4 arguments, 2 provided\n   78 |                 encoded\
    \ = encoded.replace(c, 'A');\n      |                                        \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqgee59mu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, _CharT*, _CharT*) [with _CharT = char; _Traits =\
    \ std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2127 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2127:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, const _CharT*, const _CharT*) [with _CharT = char;\
    \ _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2138 |       replace(__const_iterator __i1, __const_iterator\
    \ __i2,\n      |       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2138:7:\
    \ note:   candidate expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2149:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer = char*]\u2019\
    \n 2149 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2149:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2160:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::__const_iterator, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator) [with _CharT\
    \ = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::__const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator =\
    \ __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char> >]\u2019\
    \n 2160 |       replace(__const_iterator __i1, __const_iterator __i2,\n      |\
    \       ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2160:7: note:   candidate\
    \ expects 4 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::const_iterator, std::initializer_list<_Tp>) [with _CharT = char; _Traits\
    \ = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> >; typename __gnu_cxx::__alloc_traits<typename\
    \ __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::const_pointer = const\
    \ char*]\u2019\n 2185 |       basic_string& replace(const_iterator __i1, const_iterator\
    \ __i2,\n      |                     ^~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2185:21:\
    \ note:   candidate expects 3 arguments, 2 provided\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &i : message) {\n        switch (i) {\n         \
    \   case 'A':\n            case 'E':\n            case 'I':\n            case\
    \ 'O':\n            case 'U':\n                ans += 'A';\n                break;\n\
    \            case 'a':\n            case 'e':\n            case 'i':\n       \
    \     case 'o':\n            case 'u':\n                ans += 'E';\n        \
    \        break;\n            case 'B':\n            case 'F':\n            case\
    \ 'I':\n            case 'O':\n            case 'U':\n                ans += 'B';\n\
    \                break;\n            case 'b':\n            case 'f':\n      \
    \      case 'i':\n            case 'o':\n            case 'u':\n             \
    \   ans += 'F';\n                break;\n            case 'C':\n            case\
    \ 'G':\n            case 'K':\n            case 'M':\n            case 'O':\n\
    \            case 'U':\n                ans += 'C';\n                break;\n\
    \            case 'c':\n            case 'g':\n            case 'k':\n       \
    \     case 'm':\n            case 'o':\n            case 'u':\n              \
    \  ans += 'G';\n                break;\n            case 'D':\n            case\
    \ 'H':\n            case 'J':\n            case 'P':\n            case 'S':\n\
    \            case 'T':\n                ans += 'D';\n                break;\n\
    \            case 'd':\n            case 'h':\n            case 'j':\n       \
    \     case 'p':\n            case 's':\n            case 't':\n              \
    \  ans += 'H';\n                break;\n            case 'E':\n            case\
    \ 'J':\n            case 'K':\n            case 'M':\n            case 'O':\n\
    \            case 'U':\n                ans += 'E';\n                break;\n\
    \            case 'e':\n            case 'j':\n            case 'k':\n       \
    \     case 'm':\n            case 'o':\n            case 'u':\n              \
    \  ans += 'J';\n                break;\n            case 'F':\n            case\
    \ 'I':\n            case 'O':\n            case 'U':\n                ans += 'F';\n\
    \                break;\n            case 'f':\n            case 'i':\n      \
    \      case 'o':\n            case 'u':\n                ans += 'I';\n       \
    \         break;\n            case 'G':\n            case 'K':\n            case\
    \ 'M':\n            case 'O':\n            case 'U':\n                ans += 'G';\n\
    \                break;\n            case 'g':\n            case 'k':\n      \
    \      case 'm':\n            case 'o':\n            case 'u':\n             \
    \   ans += 'K';\n                break;\n            case 'H':\n            case\
    \ 'J':\n            case 'P':\n            case 'S':\n            case 'T':\n\
    \                ans += 'H';\n                break;\n            case 'h':\n\
    \            case 'j':\n            case 'p':\n            case 's':\n       \
    \     case 't':\n                ans += 'P';\n                break;\n       \
    \     case 'I':\n            case 'O':\n            case 'U':\n              \
    \  ans += 'I\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpahcxtk9k.cpp:136:24: warning: missing terminating ' character\n\
    \  136 |                 ans += 'I\n      |                        ^\n/tmp/tmpahcxtk9k.cpp:136:24:\
    \ error: missing terminating ' character\n  136 |                 ans += 'I\n\
    \      |                        ^~\n/tmp/tmpahcxtk9k.cpp: In function \u2018std::string\
    \ encode(std::string)\u2019:\n/tmp/tmpahcxtk9k.cpp:33:13: error: duplicate case\
    \ value\n   33 |             case 'I':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:19:13:\
    \ note: previously used here\n   19 |             case 'I':\n      |         \
    \    ^~~~\n/tmp/tmpahcxtk9k.cpp:34:13: error: duplicate case value\n   34 |  \
    \           case 'O':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:20:13: note:\
    \ previously used here\n   20 |             case 'O':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:35:13: error: duplicate case value\n   35 |             case\
    \ 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:21:13: note: previously\
    \ used here\n   21 |             case 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:40:13:\
    \ error: duplicate case value\n   40 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:41:13: error:\
    \ duplicate case value\n   41 |             case 'o':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:27:13: note: previously used here\n   27 |             case\
    \ 'o':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:42:13: error: duplicate\
    \ case value\n   42 |             case 'u':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:28:13:\
    \ note: previously used here\n   28 |             case 'u':\n      |         \
    \    ^~~~\n/tmp/tmpahcxtk9k.cpp:49:13: error: duplicate case value\n   49 |  \
    \           case 'O':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:20:13: note:\
    \ previously used here\n   20 |             case 'O':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:50:13: error: duplicate case value\n   50 |             case\
    \ 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:21:13: note: previously\
    \ used here\n   21 |             case 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:57:13:\
    \ error: duplicate case value\n   57 |             case 'o':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'o':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:58:13: error:\
    \ duplicate case value\n   58 |             case 'u':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:28:13: note: previously used here\n   28 |             case\
    \ 'u':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:77:13: error: duplicate\
    \ case value\n   77 |             case 'E':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:18:13:\
    \ note: previously used here\n   18 |             case 'E':\n      |         \
    \    ^~~~\n/tmp/tmpahcxtk9k.cpp:78:13: error: duplicate case value\n   78 |  \
    \           case 'J':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:63:13: note:\
    \ previously used here\n   63 |             case 'J':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:79:13: error: duplicate case value\n   79 |             case\
    \ 'K':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:47:13: note: previously\
    \ used here\n   47 |             case 'K':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:80:13:\
    \ error: duplicate case value\n   80 |             case 'M':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:48:13: note: previously used here\n   48 |  \
    \           case 'M':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:81:13: error:\
    \ duplicate case value\n   81 |             case 'O':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:20:13: note: previously used here\n   20 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:82:13: error: duplicate\
    \ case value\n   82 |             case 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:21:13:\
    \ note: previously used here\n   21 |             case 'U':\n      |         \
    \    ^~~~\n/tmp/tmpahcxtk9k.cpp:85:13: error: duplicate case value\n   85 |  \
    \           case 'e':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:25:13: note:\
    \ previously used here\n   25 |             case 'e':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:86:13: error: duplicate case value\n   86 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:71:13: note: previously\
    \ used here\n   71 |             case 'j':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:87:13:\
    \ error: duplicate case value\n   87 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:55:13: note: previously used here\n   55 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:88:13: error:\
    \ duplicate case value\n   88 |             case 'm':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:56:13: note: previously used here\n   56 |             case\
    \ 'm':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:89:13: error: duplicate\
    \ case value\n   89 |             case 'o':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:27:13:\
    \ note: previously used here\n   27 |             case 'o':\n      |         \
    \    ^~~~\n/tmp/tmpahcxtk9k.cpp:90:13: error: duplicate case value\n   90 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:28:13: note:\
    \ previously used here\n   28 |             case 'u':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:93:13: error: duplicate case value\n   93 |             case\
    \ 'F':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:32:13: note: previously\
    \ used here\n   32 |             case 'F':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:94:13:\
    \ error: duplicate case value\n   94 |             case 'I':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'I':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:95:13: error:\
    \ duplicate case value\n   95 |             case 'O':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:20:13: note: previously used here\n   20 |             case\
    \ 'O':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:96:13: error: duplicate\
    \ case value\n   96 |             case 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:21:13:\
    \ note: previously used here\n   21 |             case 'U':\n      |         \
    \    ^~~~\n/tmp/tmpahcxtk9k.cpp:99:13: error: duplicate case value\n   99 |  \
    \           case 'f':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:39:13: note:\
    \ previously used here\n   39 |             case 'f':\n      |             ^~~~\n\
    /tmp/tmpahcxtk9k.cpp:100:13: error: duplicate case value\n  100 |            \
    \ case 'i':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:26:13: note: previously\
    \ used here\n   26 |             case 'i':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:101:13:\
    \ error: duplicate case value\n  101 |             case 'o':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'o':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:102:13:\
    \ error: duplicate case value\n  102 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:28:13: note: previously used here\n   28 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:105:13:\
    \ error: duplicate case value\n  105 |             case 'G':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:46:13: note: previously used here\n   46 |  \
    \           case 'G':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:106:13:\
    \ error: duplicate case value\n  106 |             case 'K':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:47:13: note: previously used here\n   47 |  \
    \           case 'K':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:107:13:\
    \ error: duplicate case value\n  107 |             case 'M':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:48:13: note: previously used here\n   48 |  \
    \           case 'M':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:108:13:\
    \ error: duplicate case value\n  108 |             case 'O':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'O':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:109:13:\
    \ error: duplicate case value\n  109 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:112:13:\
    \ error: duplicate case value\n  112 |             case 'g':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:54:13: note: previously used here\n   54 |  \
    \           case 'g':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:113:13:\
    \ error: duplicate case value\n  113 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:55:13: note: previously used here\n   55 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:114:13:\
    \ error: duplicate case value\n  114 |             case 'm':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:56:13: note: previously used here\n   56 |  \
    \           case 'm':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:115:13:\
    \ error: duplicate case value\n  115 |             case 'o':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'o':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:116:13:\
    \ error: duplicate case value\n  116 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:28:13: note: previously used here\n   28 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:119:13:\
    \ error: duplicate case value\n  119 |             case 'H':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:62:13: note: previously used here\n   62 |  \
    \           case 'H':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:120:13:\
    \ error: duplicate case value\n  120 |             case 'J':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:63:13: note: previously used here\n   63 |  \
    \           case 'J':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:121:13:\
    \ error: duplicate case value\n  121 |             case 'P':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:64:13: note: previously used here\n   64 |  \
    \           case 'P':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:122:13:\
    \ error: duplicate case value\n  122 |             case 'S':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:65:13: note: previously used here\n   65 |  \
    \           case 'S':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:123:13:\
    \ error: duplicate case value\n  123 |             case 'T':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:66:13: note: previously used here\n   66 |  \
    \           case 'T':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:126:13:\
    \ error: duplicate case value\n  126 |             case 'h':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:70:13: note: previously used here\n   70 |  \
    \           case 'h':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:127:13:\
    \ error: duplicate case value\n  127 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:71:13: note: previously used here\n   71 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:128:13:\
    \ error: duplicate case value\n  128 |             case 'p':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:72:13: note: previously used here\n   72 |  \
    \           case 'p':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:129:13:\
    \ error: duplicate case value\n  129 |             case 's':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:73:13: note: previously used here\n   73 |  \
    \           case 's':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:130:13:\
    \ error: duplicate case value\n  130 |             case 't':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:74:13: note: previously used here\n   74 |  \
    \           case 't':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:133:13:\
    \ error: duplicate case value\n  133 |             case 'I':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'I':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:134:13:\
    \ error: duplicate case value\n  134 |             case 'O':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'O':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:135:13:\
    \ error: duplicate case value\n  135 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmpahcxtk9k.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'U':\n      |             ^~~~\n/tmp/tmpahcxtk9k.cpp:137:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n  137 | }\n      | ^\n\
    /tmp/tmpahcxtk9k.cpp:138:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  138 | int main() {\n      |            ^\n/tmp/tmpahcxtk9k.cpp:145:1:\
    \ error: expected \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmpahcxtk9k.cpp:15:29:\
    \ note: to match this \u2018{\u2019\n   15 |     for (auto &i : message) {\n \
    \     |                             ^\n/tmp/tmpahcxtk9k.cpp:145:1: error: expected\
    \ \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmpahcxtk9k.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpahcxtk9k.cpp:145:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  145 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            encoded +=\
    \ c;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c ==\
    \ 'U') {\n            char next = message[++i];\n            if ('a' <= next &&\
    \ next <= 'z') {\n                encoded += next;\n            } else {\n   \
    \             encoded += c;\n            }\n        } else {\n            char\
    \ next = message[++i];\n            if ('a' <= next && next <= 'z') {\n      \
    \          encoded += next;\n            } else {\n                encoded +=\
    \ c;\n            }\n        }\n    }\n    return encoded;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpm0jcuwfb: /tmp/tmpm0jcuwfb.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for (int i = 0; i < ans.size(); i++) {\n        char c =\
    \ ans[i];\n        if ('a' <= c && c <= 'z') {\n            ans[i] = 'A';\n  \
    \      }\n        if ('A' <= c && c <= 'Z') {\n            ans[i] = 'a';\n   \
    \     }\n        if ('0' <= c && c <= '9') {\n            ans[i] = '0';\n    \
    \    }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        char c = ans[i];\n\
    \        if ('a' <= c && c <= 'z') {\n            ans[i] = 'A';\n        }\n \
    \       if ('A' <= c && c <= 'Z') {\n            ans[i] = 'a';\n        }\n  \
    \      if ('0' <= c && c <= '9') {\n            ans[i] = '0';\n        }\n   \
    \ }\n    for (int i = 0; i < ans.size(); i++) {\n        char c = ans[i];\n  \
    \      if ('a' <= c && c <= 'z') {\n            ans[i] = 'A';\n        }\n   \
    \     if ('A' <= c && c <= 'Z') {\n            ans[i] = 'a';\n        }\n    \
    \    if ('0' <= c && c <= '9') {\n            ans[i] = '0';\n        }\n    }\n\
    \    for (int i = 0; i < ans.size(); i++) {\n        char c = ans[i];\n      \
    \  if ('a' <= c && c <= 'z') {\n            ans[i] = 'A';\n        }\n       \
    \ if ('A' <= c && c <= 'Z') {\n            ans[i] = 'a';\n        }\n        if\
    \ ('0' <= c && c <= '9') {\n            ans[i] = '0';\n        }\n    }\n    for\
    \ (int i = 0; i < ans.size(); i++) {\n        char c = ans[i];\n        if ('a'\
    \ <= c && c <= 'z') {\n            ans[i] = 'A';\n        }\n        if ('A' <=\
    \ c && c <= 'Z') {\n            ans[i] = 'a';\n        }\n        if ('0' <= c\
    \ && c <= '9') {\n            ans[i] = '0';\n        }\n    }\n    for (int i\
    \ = 0; i < ans.size(); i++) {\n        char c = ans[i];\n        if ('a' <= c\
    \ && c <= 'z') {\n            ans[i] = 'A';\n        }\n        if ('A' <= c &&\
    \ c <= 'Z') {\n            ans[i] = 'a';\n        }\n        if ('0' <= c && c\
    \ <= '9') {\n            ans[i] = '0';\n        }\n    }\n    for (int i = 0;\
    \ i < ans.size(); i++) {\n        char c = ans[i];\n        if ('a' <= c && c\
    \ <= 'z') {\n            ans[i] = 'A';\n        }\n        if ('A' <= c && c <=\
    \ 'Z\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeygr8q4i.cpp:92:30: warning: missing terminating ' character\n\
    \   92 |         if ('A' <= c && c <= 'Z\n      |                            \
    \  ^\n/tmp/tmpeygr8q4i.cpp:92:30: error: missing terminating ' character\n   92\
    \ |         if ('A' <= c && c <= 'Z\n      |                              ^~\n\
    /tmp/tmpeygr8q4i.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpeygr8q4i.cpp:93:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   93 | }\n      | ^\n/tmp/tmpeygr8q4i.cpp:92:29: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   92 |         if ('A' <= c && c\
    \ <= 'Z\n      |            ~                ^\n      |                      \
    \       )\n   93 | }\n      | ~                            \n/tmp/tmpeygr8q4i.cpp:93:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   93 | }\n \
    \     | ^\n/tmp/tmpeygr8q4i.cpp:94:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   94 | int main() {\n      |            ^\n\
    /tmp/tmpeygr8q4i.cpp:101:1: error: expected \u2018}\u2019 at end of input\n  101\
    \ | }\n      | ^\n/tmp/tmpeygr8q4i.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpeygr8q4i.cpp:101:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n  101 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += c;\n    }\n    for(int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        ans[i] = tolower(c);\n    }\n    for(int\
    \ i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'A';\n\
    \        }\n        if(c == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g'\
    \ || c == 'h' || c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c\
    \ == 'p' || c == 'q' || c == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w'\
    \ || c == 'x' || c == 'y' || c == 'z') {\n            ans[i] = 'B';\n        }\n\
    \    }\n    for(int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        ans[i] = toupper(c);\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1wk24h5d: /tmp/tmp1wk24h5d.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = message;\n    for (auto &c : message) {\n        switch (c) {\n  \
    \          case 'A':\n            case 'E':\n            case 'I':\n         \
    \   case 'O':\n            case 'U':\n                c += ' ';\n            \
    \    break;\n            case 'a':\n            case 'e':\n            case 'i':\n\
    \            case 'o':\n            case 'u':\n                c += ' ';\n   \
    \             break;\n            default:\n                c = tolower(c);\n\
    \                break;\n        }\n    }\n    for (auto &c : encoded) {\n   \
    \     switch (c) {\n            case 'a':\n            case 'e':\n           \
    \ case 'i':\n            case 'o':\n            case 'u':\n                c +=\
    \ ' ';\n                break;\n            case 'A':\n            case 'E':\n\
    \            case 'I':\n            case 'O':\n            case 'U':\n       \
    \         c += ' ';\n                break;\n            default:\n          \
    \      c = toupper(c);\n                break;\n        }\n    }\n    for (auto\
    \ &c : encoded) {\n        switch (c) {\n            case 'A':\n            case\
    \ 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n\
    \                c += ' ';\n                break;\n            default:\n   \
    \             c = tolower(c);\n                break;\n        }\n    }\n    return\
    \ encoded;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpnslwkp4c: /tmp/tmpnslwkp4c.cpp:75: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += (toupper(c) - 'A' + 2) % 26 + 'A';\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpdgh5a943: /tmp/tmpdgh5a943.cpp:23: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            ans += c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans += 'A';\n        } else if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            ans += 'E';\n        } else if (c\
    \ == 'A' || c == 'a') {\n            ans += 'a';\n        } else if (c == 'E'\
    \ || c == 'e') {\n            ans += 'e';\n        } else if (c == 'I' || c ==\
    \ 'i') {\n            ans += 'i';\n        } else if (c == 'O' || c == 'o') {\n\
    \            ans += 'o';\n        } else if (c == 'U' || c == 'u') {\n       \
    \     ans += 'u';\n        } else {\n            ans += c;\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if ('a' <= c && c <= 'z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans[i] = 'E';\n        } else if (c == 'A' || c == 'a')\
    \ {\n            ans[i] = 'a';\n        } else if (c == 'E' || c == 'e') {\n \
    \           ans[i] = 'e';\n        } else if (c == 'I' || c == 'i') {\n      \
    \      ans[i] = 'i';\n        } else if (c == 'O' || c == 'o') {\n           \
    \ ans[i] = 'o';\n        } else if (c == 'U' || c == 'u') {\n            ans[i]\
    \ = 'u';\n        } else {\n            ans[i] = c;\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if ('a'\
    \ <= c && c <= 'z') {\n            ans[i] = c;\n        } else if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'A';\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[i] = 'E';\n        } else if (c == 'A' || c == 'a') {\n \
    \           ans[i] = 'a';\n        } else if (c == 'E' || c == 'e') {\n      \
    \      ans[i] = 'e';\n        } else if (c == 'I' || c == 'i') {\n           \
    \ ans[i] = 'i';\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkndpil_a.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpkndpil_a.cpp:74:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   74 | int main() {\n      |            ^\n/tmp/tmpkndpil_a.cpp:81:1:\
    \ error: expected \u2018}\u2019 at end of input\n   81 | }\n      | ^\n/tmp/tmpkndpil_a.cpp:59:44:\
    \ note: to match this \u2018{\u2019\n   59 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmpkndpil_a.cpp:81:1:\
    \ error: expected \u2018}\u2019 at end of input\n   81 | }\n      | ^\n/tmp/tmpkndpil_a.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpkndpil_a.cpp:81:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   81 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        if (std::toupper(c) != c)\
    \ {\n            ans += std::toupper(c);\n        } else {\n            ans +=\
    \ c;\n        }\n    }\n    for (auto &c : ans) {\n        switch (c) {\n    \
    \    case 'A':\n            ans += 'B';\n            break;\n        case 'B':\n\
    \            ans += 'C';\n            break;\n        case 'C':\n            ans\
    \ += 'D';\n            break;\n        case 'D':\n            ans += 'E';\n  \
    \          break;\n        case 'E':\n            ans += 'F';\n            break;\n\
    \        case 'F':\n            ans += 'G';\n            break;\n        case\
    \ 'G':\n            ans += 'H';\n            break;\n        case 'H':\n     \
    \       ans += 'I';\n            break;\n        case 'I':\n            ans +=\
    \ 'J';\n            break;\n        case 'J':\n            ans += 'K';\n     \
    \       break;\n        case 'K':\n            ans += 'L';\n            break;\n\
    \        case 'L':\n            ans += 'M';\n            break;\n        case\
    \ 'M':\n            ans += 'N';\n            break;\n        case 'N':\n     \
    \       ans += 'O';\n            break;\n        case 'O':\n            ans +=\
    \ 'P';\n            break;\n        case 'P':\n            ans += 'Q';\n     \
    \       break;\n        case 'Q':\n            ans += 'R';\n            break;\n\
    \        case 'R':\n            ans += 'S';\n            break;\n        case\
    \ 'S':\n            ans += 'T';\n            break;\n        case 'T':\n     \
    \       ans += 'U';\n            break;\n        case 'U':\n            ans +=\
    \ 'V';\n            break;\n        case 'V':\n            ans += 'W';\n     \
    \       break;\n        case 'W':\n            ans += 'X';\n            break;\n\
    \        case 'X':\n            ans += 'Y';\n            break;\n        case\
    \ 'Y':\n            ans += 'Z';\n            break;\n        case 'Z':\n     \
    \       ans += 'a';\n            break;\n        case 'a':\n            ans +=\
    \ 'b';\n            break;\n        case 'b':\n            ans += 'c';\n     \
    \       break;\n        case 'c':\n            ans += 'd';\n            break;\n\
    \        case 'd':\n            ans += 'e';\n            break;\n        case\
    \ 'e':\n            ans += 'f';\n            break;\n        case 'f':\n     \
    \       ans += 'g';\n            break;\n        case 'g':\n            ans +=\
    \ 'h';\n            break;\n        case 'h':\n            ans += 'i';\n     \
    \       break;\n        case 'i':\n            ans += 'j';\n            break;\n\
    \        case 'j':\n            \n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp67m_isj_.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp67m_isj_.cpp:131:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  131 | }\n      | ^\n/tmp/tmp67m_isj_.cpp:132:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  132 | int main() {\n     \
    \ |            ^\n/tmp/tmp67m_isj_.cpp:139:1: error: expected \u2018}\u2019 at\
    \ end of input\n  139 | }\n      | ^\n/tmp/tmp67m_isj_.cpp:22:25: note: to match\
    \ this \u2018{\u2019\n   22 |     for (auto &c : ans) {\n      |             \
    \            ^\n/tmp/tmp67m_isj_.cpp:139:1: error: expected \u2018}\u2019 at end\
    \ of input\n  139 | }\n      | ^\n/tmp/tmp67m_isj_.cpp:13:41: note: to match this\
    \ \u2018{\u2019\n   13 | std::string encode(std::string message) {\n      |  \
    \                                       ^\n/tmp/tmp67m_isj_.cpp:139:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n  139 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            ans += c;\n        } else {\n            ans += 'A'\
    \ + (c - 'a');\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if (c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if (c == 'a') {\n            ans[i] = 'A';\n        } else if\
    \ (c == 'a') {\n            ans[i] = 'a';\n        } else if (c == 'A') {\n  \
    \          ans[i] = 'A';\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpz7k4oiii: /tmp/tmpz7k4oiii.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c: message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c: ans) {\n        if (c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c) + 1]\
    \ = toupper(ans[ans.find(c) + 1]);\n        }\n    }\n    for (auto &c: ans) {\n\
    \        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n   \
    \         ans[ans.find(c) + 1] = tolower(ans[ans.find(c) + 1]);\n        }\n \
    \   }\n    for (auto &c: ans) {\n        if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans[ans.find(c) + 1] = toupper(ans[ans.find(c)\
    \ + 1]);\n        }\n    }\n    for (auto &c: ans) {\n        if (c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 1] = tolower(ans[ans.find(c) + 1]);\n        }\n    }\n    for (auto &c: ans)\
    \ {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \            ans[ans.find(c) + 1] = toupper(ans[ans.find(c) + 1]);\n        }\n\
    \    }\n    for (auto &c: ans) {\n        if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans[ans.find(c) + 1] = tolower(ans[ans.find(c)\
    \ + 1]);\n        }\n    }\n    for (auto &c: ans) {\n        if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 1] = toupper(ans[ans.find(c) + 1]);\n        }\n    }\n    for (auto &c: ans)\
    \ {\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n\
    \            ans[ans.find(c) + 1] = tolower(ans[ans.find(c) + 1]);\n        }\n\
    \    }\n    for (auto &c: ans) {\n        if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans[ans.find(c) + 1] = toupper(ans[an\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_ua_bi08.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_ua_bi08.cpp:60:48: error: \u2018an\u2019 was not declared in this\
    \ scope; did you mean \u2018ans\u2019?\n   60 |             ans[ans.find(c) +\
    \ 1] = toupper(ans[an\n      |                                               \
    \ ^~\n      |                                                ans\n/tmp/tmp_ua_bi08.cpp:60:50:\
    \ error: expected \u2018]\u2019 before \u2018}\u2019 token\n   60 |          \
    \   ans[ans.find(c) + 1] = toupper(ans[an\n      |                           \
    \                       ^\n      |                                           \
    \       ]\n   61 | }\n      | ~                                              \
    \   \n/tmp/tmp_ua_bi08.cpp:62:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   62 | int main() {\n      |            ^\n\
    /tmp/tmp_ua_bi08.cpp:69:1: error: expected \u2018}\u2019 at end of input\n   69\
    \ | }\n      | ^\n/tmp/tmp_ua_bi08.cpp:58:24: note: to match this \u2018{\u2019\
    \n   58 |     for (auto &c: ans) {\n      |                        ^\n/tmp/tmp_ua_bi08.cpp:69:1:\
    \ error: expected \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmp_ua_bi08.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp_ua_bi08.cpp:69:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   69 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('A' <= c && c <= 'Z') {\n            ans += c;\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans += 'A';\n        } else if (c == 'y' || c == 'i' || c ==\
    \ 'o' || c == 'u') {\n            ans += 'Y';\n        } else if (c == 'o' ||\
    \ c == 'u' || c == 'a' || c == 'e' || c == 'i' || c == 'y') {\n            ans\
    \ += 'O';\n        } else if (c == 'h' || c == 'k' || c == 's' || c == 'c' ||\
    \ c == 'g' || c == 'g' || c == 's') {\n            ans += 'H';\n        } else\
    \ if (c == 'm' || c == 'g' || c == 's' || c == 'c' || c == 'g' || c == 'g' ||\
    \ c == 's') {\n            ans += 'M';\n        } else if (c == 't' || c == 'h'\
    \ || c == 'k' || c == 's' || c == 'c' || c == 'g' || c == 'g' || c == 's') {\n\
    \            ans += 'T';\n        } else if (c == 'r' || c == 'e' || c == 'e'\
    \ || c == 'r' || c == 't' || c == 'h' || c == 'k' || c == 's' || c == 'c' || c\
    \ == 'g' || c == 'g' || c == 's') {\n            ans += 'R';\n        } else if\
    \ (c == 'd' || c == 'e' || c == 'e' || c == 'r' || c == 't' || c == 'h' || c ==\
    \ 'k' || c == 's' || c == 'c' || c == 'g' || c == 'g' || c == 's') {\n       \
    \     ans += 'D';\n        } else if (c == 'p' || c == 'e' || c == 'e' || c ==\
    \ 'r' || c == 't' || c == 'h' || c == 'k' || c == 's' || c == 'c' || c == 'g'\
    \ || c == 'g' || c == 's') {\n            ans += 'P';\n        } else if (c ==\
    \ 'b' || c == 'e' || c == 'e' || c == 'r' || c == 't' || c == 'h' || c == 'k'\
    \ || c == 's' || c == 'c' || c == 'g' || c == 'g' || c == 's') {\n           \
    \ ans += 'B';\n        } else if (c == 'f' || c == 'e' || c == 'e' || c == 'r'\
    \ || c == 't' || c == 'h' || c == 'k' || c == 's' || c == 'c' || c == 'g' || c\
    \ == 'g' || c\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpp7dwjkyj.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpp7dwjkyj.cpp:39:153: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   39 |         } else if (c == 'f' || c == 'e' || c == 'e' || c == 'r'\
    \ || c == 't' || c == 'h' || c == 'k' || c == 's' || c == 'c' || c == 'g' || c\
    \ == 'g' || c\n      |                   ~                                   \
    \                                                                            \
    \                      ^\n      |                                            \
    \                                                                            \
    \                                 )\n   40 | }\n      | ~                    \
    \                                                                            \
    \                                                        \n/tmp/tmpp7dwjkyj.cpp:40:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   40 | }\n \
    \     | ^\n/tmp/tmpp7dwjkyj.cpp:41:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   41 | int main() {\n      |            ^\n\
    /tmp/tmpp7dwjkyj.cpp:48:1: error: expected \u2018}\u2019 at end of input\n   48\
    \ | }\n      | ^\n/tmp/tmpp7dwjkyj.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpp7dwjkyj.cpp:48:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   48 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('a' <= c && c <= 'z') {\n            ans += c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans += 'A';\n        } else if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            ans += 'a';\n        } else {\n\
    \            ans += c;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('a' <= c && c <= 'z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c\
    \ == 'O' || c == 'U') {\n            ans[i] = 'A';\n        } else if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        char\
    \ c = ans[i];\n        if ('a' <= c && c <= 'z') {\n            ans[i] = c;\n\
    \        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n            ans[i] = 'A';\n        } else if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'a';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if ('a' <= c && c <= 'z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        if ('a' <= c &&\
    \ c <= 'z') {\n            ans[i] = c;\n        } else if (c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'A';\n        }\
    \ else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n     \
    \       ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('a' <= c && c <= 'z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'A' || c == 'E' || \n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7fvpyuw5.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp7fvpyuw5.cpp:72:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   72 | }\n      | ^\n/tmp/tmp7fvpyuw5.cpp:71:43: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   71 |         } else if (c == 'A'\
    \ || c == 'E' ||\n      |                   ~                       ^\n      |\
    \                                           )\n   72 | }\n      | ~          \
    \                                \n/tmp/tmp7fvpyuw5.cpp:72:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   72 | }\n      | ^\n/tmp/tmp7fvpyuw5.cpp:73:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   73 | int main() {\n      |            ^\n/tmp/tmp7fvpyuw5.cpp:80:1: error:\
    \ expected \u2018}\u2019 at end of input\n   80 | }\n      | ^\n/tmp/tmp7fvpyuw5.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp7fvpyuw5.cpp:80:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   80 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += tolower(c);\n\
    \        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n        char c\
    \ = ans[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[i] = tolower(ans[i+1]);\n        }\n    }\n    for(int i\
    \ = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = toupper(ans[i+1]);\n\
    \        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n        char c\
    \ = ans[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[i] = toupper(ans[i+1]);\n        }\n    }\n    for(int i\
    \ = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if(c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = tolower(ans[i+1]);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpvdtdapbu: /tmp/tmpvdtdapbu.cpp:51: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u') {\n            encoded = encoded + c;\n        }\n        else if(c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            encoded\
    \ = encoded + c;\n        }\n        else {\n            int index = c - 'a';\n\
    \            int index2 = c - 'A';\n            int index3 = c - 'e';\n      \
    \      int index4 = c - 'E';\n            int index5 = c - 'i';\n            int\
    \ index6 = c - 'I';\n            int index7 = c - 'o';\n            int index8\
    \ = c - 'O';\n            int index9 = c - 'u';\n            int index10 = c -\
    \ 'U';\n            int index11 = c - 'A';\n            int index12 = c - 'E';\n\
    \            int index13 = c - 'I';\n            int index14 = c - 'O';\n    \
    \        int index15 = c - 'U';\n            int index16 = c - 'a';\n        \
    \    int index17 = c - 'e';\n            int index18 = c - 'i';\n            int\
    \ index19 = c - 'o';\n            int index20 = c - 'u';\n            int index21\
    \ = c - 'A';\n            int index22 = c - 'E';\n            int index23 = c\
    \ - 'I';\n            int index24 = c - 'O';\n            int index25 = c - 'U';\n\
    \            int index26 = c - 'a';\n            int index27 = c - 'e';\n    \
    \        int index28 = c - 'i';\n            int index29 = c - 'o';\n        \
    \    int index30 = c - 'u';\n            int index31 = c - 'A';\n            int\
    \ index32 = c - 'E';\n            int index33 = c - 'I';\n            int index34\
    \ = c - 'O';\n            int index35 = c - 'U';\n            int index36 = c\
    \ - 'a';\n            int index37 = c - 'e';\n            int index38 = c - 'i';\n\
    \            int index39 = c - 'o';\n            int index40 = c - 'u';\n    \
    \        int index41 = c - 'A';\n            int index42 = c - 'E';\n        \
    \    int index43 = c - 'I';\n            int index44 = c - 'O';\n\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpocxw54os.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpocxw54os.cpp:70:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   70 | int main() {\n      |            ^\n/tmp/tmpocxw54os.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmpocxw54os.cpp:15:47:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i = 0; i < message.length();\
    \ i++) {\n      |                                               ^\n/tmp/tmpocxw54os.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmpocxw54os.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpocxw54os.cpp:77:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   77 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if('A' <= c && c <= 'Z') {\n            ans += c;\n \
    \       } else if('a' <= c && c <= 'z') {\n            ans += c;\n        } else\
    \ if('0' <= c && c <= '9') {\n            ans += c;\n        } else if('!' <=\
    \ c && c <= '@') {\n            ans += c;\n        } else if('?' <= c && c <=\
    \ '@') {\n            ans += c;\n        } else if('[' <= c && c <= '^') {\n \
    \           ans += c;\n        } else if('{' <= c && c <= '~') {\n           \
    \ ans += c;\n        } else if('|' <= c && c <= '~') {\n            ans += c;\n\
    \        } else if('!' <= c && c <= '@') {\n            ans += c;\n        } else\
    \ if('?' <= c && c <= '@') {\n            ans += c;\n        } else if('[' <=\
    \ c && c <= '^') {\n            ans += c;\n        } else if('{' <= c && c <=\
    \ '~') {\n            ans += c;\n        } else if('|' <= c && c <= '~') {\n \
    \           ans += c;\n        } else if('!' <= c && c <= '@') {\n           \
    \ ans += c;\n        } else if('?' <= c && c <= '@') {\n            ans += c;\n\
    \        } else if('[' <= c && c <= '^') {\n            ans += c;\n        } else\
    \ if('{' <= c && c <= '~') {\n            ans += c;\n        } else if('|' <=\
    \ c && c <= '~') {\n            ans += c;\n        } else if('!' <= c && c <=\
    \ '@') {\n            ans += c;\n        } else if('?' <= c && c <= '@') {\n \
    \           ans += c;\n        } else if('[' <= c && c <= '^') {\n           \
    \ ans += c;\n        } else if('{' <= c && c <= '~') {\n            ans += c;\n\
    \        } else if('|' <= c && c <= '~') {\n            ans += c;\n        } else\
    \ if('!' <= c && c <= '@') {\n            ans += c;\n        } else if('?' <=\
    \ c && c <= '@') {\n            ans += c;\n        \n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyihhfbny.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpyihhfbny.cpp:69:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   69 | int main() {\n      |            ^\n/tmp/tmpyihhfbny.cpp:76:1:\
    \ error: expected \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpyihhfbny.cpp:15:47:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i = 0; i < message.length();\
    \ i++) {\n      |                                               ^\n/tmp/tmpyihhfbny.cpp:76:1:\
    \ error: expected \u2018}\u2019 at end of input\n   76 | }\n      | ^\n/tmp/tmpyihhfbny.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpyihhfbny.cpp:76:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   76 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c + 2 : c));\n\
    \    }\n    for (auto &c : ans) {\n        ans[ans.find(c) - 2] = ans[ans.find(c)\
    \ - 2].toupper();\n    }\n    for (auto &c : ans) {\n        ans[ans.find(c) -\
    \ 2] = ans[ans.find(c) - 2].tolower();\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsgmbg4n7.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpsgmbg4n7.cpp:19:53: error: request for member \u2018toupper\u2019 in\
    \ \u2018ans.std::__cxx11::basic_string<char>::operator[]((ans.std::__cxx11::basic_string<char>::find(((int)c),\
    \ 0) - 2))\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   19 |         ans[ans.find(c)\
    \ - 2] = ans[ans.find(c) - 2].toupper();\n      |                            \
    \                         ^~~~~~~\n/tmp/tmpsgmbg4n7.cpp:22:53: error: request\
    \ for member \u2018tolower\u2019 in \u2018ans.std::__cxx11::basic_string<char>::operator[]((ans.std::__cxx11::basic_string<char>::find(((int)c),\
    \ 0) - 2))\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   22 |         ans[ans.find(c)\
    \ - 2] = ans[ans.find(c) - 2].tolower();\n      |                            \
    \                         ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : ((c >=\
    \ 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9')\
    \ ? c : '?'))));\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd3n_p946.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpd3n_p946.cpp:16:202: error: expected \u2018)\u2019 before \u2018;\u2019\
    \ token\n   16 |         ans += (c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <=\
    \ 'Z') ? c : ((c >= '0' && c <= '9') ? c : ((c >= 'a' && c <= 'z') ? c : ((c >=\
    \ 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : '?'))));\n      |     \
    \                                        ~                                   \
    \                                                                            \
    \                                             ^\n      |                     \
    \                                                                            \
    \                                                                            \
    \                             )\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        if (message[i]\
    \ >= 'a' && message[i] <= 'z') {\n            ans += message[i];\n        }\n\
    \        else if (message[i] >= 'A' && message[i] <= 'Z') {\n            ans +=\
    \ message[i];\n        }\n        else if (message[i] >= '0' && message[i] <=\
    \ '9') {\n            ans += message[i];\n        }\n        else if (message[i]\
    \ == '.' || message[i] == '!' || message[i] == '?') {\n            ans += message[i];\n\
    \        }\n        else if (message[i] == '-' || message[i] == '_' || message[i]\
    \ == '/' || message[i] == '\\\\') {\n            ans += message[i];\n        }\n\
    \        else if (message[i] == '!' || message[i] == '?') {\n            ans +=\
    \ message[i];\n        }\n        else if (message[i] == '.' || message[i] ==\
    \ '/' || message[i] == '\\\\') {\n            ans += message[i];\n        }\n\
    \        else if (message[i] == '_' || message[i] == '-' || message[i] == '/'\
    \ || message[i] == '\\\\') {\n            ans += message[i];\n        }\n    \
    \    else if (message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || message[i]\
    \ == 'o' || message[i] == 'u') {\n            ans += message[i];\n        }\n\
    \        else if (message[i] == 'A' || message[i] == 'E' || message[i] == 'I'\
    \ || message[i] == 'O' || message[i] == 'U') {\n            ans += message[i];\n\
    \        }\n        else if (message[i] == '0' || message[i] == '1' || message[i]\
    \ == '2' || message[i] == '3' || message[i] == '4' || message[i] == '5' || message[i]\
    \ == '6' || message[i] == '7' || message[i] == '8' || message[i] == '9') {\n \
    \           ans += message[i];\n        }\n        else if (message[i] == '!'\
    \ || message[i] == '?') {\n            ans += message[i];\n        }\n       \
    \ else if (message[i] == '.' || message[i] == '/' || message[i] == '\\\\') {\n\
    \            ans += message[i];\n        }\n        else if (message[i] == '_'\
    \ || message[i] == '-' || message[i] == '/' || message[i] == '\\\\') {\n     \
    \       ans += message[i];\n        }\n        else if (message[i] == '-' || message[i]\
    \ == '_' || message[i] == '/' || message[i] == '\\\\') {\n            ans += message[i];\n\
    \        }\n        else if (message[i] == '/' || message[i] == '\\\\') {\n  \
    \          ans += message[i];\n        }\n        else if (message[i] == '_' ||\
    \ message[i] == '-' || message[i] == '/' || message[i] == '\\\\') {\n        \
    \    ans += message[i];\n        }\n        else if (message[i] == '\\\\') {\n\
    \            ans += message[i];\n        }\n        else if (message[i]\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_bqiwfoe.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_bqiwfoe.cpp:70:28: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   70 |         else if (message[i]\n      |                 ~      \
    \    ^\n      |                            )\n   71 | }\n      | ~           \
    \                \n/tmp/tmp_bqiwfoe.cpp:71:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   71 | }\n      | ^\n/tmp/tmp_bqiwfoe.cpp:72:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   72 | int main() {\n      |            ^\n/tmp/tmp_bqiwfoe.cpp:79:1: error:\
    \ expected \u2018}\u2019 at end of input\n   79 | }\n      | ^\n/tmp/tmp_bqiwfoe.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp_bqiwfoe.cpp:79:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   79 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (char &c : message) {\n        switch (c) {\n     \
    \       case 'A':\n                c = 'a';\n                break;\n        \
    \    case 'B':\n                c = 'b';\n                break;\n           \
    \ case 'C':\n                c = 'c';\n                break;\n            case\
    \ 'D':\n                c = 'd';\n                break;\n            case 'E':\n\
    \                c = 'e';\n                break;\n            case 'F':\n   \
    \             c = 'f';\n                break;\n            case 'G':\n      \
    \          c = 'g';\n                break;\n            case 'H':\n         \
    \       c = 'h';\n                break;\n            case 'I':\n            \
    \    c = 'i';\n                break;\n            case 'J':\n               \
    \ c = 'j';\n                break;\n            case 'K':\n                c =\
    \ 'k';\n                break;\n            case 'L':\n                c = 'l';\n\
    \                break;\n            case 'M':\n                c = 'm';\n   \
    \             break;\n            case 'N':\n                c = 'n';\n      \
    \          break;\n            case 'O':\n                c = 'o';\n         \
    \       break;\n            case 'P':\n                c = 'p';\n            \
    \    break;\n            case 'Q':\n                c = 'q';\n               \
    \ break;\n            case 'R':\n                c = 'r';\n                break;\n\
    \            case 'S':\n                c = 's';\n                break;\n   \
    \         case 'T':\n                c = 't';\n                break;\n      \
    \      case 'U':\n                c = 'u';\n                break;\n         \
    \   case 'V':\n                c = 'v';\n                break;\n            case\
    \ 'W':\n                c = 'w';\n                break;\n            case 'X':\n\
    \                c = 'x';\n                break;\n            case 'Y':\n   \
    \             c = 'y';\n                break;\n            case 'Z':\n      \
    \          c = 'z';\n                break;\n            case 'a':\n         \
    \       c = 'A';\n                break;\n            case 'b':\n            \
    \    c = 'B';\n                break;\n            case 'c':\n               \
    \ c = 'C';\n                break;\n            case 'd':\n                c =\
    \ 'D';\n                break;\n            case 'e':\n                c = 'E';\n\
    \                break;\n            case 'f':\n                c = 'F';\n   \
    \             break;\n            case 'g':\n                c = 'G';\n      \
    \          break;\n            case 'h':\n                c = 'H';\n         \
    \       break;\n            case 'i':\n                c = 'I';\n            \
    \    break;\n            case 'j':\n                c = 'J';\n               \
    \ break;\n            case 'k':\n                c = 'K';\n                break;\n\
    \            case 'l':\n                c = 'L';\n                break;\n   \
    \         case 'm':\n                c = 'M';\n                break;\n      \
    \      case 'n':\n                c = 'N';\n                break;\n         \
    \   case 'o':\n                c = 'O';\n                break;\n            case\
    \ 'p':\n                c = 'P';\n                break;\n            case 'q':\n\
    \                c = 'Q';\n                break;\n            case 'r':\n   \
    \             c = 'R';\n                break;\n            case 's':\n      \
    \          c = 'S';\n                break;\n            case 't\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp16q4vwhz.cpp:152:18: warning: missing terminating ' character\n\
    \  152 |             case 't\n      |                  ^\n/tmp/tmp16q4vwhz.cpp:152:18:\
    \ error: missing terminating ' character\n  152 |             case 't\n      |\
    \                  ^~\n/tmp/tmp16q4vwhz.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp16q4vwhz.cpp:153:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  153 | }\n      | ^\n/tmp/tmp16q4vwhz.cpp:152:17: error: expected\
    \ \u2018:\u2019 before \u2018}\u2019 token\n  152 |             case 't\n    \
    \  |                 ^\n      |                 :\n  153 | }\n      | ~      \
    \          \n/tmp/tmp16q4vwhz.cpp:153:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n  153 | }\n      | ^\n/tmp/tmp16q4vwhz.cpp:154:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n  154\
    \ | int main() {\n      |            ^\n/tmp/tmp16q4vwhz.cpp:161:1: error: expected\
    \ \u2018}\u2019 at end of input\n  161 | }\n      | ^\n/tmp/tmp16q4vwhz.cpp:15:29:\
    \ note: to match this \u2018{\u2019\n   15 |     for (char &c : message) {\n \
    \     |                             ^\n/tmp/tmp16q4vwhz.cpp:161:1: error: expected\
    \ \u2018}\u2019 at end of input\n  161 | }\n      | ^\n/tmp/tmp16q4vwhz.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp16q4vwhz.cpp:161:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  161 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            int index = c - 'a';\n            ans += 'a' + index;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpnclp4dmf: /tmp/tmpnclp4dmf.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        char a = c;\n        char b = c;\n        char d = c;\n\
    \        char e = c;\n        char f = c;\n        char g = c;\n        char h\
    \ = c;\n        char j = c;\n        char k = c;\n        char l = c;\n      \
    \  char m = c;\n        char n = c;\n        char o = c;\n        char p = c;\n\
    \        char q = c;\n        char r = c;\n        char s = c;\n        char t\
    \ = c;\n        char u = c;\n        char v = c;\n        char w = c;\n      \
    \  char x = c;\n        char y = c;\n        char z = c;\n        char A = c;\n\
    \        char B = c;\n        char C = c;\n        char D = c;\n        char E\
    \ = c;\n        char F = c;\n        char G = c;\n        char H = c;\n      \
    \  char I = c;\n        char J = c;\n        char K = c;\n        char L = c;\n\
    \        char M = c;\n        char N = c;\n        char O = c;\n        char P\
    \ = c;\n        char Q = c;\n        char R = c;\n        char S = c;\n      \
    \  char T = c;\n        char U = c;\n        char V = c;\n        char W = c;\n\
    \        char X = c;\n        char Y = c;\n        char Z = c;\n        char aA\
    \ = c;\n        char aB = c;\n        char aC = c;\n        char aD = c;\n   \
    \     char aE = c;\n        char aF = c;\n        char aG = c;\n        char aH\
    \ = c;\n        char aI = c;\n        char aJ = c;\n        char aK = c;\n   \
    \     char aL = c;\n        char aM = c;\n        char aN = c;\n        char aO\
    \ = c;\n        char aP = c;\n        char aQ = c;\n        char aR = c;\n   \
    \     char aS = c;\n        char aT = c;\n        char aU = c;\n        char aV\
    \ = c;\n        char aW = c;\n        char aX = c;\n        char aY = c;\n   \
    \     char aZ = c;\n        char bA = c;\n        char bB = c;\n        char bC\
    \ = c;\n        char bD = c;\n        char bE = c;\n        char bF = c;\n   \
    \     char bG = c;\n        char bH = c;\n        char bI = c;\n        char bJ\
    \ = c;\n        char b\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps7yc4bxs.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmps7yc4bxs.cpp:104:1: error: expected initializer before \u2018}\u2019\
    \ token\n  104 | }\n      | ^\n/tmp/tmps7yc4bxs.cpp:105:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  105 | int main() {\n     \
    \ |            ^\n/tmp/tmps7yc4bxs.cpp:112:1: error: expected \u2018}\u2019 at\
    \ end of input\n  112 | }\n      | ^\n/tmp/tmps7yc4bxs.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmps7yc4bxs.cpp:112:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n  112 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (char c : ans) {\n        if (c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c) + 2]\
    \ = tolower(c);\n        }\n    }\n    for (char c : ans) {\n        if (c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = tolower(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = tolower(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = tolower(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = tolower(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'A' || c == 'E' || c == 'I' || \n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfcnw9n74.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpfcnw9n74.cpp:70:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   70 | }\n      | ^\n/tmp/tmpfcnw9n74.cpp:69:48: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   69 |         if (c == 'A' || c\
    \ == 'E' || c == 'I' ||\n      |            ~                                \
    \   ^\n      |                                                )\n   70 | }\n \
    \     | ~                                               \n/tmp/tmpfcnw9n74.cpp:70:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   70 | }\n \
    \     | ^\n/tmp/tmpfcnw9n74.cpp:71:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   71 | int main() {\n      |            ^\n\
    /tmp/tmpfcnw9n74.cpp:78:1: error: expected \u2018}\u2019 at end of input\n   78\
    \ | }\n      | ^\n/tmp/tmpfcnw9n74.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpfcnw9n74.cpp:78:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   78 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpdut9931l: /tmp/tmpdut9931l.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if('a' <= c && c <= 'z') {\n            ans += c;\n \
    \       }\n        else if('A' <= c && c <= 'Z') {\n            ans += c;\n  \
    \      }\n        else if('0' <= c && c <= '9') {\n            ans += c;\n   \
    \     }\n        else if('!' <= c && c <= '@') {\n            ans += c;\n    \
    \    }\n        else if('?' <= c && c <= '@') {\n            ans += c;\n     \
    \   }\n        else if('[' <= c && c <= '^') {\n            ans += c;\n      \
    \  }\n        else if('{' <= c && c <= '}') {\n            ans += c;\n       \
    \ }\n        else if('|' <= c && c <= '~') {\n            ans += c;\n        }\n\
    \        else if('\\\\' <= c && c <= '/') {\n            ans += c;\n        }\n\
    \        else if('*' <= c && c <= '&') {\n            ans += c;\n        }\n \
    \       else if('+' <= c && c <= '=') {\n            ans += c;\n        }\n  \
    \      else if('-' <= c && c <= '=') {\n            ans += c;\n        }\n   \
    \     else if('>' <= c && c <= '<') {\n            ans += c;\n        }\n    \
    \    else if('?' <= c && c <= '@') {\n            ans += c;\n        }\n     \
    \   else if('!' <= c && c <= '@') {\n            ans += c;\n        }\n      \
    \  else if('?' <= c && c <= '@') {\n            ans += c;\n        }\n       \
    \ else if('?' <= c && c <= '@') {\n            ans += c;\n        }\n        else\
    \ if('?' <= c && c <= '@') {\n            ans += c;\n        }\n        else if('?'\
    \ <= c && c <= '@') {\n            ans += c;\n        }\n        else if('?' <=\
    \ c && c <= '@') {\n            ans += c;\n        }\n        else if('?' <= c\
    \ && c <= '@') {\n            ans += c;\n        }\n        else if('?' <= c &&\
    \ c <= '@') {\n            ans += c;\n        }\n        else if('?' <= c && c\
    \ <= '@') {\n            ans += c;\n        }\n        else if('?' <= c && c <=\
    \ '@') {\n            ans += c;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfn36h__c.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpfn36h__c.cpp:89:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   89 | int main() {\n      |            ^\n/tmp/tmpfn36h__c.cpp:96:1:\
    \ error: expected \u2018}\u2019 at end of input\n   96 | }\n      | ^\n/tmp/tmpfn36h__c.cpp:15:47:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i = 0; i < message.length();\
    \ i++) {\n      |                                               ^\n/tmp/tmpfn36h__c.cpp:96:1:\
    \ error: expected \u2018}\u2019 at end of input\n   96 | }\n      | ^\n/tmp/tmpfn36h__c.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpfn36h__c.cpp:96:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   96 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (auto &c : message) {\n        switch (c) {\n     \
    \       case 'a':\n                encoded += 'A';\n                break;\n \
    \           case 'b':\n                encoded += 'B';\n                break;\n\
    \            case 'c':\n                encoded += 'C';\n                break;\n\
    \            case 'd':\n                encoded += 'D';\n                break;\n\
    \            case 'e':\n                encoded += 'E';\n                break;\n\
    \            case 'f':\n                encoded += 'F';\n                break;\n\
    \            case 'g':\n                encoded += 'G';\n                break;\n\
    \            case 'h':\n                encoded += 'H';\n                break;\n\
    \            case 'i':\n                encoded += 'I';\n                break;\n\
    \            case 'j':\n                encoded += 'J';\n                break;\n\
    \            case 'k':\n                encoded += 'K';\n                break;\n\
    \            case 'l':\n                encoded += 'L';\n                break;\n\
    \            case 'm':\n                encoded += 'M';\n                break;\n\
    \            case 'n':\n                encoded += 'N';\n                break;\n\
    \            case 'o':\n                encoded += 'O';\n                break;\n\
    \            case 'p':\n                encoded += 'P';\n                break;\n\
    \            case 'q':\n                encoded += 'Q';\n                break;\n\
    \            case 'r':\n                encoded += 'R';\n                break;\n\
    \            case 's':\n                encoded += 'S';\n                break;\n\
    \            case 't':\n                encoded += 'T';\n                break;\n\
    \            case 'u':\n                encoded += 'U';\n                break;\n\
    \            case 'v':\n                encoded += 'V';\n                break;\n\
    \            case 'w':\n                encoded += 'W';\n                break;\n\
    \            case 'x':\n                encoded += 'X';\n                break;\n\
    \            case 'y':\n                encoded += 'Y';\n                break;\n\
    \            case 'z':\n                encoded += 'Z';\n                break;\n\
    \            case 'A':\n                encoded += 'a';\n                break;\n\
    \            case 'B':\n                encoded += 'b';\n                break;\n\
    \            case 'C':\n                encoded += 'c';\n                break;\n\
    \            case 'D':\n                encoded += 'd';\n                break;\n\
    \            case 'E':\n                encoded += 'e';\n                break;\n\
    \            case 'F':\n                encoded += 'f';\n                break;\n\
    \            case 'G':\n                encoded += 'g';\n                break;\n\
    \            case 'H':\n                encoded += 'h';\n                break;\n\
    \            case 'I':\n                encoded += 'i';\n                break;\n\
    \            case 'J':\n                encoded += 'j';\n                break;\n\
    \            case 'K':\n                encoded += 'k';\n                break;\n\
    \            case 'L':\n                encoded += 'l';\n                break;\n\
    \            case 'M':\n                encoded += 'm';\n                break;\n\
    \            case 'N':\n                encoded += 'n';\n                break;\n\
    \            case 'O':\n                encoded += 'o';\n                break;\n\
    \            case 'P':\n\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpegdlzrk6.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpegdlzrk6.cpp:142:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  142 | }\n      | ^\n/tmp/tmpegdlzrk6.cpp:143:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  143 | int main() {\n     \
    \ |            ^\n/tmp/tmpegdlzrk6.cpp:150:1: error: expected \u2018}\u2019 at\
    \ end of input\n  150 | }\n      | ^\n/tmp/tmpegdlzrk6.cpp:15:29: note: to match\
    \ this \u2018{\u2019\n   15 |     for (auto &c : message) {\n      |         \
    \                    ^\n/tmp/tmpegdlzrk6.cpp:150:1: error: expected \u2018}\u2019\
    \ at end of input\n  150 | }\n      | ^\n/tmp/tmpegdlzrk6.cpp:13:41: note: to\
    \ match this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n\
    \      |                                         ^\n/tmp/tmpegdlzrk6.cpp:150:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  150 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (auto &c : message) {\n        switch (c) {\n     \
    \       case 'A':\n            case 'a':\n                encoded += 'a';\n  \
    \              break;\n            case 'B':\n            case 'b':\n        \
    \        encoded += 'b';\n                break;\n            case 'C':\n    \
    \        case 'c':\n                encoded += 'c';\n                break;\n\
    \            case 'D':\n            case 'd':\n                encoded += 'd';\n\
    \                break;\n            case 'E':\n            case 'e':\n      \
    \          encoded += 'e';\n                break;\n            case 'F':\n  \
    \          case 'f':\n                encoded += 'f';\n                break;\n\
    \            case 'G':\n            case 'g':\n                encoded += 'g';\n\
    \                break;\n            case 'H':\n            case 'h':\n      \
    \          encoded += 'h';\n                break;\n            case 'I':\n  \
    \          case 'i':\n                encoded += 'i';\n                break;\n\
    \            case 'J':\n            case 'j':\n                encoded += 'j';\n\
    \                break;\n            case 'K':\n            case 'k':\n      \
    \          encoded += 'k';\n                break;\n            case 'L':\n  \
    \          case 'l':\n                encoded += 'l';\n                break;\n\
    \            case 'M':\n            case 'm':\n                encoded += 'm';\n\
    \                break;\n            case 'N':\n            case 'n':\n      \
    \          encoded += 'n';\n                break;\n            case 'O':\n  \
    \          case 'o':\n                encoded += 'o';\n                break;\n\
    \            case 'P':\n            case 'p':\n                encoded += 'p';\n\
    \                break;\n            case 'Q':\n            case 'q':\n      \
    \          encoded += 'q';\n                break;\n            case 'R':\n  \
    \          case 'r':\n                encoded += 'r';\n                break;\n\
    \            case 'S':\n            case 's':\n                encoded += 's';\n\
    \                break;\n            case 'T':\n            case 't':\n      \
    \          encoded += 't';\n                break;\n            case 'U':\n  \
    \          case 'u':\n                encoded += 'u';\n                break;\n\
    \            case 'V':\n            case 'v':\n                encoded += 'v';\n\
    \                break;\n            case 'W':\n            case 'w':\n      \
    \          encoded += 'w';\n                break;\n            case 'X':\n  \
    \          case 'x':\n                encoded += 'x';\n                break;\n\
    \            case 'Y':\n            case 'y':\n                encoded += 'y';\n\
    \                break;\n            case 'Z':\n            case 'z':\n      \
    \          encoded += 'z';\n                break;\n            default:\n   \
    \             encoded += c;\n        }\n    }\n    return encoded;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpi0qzr635: /tmp/tmpi0qzr635.cpp:129: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpw61___31: /tmp/tmpw61___31.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (tolower(c) == c)\
    \ ? toupper(c) : tolower(c);\n    }\n    for (char c : ans) {\n        if (c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    for (char c : ans) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ - 2] = tolower(c);\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp8ewk5eb0: /tmp/tmp8ewk5eb0.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char &c : message) {\n        switch (c) {\n         \
    \   case 'A':\n            case 'a':\n                ans += 'B';\n          \
    \      break;\n            case 'B':\n            case 'b':\n                ans\
    \ += 'A';\n                break;\n            case 'C':\n            case 'c':\n\
    \                ans += 'D';\n                break;\n            case 'D':\n\
    \            case 'd':\n                ans += 'C';\n                break;\n\
    \            case 'E':\n            case 'e':\n                ans += 'F';\n \
    \               break;\n            case 'F':\n            case 'f':\n       \
    \         ans += 'E';\n                break;\n            case 'G':\n       \
    \     case 'g':\n                ans += 'H';\n                break;\n       \
    \     case 'H':\n            case 'h':\n                ans += 'G';\n        \
    \        break;\n            case 'I':\n            case 'i':\n              \
    \  ans += 'J';\n                break;\n            case 'J':\n            case\
    \ 'j':\n                ans += 'I';\n                break;\n            case\
    \ 'K':\n            case 'k':\n                ans += 'L';\n                break;\n\
    \            case 'L':\n            case 'l':\n                ans += 'K';\n \
    \               break;\n            case 'M':\n            case 'm':\n       \
    \         ans += 'N';\n                break;\n            case 'N':\n       \
    \     case 'n':\n                ans += 'M';\n                break;\n       \
    \     case 'O':\n            case 'o':\n                ans += 'P';\n        \
    \        break;\n            case 'P':\n            case 'p':\n              \
    \  ans += 'O';\n                break;\n            case 'Q':\n            case\
    \ 'q':\n                ans += 'R';\n                break;\n            case\
    \ 'R':\n            case 'r':\n                ans += 'Q';\n                break;\n\
    \            case 'S':\n            case 's':\n                ans += 'T';\n \
    \               break;\n            case 'T':\n            case 't':\n       \
    \         ans += 'S';\n                break;\n            case 'U':\n       \
    \     case 'u':\n                ans += 'V';\n                break;\n       \
    \     case 'V':\n            case 'v':\n                ans += 'U';\n        \
    \        break;\n            case 'W':\n            case 'w':\n              \
    \  ans += 'X';\n                break;\n            case 'X':\n            case\
    \ 'x':\n                ans += 'W';\n                break;\n            case\
    \ 'Y':\n            case 'y':\n                ans += 'Z';\n                break;\n\
    \            case 'Z':\n            case 'z':\n                ans += 'Y';\n \
    \               break;\n            default:\n                ans += c;\n    \
    \    }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp4fozfapq: /tmp/tmp4fozfapq.cpp:129: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? (c + 2) : c;\n    }\n    for (auto &c : ans) {\n        ans[ans.find(c)\
    \ - 1] = (c >= 'a' && c <= 'z') ? (c + 2) : c;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpbbbuz0tm: /tmp/tmpbbbuz0tm.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        char c = message[i];\n\
    \        if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n            ans += c;\n        }\n        else\
    \ if(c>='A' && c<='Z') {\n            ans += c;\n        }\n        else if(c>='a'\
    \ && c<='z') {\n            ans += c;\n        }\n        else if(c>='A' && c<='Z')\
    \ {\n            ans += c;\n        }\n        else if(c>='a' && c<='z') {\n \
    \           ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n      \
    \      ans += c;\n        }\n        else if(c>='a' && c<='z') {\n           \
    \ ans += c;\n        }\n        else if(c>='A' && c<='Z') {\n            ans +=\
    \ c;\n        }\n        else if(c>='a' && c<='z') {\n            ans += c;\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += c;\n     \
    \   }\n        else if(c>='a' && c<='z') {\n            ans += c;\n        }\n\
    \        else if(c>='A' && c<='Z') {\n            ans += c;\n        }\n     \
    \   else if(c>='a' && c<='z') {\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl316h_7x.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpl316h_7x.cpp:91:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   91 | int main() {\n      |            ^\n/tmp/tmpl316h_7x.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpl316h_7x.cpp:15:41:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i=0;i<message.length();i++)\
    \ {\n      |                                         ^\n/tmp/tmpl316h_7x.cpp:98:1:\
    \ error: expected \u2018}\u2019 at end of input\n   98 | }\n      | ^\n/tmp/tmpl316h_7x.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpl316h_7x.cpp:98:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   98 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        char prev = message[i - 1];\n        if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans += prev;\n\
    \        }\n        ans += c;\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp7e264bws: /tmp/tmp7e264bws.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpo4wfj83d: /tmp/tmpo4wfj83d.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (c >= 'a' && c <=\
    \ 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : 'A'));\n\
    \    }\n    for (char c : ans) {\n        ans[ans.find(c)] = ans[ans.find(c) +\
    \ 2];\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmphekq13s3: /tmp/tmphekq13s3.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        switch (c) {\n         \
    \   case 'A':\n            case 'E':\n            case 'I':\n            case\
    \ 'O':\n            case 'U':\n                ans += 'A';\n                break;\n\
    \            case 'a':\n            case 'e':\n            case 'i':\n       \
    \     case 'o':\n            case 'u':\n                ans += 'E';\n        \
    \        break;\n            case 'B':\n            case 'F':\n            case\
    \ 'I':\n            case 'O':\n            case 'U':\n                ans += 'B';\n\
    \                break;\n            case 'b':\n            case 'f':\n      \
    \      case 'i':\n            case 'o':\n            case 'u':\n             \
    \   ans += 'F';\n                break;\n            case 'C':\n            case\
    \ 'G':\n            case 'K':\n            case 'M':\n            case 'S':\n\
    \                ans += 'C';\n                break;\n            case 'c':\n\
    \            case 'g':\n            case 'k':\n            case 'm':\n       \
    \     case 's':\n                ans += 'G';\n                break;\n       \
    \     case 'D':\n            case 'H':\n            case 'J':\n            case\
    \ 'P':\n            case 'T':\n                ans += 'D';\n                break;\n\
    \            case 'd':\n            case 'h':\n            case 'j':\n       \
    \     case 'p':\n            case 't':\n                ans += 'H';\n        \
    \        break;\n            case 'E':\n            case 'I':\n            case\
    \ 'O':\n            case 'U':\n                ans += 'E';\n                break;\n\
    \            case 'e':\n            case 'i':\n            case 'o':\n       \
    \     case 'u':\n                ans += 'I';\n                break;\n       \
    \     case 'F':\n            case 'I':\n            case 'O':\n            case\
    \ 'U':\n                ans += 'F';\n                break;\n            case\
    \ 'f':\n            case 'i':\n            case 'o':\n            case 'u':\n\
    \                ans += 'I';\n                break;\n            case 'G':\n\
    \            case 'K':\n            case 'M':\n            case 'S':\n       \
    \         ans += 'G';\n                break;\n            case 'g':\n       \
    \     case 'k':\n            case 'm':\n            case 's':\n              \
    \  ans += 'K';\n                break;\n            case 'H':\n            case\
    \ 'J':\n            case 'P':\n            case 'T':\n                ans += 'H';\n\
    \                break;\n            case 'h':\n            case 'j':\n      \
    \      case 'p':\n            case 't':\n                ans += 'J';\n       \
    \         break;\n            case 'I':\n            case 'O':\n            case\
    \ 'U':\n                ans += 'I';\n                break;\n            case\
    \ 'i':\n            case 'o':\n            case 'u':\n                ans += 'O';\n\
    \                break;\n            case 'J':\n            case 'P':\n      \
    \      case 'T':\n                ans += 'J';\n                break;\n      \
    \      case 'j\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0dc_9cgh.cpp:136:18: warning: missing terminating ' character\n\
    \  136 |             case 'j\n      |                  ^\n/tmp/tmp0dc_9cgh.cpp:136:18:\
    \ error: missing terminating ' character\n  136 |             case 'j\n      |\
    \                  ^~\n/tmp/tmp0dc_9cgh.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp0dc_9cgh.cpp:33:13: error: duplicate case value\n   33 |          \
    \   case 'I':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:19:13: note: previously\
    \ used here\n   19 |             case 'I':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:34:13:\
    \ error: duplicate case value\n   34 |             case 'O':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'O':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:35:13: error:\
    \ duplicate case value\n   35 |             case 'U':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:21:13: note: previously used here\n   21 |             case\
    \ 'U':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:40:13: error: duplicate\
    \ case value\n   40 |             case 'i':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:26:13:\
    \ note: previously used here\n   26 |             case 'i':\n      |         \
    \    ^~~~\n/tmp/tmp0dc_9cgh.cpp:41:13: error: duplicate case value\n   41 |  \
    \           case 'o':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:27:13: note:\
    \ previously used here\n   27 |             case 'o':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:42:13: error: duplicate case value\n   42 |             case\
    \ 'u':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:28:13: note: previously\
    \ used here\n   28 |             case 'u':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:73:13:\
    \ error: duplicate case value\n   73 |             case 'E':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:18:13: note: previously used here\n   18 |  \
    \           case 'E':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:74:13: error:\
    \ duplicate case value\n   74 |             case 'I':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:19:13: note: previously used here\n   19 |             case\
    \ 'I':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:75:13: error: duplicate\
    \ case value\n   75 |             case 'O':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:20:13:\
    \ note: previously used here\n   20 |             case 'O':\n      |         \
    \    ^~~~\n/tmp/tmp0dc_9cgh.cpp:76:13: error: duplicate case value\n   76 |  \
    \           case 'U':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:21:13: note:\
    \ previously used here\n   21 |             case 'U':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:79:13: error: duplicate case value\n   79 |             case\
    \ 'e':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:25:13: note: previously\
    \ used here\n   25 |             case 'e':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:80:13:\
    \ error: duplicate case value\n   80 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:81:13: error:\
    \ duplicate case value\n   81 |             case 'o':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:27:13: note: previously used here\n   27 |             case\
    \ 'o':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:82:13: error: duplicate\
    \ case value\n   82 |             case 'u':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:28:13:\
    \ note: previously used here\n   28 |             case 'u':\n      |         \
    \    ^~~~\n/tmp/tmp0dc_9cgh.cpp:85:13: error: duplicate case value\n   85 |  \
    \           case 'F':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:32:13: note:\
    \ previously used here\n   32 |             case 'F':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:86:13: error: duplicate case value\n   86 |             case\
    \ 'I':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:19:13: note: previously\
    \ used here\n   19 |             case 'I':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:87:13:\
    \ error: duplicate case value\n   87 |             case 'O':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'O':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:88:13: error:\
    \ duplicate case value\n   88 |             case 'U':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:21:13: note: previously used here\n   21 |             case\
    \ 'U':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:91:13: error: duplicate\
    \ case value\n   91 |             case 'f':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:39:13:\
    \ note: previously used here\n   39 |             case 'f':\n      |         \
    \    ^~~~\n/tmp/tmp0dc_9cgh.cpp:92:13: error: duplicate case value\n   92 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:26:13: note:\
    \ previously used here\n   26 |             case 'i':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:93:13: error: duplicate case value\n   93 |             case\
    \ 'o':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:27:13: note: previously\
    \ used here\n   27 |             case 'o':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:94:13:\
    \ error: duplicate case value\n   94 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:28:13: note: previously used here\n   28 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:97:13: error:\
    \ duplicate case value\n   97 |             case 'G':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:46:13: note: previously used here\n   46 |             case\
    \ 'G':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:98:13: error: duplicate\
    \ case value\n   98 |             case 'K':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:47:13:\
    \ note: previously used here\n   47 |             case 'K':\n      |         \
    \    ^~~~\n/tmp/tmp0dc_9cgh.cpp:99:13: error: duplicate case value\n   99 |  \
    \           case 'M':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:48:13: note:\
    \ previously used here\n   48 |             case 'M':\n      |             ^~~~\n\
    /tmp/tmp0dc_9cgh.cpp:100:13: error: duplicate case value\n  100 |            \
    \ case 'S':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:49:13: note: previously\
    \ used here\n   49 |             case 'S':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:103:13:\
    \ error: duplicate case value\n  103 |             case 'g':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:53:13: note: previously used here\n   53 |  \
    \           case 'g':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:104:13:\
    \ error: duplicate case value\n  104 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:54:13: note: previously used here\n   54 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:105:13:\
    \ error: duplicate case value\n  105 |             case 'm':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:55:13: note: previously used here\n   55 |  \
    \           case 'm':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:106:13:\
    \ error: duplicate case value\n  106 |             case 's':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:56:13: note: previously used here\n   56 |  \
    \           case 's':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:109:13:\
    \ error: duplicate case value\n  109 |             case 'H':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:60:13: note: previously used here\n   60 |  \
    \           case 'H':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:110:13:\
    \ error: duplicate case value\n  110 |             case 'J':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:61:13: note: previously used here\n   61 |  \
    \           case 'J':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:111:13:\
    \ error: duplicate case value\n  111 |             case 'P':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:62:13: note: previously used here\n   62 |  \
    \           case 'P':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:112:13:\
    \ error: duplicate case value\n  112 |             case 'T':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:63:13: note: previously used here\n   63 |  \
    \           case 'T':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:115:13:\
    \ error: duplicate case value\n  115 |             case 'h':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:67:13: note: previously used here\n   67 |  \
    \           case 'h':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:116:13:\
    \ error: duplicate case value\n  116 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:68:13: note: previously used here\n   68 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:117:13:\
    \ error: duplicate case value\n  117 |             case 'p':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:69:13: note: previously used here\n   69 |  \
    \           case 'p':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:118:13:\
    \ error: duplicate case value\n  118 |             case 't':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:70:13: note: previously used here\n   70 |  \
    \           case 't':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:121:13:\
    \ error: duplicate case value\n  121 |             case 'I':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'I':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:122:13:\
    \ error: duplicate case value\n  122 |             case 'O':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:20:13: note: previously used here\n   20 |  \
    \           case 'O':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:123:13:\
    \ error: duplicate case value\n  123 |             case 'U':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'U':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:126:13:\
    \ error: duplicate case value\n  126 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:127:13:\
    \ error: duplicate case value\n  127 |             case 'o':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'o':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:128:13:\
    \ error: duplicate case value\n  128 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:28:13: note: previously used here\n   28 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:131:13:\
    \ error: duplicate case value\n  131 |             case 'J':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:61:13: note: previously used here\n   61 |  \
    \           case 'J':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:132:13:\
    \ error: duplicate case value\n  132 |             case 'P':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:62:13: note: previously used here\n   62 |  \
    \           case 'P':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:133:13:\
    \ error: duplicate case value\n  133 |             case 'T':\n      |        \
    \     ^~~~\n/tmp/tmp0dc_9cgh.cpp:63:13: note: previously used here\n   63 |  \
    \           case 'T':\n      |             ^~~~\n/tmp/tmp0dc_9cgh.cpp:137:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n  137 | }\n      | ^\n\
    /tmp/tmp0dc_9cgh.cpp:136:17: error: expected \u2018:\u2019 before \u2018}\u2019\
    \ token\n  136 |             case 'j\n      |                 ^\n      |     \
    \            :\n  137 | }\n      | ~                \n/tmp/tmp0dc_9cgh.cpp:137:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  137 | }\n \
    \     | ^\n/tmp/tmp0dc_9cgh.cpp:138:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  138 | int main() {\n      |            ^\n\
    /tmp/tmp0dc_9cgh.cpp:145:1: error: expected \u2018}\u2019 at end of input\n  145\
    \ | }\n      | ^\n/tmp/tmp0dc_9cgh.cpp:15:29: note: to match this \u2018{\u2019\
    \n   15 |     for (auto &c : message) {\n      |                             ^\n\
    /tmp/tmp0dc_9cgh.cpp:145:1: error: expected \u2018}\u2019 at end of input\n  145\
    \ | }\n      | ^\n/tmp/tmp0dc_9cgh.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmp0dc_9cgh.cpp:145:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n  145 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('A' <= c && c <= 'Z') {\n            ans += c;\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans += 'A';\n        } else if (c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U') {\n            ans += 'a';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if ('A' <= c && c <= 'Z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c\
    \ == 'U') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        if ('A' <= c &&\
    \ c <= 'Z') {\n            ans[i] = c;\n        } else if (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'A';\n        }\
    \ else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n     \
    \       ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('A' <= c && c <= 'Z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u') {\n            ans[i] = 'A';\n        } else if (c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'a';\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        char\
    \ c = ans[i];\n        if ('A' <= c && c <= 'Z') {\n            ans[i] = c;\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[i] = 'A';\n        } else if (c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'a';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if ('A' <= c && c <= 'Z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnrbmj767.cpp:69:61: warning: missing terminating ' character\n\
    \   69 |         } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o\n    \
    \  |                                                             ^\n/tmp/tmpnrbmj767.cpp:69:61:\
    \ error: missing terminating ' character\n   69 |         } else if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o\n      |                                \
    \                             ^~\n/tmp/tmpnrbmj767.cpp: In function \u2018std::string\
    \ encode(std::string)\u2019:\n/tmp/tmpnrbmj767.cpp:70:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   70 | }\n      | ^\n/tmp/tmpnrbmj767.cpp:69:60:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   69 |         }\
    \ else if (c == 'a' || c == 'e' || c == 'i' || c == 'o\n      |              \
    \     ~                                        ^\n      |                    \
    \                                        )\n   70 | }\n      | ~             \
    \                                              \n/tmp/tmpnrbmj767.cpp:70:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   70 | }\n      | ^\n\
    /tmp/tmpnrbmj767.cpp:71:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   71 | int main() {\n      |            ^\n/tmp/tmpnrbmj767.cpp:78:1:\
    \ error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpnrbmj767.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpnrbmj767.cpp:78:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   78 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for(int i=0;i<message.length();i++) {\n        char c = message[i];\n\
    \        if(c>='a' && c<='z') {\n            ans += message[i];\n        }\n \
    \       else if(c>='A' && c<='Z') {\n            ans += message[i];\n        }\n\
    \        else if(c>='a' && c<='z') {\n            ans += message[i];\n       \
    \ }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n   \
    \     }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<='Z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='a' && c<='z') {\n            ans += message[i];\n\
    \        }\n        else if(c>='A' && c<\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_7b5peqx.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_7b5peqx.cpp:87:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   87 | }\n      | ^\n/tmp/tmp_7b5peqx.cpp:86:29: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   86 |         else if(c>='A' &&\
    \ c<\n      |                ~            ^\n      |                         \
    \    )\n   87 | }\n      | ~                            \n/tmp/tmp_7b5peqx.cpp:87:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   87 | }\n \
    \     | ^\n/tmp/tmp_7b5peqx.cpp:88:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   88 | int main() {\n      |            ^\n\
    /tmp/tmp_7b5peqx.cpp:95:1: error: expected \u2018}\u2019 at end of input\n   95\
    \ | }\n      | ^\n/tmp/tmp_7b5peqx.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmp_7b5peqx.cpp:95:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   95 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('A' <= c && c <= 'Z') {\n            ans += c;\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans += 'A';\n        } else if (c == 'y' || c == 'o' || c ==\
    \ 'u') {\n            ans += 'Y';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('A' <= c && c <= 'Z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u') {\n            ans[i] = 'A';\n        } else if (c == 'y'\
    \ || c == 'o' || c == 'u') {\n            ans[i] = 'Y';\n        }\n    }\n  \
    \  for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n      \
    \  if ('A' <= c && c <= 'Z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'y' || c == 'o' || c == 'u') {\n           \
    \ ans[i] = 'Y';\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        char c = ans[i];\n        if ('A' <= c && c <= 'Z') {\n         \
    \   ans[i] = c;\n        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') {\n            ans[i] = 'A';\n        } else if (c == 'y' || c\
    \ == 'o' || c == 'u') {\n            ans[i] = 'Y';\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if ('A'\
    \ <= c && c <= 'Z') {\n            ans[i] = c;\n        } else if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'A';\n\
    \        } else if (c == 'y' || c == 'o' || c == 'u') {\n            ans[i] =\
    \ 'Y';\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n     \
    \   char c = ans[i];\n        if ('A' <= c && c <= 'Z') {\n            ans[i]\
    \ = c;\n        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n            ans[i] = 'A';\n        } else if (c == 'y' || c == 'o' ||\
    \ c == 'u') {\n            ans[i] = 'Y';\n        }\n    }\n    for (int i = 0;\
    \ i < \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph_fawvil.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmph_fawvil.cpp:76:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   76 | }\n      | ^\n/tmp/tmph_fawvil.cpp:75:24: error: expected\
    \ \u2018;\u2019 before \u2018}\u2019 token\n   75 |     for (int i = 0; i <\n\
    \      |                        ^\n      |                        ;\n   76 | }\n\
    \      | ~                       \n/tmp/tmph_fawvil.cpp:76:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   76 | }\n      | ^\n/tmp/tmph_fawvil.cpp:75:24:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   75 |     for (int\
    \ i = 0; i <\n      |         ~              ^\n      |                      \
    \  )\n   76 | }\n      | ~                       \n/tmp/tmph_fawvil.cpp:76:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   76 | }\n \
    \     | ^\n/tmp/tmph_fawvil.cpp:76:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ (c - 'a');\n        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if(c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if(c == 'a') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpwz6hpvc0: /tmp/tmpwz6hpvc0.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            ans += c;\n        } else if (c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n            ans += 'A';\n        } else if (c ==\
    \ 'y' || c == 'i' || c == 'o' || c == 'u') {\n            ans += 'Y';\n      \
    \  } else {\n            ans += c;\n        }\n    }\n    for (int i = 0; i <\
    \ ans.size(); i++) {\n        if (ans[i] == 'A') {\n            ans[i] = 'a';\n\
    \        } else if (ans[i] == 'Y') {\n            ans[i] = 'y';\n        } else\
    \ if (ans[i] == 'a') {\n            ans[i] = 'e';\n        } else if (ans[i] ==\
    \ 'y') {\n            ans[i] = 'i';\n        } else if (ans[i] == 'e') {\n   \
    \         ans[i] = 'o';\n        } else if (ans[i] == 'i') {\n            ans[i]\
    \ = 'u';\n        } else if (ans[i] == 'o') {\n            ans[i] = 'u';\n   \
    \     } else if (ans[i] == 'u') {\n            ans[i] = 'u';\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpmwdmip31: /tmp/tmpmwdmip31.cpp:49: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for(int i = 0; i < ans.length(); i++) {\n        if(isalpha(ans[i]))\
    \ {\n            ans[i] = toupper(ans[i]);\n        }\n    }\n    for(int i =\
    \ 0; i < ans.length(); i++) {\n        if(isalpha(ans[i])) {\n            for(int\
    \ j = i + 1; j < ans.length(); j++) {\n                if(isalpha(ans[j])) {\n\
    \                    ans[i] = ans[j];\n                }\n            }\n    \
    \    }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n        if(isalpha(ans[i]))\
    \ {\n            for(int j = i + 1; j < ans.length(); j++) {\n               \
    \ if(isalpha(ans[j])) {\n                    ans[j] = ans[i];\n              \
    \  }\n            }\n        }\n    }\n    for(int i = 0; i < ans.length(); i++)\
    \ {\n        if(isalpha(ans[i])) {\n            for(int j = i + 1; j < ans.length();\
    \ j++) {\n                if(isalpha(ans[j])) {\n                    ans[j] =\
    \ ans[i];\n                }\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp5rkny9g4: /tmp/tmp5rkny9g4.cpp:51: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char &c : message) {\n        c = toupper(c);\n      \
    \  ans += c;\n    }\n    for (char &c : ans) {\n        c = tolower(c);\n    }\n\
    \    for (char &c : ans) {\n        if (c >= 'a' && c <= 'z') {\n            c\
    \ = tolower(c + 2);\n        }\n        if (c >= 'A' && c <= 'Z') {\n        \
    \    c = toupper(c + 2);\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpcgska27o: /tmp/tmpcgska27o.cpp:34: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &i : message) {\n        switch (i) {\n        case\
    \ 'a':\n            ans += 'A';\n            break;\n        case 'b':\n     \
    \       ans += 'B';\n            break;\n        case 'c':\n            ans +=\
    \ 'C';\n            break;\n        case 'd':\n            ans += 'D';\n     \
    \       break;\n        case 'e':\n            ans += 'E';\n            break;\n\
    \        case 'f':\n            ans += 'F';\n            break;\n        case\
    \ 'g':\n            ans += 'G';\n            break;\n        case 'h':\n     \
    \       ans += 'H';\n            break;\n        case 'i':\n            ans +=\
    \ 'I';\n            break;\n        case 'j':\n            ans += 'J';\n     \
    \       break;\n        case 'k':\n            ans += 'K';\n            break;\n\
    \        case 'l':\n            ans += 'L';\n            break;\n        case\
    \ 'm':\n            ans += 'M';\n            break;\n        case 'n':\n     \
    \       ans += 'N';\n            break;\n        case 'o':\n            ans +=\
    \ 'O';\n            break;\n        case 'p':\n            ans += 'P';\n     \
    \       break;\n        case 'q':\n            ans += 'Q';\n            break;\n\
    \        case 'r':\n            ans += 'R';\n            break;\n        case\
    \ 's':\n            ans += 'S';\n            break;\n        case 't':\n     \
    \       ans += 'T';\n            break;\n        case 'u':\n            ans +=\
    \ 'U';\n            break;\n        case 'v':\n            ans += 'V';\n     \
    \       break;\n        case 'w':\n            ans += 'W';\n            break;\n\
    \        case 'x':\n            ans += 'X';\n            break;\n        case\
    \ 'y':\n            ans += 'Y';\n            break;\n        case 'z':\n     \
    \       ans += 'Z';\n            break;\n        case 'A':\n            ans +=\
    \ 'a';\n            break;\n        case 'B':\n            ans += 'b';\n     \
    \       break;\n        case 'C':\n            ans += 'c';\n            break;\n\
    \        case 'D':\n            ans += 'd';\n            break;\n        case\
    \ 'E':\n            ans += 'e';\n            break;\n        case 'F':\n     \
    \       ans += 'f';\n            break;\n        case 'G':\n            ans +=\
    \ 'g';\n            break;\n        case 'H':\n            ans += 'h';\n     \
    \       break;\n        case 'I':\n            ans += 'i';\n            break;\n\
    \        case 'J':\n            ans += 'j';\n            break;\n        case\
    \ 'K':\n            ans += 'k';\n            break;\n        case 'L':\n     \
    \       ans += 'l';\n            break;\n        case 'M\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpt_8nkv5m.cpp:131:14: warning: missing terminating ' character\n\
    \  131 |         case 'M\n      |              ^\n/tmp/tmpt_8nkv5m.cpp:131:14:\
    \ error: missing terminating ' character\n  131 |         case 'M\n      |   \
    \           ^~\n/tmp/tmpt_8nkv5m.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpt_8nkv5m.cpp:132:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  132 | }\n      | ^\n/tmp/tmpt_8nkv5m.cpp:131:13: error: expected\
    \ \u2018:\u2019 before \u2018}\u2019 token\n  131 |         case 'M\n      | \
    \            ^\n      |             :\n  132 | }\n      | ~            \n/tmp/tmpt_8nkv5m.cpp:132:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  132 | }\n \
    \     | ^\n/tmp/tmpt_8nkv5m.cpp:133:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  133 | int main() {\n      |            ^\n\
    /tmp/tmpt_8nkv5m.cpp:140:1: error: expected \u2018}\u2019 at end of input\n  140\
    \ | }\n      | ^\n/tmp/tmpt_8nkv5m.cpp:15:29: note: to match this \u2018{\u2019\
    \n   15 |     for (auto &i : message) {\n      |                             ^\n\
    /tmp/tmpt_8nkv5m.cpp:140:1: error: expected \u2018}\u2019 at end of input\n  140\
    \ | }\n      | ^\n/tmp/tmpt_8nkv5m.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpt_8nkv5m.cpp:140:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n  140 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        switch (c) {\n         \
    \   case 'a':\n            case 'e':\n            case 'i':\n            case\
    \ 'o':\n            case 'u':\n                ans += 'A';\n                break;\n\
    \            case 'b':\n            case 'f':\n            case 'n':\n       \
    \     case 'r':\n            case 't':\n                ans += 'B';\n        \
    \        break;\n            case 'c':\n            case 'g':\n            case\
    \ 'j':\n            case 'k':\n            case 'm':\n                ans += 'C';\n\
    \                break;\n            case 'd':\n            case 'h':\n      \
    \      case 'j':\n            case 'k':\n            case 'n':\n             \
    \   ans += 'D';\n                break;\n            case 'e':\n            case\
    \ 'f':\n            case 'h':\n            case 'l':\n            case 'n':\n\
    \                ans += 'E';\n                break;\n            case 'f':\n\
    \            case 'g':\n            case 'j':\n            case 'k':\n       \
    \     case 'n':\n                ans += 'F';\n                break;\n       \
    \     case 'g':\n            case 'h':\n            case 'j':\n            case\
    \ 'k':\n            case 'n':\n                ans += 'G';\n                break;\n\
    \            case 'h':\n            case 'j':\n            case 'k':\n       \
    \     case 'n':\n                ans += 'H';\n                break;\n       \
    \     case 'i':\n            case 'j':\n            case 'k':\n            case\
    \ 'l':\n            case 'm':\n                ans += 'I';\n                break;\n\
    \            case 'i':\n            case 'j':\n            case 'k':\n       \
    \     case 'l':\n            case 'n':\n                ans += 'J';\n        \
    \        break;\n            case 'i':\n            case 'j':\n            case\
    \ 'k':\n            case 'l':\n            case 'o':\n                ans += 'K';\n\
    \                break;\n            case 'i':\n            case 'j':\n      \
    \      case 'k':\n            case 'l':\n            case 'p':\n             \
    \   ans += 'L';\n                break;\n            case 'i':\n            case\
    \ 'j':\n            case 'k':\n            case 'l':\n            case 'q':\n\
    \                ans += 'M';\n                break;\n            case 'i':\n\
    \            case 'j':\n            case 'k':\n            case 'l':\n       \
    \     case 'r':\n                ans += 'N';\n                break;\n       \
    \     case 'i':\n            case 'j':\n            case 'k':\n            case\
    \ 'l':\n            case 's':\n                ans += 'O';\n                break;\n\
    \            case 'i':\n            case 'j':\n            case 'k':\n       \
    \     case 'l':\n            case 't':\n                ans += 'P';\n        \
    \        break;\n            case 'i':\n            case 'j':\n            case\
    \ 'k':\n            case 'l':\n            case 'u':\n                ans += 'Q';\n\
    \                break;\n            case 'i':\n            case 'j':\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp72pu_jw2.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp72pu_jw2.cpp:40:13: error: duplicate case value\n   40 |          \
    \   case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note: previously\
    \ used here\n   33 |             case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:41:13:\
    \ error: duplicate case value\n   41 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:42:13: error:\
    \ duplicate case value\n   42 |             case 'n':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:26:13: note: previously used here\n   26 |             case\
    \ 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:45:13: error: duplicate\
    \ case value\n   45 |             case 'e':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:18:13:\
    \ note: previously used here\n   18 |             case 'e':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:46:13: error: duplicate case value\n   46 |  \
    \           case 'f':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:25:13: note:\
    \ previously used here\n   25 |             case 'f':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:47:13: error: duplicate case value\n   47 |             case\
    \ 'h':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:39:13: note: previously\
    \ used here\n   39 |             case 'h':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:49:13:\
    \ error: duplicate case value\n   49 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:52:13: error:\
    \ duplicate case value\n   52 |             case 'f':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:25:13: note: previously used here\n   25 |             case\
    \ 'f':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:53:13: error: duplicate\
    \ case value\n   53 |             case 'g':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:32:13:\
    \ note: previously used here\n   32 |             case 'g':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:54:13: error: duplicate case value\n   54 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note:\
    \ previously used here\n   33 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:55:13: error: duplicate case value\n   55 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously\
    \ used here\n   34 |             case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:56:13:\
    \ error: duplicate case value\n   56 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:59:13: error:\
    \ duplicate case value\n   59 |             case 'g':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:32:13: note: previously used here\n   32 |             case\
    \ 'g':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:60:13: error: duplicate\
    \ case value\n   60 |             case 'h':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:39:13:\
    \ note: previously used here\n   39 |             case 'h':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:61:13: error: duplicate case value\n   61 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note:\
    \ previously used here\n   33 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:62:13: error: duplicate case value\n   62 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously\
    \ used here\n   34 |             case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:63:13:\
    \ error: duplicate case value\n   63 |             case 'n':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:66:13: error:\
    \ duplicate case value\n   66 |             case 'h':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:39:13: note: previously used here\n   39 |             case\
    \ 'h':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:67:13: error: duplicate\
    \ case value\n   67 |             case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13:\
    \ note: previously used here\n   33 |             case 'j':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:68:13: error: duplicate case value\n   68 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note:\
    \ previously used here\n   34 |             case 'k':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:69:13: error: duplicate case value\n   69 |             case\
    \ 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:26:13: note: previously\
    \ used here\n   26 |             case 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:72:13:\
    \ error: duplicate case value\n   72 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:73:13: error:\
    \ duplicate case value\n   73 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:74:13: error: duplicate\
    \ case value\n   74 |             case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13:\
    \ note: previously used here\n   34 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:75:13: error: duplicate case value\n   75 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note:\
    \ previously used here\n   48 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:76:13: error: duplicate case value\n   76 |             case\
    \ 'm':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:35:13: note: previously\
    \ used here\n   35 |             case 'm':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:79:13:\
    \ error: duplicate case value\n   79 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:80:13: error:\
    \ duplicate case value\n   80 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:81:13: error: duplicate\
    \ case value\n   81 |             case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13:\
    \ note: previously used here\n   34 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:82:13: error: duplicate case value\n   82 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note:\
    \ previously used here\n   48 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:83:13: error: duplicate case value\n   83 |             case\
    \ 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:26:13: note: previously\
    \ used here\n   26 |             case 'n':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:86:13:\
    \ error: duplicate case value\n   86 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:87:13: error:\
    \ duplicate case value\n   87 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:88:13: error: duplicate\
    \ case value\n   88 |             case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13:\
    \ note: previously used here\n   34 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:89:13: error: duplicate case value\n   89 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note:\
    \ previously used here\n   48 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:90:13: error: duplicate case value\n   90 |             case\
    \ 'o':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:20:13: note: previously\
    \ used here\n   20 |             case 'o':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:93:13:\
    \ error: duplicate case value\n   93 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:94:13: error:\
    \ duplicate case value\n   94 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:95:13: error: duplicate\
    \ case value\n   95 |             case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13:\
    \ note: previously used here\n   34 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp72pu_jw2.cpp:96:13: error: duplicate case value\n   96 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note:\
    \ previously used here\n   48 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmp72pu_jw2.cpp:100:13: error: duplicate case value\n  100 |            \
    \ case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously\
    \ used here\n   19 |             case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:101:13:\
    \ error: duplicate case value\n  101 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:102:13:\
    \ error: duplicate case value\n  102 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:103:13:\
    \ error: duplicate case value\n  103 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note: previously used here\n   48 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:107:13:\
    \ error: duplicate case value\n  107 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:108:13:\
    \ error: duplicate case value\n  108 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:109:13:\
    \ error: duplicate case value\n  109 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:110:13:\
    \ error: duplicate case value\n  110 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note: previously used here\n   48 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:111:13:\
    \ error: duplicate case value\n  111 |             case 'r':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:27:13: note: previously used here\n   27 |  \
    \           case 'r':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:114:13:\
    \ error: duplicate case value\n  114 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:115:13:\
    \ error: duplicate case value\n  115 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:116:13:\
    \ error: duplicate case value\n  116 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:117:13:\
    \ error: duplicate case value\n  117 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note: previously used here\n   48 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:121:13:\
    \ error: duplicate case value\n  121 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:122:13:\
    \ error: duplicate case value\n  122 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:123:13:\
    \ error: duplicate case value\n  123 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:124:13:\
    \ error: duplicate case value\n  124 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note: previously used here\n   48 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:125:13:\
    \ error: duplicate case value\n  125 |             case 't':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:28:13: note: previously used here\n   28 |  \
    \           case 't':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:128:13:\
    \ error: duplicate case value\n  128 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:129:13:\
    \ error: duplicate case value\n  129 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:130:13:\
    \ error: duplicate case value\n  130 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:131:13:\
    \ error: duplicate case value\n  131 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:48:13: note: previously used here\n   48 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:132:13:\
    \ error: duplicate case value\n  132 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:135:13:\
    \ error: duplicate case value\n  135 |             case 'i':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:19:13: note: previously used here\n   19 |  \
    \           case 'i':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:136:13:\
    \ error: duplicate case value\n  136 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp72pu_jw2.cpp:33:13: note: previously used here\n   33 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp72pu_jw2.cpp:137:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n  137 | }\n      | ^\n\
    /tmp/tmp72pu_jw2.cpp:138:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  138 | int main() {\n      |            ^\n/tmp/tmp72pu_jw2.cpp:145:1:\
    \ error: expected \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmp72pu_jw2.cpp:15:29:\
    \ note: to match this \u2018{\u2019\n   15 |     for (auto &c : message) {\n \
    \     |                             ^\n/tmp/tmp72pu_jw2.cpp:145:1: error: expected\
    \ \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmp72pu_jw2.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp72pu_jw2.cpp:145:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  145 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        if (c >= 'a' && c <= 'z')\
    \ {\n            ans += c;\n        } else if (c >= 'A' && c <= 'Z') {\n     \
    \       ans += c;\n        } else if (c >= '0' && c <= '9') {\n            ans\
    \ += c;\n        } else if (c == '.') {\n            ans += c;\n        } else\
    \ if (c == '!') {\n            ans += c;\n        } else if (c == '?') {\n   \
    \         ans += c;\n        } else if (c == '-') {\n            ans += c;\n \
    \       } else if (c == '_') {\n            ans += c;\n        } else if (c ==\
    \ '/') {\n            ans += c;\n        } else if (c == '(') {\n            ans\
    \ += c;\n        } else if (c == ')') {\n            ans += c;\n        } else\
    \ if (c == '+') {\n            ans += c;\n        } else if (c == '=') {\n   \
    \         ans += c;\n        } else if (c == '[') {\n            ans += c;\n \
    \       } else if (c == ']') {\n            ans += c;\n        } else if (c ==\
    \ '{') {\n            ans += c;\n        } else if (c == '}') {\n            ans\
    \ += c;\n        } else if (c == '%') {\n            ans += c;\n        } else\
    \ if (c == '&') {\n            ans += c;\n        } else if (c == '*') {\n   \
    \         ans += c;\n        } else if (c == '(') {\n            ans += c;\n \
    \       } else if (c == ')') {\n            ans += c;\n        } else if (c ==\
    \ '<') {\n            ans += c;\n        } else if (c == '>') {\n            ans\
    \ += c;\n        } else if (c == '?') {\n            ans += c;\n        } else\
    \ if (c == '!') {\n            ans += c;\n        } else if (c == '.') {\n   \
    \         ans += c;\n        } else if (c == '/') {\n            ans += c;\n \
    \       } else if (c == '@') {\n            ans += c;\n        } else if (c ==\
    \ '[') {\n            ans += c;\n        } else if (c == ']') {\n            ans\
    \ += c;\n        } else if (c == '{') {\n            ans += c;\n        } else\
    \ if (c == '}') {\n            ans += c;\n        } else if (c == '^') {\n   \
    \         ans += c;\n        } else if (c == '~') {\n            ans += c;\n \
    \       } else if (c == '|') {\n            ans += c;\n        } else if (c ==\
    \ '\\\\') {\n            ans += c;\n        } else if (c == '\"') {\n        \
    \    ans += c;\n        } else if (c == '$') {\n            ans += c;\n      \
    \  } else if (c == '%') {\n            ans += c;\n        } else if (c == '&')\
    \ {\n            ans += c;\n        } else if (c == '*') {\n            ans +=\
    \ c;\n        } else if (c == '(') {\n            ans += c;\n        } else if\
    \ (c == ')') {\n            ans += c;\n        } else if (\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9wo2ounm.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp9wo2ounm.cpp:105:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  105 | }\n      | ^\n/tmp/tmp9wo2ounm.cpp:104:20: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n  104 |         } else if (\n    \
    \  |                   ~^\n      |                    )\n  105 | }\n      | ~\
    \                   \n/tmp/tmp9wo2ounm.cpp:105:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  105 | }\n      | ^\n/tmp/tmp9wo2ounm.cpp:106:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  106 | int main() {\n      |            ^\n/tmp/tmp9wo2ounm.cpp:113:1: error:\
    \ expected \u2018}\u2019 at end of input\n  113 | }\n      | ^\n/tmp/tmp9wo2ounm.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp9wo2ounm.cpp:113:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  113 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ (c - 'a');\n        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if(c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if(c == 'a') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    for(int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n     \
    \   if(c == 'a' || c == 'A') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    for(int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n     \
    \   if(c == 'A') {\n            ans[i] = 'a';\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpwbkg6gg0: /tmp/tmpwbkg6gg0.cpp:47: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ (c - 'a');\n        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        if(c == 'A') {\n            ans[i] = 'a';\n\
    \        } else if(c == 'a') {\n            ans[i] = 'A';\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpuieqp1gz: /tmp/tmpuieqp1gz.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded;\n    for(int i = 0; i < message.length(); i++) {\n        char c =\
    \ message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n            encoded += c;\n        }\n        else {\n            char\
    \ prev = encoded[encoded.length() - 1];\n            char next = encoded[encoded.length()\
    \ - 2];\n            if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\
    \ {\n                encoded += c;\n            }\n            else {\n      \
    \          char replacement = prev + next;\n                encoded = encoded.substr(0,\
    \ encoded.length() - 1) + replacement + encoded.substr(encoded.length() - 1);\n\
    \            }\n        }\n    }\n    return encoded;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 18446744073709551615) > this->size()\
    \ (which is 0)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        if\
    \ (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n\
    \    for (int i = 0; i < ans.size(); i++) {\n        if (islower(ans[i])) {\n\
    \            ans[i] = toupper(ans[i]);\n        }\n    }\n    for (int i = 0;\
    \ i < ans.size(); i++) {\n        if (isalpha(ans[i])) {\n            ans[i] =\
    \ ans[i] - 'A' + 26;\n        }\n    }\n    for (int i = 0; i < ans.size(); i++)\
    \ {\n        if (isupper(ans[i])) {\n            ans[i] = tolower(ans[i]);\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpw3f_3l8_: /tmp/tmpw3f_3l8_.cpp:42: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (tolower(c) == c)\
    \ ? toupper(c) : tolower(c);\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] ==\
    \ 'o' || ans[i] == 'u') {\n            ans[i] = ans[i - 1];\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'a' || ans[i]\
    \ == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n            ans[i]\
    \ = ans[ans.length() - 1 - i];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[ans.length() - 1 - i];\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[ans.length() - 1 - i];\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'a' || ans[i] ==\
    \ 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n            ans[i]\
    \ = ans[ans.length() - 1 - i];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[ans.length() - 1 - i];\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n            ans[i] = ans[ans.length() - 1 - i];\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == 'a' || ans[i] ==\
    \ 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n            ans[i]\
    \ = ans[ans.length() - 1 - i];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            ans[i] = ans[ans.length() - 1 - i];\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u')\
    \ {\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjh4y7n3y.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpjh4y7n3y.cpp:66:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   66 | int main() {\n      |            ^\n/tmp/tmpjh4y7n3y.cpp:73:1:\
    \ error: expected \u2018}\u2019 at end of input\n   73 | }\n      | ^\n/tmp/tmpjh4y7n3y.cpp:63:44:\
    \ note: to match this \u2018{\u2019\n   63 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmpjh4y7n3y.cpp:73:1:\
    \ error: expected \u2018}\u2019 at end of input\n   73 | }\n      | ^\n/tmp/tmpjh4y7n3y.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpjh4y7n3y.cpp:73:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   73 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isalpha(c) ? toupper(c)\
    \ : c);\n    }\n    for (char c : ans) {\n        if (isalpha(c)) {\n        \
    \    ans[ans.find(c)] = toupper(c);\n        }\n    }\n    for (int i = 0; i <\
    \ ans.size(); i++) {\n        if (isalpha(ans[i])) {\n            ans[i] = toupper(ans[i]);\n\
    \        }\n    }\n    for (int i = 0; i < ans.size(); i++) {\n        if (isalpha(ans[i]))\
    \ {\n            ans[i] = tolower(ans[i]);\n        }\n    }\n    for (int i =\
    \ 0; i < ans.size(); i++) {\n        if (isalpha(ans[i])) {\n            ans[i]\
    \ = toupper(ans[i]);\n        }\n    }\n    for (int i = 0; i < ans.size(); i++)\
    \ {\n        if (isalpha(ans[i])) {\n            ans[i] = tolower(ans[i]);\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpft8mq1_c: /tmp/tmpft8mq1_c.cpp:47: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (char c : ans) {\n        if (c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c) + 2]\
    \ = tolower(c);\n        }\n    }\n    for (char c : ans) {\n        if (c ==\
    \ 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpw8kvhlgx: /tmp/tmpw8kvhlgx.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else if(c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans += c;\n        }\n\
    \        else {\n            ans += 'A';\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpwysvsap5: /tmp/tmpwysvsap5.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        if (message[i]\
    \ >= 'a' && message[i] <= 'z') {\n            ans += message[i];\n        } else\
    \ if (message[i] >= 'A' && message[i] <= 'Z') {\n            ans += message[i];\n\
    \        } else if (message[i] >= '0' && message[i] <= '9') {\n            ans\
    \ += message[i];\n        } else if (message[i] == '.') {\n            ans +=\
    \ message[i];\n        } else if (message[i] == '!') {\n            ans += message[i];\n\
    \        } else if (message[i] == '?') {\n            ans += message[i];\n   \
    \     } else if (message[i] == '-') {\n            ans += message[i];\n      \
    \  } else if (message[i] == '_') {\n            ans += message[i];\n        }\
    \ else if (message[i] == '/') {\n            ans += message[i];\n        } else\
    \ if (message[i] == '(') {\n            ans += message[i];\n        } else if\
    \ (message[i] == ')') {\n            ans += message[i];\n        } else if (message[i]\
    \ == '+') {\n            ans += message[i];\n        } else if (message[i] ==\
    \ '=') {\n            ans += message[i];\n        } else if (message[i] == '[')\
    \ {\n            ans += message[i];\n        } else if (message[i] == ']') {\n\
    \            ans += message[i];\n        } else if (message[i] == '%') {\n   \
    \         ans += message[i];\n        } else if (message[i] == '&') {\n      \
    \      ans += message[i];\n        } else if (message[i] == '*') {\n         \
    \   ans += message[i];\n        } else if (message[i] == '^') {\n            ans\
    \ += message[i];\n        } else if (message[i] == '~') {\n            ans +=\
    \ message[i];\n        } else if (message[i] == '<') {\n            ans += message[i];\n\
    \        } else if (message[i] == '>') {\n            ans += message[i];\n   \
    \     } else if (message[i] == '|') {\n            ans += message[i];\n      \
    \  } else if (message[i] == '{') {\n            ans += message[i];\n        }\
    \ else if (message[i] == '}') {\n            ans += message[i];\n        } else\
    \ if (message[i] == '\\\\') {\n            ans += message[i];\n        } else\
    \ if (message[i] == '\"') {\n            ans += message[i];\n        } else if\
    \ (message[i] == '$') {\n            ans += message[i];\n        } else if (message[i]\
    \ == '@') {\n            ans += message[i];\n        } else if (message[i] ==\
    \ '!') {\n            ans += message[i];\n        } else if (message[i] == '?')\
    \ {\n            ans += message[i];\n        } else if (message[i] == '.') {\n\
    \            ans += message[i];\n        } else if (message[i] == '-') {\n   \
    \         ans += message[i];\n        } else if (message[i] == '_') {\n      \
    \      ans += message[i];\n        } else if (message[i] == '/') {\n         \
    \   ans += message[i];\n        } else if (message[i] == '(') {\n            ans\
    \ += message[i];\n        } else if (message[i] == ')') {\n            ans +=\
    \ message[i];\n\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpptrccaz8.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpptrccaz8.cpp:92:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   92 | int main() {\n      |            ^\n/tmp/tmpptrccaz8.cpp:99:1:\
    \ error: expected \u2018}\u2019 at end of input\n   99 | }\n      | ^\n/tmp/tmpptrccaz8.cpp:15:48:\
    \ note: to match this \u2018{\u2019\n   15 |     for (int i = 0; i < message.length();\
    \ i++) {\n      |                                                ^\n/tmp/tmpptrccaz8.cpp:99:1:\
    \ error: expected \u2018}\u2019 at end of input\n   99 | }\n      | ^\n/tmp/tmpptrccaz8.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpptrccaz8.cpp:99:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   99 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        } else {\n            ans += 'A' +\
    \ c - 'a';\n        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n  \
    \      char c = ans[i];\n        if(c == 'A' || c == 'E' || c == 'I' || c == 'O'\
    \ || c == 'U') {\n            ans[i] = 'a';\n        } else {\n            ans[i]\
    \ = 'A';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmplpvhr7uk: /tmp/tmplpvhr7uk.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if('A' <= c && c <= 'Z') {\n            ans += c;\n \
    \       } else {\n            ans += 'A' + (c - 'A');\n        }\n    }\n    for(int\
    \ i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        if('A' <=\
    \ c && c <= 'Z') {\n            ans[i] = c;\n        } else {\n            ans[i]\
    \ = 'A' + (c - 'A');\n        }\n    }\n    for(int i = 0; i < ans.length(); i++)\
    \ {\n        char c = ans[i];\n        if('A' <= c && c <= 'Z') {\n          \
    \  ans[i] = c;\n        } else {\n            ans[i] = 'A' + (c - 'A');\n    \
    \    }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpuvt679sl: /tmp/tmpuvt679sl.cpp:43: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        ans += (c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c\
    \ <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : 'a'));\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        char c = ans[i];\n        ans[i] = ((c\
    \ >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9')\
    \ ? c : 'a')));\n    }\n    for (int i = 0; i < ans.length(); i++) {\n       \
    \ char c = ans[i];\n        ans[i] = ((c >= 'a' && c <= 'z') ? c : ((c >= 'A'\
    \ && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : 'a')));\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n        ans[i] =\
    \ ((c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c\
    \ <= '9') ? c : 'a')));\n    }\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        char c = ans[i];\n        ans[i] = ((c >= 'a' && c <= 'z') ? c : ((c\
    \ >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : 'a')));\n    }\n   \
    \ for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n       \
    \ ans[i] = ((c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >=\
    \ '0' && c <= '9') ? c : 'a')));\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        ans[i] = ((c >= 'a' && c <= 'z') ?\
    \ c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : 'a')));\n  \
    \  }\n    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        ans[i] = ((c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z') ? c :\
    \ ((c >= '0' && c <= '9') ? c : 'a\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyn1qq7_6.cpp:45:108: warning: missing terminating ' character\n\
    \   45 |         ans[i] = ((c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z')\
    \ ? c : ((c >= '0' && c <= '9') ? c : 'a\n      |                            \
    \                                                                            \
    \    ^\n/tmp/tmpyn1qq7_6.cpp:45:108: error: missing terminating ' character\n\
    \   45 |         ans[i] = ((c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z')\
    \ ? c : ((c >= '0' && c <= '9') ? c : 'a\n      |                            \
    \                                                                            \
    \    ^~\n/tmp/tmpyn1qq7_6.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpyn1qq7_6.cpp:46:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   46 | }\n      | ^\n/tmp/tmpyn1qq7_6.cpp:45:107: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   45 |         ans[i] = ((c >= 'a'\
    \ && c <= 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c\
    \ : 'a\n      |                                                              \
    \                ~                            ^\n      |                     \
    \                                                                            \
    \          )\n   46 | }\n      | ~                                           \
    \                                                               \n/tmp/tmpyn1qq7_6.cpp:45:107:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   45 |         ans[i]\
    \ = ((c >= 'a' && c <= 'z') ? c : ((c >= 'A' && c <= 'Z') ? c : ((c >= '0' &&\
    \ c <= '9') ? c : 'a\n      |                                                ~\
    \                                                          ^\n      |        \
    \                                                                            \
    \                       )\n   46 | }\n      | ~                              \
    \                                                                            \n\
    /tmp/tmpyn1qq7_6.cpp:45:107: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   45 |         ans[i] = ((c >= 'a' && c <= 'z') ? c : ((c >= 'A' &&\
    \ c <= 'Z') ? c : ((c >= '0' && c <= '9') ? c : 'a\n      |                  ~\
    \                                                                            \
    \            ^\n      |                                                      \
    \                                                     )\n   46 | }\n      | ~\
    \                                                                            \
    \                              \n/tmp/tmpyn1qq7_6.cpp:47:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   47 | int main() {\n     \
    \ |            ^\n/tmp/tmpyn1qq7_6.cpp:54:1: error: expected \u2018}\u2019 at\
    \ end of input\n   54 | }\n      | ^\n/tmp/tmpyn1qq7_6.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmpyn1qq7_6.cpp:54:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   54 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if ('A' <= c && c <= 'Z') {\n            ans += c;\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans += 'A';\n        } else if (c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U') {\n            ans += 'a';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if ('A' <= c && c <= 'Z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[i]\
    \ = 'A';\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c\
    \ == 'U') {\n            ans[i] = 'a';\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        char c = ans[i];\n        if ('A' <= c &&\
    \ c <= 'Z') {\n            ans[i] = c;\n        } else if (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            ans[i] = 'A';\n        }\
    \ else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n     \
    \       ans[i] = 'a';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        char c = ans[i];\n        if ('A' <= c && c <= 'Z') {\n    \
    \        ans[i] = c;\n        } else if (c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u') {\n            ans[i] = 'A';\n        } else if (c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'a';\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        char\
    \ c = ans[i];\n        if ('A' <= c && c <= 'Z') {\n            ans[i] = c;\n\
    \        } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ {\n            ans[i] = 'A';\n        } else if (c == 'A' || c == 'E' || c ==\
    \ 'I' || c == 'O' || c == 'U') {\n            ans[i] = 'a';\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n    \
    \    if ('A' <= c && c <= 'Z') {\n            ans[i] = c;\n        } else if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp93o1hu_c.cpp:69:61: warning: missing terminating ' character\n\
    \   69 |         } else if (c == 'a' || c == 'e' || c == 'i' || c == 'o\n    \
    \  |                                                             ^\n/tmp/tmp93o1hu_c.cpp:69:61:\
    \ error: missing terminating ' character\n   69 |         } else if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o\n      |                                \
    \                             ^~\n/tmp/tmp93o1hu_c.cpp: In function \u2018std::string\
    \ encode(std::string)\u2019:\n/tmp/tmp93o1hu_c.cpp:70:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   70 | }\n      | ^\n/tmp/tmp93o1hu_c.cpp:69:60:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   69 |         }\
    \ else if (c == 'a' || c == 'e' || c == 'i' || c == 'o\n      |              \
    \     ~                                        ^\n      |                    \
    \                                        )\n   70 | }\n      | ~             \
    \                                              \n/tmp/tmp93o1hu_c.cpp:70:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   70 | }\n      | ^\n\
    /tmp/tmp93o1hu_c.cpp:71:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   71 | int main() {\n      |            ^\n/tmp/tmp93o1hu_c.cpp:78:1:\
    \ error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmp93o1hu_c.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp93o1hu_c.cpp:78:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   78 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        ans += (isalpha(c)) ? toupper(c)\
    \ : c;\n    }\n    for (auto &c : ans) {\n        if (isalpha(c)) {\n        \
    \    ans[ans.find(c) + 2] = tolower(c);\n        }\n    }\n    for (auto &c :\
    \ ans) {\n        if (isalpha(c)) {\n            ans[ans.find(c) + 1] = toupper(c);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpm9bhaa5d: /tmp/tmpm9bhaa5d.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += tolower(c);\n        }\n    }\n    for(int i = 0; i < ans.length(); i++)\
    \ {\n        char c = ans[i];\n        if(c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u') {\n            ans[i] = tolower(ans[i+1]);\n        }\n\
    \    }\n    for(int i = 0; i < ans.length(); i++) {\n        char c = ans[i];\n\
    \        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n    \
    \        ans[i] = toupper(ans[i+1]);\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp5x4yxnk8: /tmp/tmp5x4yxnk8.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c: message) {\n        ans += (isupper(c) ? tolower(c)\
    \ : toupper(c));\n    }\n    for (auto &c: ans) {\n        if (c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c) + 2]\
    \ = tolower(c);\n        }\n    }\n    for (auto &c: ans) {\n        if (c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    for (auto &c: ans) {\n        if (c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans[ans.find(c)\
    \ + 2] = tolower(c);\n        }\n    }\n    for (auto &c: ans) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c)\
    \ + 2] = toupper(c);\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmptupf35_h: /tmp/tmptupf35_h.cpp:42: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &c : message) {\n        switch (c) {\n         \
    \   case 'a':\n            case 'e':\n            case 'i':\n            case\
    \ 'o':\n            case 'u':\n                ans += 'A';\n                break;\n\
    \            case 'b':\n            case 'f':\n            case 'k':\n       \
    \     case 'p':\n            case 's':\n                ans += 'B';\n        \
    \        break;\n            case 'c':\n            case 'd':\n            case\
    \ 'g':\n            case 'j':\n            case 'z':\n                ans += 'C';\n\
    \                break;\n            case 'e':\n            case 'f':\n      \
    \      case 'h':\n            case 'j':\n            case 'k':\n            case\
    \ 'l':\n                ans += 'D';\n                break;\n            case\
    \ 'f':\n            case 'g':\n            case 'h':\n            case 'k':\n\
    \            case 'l':\n                ans += 'E';\n                break;\n\
    \            case 'g':\n            case 'h':\n            case 'j':\n       \
    \     case 'k':\n            case 'l':\n                ans += 'F';\n        \
    \        break;\n            case 'h':\n            case 'j':\n            case\
    \ 'k':\n            case 'l':\n                ans += 'G';\n                break;\n\
    \            case 'i':\n            case 'j':\n            case 'k':\n       \
    \     case 'l':\n                ans += 'H';\n                break;\n       \
    \     case 'j':\n            case 'k':\n            case 'l':\n              \
    \  ans += 'I';\n                break;\n            case 'k':\n            case\
    \ 'l':\n                ans += 'J';\n                break;\n            case\
    \ 'l':\n                ans += 'K';\n                break;\n            case\
    \ 'm':\n                ans += 'M';\n                break;\n            case\
    \ 'n':\n                ans += 'N';\n                break;\n            case\
    \ 'o':\n                ans += 'O';\n                break;\n            case\
    \ 'p':\n                ans += 'P';\n                break;\n            case\
    \ 'q':\n                ans += 'Q';\n                break;\n            case\
    \ 'r':\n                ans += 'R';\n                break;\n            case\
    \ 's':\n                ans += 'S';\n                break;\n            case\
    \ 't':\n                ans += 'T';\n                break;\n            case\
    \ 'u':\n                ans += 'U';\n                break;\n            case\
    \ 'v':\n                ans += 'V';\n                break;\n            case\
    \ 'w':\n                ans += 'W';\n                break;\n            case\
    \ 'x':\n                ans += 'X';\n                break;\n            case\
    \ 'y':\n                ans += 'Y';\n                break;\n            case\
    \ 'z':\n                ans += 'Z';\n                break;\n            default:\n\
    \                ans += c;\n                break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_ij0x9mx.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_ij0x9mx.cpp:38:13: error: duplicate case value\n   38 |          \
    \   case 'e':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:18:13: note: previously\
    \ used here\n   18 |             case 'e':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:39:13:\
    \ error: duplicate case value\n   39 |             case 'f':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:25:13: note: previously used here\n   25 |  \
    \           case 'f':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:41:13: error:\
    \ duplicate case value\n   41 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:34:13: note: previously used here\n   34 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:42:13: error: duplicate\
    \ case value\n   42 |             case 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:26:13:\
    \ note: previously used here\n   26 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp_ij0x9mx.cpp:46:13: error: duplicate case value\n   46 |  \
    \           case 'f':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:25:13: note:\
    \ previously used here\n   25 |             case 'f':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:47:13: error: duplicate case value\n   47 |             case\
    \ 'g':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:33:13: note: previously\
    \ used here\n   33 |             case 'g':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:48:13:\
    \ error: duplicate case value\n   48 |             case 'h':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:40:13: note: previously used here\n   40 |  \
    \           case 'h':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:49:13: error:\
    \ duplicate case value\n   49 |             case 'k':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:26:13: note: previously used here\n   26 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:50:13: error: duplicate\
    \ case value\n   50 |             case 'l':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:43:13:\
    \ note: previously used here\n   43 |             case 'l':\n      |         \
    \    ^~~~\n/tmp/tmp_ij0x9mx.cpp:53:13: error: duplicate case value\n   53 |  \
    \           case 'g':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:33:13: note:\
    \ previously used here\n   33 |             case 'g':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:54:13: error: duplicate case value\n   54 |             case\
    \ 'h':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:40:13: note: previously\
    \ used here\n   40 |             case 'h':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:55:13:\
    \ error: duplicate case value\n   55 |             case 'j':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:34:13: note: previously used here\n   34 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:56:13: error:\
    \ duplicate case value\n   56 |             case 'k':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:26:13: note: previously used here\n   26 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:57:13: error: duplicate\
    \ case value\n   57 |             case 'l':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:43:13:\
    \ note: previously used here\n   43 |             case 'l':\n      |         \
    \    ^~~~\n/tmp/tmp_ij0x9mx.cpp:60:13: error: duplicate case value\n   60 |  \
    \           case 'h':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:40:13: note:\
    \ previously used here\n   40 |             case 'h':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:61:13: error: duplicate case value\n   61 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:34:13: note: previously\
    \ used here\n   34 |             case 'j':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:62:13:\
    \ error: duplicate case value\n   62 |             case 'k':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:26:13: note: previously used here\n   26 |  \
    \           case 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:63:13: error:\
    \ duplicate case value\n   63 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:43:13: note: previously used here\n   43 |             case\
    \ 'l':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:66:13: error: duplicate\
    \ case value\n   66 |             case 'i':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:19:13:\
    \ note: previously used here\n   19 |             case 'i':\n      |         \
    \    ^~~~\n/tmp/tmp_ij0x9mx.cpp:67:13: error: duplicate case value\n   67 |  \
    \           case 'j':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:34:13: note:\
    \ previously used here\n   34 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:68:13: error: duplicate case value\n   68 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:26:13: note: previously\
    \ used here\n   26 |             case 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:69:13:\
    \ error: duplicate case value\n   69 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:43:13: note: previously used here\n   43 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:72:13: error:\
    \ duplicate case value\n   72 |             case 'j':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:34:13: note: previously used here\n   34 |             case\
    \ 'j':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:73:13: error: duplicate\
    \ case value\n   73 |             case 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:26:13:\
    \ note: previously used here\n   26 |             case 'k':\n      |         \
    \    ^~~~\n/tmp/tmp_ij0x9mx.cpp:74:13: error: duplicate case value\n   74 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:43:13: note:\
    \ previously used here\n   43 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:77:13: error: duplicate case value\n   77 |             case\
    \ 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:26:13: note: previously\
    \ used here\n   26 |             case 'k':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:78:13:\
    \ error: duplicate case value\n   78 |             case 'l':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:43:13: note: previously used here\n   43 |  \
    \           case 'l':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:81:13: error:\
    \ duplicate case value\n   81 |             case 'l':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:43:13: note: previously used here\n   43 |             case\
    \ 'l':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:90:13: error: duplicate\
    \ case value\n   90 |             case 'o':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:20:13:\
    \ note: previously used here\n   20 |             case 'o':\n      |         \
    \    ^~~~\n/tmp/tmp_ij0x9mx.cpp:93:13: error: duplicate case value\n   93 |  \
    \           case 'p':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:27:13: note:\
    \ previously used here\n   27 |             case 'p':\n      |             ^~~~\n\
    /tmp/tmp_ij0x9mx.cpp:102:13: error: duplicate case value\n  102 |            \
    \ case 's':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:28:13: note: previously\
    \ used here\n   28 |             case 's':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:108:13:\
    \ error: duplicate case value\n  108 |             case 'u':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:21:13: note: previously used here\n   21 |  \
    \           case 'u':\n      |             ^~~~\n/tmp/tmp_ij0x9mx.cpp:123:13:\
    \ error: duplicate case value\n  123 |             case 'z':\n      |        \
    \     ^~~~\n/tmp/tmp_ij0x9mx.cpp:35:13: note: previously used here\n   35 |  \
    \           case 'z':\n      |             ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        ans += (isalpha(c) ? toupper(c)\
    \ : c);\n    }\n    for (char c : ans) {\n        ans[ans.find(c)] = tolower(c);\n\
    \    }\n    for (char c : ans) {\n        if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans[ans.find(c) + 2] = tolower(c);\n\
    \        }\n    }\n    for (char c : ans) {\n        if (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') {\n            ans[ans.find(c) + 2] = toupper(c);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1wv5zkmg: /tmp/tmp1wv5zkmg.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (auto &i : message) {\n        switch (i) {\n        case\
    \ 'a':\n            ans += 'A';\n            break;\n        case 'b':\n     \
    \       ans += 'B';\n            break;\n        case 'c':\n            ans +=\
    \ 'C';\n            break;\n        case 'd':\n            ans += 'D';\n     \
    \       break;\n        case 'e':\n            ans += 'E';\n            break;\n\
    \        case 'f':\n            ans += 'F';\n            break;\n        case\
    \ 'g':\n            ans += 'G';\n            break;\n        case 'h':\n     \
    \       ans += 'H';\n            break;\n        case 'i':\n            ans +=\
    \ 'I';\n            break;\n        case 'j':\n            ans += 'J';\n     \
    \       break;\n        case 'k':\n            ans += 'K';\n            break;\n\
    \        case 'l':\n            ans += 'L';\n            break;\n        case\
    \ 'm':\n            ans += 'M';\n            break;\n        case 'n':\n     \
    \       ans += 'N';\n            break;\n        case 'o':\n            ans +=\
    \ 'O';\n            break;\n        case 'p':\n            ans += 'P';\n     \
    \       break;\n        case 'q':\n            ans += 'Q';\n            break;\n\
    \        case 'r':\n            ans += 'R';\n            break;\n        case\
    \ 's':\n            ans += 'S';\n            break;\n        case 't':\n     \
    \       ans += 'T';\n            break;\n        case 'u':\n            ans +=\
    \ 'U';\n            break;\n        case 'v':\n            ans += 'V';\n     \
    \       break;\n        case 'w':\n            ans += 'W';\n            break;\n\
    \        case 'x':\n            ans += 'X';\n            break;\n        case\
    \ 'y':\n            ans += 'Y';\n            break;\n        case 'z':\n     \
    \       ans += 'Z';\n            break;\n        case 'A':\n            ans +=\
    \ 'a';\n            break;\n        case 'B':\n            ans += 'b';\n     \
    \       break;\n        case 'C':\n            ans += 'c';\n            break;\n\
    \        case 'D':\n            ans += 'd';\n            break;\n        case\
    \ 'E':\n            ans += 'e';\n            break;\n        case 'F':\n     \
    \       ans += 'f';\n            break;\n        case 'G':\n            ans +=\
    \ 'g';\n            break;\n        case 'H':\n            ans += 'h';\n     \
    \       break;\n        case 'I':\n            ans += 'i';\n            break;\n\
    \        case 'J':\n            ans += 'j';\n            break;\n        case\
    \ 'K':\n            ans += 'k';\n            break;\n        case 'L':\n     \
    \       ans += 'l';\n            break;\n        case 'M\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbjd25yqr.cpp:131:14: warning: missing terminating ' character\n\
    \  131 |         case 'M\n      |              ^\n/tmp/tmpbjd25yqr.cpp:131:14:\
    \ error: missing terminating ' character\n  131 |         case 'M\n      |   \
    \           ^~\n/tmp/tmpbjd25yqr.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpbjd25yqr.cpp:132:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  132 | }\n      | ^\n/tmp/tmpbjd25yqr.cpp:131:13: error: expected\
    \ \u2018:\u2019 before \u2018}\u2019 token\n  131 |         case 'M\n      | \
    \            ^\n      |             :\n  132 | }\n      | ~            \n/tmp/tmpbjd25yqr.cpp:132:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  132 | }\n \
    \     | ^\n/tmp/tmpbjd25yqr.cpp:133:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  133 | int main() {\n      |            ^\n\
    /tmp/tmpbjd25yqr.cpp:140:1: error: expected \u2018}\u2019 at end of input\n  140\
    \ | }\n      | ^\n/tmp/tmpbjd25yqr.cpp:15:29: note: to match this \u2018{\u2019\
    \n   15 |     for (auto &i : message) {\n      |                             ^\n\
    /tmp/tmpbjd25yqr.cpp:140:1: error: expected \u2018}\u2019 at end of input\n  140\
    \ | }\n      | ^\n/tmp/tmpbjd25yqr.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpbjd25yqr.cpp:140:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n  140 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpp8vqn4xf: /tmp/tmpp8vqn4xf.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u') {\n            ans += c;\n        }\n        else {\n            ans\
    \ += 'A' + (c - 'a');\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp3lnugmjv: /tmp/tmp3lnugmjv.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        char prev = message[i-1];\n        char next = message[i+1];\n\
    \        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n    \
    \        ans += c;\n        }\n        else if(c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            ans += c;\n        }\n        else if(c\
    \ == 'b' || c == 'c' || c == 'd' || c == 'f' || c == 'g' || c == 'h' || c == 'j'\
    \ || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'p' || c == 'q' || c\
    \ == 'r' || c == 's' || c == 't' || c == 'v' || c == 'w' || c == 'x' || c == 'y'\
    \ || c == 'z') {\n            ans += c;\n        }\n        else if(c == 'B' ||\
    \ c == 'C' || c == 'D' || c == 'F' || c == 'G' || c == 'H' || c == 'J' || c ==\
    \ 'K' || c == 'L' || c == 'M' || c == 'N' || c == 'P' || c == 'Q' || c == 'R'\
    \ || c == 'S' || c == 'T' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c\
    \ == 'Z') {\n            ans += c;\n        }\n        else if(c == '0' || c ==\
    \ '1') {\n            ans += c;\n        }\n        else if(c == '!' || c == '@'\
    \ || c == '#' || c == '$' || c == '%' || c == '^' || c == '&' || c == '*' || c\
    \ == '(' || c == ')' || c == '_' || c == '-' || c == '+' || c == '=' || c == '['\
    \ || c == ']' || c == '{' || c == '}' || c == '|' || c == ':' || c == '<' || c\
    \ == '>' || c == '?' || c == '/' || c == '\\\\' || c == '~') {\n            ans\
    \ += c;\n        }\n        else if(c == 'B' || c == 'C' || c == 'D' || c == 'F'\
    \ || c == 'G' || c == 'H' || c == 'J' || c == 'K' || c == 'L' || c == 'M' || c\
    \ == 'N' || c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c == 'T' || c == 'V'\
    \ || c == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n            ans += c;\n\
    \        }\n        else if(c == 'a' || c == '\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyn0k4fdu.cpp:40:34: warning: missing terminating ' character\n\
    \   40 |         else if(c == 'a' || c == '\n      |                         \
    \         ^\n/tmp/tmpyn0k4fdu.cpp:40:34: error: missing terminating ' character\n\
    /tmp/tmpyn0k4fdu.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpyn0k4fdu.cpp:41:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   41 | }\n      | ^\n/tmp/tmpyn0k4fdu.cpp:40:33: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   40 |         else if(c == 'a' ||\
    \ c == '\n      |                ~                ^\n      |                 \
    \                )\n   41 | }\n      | ~                                \n/tmp/tmpyn0k4fdu.cpp:41:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   41 | }\n \
    \     | ^\n/tmp/tmpyn0k4fdu.cpp:42:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   42 | int main() {\n      |            ^\n\
    /tmp/tmpyn0k4fdu.cpp:49:1: error: expected \u2018}\u2019 at end of input\n   49\
    \ | }\n      | ^\n/tmp/tmpyn0k4fdu.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpyn0k4fdu.cpp:49:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   49 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (char c : message) {\n        if (std::isalpha(c))\
    \ {\n            char temp = c;\n            int index = c - 'a';\n          \
    \  int index2 = c - 'A';\n            if (index == index2) {\n               \
    \ temp = temp + 'A';\n            }\n            encoded = encoded + temp;\n \
    \       } else {\n            encoded = encoded + c;\n        }\n    }\n    return\
    \ encoded;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpkl2zsv44: /tmp/tmpkl2zsv44.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for (auto &c : ans) {\n        switch (c) {\n        case\
    \ 'a':\n            ans.insert(ans.begin(), 'e');\n            break;\n      \
    \  case 'e':\n            ans.insert(ans.begin(), 'a');\n            break;\n\
    \        case 'i':\n            ans.insert(ans.begin(), 'o');\n            break;\n\
    \        case 'o':\n            ans.insert(ans.begin(), 'i');\n            break;\n\
    \        case 'u':\n            ans.insert(ans.begin(), 'y');\n            break;\n\
    \        case 'y':\n            ans.insert(ans.begin(), 'u');\n            break;\n\
    \        default:\n            break;\n        }\n    }\n    for (auto &c : ans)\
    \ {\n        switch (c) {\n        case 'a':\n            ans.insert(ans.begin(),\
    \ 'e');\n            break;\n        case 'e':\n            ans.insert(ans.begin(),\
    \ 'a');\n            break;\n        case 'i':\n            ans.insert(ans.begin(),\
    \ 'o');\n            break;\n        case 'o':\n            ans.insert(ans.begin(),\
    \ 'i');\n            break;\n        case 'u':\n            ans.insert(ans.begin(),\
    \ 'y');\n            break;\n        case 'y':\n            ans.insert(ans.begin(),\
    \ 'u');\n            break;\n        default:\n            break;\n        }\n\
    \    }\n    for (auto &c : ans) {\n        switch (c) {\n        case 'a':\n \
    \           ans.insert(ans.begin(), 'e');\n            break;\n        case 'e':\n\
    \            ans.insert(ans.begin(), 'a');\n            break;\n        case 'i':\n\
    \            ans.insert(ans.begin(), 'o');\n            break;\n        case 'o':\n\
    \            ans.insert(ans.begin(), 'i');\n            break;\n        case 'u':\n\
    \            ans.insert(ans.begin(), 'y');\n            break;\n        case 'y':\n\
    \            ans.insert(ans.begin(), 'u');\n            break;\n        default:\n\
    \            break;\n        }\n    }\n    for (auto &c : ans) {\n        switch\
    \ (c) {\n        case 'a':\n            ans.insert(ans.begin(), 'e');\n      \
    \      break;\n        case 'e':\n            ans.insert(ans.begin(), 'a');\n\
    \            break;\n        case 'i':\n            ans.insert(ans.begin(), 'o');\n\
    \            break;\n        case 'o':\n            ans.insert(ans.begin(), 'i');\n\
    \            break;\n        case 'u':\n            ans.insert(ans.begin(), 'y');\n\
    \            break;\n        case 'y':\n            ans.insert(ans.begin(), 'u');\n\
    \            break;\n        default:\n            break;\n        }\n    }\n\
    \    for (auto &c : ans) {\n        switch (c) {\n        case '\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcygk4yyg.cpp:113:14: warning: missing terminating ' character\n\
    \  113 |         case '\n      |              ^\n/tmp/tmpcygk4yyg.cpp:113:14:\
    \ error: missing terminating ' character\n/tmp/tmpcygk4yyg.cpp: In function \u2018\
    std::string encode(std::string)\u2019:\n/tmp/tmpcygk4yyg.cpp:114:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n  114 | }\n      | ^\n/tmp/tmpcygk4yyg.cpp:113:13:\
    \ error: expected \u2018:\u2019 before \u2018}\u2019 token\n  113 |         case\
    \ '\n      |             ^\n      |             :\n  114 | }\n      | ~      \
    \      \n/tmp/tmpcygk4yyg.cpp:114:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n  114 | }\n      | ^\n/tmp/tmpcygk4yyg.cpp:115:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n  115\
    \ | int main() {\n      |            ^\n/tmp/tmpcygk4yyg.cpp:122:1: error: expected\
    \ \u2018}\u2019 at end of input\n  122 | }\n      | ^\n/tmp/tmpcygk4yyg.cpp:111:25:\
    \ note: to match this \u2018{\u2019\n  111 |     for (auto &c : ans) {\n     \
    \ |                         ^\n/tmp/tmpcygk4yyg.cpp:122:1: error: expected \u2018\
    }\u2019 at end of input\n  122 | }\n      | ^\n/tmp/tmpcygk4yyg.cpp:13:41: note:\
    \ to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpcygk4yyg.cpp:122:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  122 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.length(); i++) {\n        char c\
    \ = message[i];\n        ans += c;\n        ans += c;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpnjue2r32: /tmp/tmpnjue2r32.cpp:24: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
