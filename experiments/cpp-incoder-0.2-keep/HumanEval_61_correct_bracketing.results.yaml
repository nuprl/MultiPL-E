name: HumanEval_61_correct_bracketing
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find('(') != brackets.find(')')) {\n                result = false;\n\
    \                break;\n            }\n        } else if (c == ')') {\n     \
    \       if (brackets.find('(') == brackets.find(')')) {\n                result\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpi07efdpl: /tmp/tmpi07efdpl.cpp:32: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpe4bgjy4i: /tmp/tmpe4bgjy4i.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     } else if (brackets[i] == '[') {\n            ++open_brackets;\n       \
    \ } else if (brackets[i] == ']') {\n            ++close_brackets;\n        } else\
    \ if (brackets[i] == '{') {\n            ++open_brackets;\n        } else if (brackets[i]\
    \ == '}') {\n            ++close_brackets;\n        }\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpjn0mqycf: /tmp/tmpjn0mqycf.cpp:40: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpg16wn0jb: /tmp/tmpg16wn0jb.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpsc3ah4zz: /tmp/tmpsc3ah4zz.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        } else {\n            return false;\n        }\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnzuz0c4l: /tmp/tmpnzuz0c4l.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9dl7xdha: /tmp/tmp9dl7xdha.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    // Your\
    \ code here\n    std::string opening_brackets = \"(\";\n    std::string closing_brackets\
    \ = \")\";\n    std::string brackets_copy = brackets;\n    bool result = false;\n\
    \    size_t opening_brackets_size = opening_brackets.size();\n    size_t closing_brackets_size\
    \ = closing_brackets.size();\n    size_t brackets_copy_size = brackets_copy.size();\n\
    \    for (size_t i = 0; i < brackets_copy_size; i++) {\n        if (brackets_copy[i]\
    \ == opening_brackets[i]) {\n            brackets_copy[i] = closing_brackets[i];\n\
    \            brackets_copy[brackets_copy_size - 1] = opening_brackets[i];\n  \
    \          brackets_copy_size = brackets_copy_size - 2;\n            result =\
    \ true;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp292w69f1: /tmp/tmp292w69f1.cpp:38: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') opening_brackets++;\n        if (brackets[i]\
    \ == ')') closing_brackets++;\n    }\n    return opening_brackets == closing_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp712rg0ev: /tmp/tmp712rg0ev.cpp:29: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    size_t i = 0;\n    size_t\
    \ j = 0;\n    while (i < brackets.size()) {\n        if (brackets[i] == '(') {\n\
    \            open_brackets++;\n        } else if (brackets[i] == ')') {\n    \
    \        close_brackets++;\n        }\n        i++;\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmph809fupu: /tmp/tmph809fupu.cpp:35: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            opening_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            closing_brackets++;\n \
    \       }\n    }\n    return opening_brackets == closing_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpiv7ha8fl: /tmp/tmpiv7ha8fl.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.length(); i++) {\n        if (brackets[i] == '(') {\n           \
    \ open_brackets++;\n        } else if (brackets[i] == ')') {\n            close_brackets++;\n\
    \        }\n    }\n    return open_brackets == close_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpfgt01jaq: /tmp/tmpfgt01jaq.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpajj3gimu: /tmp/tmpajj3gimu.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpu5_srvon: /tmp/tmpu5_srvon.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    // Write\
    \ your code here.\n    int brackets_size = brackets.size();\n    for(int i = 0;\
    \ i < brackets_size; i++) {\n        if(brackets[i] == '(') {\n            if(brackets[i+1]\
    \ == '(') {\n                if(brackets[i+2] == '(') {\n                    if(brackets[i+3]\
    \ == '(') {\n                        if(brackets[i+4] == '(') {\n            \
    \                if(brackets[i+5] == '(') {\n                                if(brackets[i+6]\
    \ == '(') {\n                                    if(brackets[i+7] == '(') {\n\
    \                                        if(brackets[i+8] == '(') {\n        \
    \                                    if(brackets[i+9] == '(') {\n            \
    \                                    if(brackets[i+10] == '(') {\n           \
    \                                         if(brackets[i+11] == '(') {\n      \
    \                                                  if(brackets[i+12] == '(') {\n\
    \                                                            if(brackets[i+13]\
    \ == '(') {\n                                                                if(brackets[i+14]\
    \ == '(') {\n                                                                \
    \    if(brackets[i+15] == '(') {\n                                           \
    \                             if(brackets[i+16] == '(') {\n                  \
    \                                                          if(brackets[i+17] ==\
    \ '(') {\n                                                                   \
    \             if(brackets[i+18] == '(') {\n                                  \
    \                                                  if(brackets[i+19] == '(') {\n\
    \                                                                            \
    \            if(brackets[i+20] == '(') {\n                                   \
    \                                                         if(brackets[i+21] ==\
    \ '(') {\n                                                                   \
    \                             if(brackets[i+22] == '(') {\n                  \
    \                                                                            \
    \      if(brackets[i+23] == '(') {\n                                         \
    \                                                               if(brackets[i+24]\
    \ == '(') {\n                                                                \
    \                                            if(brackets[i+25] == '(') {\n   \
    \                                                                            \
    \                                 if(brackets[i+26] == '(') {\n              \
    \                                                                            \
    \                          if(brackets[i+27] == '(') {\n                     \
    \                                                                            \
    \                       if(brackets[i+28] == '(') {\n                        \
    \                                                                            \
    \                        if(brackets[i+29] == '(') {\n                       \
    \                                                                            \
    \                             if(brackets[i+30] == '(') {\n                  \
    \                                                                            \
    \                                      if(brackets[i+31] == '(') {\n         \
    \                                                                            \
    \                                                   if(brackets[i+32] == '(')\
    \ {\n                                                                        \
    \                                                                    if(brackets[i+33]\
    \ == '(') {\n                                                                \
    \                                                                            \
    \    if(brackets[i+34] == '(') {\n                                           \
    \                                                                            \
    \                             if(brackets[i+35] == '(') {\n                  \
    \                                                                            \
    \                                                          if(brackets[i+36] ==\
    \ '(') {\n                                                                   \
    \                                                                            \
    \             if(brackets[i+37] == '(') {\n                                  \
    \                                                                            \
    \                                                  if(bra\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn6_k7dee.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpn6_k7dee.cpp:55:164: error: \u2018bra\u2019 was not declared in this\
    \ scope\n   55 |                                                             \
    \                                                                            \
    \                        if(bra\n      |                                     \
    \                                                                            \
    \                                                   ^~~\n/tmp/tmpn6_k7dee.cpp:55:167:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   55 |          \
    \                                                                            \
    \                                                                           if(bra\n\
    \      |                                                                     \
    \                                                                            \
    \                  ~   ^\n      |                                            \
    \                                                                            \
    \                                               )\n   56 | }\n      | ~      \
    \                                                                            \
    \                                                                            \
    \        \n/tmp/tmpn6_k7dee.cpp:56:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n   56 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:57:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   57\
    \ | int main() {\n      |            ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:53:179:\
    \ note: to match this \u2018{\u2019\n   53 |                                 \
    \                                                                            \
    \                                            if(brackets[i+36] == '(') {\n   \
    \   |                                                                        \
    \                                                                            \
    \                               ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:52:175:\
    \ note: to match this \u2018{\u2019\n   52 |                                 \
    \                                                                            \
    \                                        if(brackets[i+35] == '(') {\n      |\
    \                                                                            \
    \                                                                            \
    \                       ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019\
    \ at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:51:171: note: to\
    \ match this \u2018{\u2019\n   51 |                                          \
    \                                                                            \
    \                           if(brackets[i+34] == '(') {\n      |             \
    \                                                                            \
    \                                                                            \
    \      ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019 at end of input\n\
    \   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:50:167: note: to match this \u2018\
    {\u2019\n   50 |                                                             \
    \                                                                            \
    \    if(brackets[i+33] == '(') {\n      |                                    \
    \                                                                            \
    \                                                       ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:49:163:\
    \ note: to match this \u2018{\u2019\n   49 |                                 \
    \                                                                            \
    \                            if(brackets[i+32] == '(') {\n      |            \
    \                                                                            \
    \                                                                           ^\n\
    /tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019 at end of input\n   71\
    \ | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:48:159: note: to match this \u2018{\u2019\
    \n   48 |                                                                    \
    \                                                                 if(brackets[i+31]\
    \ == '(') {\n      |                                                         \
    \                                                                            \
    \                          ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018\
    }\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:47:155: note:\
    \ to match this \u2018{\u2019\n   47 |                                       \
    \                                                                            \
    \              if(brackets[i+30] == '(') {\n      |                          \
    \                                                                            \
    \                                                     ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:46:151:\
    \ note: to match this \u2018{\u2019\n   46 |                                 \
    \                                                                            \
    \                if(brackets[i+29] == '(') {\n      |                        \
    \                                                                            \
    \                                                   ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:45:147:\
    \ note: to match this \u2018{\u2019\n   45 |                                 \
    \                                                                            \
    \            if(brackets[i+28] == '(') {\n      |                            \
    \                                                                            \
    \                                           ^\n/tmp/tmpn6_k7dee.cpp:71:1: error:\
    \ expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:44:143:\
    \ note: to match this \u2018{\u2019\n   44 |                                 \
    \                                                                            \
    \        if(brackets[i+27] == '(') {\n      |                                \
    \                                                                            \
    \                                   ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:43:139:\
    \ note: to match this \u2018{\u2019\n   43 |                                 \
    \                                                                            \
    \    if(brackets[i+26] == '(') {\n      |                                    \
    \                                                                            \
    \                           ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018\
    }\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:42:135: note:\
    \ to match this \u2018{\u2019\n   42 |                                       \
    \                                                                      if(brackets[i+25]\
    \ == '(') {\n      |                                                         \
    \                                                                            \
    \  ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019 at end of input\n\
    \   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:41:131: note: to match this \u2018\
    {\u2019\n   41 |                                                             \
    \                                            if(brackets[i+24] == '(') {\n   \
    \   |                                                                        \
    \                                                           ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:40:127:\
    \ note: to match this \u2018{\u2019\n   40 |                                 \
    \                                                                    if(brackets[i+23]\
    \ == '(') {\n      |                                                         \
    \                                                                      ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:39:123:\
    \ note: to match this \u2018{\u2019\n   39 |                                 \
    \                                                                if(brackets[i+22]\
    \ == '(') {\n      |                                                         \
    \                                                                  ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:38:119:\
    \ note: to match this \u2018{\u2019\n   38 |                                 \
    \                                                            if(brackets[i+21]\
    \ == '(') {\n      |                                                         \
    \                                                              ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:37:115:\
    \ note: to match this \u2018{\u2019\n   37 |                                 \
    \                                                        if(brackets[i+20] ==\
    \ '(') {\n      |                                                            \
    \                                                       ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:36:111:\
    \ note: to match this \u2018{\u2019\n   36 |                                 \
    \                                                    if(brackets[i+19] == '(')\
    \ {\n      |                                                                 \
    \                                              ^\n/tmp/tmpn6_k7dee.cpp:71:1: error:\
    \ expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:35:107:\
    \ note: to match this \u2018{\u2019\n   35 |                                 \
    \                                                if(brackets[i+18] == '(') {\n\
    \      |                                                                     \
    \                                      ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:34:103:\
    \ note: to match this \u2018{\u2019\n   34 |                                 \
    \                                            if(brackets[i+17] == '(') {\n   \
    \   |                                                                        \
    \                               ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:33:99:\
    \ note: to match this \u2018{\u2019\n   33 |                                 \
    \                                        if(brackets[i+16] == '(') {\n      |\
    \                                                                            \
    \                       ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019\
    \ at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:32:95: note: to\
    \ match this \u2018{\u2019\n   32 |                                          \
    \                           if(brackets[i+15] == '(') {\n      |             \
    \                                                                            \
    \      ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019 at end of input\n\
    \   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:31:91: note: to match this \u2018\
    {\u2019\n   31 |                                                             \
    \    if(brackets[i+14] == '(') {\n      |                                    \
    \                                                       ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:30:87:\
    \ note: to match this \u2018{\u2019\n   30 |                                 \
    \                            if(brackets[i+13] == '(') {\n      |            \
    \                                                                           ^\n\
    /tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019 at end of input\n   71\
    \ | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:29:83: note: to match this \u2018{\u2019\
    \n   29 |                                                         if(brackets[i+12]\
    \ == '(') {\n      |                                                         \
    \                          ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018\
    }\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:28:79: note:\
    \ to match this \u2018{\u2019\n   28 |                                       \
    \              if(brackets[i+11] == '(') {\n      |                          \
    \                                                     ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:27:75:\
    \ note: to match this \u2018{\u2019\n   27 |                                 \
    \                if(brackets[i+10] == '(') {\n      |                        \
    \                                                   ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:26:70:\
    \ note: to match this \u2018{\u2019\n   26 |                                 \
    \            if(brackets[i+9] == '(') {\n      |                             \
    \                                         ^\n/tmp/tmpn6_k7dee.cpp:71:1: error:\
    \ expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:25:66:\
    \ note: to match this \u2018{\u2019\n   25 |                                 \
    \        if(brackets[i+8] == '(') {\n      |                                 \
    \                                 ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:24:62:\
    \ note: to match this \u2018{\u2019\n   24 |                                 \
    \    if(brackets[i+7] == '(') {\n      |                                     \
    \                         ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018\
    }\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:23:58: note:\
    \ to match this \u2018{\u2019\n   23 |                                 if(brackets[i+6]\
    \ == '(') {\n      |                                                         \
    \ ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected \u2018}\u2019 at end of input\n\
    \   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:22:54: note: to match this \u2018\
    {\u2019\n   22 |                             if(brackets[i+5] == '(') {\n    \
    \  |                                                      ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:21:50:\
    \ note: to match this \u2018{\u2019\n   21 |                         if(brackets[i+4]\
    \ == '(') {\n      |                                                  ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:20:46:\
    \ note: to match this \u2018{\u2019\n   20 |                     if(brackets[i+3]\
    \ == '(') {\n      |                                              ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:19:42:\
    \ note: to match this \u2018{\u2019\n   19 |                 if(brackets[i+2]\
    \ == '(') {\n      |                                          ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:18:38:\
    \ note: to match this \u2018{\u2019\n   18 |             if(brackets[i+1] == '(')\
    \ {\n      |                                      ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:17:32:\
    \ note: to match this \u2018{\u2019\n   17 |         if(brackets[i] == '(') {\n\
    \      |                                ^\n/tmp/tmpn6_k7dee.cpp:71:1: error: expected\
    \ \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:16:44:\
    \ note: to match this \u2018{\u2019\n   16 |     for(int i = 0; i < brackets_size;\
    \ i++) {\n      |                                            ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmpn6_k7dee.cpp:13:47:\
    \ note: to match this \u2018{\u2019\n   13 | bool correct_bracketing(std::string\
    \ brackets) {\n      |                                               ^\n/tmp/tmpn6_k7dee.cpp:71:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   71 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        } else {\n            return false;\n        }\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpr7tsglfy: /tmp/tmpr7tsglfy.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.length(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp4z62xukf: /tmp/tmp4z62xukf.cpp:28: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n   \
    \     if (brackets[i] == '(') {\n            ++open_brackets;\n        } else\
    \ if (brackets[i] == ')') {\n            --open_brackets;\n        }\n    }\n\
    \    return open_brackets == 0;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmppgvmetd6: /tmp/tmppgvmetd6.cpp:31: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpvp5ueg1g: /tmp/tmpvp5ueg1g.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = 0;\n  int close_brackets = 0;\n  for (int i = 0; i < brackets.size(); i++)\
    \ {\n    if (brackets[i] == '(') {\n      open_brackets++;\n    } else if (brackets[i]\
    \ == ')') {\n      close_brackets++;\n    }\n  }\n  return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpv6yxrzew: /tmp/tmpv6yxrzew.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ brackets_copy = brackets;\n    size_t open_brackets = 0;\n    size_t close_brackets\
    \ = 0;\n    size_t open_brackets_size = brackets_copy.size();\n    size_t close_brackets_size\
    \ = brackets_copy.size();\n    size_t i = 0;\n    while (i < open_brackets_size)\
    \ {\n        if (brackets_copy[i] == '(') {\n            open_brackets++;\n  \
    \      }\n        if (brackets_copy[i] == ')') {\n            close_brackets++;\n\
    \        }\n        i++;\n    }\n    if (open_brackets == close_brackets) {\n\
    \        return true;\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp3vokbniq: /tmp/tmp3vokbniq.cpp:41: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp096uwry4: /tmp/tmp096uwry4.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpjf6ntg4u: /tmp/tmpjf6ntg4u.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.length(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n        } else if (brackets[i]\
    \ == ')') {\n            if (brackets[i + 1] != '(') {\n                result\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpqgv0ciou: /tmp/tmpqgv0ciou.cpp:32: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpzv7twvfx: /tmp/tmpzv7twvfx.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find('(') != brackets.find(')')) {\n                result = false;\n\
    \            }\n        } else if (c == ')') {\n            if (brackets.find('(')\
    \ == brackets.find(')')) {\n                result = false;\n            }\n \
    \       }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpy_tdp49u: /tmp/tmpy_tdp49u.cpp:30: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmprtvv6nds: /tmp/tmprtvv6nds.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    size_t opening_brackets_size = opening_brackets.size();\n    size_t closing_brackets_size\
    \ = closing_brackets.size();\n    size_t opening_brackets_index = 0;\n    size_t\
    \ closing_brackets_index = 0;\n    while (opening_brackets_index < opening_brackets_size)\
    \ {\n        char opening_bracket = opening_brackets[opening_brackets_index];\n\
    \        char closing_bracket = closing_brackets[closing_brackets_index];\n  \
    \      if (opening_bracket == '(') {\n            opening_brackets_index++;\n\
    \        } else if (opening_bracket == ')') {\n            closing_brackets_index++;\n\
    \        } else {\n            return false;\n        }\n    }\n    while (closing_brackets_index\
    \ < closing_brackets_size) {\n        char opening_bracket = opening_brackets[opening_brackets_index];\n\
    \        char closing_bracket = closing_brackets[closing_brackets_index];\n  \
    \      if (closing_bracket == '(') {\n            closing_brackets_index++;\n\
    \        } else if (closing_bracket == ')') {\n            opening_brackets_index++;\n\
    \        } else {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n  \
    \      } else if (brackets[i] == ')') {\n            ++close_brackets;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpd4ee3kbk: /tmp/tmpd4ee3kbk.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(\";\n    std::string closing_brackets = \")\";\n    std::string\
    \ opening_brackets_reversed = closing_brackets;\n    std::string closing_brackets_reversed\
    \ = opening_brackets;\n    std::string opening_brackets_reversed_reversed = opening_brackets_reversed;\n\
    \    std::string closing_brackets_reversed_reversed = closing_brackets_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed = opening_brackets_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed = closing_brackets_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed = opening_brackets_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed;\n    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed;\n    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvr52v0aw.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpvr52v0aw.cpp:31:117: error: \u2018closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\u2019\
    \ was not declared in this scope; did you mean \u2018opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    ?\n   31 |     std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    \      |                                                                     \
    \                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                                     \
    \                                                opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\n\
    /tmp/tmpvr52v0aw.cpp:32:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   32 | }\n      | ^\n/tmp/tmpvr52v0aw.cpp:32:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    size_t opening_brackets_size = opening_brackets.size();\n    size_t closing_brackets_size\
    \ = closing_brackets.size();\n    for (size_t i = 0; i < opening_brackets_size;\
    \ i++) {\n        if (opening_brackets[i] == '(') {\n            opening_brackets[i]\
    \ = '[';\n        } else if (opening_brackets[i] == '[') {\n            opening_brackets[i]\
    \ = '(';\n        } else if (opening_brackets[i] == '{') {\n            opening_brackets[i]\
    \ = '{';\n        } else if (opening_brackets[i] == '}') {\n            opening_brackets[i]\
    \ = '}';\n        }\n    }\n    for (size_t i = 0; i < closing_brackets_size;\
    \ i++) {\n        if (closing_brackets[i] == ')') {\n            closing_brackets[i]\
    \ = ']';\n        } else if (closing_brackets[i] == ']') {\n            closing_brackets[i]\
    \ = ')';\n        } else if (closing_brackets[i] == '}') {\n            closing_brackets[i]\
    \ = '}';\n        }\n    }\n    return opening_brackets == closing_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpaa8nkq4v: /tmp/tmpaa8nkq4v.cpp:42: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = 0;\n  int close_brackets = 0;\n  for (int i = 0; i < brackets.size(); i++)\
    \ {\n    if (brackets[i] == '(') {\n      open_brackets++;\n    } else if (brackets[i]\
    \ == ')') {\n      close_brackets++;\n    }\n  }\n  if (open_brackets == close_brackets)\
    \ {\n    return true;\n  } else {\n    return false;\n  }\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpr_ze8h7z: /tmp/tmpr_ze8h7z.cpp:36: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    size_t i = 0;\n    size_t\
    \ j = 0;\n    while (i<brackets.size()) {\n        if (brackets[i] == '(') {\n\
    \            open_brackets++;\n        }\n        else if (brackets[i] == ')')\
    \ {\n            close_brackets++;\n        }\n        i++;\n    }\n    if (open_brackets\
    \ != close_brackets) {\n        return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpjnism_nx: /tmp/tmpjnism_nx.cpp:39: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    std::string opening_brackets_copy = opening_brackets;\n    std::string closing_brackets_copy\
    \ = closing_brackets;\n    bool found = false;\n    while (opening_brackets_copy.size()\
    \ > 0) {\n        opening_brackets_copy = opening_brackets_copy.substr(0, opening_brackets_copy.size()\
    \ - 1);\n        closing_brackets_copy = closing_brackets_copy.substr(0, closing_brackets_copy.size()\
    \ - 1);\n        if (opening_brackets_copy == closing_brackets_copy) {\n     \
    \       found = true;\n            break;\n        }\n    }\n    return found;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpoc1mt1b6: /tmp/tmpoc1mt1b6.cpp:35: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9xr3u6lt: /tmp/tmp9xr3u6lt.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.length(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n            }\n            ++i;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpj9gcxecd: /tmp/tmpj9gcxecd.cpp:28: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            ++i;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpoktsje6l: /tmp/tmpoktsje6l.cpp:29: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpd0oo0025: /tmp/tmpd0oo0025.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmprbt6ev31: /tmp/tmprbt6ev31.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpk2dlwaji: /tmp/tmpk2dlwaji.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnpc3awp6: /tmp/tmpnpc3awp6.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        } else {\n            return false;\n        }\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpun9vkend: /tmp/tmpun9vkend.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(){}[]\";\n    std::string closing_brackets = \"(){}[]\"\
    ;\n    std::string opening_brackets_set = opening_brackets;\n    std::string closing_brackets_set\
    \ = closing_brackets;\n    std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \    std::string closing_brackets_set_copy = closing_brackets_set;\n    std::string\
    \ opening_brackets_set_copy = opening_brackets_set;\n    std::string closing_brackets_set_copy\
    \ = closing_brackets_set;\n    std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \    std::string closing_brackets_set_copy = closing_brackets_set;\n    std::string\
    \ opening_brackets_set_copy = opening_brackets_set;\n    std::string closing_brackets_set_copy\
    \ = closing_brackets_set;\n    std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \    std::string closing_brackets_set_copy = closing_brackets_set;\n    std::string\
    \ opening_brackets_set_copy = opening_brackets_set;\n    std::string closing_brackets_set_copy\
    \ = closing_brackets_set;\n    std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \    std::string closing_brackets_set_copy = closing_brackets_set;\n    std::string\
    \ opening_brackets_set_copy = opening_brackets_set;\n    std::string closing_brackets_set_copy\
    \ = closing_brackets_set;\n    std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \    std::string closing_brackets_set_copy = closing_brackets_set;\n    std::string\
    \ opening_brackets_set_copy = opening_brackets_set;\n    std::string closing_brackets_set_copy\
    \ = closing_brackets_set;\n    std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \    std::string closing_brackets_set_copy = closing_brackets_set;\n    std::string\
    \ opening_brackets_set_copy = opening_brackets_set;\n    std::string closing_brackets_set_copy\
    \ = closing_brackets_set;\n    std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \    std::string closing_brackets_set_copy = closing_brackets_set;\n    std::string\
    \ opening_brackets_set_copy = opening_bracket\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxx_z64ej.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpxx_z64ej.cpp:20:17: error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\
    \n   20 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:21:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   21 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:22:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   22 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:23:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   23 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:24:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   24 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:25:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   25 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:26:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   26 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:27:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   27 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:28:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   28 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:29:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   29 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:30:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   30 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:31:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   31 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:32:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   32 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:33:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   33 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:34:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   34 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:35:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   35 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:36:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   36 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:37:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   37 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:38:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   38 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:39:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   39 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:40:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   40 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:41:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   41 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:42:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   42 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17:\
    \ note: \u2018std::string opening_brackets_set_copy\u2019 previously declared\
    \ here\n   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:43:17:\
    \ error: redeclaration of \u2018std::string closing_brackets_set_copy\u2019\n\
    \   43 |     std::string closing_brackets_set_copy = closing_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:19:17:\
    \ note: \u2018std::string closing_brackets_set_copy\u2019 previously declared\
    \ here\n   19 |     std::string closing_brackets_set_copy = closing_brackets_set;\n\
    \      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:44:17:\
    \ error: redeclaration of \u2018std::string opening_brackets_set_copy\u2019\n\
    \   44 |     std::string opening_brackets_set_copy = opening_bracket\n      |\
    \                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:18:17: note:\
    \ \u2018std::string opening_brackets_set_copy\u2019 previously declared here\n\
    \   18 |     std::string opening_brackets_set_copy = opening_brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxx_z64ej.cpp:44:45:\
    \ error: \u2018opening_bracket\u2019 was not declared in this scope; did you mean\
    \ \u2018opening_brackets\u2019?\n   44 |     std::string opening_brackets_set_copy\
    \ = opening_bracket\n      |                                             ^~~~~~~~~~~~~~~\n\
    \      |                                             opening_brackets\n/tmp/tmpxx_z64ej.cpp:45:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   45 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpqmk42c0u: /tmp/tmpqmk42c0u.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i]\
    \ != '(') {\n            result = false;\n            break;\n        }\n    }\n\
    \    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] !=\
    \ ')') {\n            result = false;\n            break;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnd4qk9xi: /tmp/tmpnd4qk9xi.cpp:31: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp15snl195: /tmp/tmp15snl195.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.length(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i += 2;\n     \
    \   } else if (brackets[i] == ')') {\n            if (brackets[i + 1] != '(')\
    \ {\n                result = false;\n                break;\n            }\n\
    \            i += 2;\n        } else {\n            result = false;\n        \
    \    break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpts25vtux: /tmp/tmpts25vtux.cpp:38: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp51zbi1px: /tmp/tmp51zbi1px.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp0vpoxop1: /tmp/tmp0vpoxop1.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i += 2;\n     \
    \   } else if (brackets[i] == ')') {\n            if (brackets[i + 1] != '(')\
    \ {\n                result = false;\n                break;\n            }\n\
    \            i += 2;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp3yx14ca_: /tmp/tmp3yx14ca_.cpp:35: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find('(') != brackets.size() - 1) {\n                result =\
    \ false;\n            }\n        } else if (c == ')') {\n            if (brackets.find('(')\
    \ == brackets.size() - 1) {\n                result = false;\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpbsq5vyp1: /tmp/tmpbsq5vyp1.cpp:30: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = brackets.size();\n    int close_brackets = 0;\n    for (int i = 0; i < open_brackets;\
    \ i++) {\n        if (brackets[i] == '(') {\n            close_brackets++;\n \
    \       }\n    }\n    return close_brackets == open_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmptjjbsnt1: /tmp/tmptjjbsnt1.cpp:25: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmplkizoqcc: /tmp/tmplkizoqcc.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = brackets.size();\n  int close_brackets = 0;\n  for (int i = 0; i < brackets.size();\
    \ i++) {\n    if (brackets[i] == '(') open_brackets++;\n    else if (brackets[i]\
    \ == ')') close_brackets++;\n  }\n  return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpcsw5r7z0: /tmp/tmpcsw5r7z0.cpp:24: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ brackets_size = brackets.size();\n    bool result = true;\n    for (size_t i\
    \ = 0; i < brackets_size; i++) {\n        if (brackets[i] != '(' && brackets[i]\
    \ != ')') {\n            result = false;\n            break;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmp8f8u_3eh: /tmp/tmp8f8u_3eh.cpp:30: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size() - 1; i++) {\n        if\
    \ (brackets[i] == '(' && brackets[i + 1] == ')') {\n            result = false;\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpvbn6mm89: /tmp/tmpvbn6mm89.cpp:25: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') ++open_brackets;\n\
    \        if (brackets[i] == ')') ++close_brackets;\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpb4lxn30z: /tmp/tmpb4lxn30z.cpp:29: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.length(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i += 2;\n     \
    \   } else if (brackets[i] == ')') {\n            if (brackets[i + 1] != '(')\
    \ {\n                result = false;\n                break;\n            }\n\
    \            i += 2;\n        } else {\n            result = false;\n        \
    \    break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpn069aty9: /tmp/tmpn069aty9.cpp:38: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ brackets_size = brackets.size();\n    size_t opening_brackets_size = 0;\n  \
    \  for (size_t i = 0; i < brackets_size; ++i) {\n        if (brackets[i] == '(')\
    \ {\n            ++opening_brackets_size;\n        } else if (brackets[i] == ')')\
    \ {\n            --opening_brackets_size;\n        }\n    }\n    return opening_brackets_size\
    \ == brackets_size;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpzghhyz1q: /tmp/tmpzghhyz1q.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.length(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n            }\n            i += 1;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpdtfp9ufk: /tmp/tmpdtfp9ufk.cpp:28: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpf3556ud3: /tmp/tmpf3556ud3.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    // Write\
    \ your code here.\n    int open_brackets = 0;\n    int close_brackets = 0;\n \
    \   for(int i = 0; i < brackets.length(); i++) {\n        if(brackets[i] == '(')\
    \ {\n            open_brackets++;\n        }\n        if(brackets[i] == ')') {\n\
    \            close_brackets++;\n        }\n    }\n    return open_brackets ==\
    \ close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpn5ucht1e: /tmp/tmpn5ucht1e.cpp:34: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpxw_b7__d: /tmp/tmpxw_b7__d.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnkb9p0rd: /tmp/tmpnkb9p0rd.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = 0;\n  int close_brackets = 0;\n  for (int i = 0; i < brackets.length(); i++)\
    \ {\n    if (brackets[i] == '(') {\n      open_brackets++;\n    } else if (brackets[i]\
    \ == ')') {\n      close_brackets++;\n    }\n  }\n  return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpwew20t55: /tmp/tmpwew20t55.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpt30g5ofx: /tmp/tmpt30g5ofx.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpe9vy6620: /tmp/tmpe9vy6620.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            while (i < brackets.size() && brackets[i] != ')') {\n\
    \                ++i;\n            }\n            if (i == brackets.size()) {\n\
    \                result = false;\n                break;\n            }\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpk_4i6kpv: /tmp/tmpk_4i6kpv.cpp:34: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find(\")\", brackets.find(c) + 1) != std::string::npos) {\n  \
    \              result = false;\n            }\n        } else if (c == ')') {\n\
    \            if (brackets.find(\"(\", brackets.find(c) + 1) != std::string::npos)\
    \ {\n                result = false;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9hpz7qxh: /tmp/tmp9hpz7qxh.cpp:30: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpf5ea_26z: /tmp/tmpf5ea_26z.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(\";\n    std::string closing_brackets = \")\";\n    std::string\
    \ opening_brackets_reversed = closing_brackets;\n    std::string closing_brackets_reversed\
    \ = opening_brackets;\n    std::string opening_brackets_reversed_reversed = opening_brackets_reversed;\n\
    \    std::string closing_brackets_reversed_reversed = closing_brackets_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed = opening_brackets_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed = closing_brackets_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed = opening_brackets_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed;\n    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed;\n    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq7ty7g2f.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpq7ty7g2f.cpp:31:117: error: \u2018closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\u2019\
    \ was not declared in this scope; did you mean \u2018opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    ?\n   31 |     std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    \      |                                                                     \
    \                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                                     \
    \                                                opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\n\
    /tmp/tmpq7ty7g2f.cpp:32:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   32 | }\n      | ^\n/tmp/tmpq7ty7g2f.cpp:32:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') open_brackets++;\n        else if (brackets[i]\
    \ == ')') close_brackets++;\n        else if (brackets[i] == '[') open_brackets++;\n\
    \        else if (brackets[i] == ']') close_brackets++;\n        else if (brackets[i]\
    \ == '{') open_brackets++;\n        else if (brackets[i] == '}') close_brackets++;\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnnutdi5p: /tmp/tmpnnutdi5p.cpp:33: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp6k7hz0tf: /tmp/tmp6k7hz0tf.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp5mes9e58: /tmp/tmp5mes9e58.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpm97wfl2b: /tmp/tmpm97wfl2b.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp0gcbj8ln: /tmp/tmp0gcbj8ln.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpy3e4j7_3: /tmp/tmpy3e4j7_3.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpaadhx973: /tmp/tmpaadhx973.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find('(') != brackets.find(')')) {\n                result = false;\n\
    \                break;\n            }\n        } else if (c == ')') {\n     \
    \       if (brackets.find('(') == brackets.find(')')) {\n                result\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpc179ycjp: /tmp/tmpc179ycjp.cpp:32: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp6tsyy13e: /tmp/tmp6tsyy13e.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.length(); ++i) {\n        if (brackets[i] == '(') ++open_brackets;\n\
    \        if (brackets[i] == ')') ++close_brackets;\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2ok499zj: /tmp/tmp2ok499zj.cpp:29: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    // initialize\
    \ a stack to store opening brackets\n    stack<char> brackets_stack;\n    // initialize\
    \ a stack to store closing brackets\n    stack<char> brackets_stack_close;\n \
    \   // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close_open_close;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open_close_open;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close_open_close_open_close;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store closing brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store opening brackets\n    stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \    // initialize a stack to store closing brackets\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7w3h16od.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmp7w3h16od.cpp:15:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   15 |     stack<char> brackets_stack;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp7w3h16od.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp7w3h16od.cpp:15:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   15 |     stack<char> brackets_stack;\n      |  \
    \         ^~~~\n/tmp/tmp7w3h16od.cpp:17:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   17 |     stack<char> brackets_stack_close;\n   \
    \   |           ^~~~\n/tmp/tmp7w3h16od.cpp:19:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   19 |     stack<char> brackets_stack_open;\n    \
    \  |           ^~~~\n/tmp/tmp7w3h16od.cpp:21:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   21 |     stack<char> brackets_stack_open_close;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:23:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   23 |     stack<char> brackets_stack_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:25:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   25 |     stack<char> brackets_stack_open_close_open_close;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:27:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   27 |     stack<char> brackets_stack_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:29:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   29 |     stack<char> brackets_stack_open_close_open_close_open_close;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:31:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   31 |     stack<char> brackets_stack_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:33:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   33 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:35:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   35 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:37:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   37 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:39:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   39 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:41:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   41 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:43:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   43 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:45:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   45 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:47:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   47 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:49:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   49 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:51:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   51 |     stack<char> brackets_stack_open_close_open_close_open_close_open_close_open_close_open_close_open;\n\
    \      |           ^~~~\n/tmp/tmp7w3h16od.cpp:53:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   53 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp0dnxnbk8: /tmp/tmp0dnxnbk8.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool correct\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                correct\
    \ = false;\n            }\n        }\n    }\n    return correct;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2_kem22c: /tmp/tmp2_kem22c.cpp:27: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpc8oy44zg: /tmp/tmpc8oy44zg.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n   \
    \     if (brackets[i] == '(') {\n            ++open_brackets;\n        } else\
    \ if (brackets[i] == ')') {\n            --open_brackets;\n        }\n       \
    \ if (open_brackets == 0) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = correct_bracketing;\n  \
    \  assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"))\
    \ == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmp5kpltd7_: /tmp/tmp5kpltd7_.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n  \
    \      } else if (brackets[i] == ')') {\n            ++close_brackets;\n     \
    \   } else if (brackets[i] == '[') {\n            ++open_brackets;\n        }\
    \ else if (brackets[i] == ']') {\n            ++close_brackets;\n        } else\
    \ if (brackets[i] == '{') {\n            ++open_brackets;\n        } else if (brackets[i]\
    \ == '}') {\n            ++close_brackets;\n        }\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpv7ean0d5: /tmp/tmpv7ean0d5.cpp:40: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = brackets.size();\n    int close_brackets = 0;\n    for (int i = 0; i < open_brackets;\
    \ i++) {\n        if (brackets[i] == '(') {\n            close_brackets++;\n \
    \       }\n        else if (brackets[i] == ')') {\n            close_brackets--;\n\
    \        }\n    }\n    return close_brackets == 0;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpd1voyduk: /tmp/tmpd1voyduk.cpp:33: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp8r8smf1v: /tmp/tmp8r8smf1v.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpbt77pkg4: /tmp/tmpbt77pkg4.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    // Your\
    \ code here\n    bool result = true;\n    for (size_t i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            if (brackets[i + 1] !=\
    \ ')') {\n                result = false;\n            }\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpqeh1h0js: /tmp/tmpqeh1h0js.cpp:28: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (size_t i = 0; i < brackets.size();\
    \ ++i) {\n        if (brackets[i] == '(')\n            ++open_brackets;\n    \
    \    else if (brackets[i] == ')')\n            ++close_brackets;\n        else\
    \ if (brackets[i] == '[' || brackets[i] == '{' || brackets[i] == '(')\n      \
    \      ++open_brackets;\n        else if (brackets[i] == ']' || brackets[i] ==\
    \ '}' || brackets[i] == ')')\n            ++close_brackets;\n        else if (brackets[i]\
    \ == '(' && open_brackets == close_brackets)\n            return false;\n    }\n\
    \    return open_brackets == close_brackets;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp6bur6u3a: /tmp/tmp6bur6u3a.cpp:37: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2fu6x9d7: /tmp/tmp2fu6x9d7.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2_fgw3al: /tmp/tmp2_fgw3al.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2c75dog8: /tmp/tmp2c75dog8.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ brackets_size = brackets.size();\n    size_t opening_brackets_size = brackets.find_first_of(\"\
    (\") - 1;\n    size_t closing_brackets_size = brackets.find_first_of(\")\") -\
    \ 1;\n    size_t total_brackets_size = opening_brackets_size + closing_brackets_size;\n\
    \    if (total_brackets_size != brackets_size) {\n        return false;\n    }\n\
    \    for (size_t i = 0; i < opening_brackets_size; i++) {\n        if (brackets[i]\
    \ != brackets[opening_brackets_size + i]) {\n            return false;\n     \
    \   }\n    }\n    for (size_t i = 0; i < closing_brackets_size; i++) {\n     \
    \   if (brackets[i] != brackets[opening_brackets_size + opening_brackets_size\
    \ + i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\
    int main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpgsduuzk2: /tmp/tmpgsduuzk2.cpp:35: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpx1zv4ra9: /tmp/tmpx1zv4ra9.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            opening_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            closing_brackets++;\n \
    \       }\n    }\n    return opening_brackets == closing_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpl4o3zf3j: /tmp/tmpl4o3zf3j.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     } else {\n            return false;\n        }\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpgf8fqwor: /tmp/tmpgf8fqwor.cpp:34: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = 0;\n  int close_brackets = 0;\n  for (int i = 0; i < brackets.length(); i++)\
    \ {\n    if (brackets[i] == '(') {\n      open_brackets++;\n    } else if (brackets[i]\
    \ == ')') {\n      close_brackets++;\n    }\n  }\n  return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp_tvjz_y2: /tmp/tmp_tvjz_y2.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    size_t brackets_size\
    \ = brackets.size();\n    std::string current_bracket;\n    for (size_t i = 0;\
    \ i < brackets_size; ++i) {\n        current_bracket = brackets.substr(i, 1);\n\
    \        if (current_bracket == \"(\") {\n            open_brackets++;\n     \
    \   } else if (current_bracket == \")\") {\n            close_brackets++;\n  \
    \      }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpaq9jnii_: /tmp/tmpaq9jnii_.cpp:35: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.length(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n            }\n            i += 2;\n        } else if (brackets[i]\
    \ == ')') {\n            if (brackets[i + 1] != '(') {\n                result\
    \ = false;\n            }\n            i += 2;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpuz_5jitv: /tmp/tmpuz_5jitv.cpp:33: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    opening_brackets.erase(opening_brackets.begin(), opening_brackets.begin()\
    \ + 1);\n    closing_brackets.erase(closing_brackets.begin(), closing_brackets.begin()\
    \ + 1);\n    bool result = false;\n    for (auto it = opening_brackets.begin();\
    \ it != opening_brackets.end(); ++it) {\n        if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n            result = true;\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0m4r9aq9.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmp0m4r9aq9.cpp:20:40: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                  |                            |\n   \
    \   |                                  |                            std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    \      |                                  std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:904:5:\
    \ note: candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator!=(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  904 |     operator!=(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:904:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1037:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1112:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1112 |     operator!=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1112:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1186:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1186 |     operator!=(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1186:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1260:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1260 |     operator!=(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1260:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1334:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1334 |     operator!=(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1334:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1408:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1408 |     operator!=(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1408:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:1486:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1486 |     operator!=(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1486:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/regex.h:2015:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 2015 |     operator!=(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:2015:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/postypes.h:227:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  227 |     operator!=(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:227:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:461:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  461 |     operator!=(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:461:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:337:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  337 |     operator!=(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:337:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:375:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator!=(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  375 |     operator!=(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:375:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched\
    \ types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1148:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator!=(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1148 |     operator!=(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1154:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator!=(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1154 |     operator!=(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1154:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:173:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  173 |     operator!=(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:173:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6191:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6191 |     operator!=(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6191:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6204:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6204 |     operator!=(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6204:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018long unsigned int\u2019\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6216:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator!=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6216 |     operator!=(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6216:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/system_error:319:3: note: candidate:\
    \ \u2018bool std::operator!=(const std::error_code&, const std::error_code&)\u2019\
    \n  319 |   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:319:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_code&\u2019\n\
    \  319 |   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:323:3:\
    \ note: candidate: \u2018bool std::operator!=(const std::error_code&, const std::error_condition&)\u2019\
    \n  323 |   operator!=(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:323:32: note:\
    \   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_code&\u2019\n\
    \  323 |   operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:327:3:\
    \ note: candidate: \u2018bool std::operator!=(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  327 |   operator!=(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:327:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_condition&\u2019\
    \n  327 |   operator!=(const error_condition& __lhs, const error_code& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:331:3:\
    \ note: candidate: \u2018bool std::operator!=(const std::error_condition&, const\
    \ std::error_condition&)\u2019\n  331 |   operator!=(const error_condition& __lhs,\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:331:37: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_condition&\u2019\
    \n  331 |   operator!=(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:214:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator!=(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  214 |     operator!=(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:214:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/complex:481:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator!=(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  481 |     operator!=(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:481:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/complex:486:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator!=(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  486 |     operator!=(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:486:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/complex:491:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator!=(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  491 |     operator!=(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:491:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::complex<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:299:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator!=(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  299 |     operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:299:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:306:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator!=(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  306 |     operator!=(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:306:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator!=(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2338 |   \
    \  operator!=(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2338:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::deque<_Tp, _Alloc>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/array:257:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator!=(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  257 |     operator!=(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:257:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::array<_Tp,\
    \ _Nm>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/tuple:1445:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator!=(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1445 |     operator!=(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1445:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched\
    \ types \u2018const std::tuple<_Tps ...>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:764:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator!=(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  764 |     operator!=(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:764:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/functional:59,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/std_function.h:770:5: note:\
    \ candidate: \u2018template<class _Res, class ... _Args> bool std::operator!=(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  770 |     operator!=(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:770:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::function<_Res(_ArgTypes\
    \ ...)>\u2019\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:732:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator!=(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  732 |     operator!=(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:732:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:738:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator!=(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  738 |     operator!=(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:738:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/bits/locale_conv.h:41,\n             \
    \    from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:743:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator!=(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  743 |     operator!=(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:743:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::unique_ptr<_Tp,\
    \ _Dp>\u2019\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:141:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator!=(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  141 |     operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:141:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:2032:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator!=(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 2032 |     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:2032:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/map:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1479:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator!=(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1479 |     operator!=(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1479:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/map:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1143:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator!=(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1143 |     operator!=(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1143:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1428:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator!=(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1428 |     operator!=(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1428:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1434:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator!=(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1434 |     operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1434:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n              \
    \   from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1439:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator!=(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1439 |     operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1439:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__shared_ptr<_Tp,\
    \ _Lp>\u2019\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:398:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator!=(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  398 |     operator!=(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:398:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:403:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator!=(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  403 |     operator!=(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:403:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:408:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator!=(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  408 |     operator!=(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:408:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1912:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator!=(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1912 | \
    \    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1912:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:362:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator!=(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  362 |     operator!=(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:362:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::queue<_Tp,\
    \ _Seq>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:1003:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator!=(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n 1003 |     operator!=(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:1003:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::set<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/set:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:988:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator!=(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  988 |     operator!=(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:988:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/stack:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:337:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator!=(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  337 |     operator!=(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:337:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::stack<_Tp,\
    \ _Seq>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  418\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n \
    \                from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/valarray:1198:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to,\
    \ _Tp>::result_type> std::operator!=(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1198 | _DEFINE_BINARY_OPERATOR(!=, __not_equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1198:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::valarray<_Tp>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/valarray:1198:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__not_equal_to,\
    \ _Tp>::result_type> std::operator!=(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1198 | _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1198:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/valarray:1198:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to,\
    \ _Tp>::result_type> std::operator!=(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1198 | _DEFINE_BINARY_OPERATOR(!=, __not_equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1198:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/forward_list:38,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/forward_list.h:1451:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator!=(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n 1451 |     operator!=(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.h:1451:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/thread:286:3:\
    \ note: candidate: \u2018bool std::operator!=(std::thread::id, std::thread::id)\u2019\
    \n  286 |   operator!=(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:286:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019} to \u2018std::thread::id\u2019\n  286 |   operator!=(thread::id __x,\
    \ thread::id __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included\
    \ from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:421:5:\
    \ note: candidate: \u2018template<class _UIntType, _UIntType __a, _UIntType __c,\
    \ _UIntType __m> bool std::operator!=(const std::linear_congruential_engine<_UIntType,\
    \ __a, __c, __m>&, const std::linear_congruential_engine<_UIntType, __a, __c,\
    \ __m>&)\u2019\n  421 |     operator!=(const std::linear_congruential_engine<_UIntType,\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:421:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::linear_congruential_engine<_UIntType,\
    \ __a, __c, __m>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:658:5:\
    \ note: candidate: \u2018template<class _UIntType, long unsigned int __w, long\
    \ unsigned int __n, long unsigned int __m, long unsigned int __r, _UIntType __a,\
    \ long unsigned int __u, _UIntType __d, long unsigned int __s, _UIntType __b,\
    \ long unsigned int __t, _UIntType __c, long unsigned int __l, _UIntType __f>\
    \ bool std::operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n,\
    \ __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>&, const std::mersenne_twister_engine<_UIntType,\
    \ __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>&)\u2019\n \
    \ 658 |     operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n,\
    \ __m,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:658:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::mersenne_twister_engine<_UIntType,\
    \ __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:859:5:\
    \ note: candidate: \u2018template<class _UIntType, long unsigned int __w, long\
    \ unsigned int __s, long unsigned int __r> bool std::operator!=(const std::subtract_with_carry_engine<_UIntType,\
    \ __w, __s, __r>&, const std::subtract_with_carry_engine<_UIntType, __w, __s,\
    \ __r>&)\u2019\n  859 |     operator!=(const std::subtract_with_carry_engine<_UIntType,\
    \ __w,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:859:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::subtract_with_carry_engine<_UIntType,\
    \ __w, __s, __r>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:1082:5:\
    \ note: candidate: \u2018template<class _RandomNumberEngine, long unsigned int\
    \ __p, long unsigned int __r> bool std::operator!=(const std::discard_block_engine<_RandomNumberEngine,\
    \ __p, __r>&, const std::discard_block_engine<_RandomNumberEngine, __p, __r>&)\u2019\
    \n 1082 |     operator!=(const std::discard_block_engine<_RandomNumberEngine,\
    \ __p,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1082:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::discard_block_engine<_RandomNumberEngine,\
    \ __p, __r>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:1279:5:\
    \ note: candidate: \u2018template<class _RandomNumberEngine, long unsigned int\
    \ __w, class _UIntType> bool std::operator!=(const std::independent_bits_engine<_RandomNumberEngine,\
    \ __w, _UIntType>&, const std::independent_bits_engine<_RandomNumberEngine, __w,\
    \ _UIntType>&)\u2019\n 1279 |     operator!=(const std::independent_bits_engine<_RandomNumberEngine,\
    \ __w,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1279:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::independent_bits_engine<_RandomNumberEngine,\
    \ __w, _UIntType>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:1532:5:\
    \ note: candidate: \u2018template<class _RandomNumberEngine, long unsigned int\
    \ __k> bool std::operator!=(const std::shuffle_order_engine<_RandomNumberEngine,\
    \ __k>&, const std::shuffle_order_engine<_RandomNumberEngine, __k>&)\u2019\n 1532\
    \ |     operator!=(const std::shuffle_order_engine<_RandomNumberEngine,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1532:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched\
    \ types \u2018const std::shuffle_order_engine<_RandomNumberEngine, __k>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:1692:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::uniform_int_distribution<_IntType>&,\
    \ const std::uniform_int_distribution<_IntType>&)\u2019\n 1692 |     operator!=(const\
    \ std::uniform_int_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1692:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::uniform_int_distribution<_IntType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:1913:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::uniform_real_distribution<_IntType>&,\
    \ const std::uniform_real_distribution<_IntType>&)\u2019\n 1913 |     operator!=(const\
    \ std::uniform_real_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1913:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::uniform_real_distribution<_IntType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:2170:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 2170 |     operator!=(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2170:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:2381:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::lognormal_distribution<_RealType>&, const std::lognormal_distribution<_RealType>&)\u2019\
    \n 2381 |     operator!=(const std::lognormal_distribution<_RealType>& __d1,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2381:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::lognormal_distribution<_RealType>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:2612:6:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::gamma_distribution<_RealType>&, const std::gamma_distribution<_RealType>&)\u2019\
    \n 2612 |      operator!=(const std::gamma_distribution<_RealType>& __d1,\n  \
    \    |      ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2612:6: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::gamma_distribution<_RealType>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:2836:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::chi_squared_distribution<_RealType>&, const std::chi_squared_distribution<_RealType>&)\u2019\
    \n 2836 |     operator!=(const std::chi_squared_distribution<_RealType>& __d1,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2836:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::chi_squared_distribution<_RealType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:3010:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::cauchy_distribution<_RealType>&, const std::cauchy_distribution<_RealType>&)\u2019\
    \n 3010 |     operator!=(const std::cauchy_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3010:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::cauchy_distribution<_RealType>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:3274:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::fisher_f_distribution<_RealType>&, const std::fisher_f_distribution<_RealType>&)\u2019\
    \n 3274 |     operator!=(const std::fisher_f_distribution<_RealType>& __d1,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3274:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::fisher_f_distribution<_RealType>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:3496:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::student_t_distribution<_RealType>&, const std::student_t_distribution<_RealType>&)\u2019\
    \n 3496 |     operator!=(const std::student_t_distribution<_RealType>& __d1,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3496:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::student_t_distribution<_RealType>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:3684:3:\
    \ note: candidate: \u2018bool std::operator!=(const std::bernoulli_distribution&,\
    \ const std::bernoulli_distribution&)\u2019\n 3684 |   operator!=(const std::bernoulli_distribution&\
    \ __d1,\n      |   ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3684:49: note: \
    \  no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::bernoulli_distribution&\u2019\
    \n 3684 |   operator!=(const std::bernoulli_distribution& __d1,\n      |     \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/usr/include/c++/9/bits/random.h:3959:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::binomial_distribution<_IntType>&,\
    \ const std::binomial_distribution<_IntType>&)\u2019\n 3959 |     operator!=(const\
    \ std::binomial_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3959:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::binomial_distribution<_IntType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:4138:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::geometric_distribution<_IntType>&,\
    \ const std::geometric_distribution<_IntType>&)\u2019\n 4138 |     operator!=(const\
    \ std::geometric_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:4138:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::geometric_distribution<_IntType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:4392:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::negative_binomial_distribution<_IntType>&,\
    \ const std::negative_binomial_distribution<_IntType>&)\u2019\n 4392 |     operator!=(const\
    \ std::negative_binomial_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/random.h:4392:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note:   mismatched types \u2018const std::negative_binomial_distribution<_IntType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:4618:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::poisson_distribution<_IntType>&,\
    \ const std::poisson_distribution<_IntType>&)\u2019\n 4618 |     operator!=(const\
    \ std::poisson_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:4618:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::poisson_distribution<_IntType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:4809:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::exponential_distribution<_RealType>&, const std::exponential_distribution<_RealType>&)\u2019\
    \n 4809 |     operator!=(const std::exponential_distribution<_RealType>& __d1,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:4809:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::exponential_distribution<_RealType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:5019:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::weibull_distribution<_RealType>&, const std::weibull_distribution<_RealType>&)\u2019\
    \n 5019 |     operator!=(const std::weibull_distribution<_RealType>& __d1,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:5019:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::weibull_distribution<_RealType>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:5229:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::extreme_value_distribution<_RealType>&, const std::extreme_value_distribution<_RealType>&)\u2019\
    \n 5229 |     operator!=(const std::extreme_value_distribution<_RealType>& __d1,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:5229:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::extreme_value_distribution<_RealType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:5494:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::discrete_distribution<_IntType>&,\
    \ const std::discrete_distribution<_IntType>&)\u2019\n 5494 |     operator!=(const\
    \ std::discrete_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:5494:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::discrete_distribution<_IntType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:5765:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::piecewise_constant_distribution<_RealType>&, const std::piecewise_constant_distribution<_RealType>&)\u2019\
    \n 5765 |     operator!=(const std::piecewise_constant_distribution<_RealType>&\
    \ __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:5765:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::piecewise_constant_distribution<_RealType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/random.h:6038:5:\
    \ note: candidate: \u2018template<class _RealType> bool std::operator!=(const\
    \ std::piecewise_linear_distribution<_RealType>&, const std::piecewise_linear_distribution<_RealType>&)\u2019\
    \n 6038 |     operator!=(const std::piecewise_linear_distribution<_RealType>&\
    \ __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:6038:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::piecewise_linear_distribution<_RealType>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/scoped_allocator:498:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator!=(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  498\
    \ |     operator!=(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:498:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64: note: \
    \  mismatched types \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) != closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/unordered_map:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2099:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\n\
    \ 2099 |     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2099:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2111:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2111 |     operator!=(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2111:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_multimap<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1711:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator!=(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1711\
    \ |     operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1711:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1723:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator!=(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1723 |     operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1723:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_multiset<_Value, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ != closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/bits/allocator.h:159:7:\
    \ note: candidate: \u2018bool std::operator!=(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  159 |       operator!=(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:159:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  159 |       operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0m4r9aq9.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:172:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator!=(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  172 |  operator!=(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:172:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp0m4r9aq9.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const __gnu_cxx::new_allocator<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) != closing_brackets.end()) {\n\
    \      |                                                                ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(){}[]\";\n    std::string closing_brackets = \"(){}[]\"\
    ;\n    std::string opening_brackets_set = opening_brackets;\n    std::string closing_brackets_set\
    \ = closing_brackets;\n    std::string brackets_set = brackets;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n    std::string\
    \ brackets_set_copy = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n\
    \    std::string brackets_set_copy = brackets_set;\n    std::string brackets_set_copy\
    \ = brackets_set;\n    std::string brackets_set_copy = brackets_set;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5abya0pg.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmp5abya0pg.cpp:20:17: error: redeclaration of \u2018std::string brackets_set_copy\u2019\
    \n   20 |     std::string brackets_set_copy = brackets_set;\n      |         \
    \        ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string\
    \ brackets_set_copy\u2019 previously declared here\n   19 |     std::string brackets_set_copy\
    \ = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:21:17:\
    \ error: redeclaration of \u2018std::string brackets_set_copy\u2019\n   21 | \
    \    std::string brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:22:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   22 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:23:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   23 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:24:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   24 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:25:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   25 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:26:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   26 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:27:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   27 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:28:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   28 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:29:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   29 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:30:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   30 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:31:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   31 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:32:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   32 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:33:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   33 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:34:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   34 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:35:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   35 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:36:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   36 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:37:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   37 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:38:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   38 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:39:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   39 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:40:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   40 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:41:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   41 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:42:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   42 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:43:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   43 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:44:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   44 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:45:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   45 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:46:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   46 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:47:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   47 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:48:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   48 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:49:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   49 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:50:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   50 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:51:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   51 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:52:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   52 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:53:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   53 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:54:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   54 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:55:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   55 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:56:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   56 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:57:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   57 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:58:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   58 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:59:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   59 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:60:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   60 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:61:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   61 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:62:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   62 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:63:17: error:\
    \ redeclaration of \u2018std::string brackets_set_copy\u2019\n   63 |     std::string\
    \ brackets_set_copy = brackets_set;\n      |                 ^~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5abya0pg.cpp:19:17: note: \u2018std::string brackets_set_copy\u2019 previously\
    \ declared here\n   19 |     std::string brackets_set_copy = brackets_set;\n \
    \     |                 ^~~~~~~~~~~~~~~~~\n/tmp/tmp5abya0pg.cpp:64:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   64 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpuwiizc5s: /tmp/tmpuwiizc5s.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = brackets.size();\n    int close_brackets = 0;\n    for (int i = 0; i < open_brackets;\
    \ i++) {\n        if (brackets[i] == '(') {\n            close_brackets++;\n \
    \       }\n        if (brackets[i] == ')') {\n            close_brackets--;\n\
    \        }\n    }\n    return close_brackets == 0;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpafzaytui: /tmp/tmpafzaytui.cpp:33: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp8jfe5aco: /tmp/tmp8jfe5aco.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    size_t open_brackets = brackets.size();\n    size_t close_brackets\
    \ = 0;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            ++open_brackets;\n        } else if (brackets[i] == ')')\
    \ {\n            ++close_brackets;\n        } else {\n            result = false;\n\
    \        }\n    }\n    if (open_brackets == close_brackets) {\n        return\
    \ true;\n    } else {\n        return false;\n    }\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpv1h3klkk: /tmp/tmpv1h3klkk.cpp:34: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            opening_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            closing_brackets++;\n \
    \       }\n    }\n    return opening_brackets == closing_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpdntc4lm3: /tmp/tmpdntc4lm3.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpml1hpfqm: /tmp/tmpml1hpfqm.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find(\")\", brackets.find(c) + 1) != std::string::npos) {\n  \
    \              result = false;\n                break;\n            }\n      \
    \  } else if (c == ')') {\n            if (brackets.find(\"(\", brackets.find(c)\
    \ + 1) != std::string::npos) {\n                result = false;\n            \
    \    break;\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp7tervqsa: /tmp/tmp7tervqsa.cpp:32: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n            }\n            i += 1;\n        } else {\n           \
    \ if (brackets[i + 1] != ')') {\n                result = false;\n           \
    \ }\n            i += 1;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmphdohiyww: /tmp/tmphdohiyww.cpp:33: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpp55nzem9: /tmp/tmpp55nzem9.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ brackets_size = brackets.size();\n    size_t opening_brackets_cnt = 0;\n   \
    \ size_t closing_brackets_cnt = 0;\n    for (size_t i = 0; i < brackets_size;\
    \ i++) {\n        if (brackets[i] == '(') {\n            opening_brackets_cnt++;\n\
    \        } else if (brackets[i] == ')') {\n            closing_brackets_cnt++;\n\
    \        }\n    }\n    return opening_brackets_cnt == closing_brackets_cnt;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp7v19hvdw: /tmp/tmp7v19hvdw.cpp:33: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(\";\n    std::string closing_brackets = \")\";\n    std::string\
    \ opening_brackets_reversed = closing_brackets;\n    std::string closing_brackets_reversed\
    \ = opening_brackets;\n    std::string opening_brackets_reversed_reversed = opening_brackets_reversed;\n\
    \    std::string closing_brackets_reversed_reversed = closing_brackets_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed = opening_brackets_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed = closing_brackets_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed = opening_brackets_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed;\n    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed;\n    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    \n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmpq8tj12.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpmpq8tj12.cpp:31:108: error: \u2018closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    \ was not declared in this scope; did you mean \u2018closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    ?\n   31 |     std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \      |                                                                     \
    \                                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                                     \
    \                                       closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\n\
    /tmp/tmpmpq8tj12.cpp:33:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n   33 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp1asywnt1: /tmp/tmp1asywnt1.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    std::string brackets_copy = brackets;\n\
    \    for(int i = 0; i < brackets_copy.size(); i++) {\n        if(brackets_copy[i]\
    \ == '(') {\n            open_brackets++;\n        }\n        if(brackets_copy[i]\
    \ == ')') {\n            close_brackets++;\n        }\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmp9gcqp276: /tmp/tmp9gcqp276.cpp:34: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpb9qw5lye: /tmp/tmpb9qw5lye.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpl32eggd2: /tmp/tmpl32eggd2.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpj_ixpghn: /tmp/tmpj_ixpghn.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp0jydff2y: /tmp/tmp0jydff2y.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpq_zqtt41: /tmp/tmpq_zqtt41.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnelwrer5: /tmp/tmpnelwrer5.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpfqaadfa6: /tmp/tmpfqaadfa6.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpu7jszh_k: /tmp/tmpu7jszh_k.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') ++open_brackets;\n\
    \        if (brackets[i] == ')') ++close_brackets;\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpuhybix8_: /tmp/tmpuhybix8_.cpp:24: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        } else {\n            return false;\n        }\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmph8foihtj: /tmp/tmph8foihtj.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp_ok94yql: /tmp/tmp_ok94yql.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpukvl_7qa: /tmp/tmpukvl_7qa.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets[brackets.size() - 1] != ')') {\n                result = false;\n\
    \                break;\n            }\n        } else if (c == ')') {\n     \
    \       if (brackets[brackets.size() - 1] != '(') {\n                result =\
    \ false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpef_9y_zk: /tmp/tmpef_9y_zk.cpp:32: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpv_ndzhsj: /tmp/tmpv_ndzhsj.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2ettrthp: /tmp/tmp2ettrthp.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    if (open_brackets == close_brackets) {\n        return true;\n\
    \    } else {\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpiub9uvvc: /tmp/tmpiub9uvvc.cpp:36: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    opening_brackets.erase(opening_brackets.begin(), std::find(opening_brackets.begin(),\
    \ opening_brackets.end(), '('));\n    closing_brackets.erase(closing_brackets.begin(),\
    \ std::find(closing_brackets.begin(), closing_brackets.end(), ')'));\n    return\
    \ opening_brackets == closing_brackets;\n}\nint main() {\n    auto candidate =\
    \ correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpawwv3oo9: /tmp/tmpawwv3oo9.cpp:22: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    if (open_brackets != close_brackets)\
    \ {\n        return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpkmcg5q4e: /tmp/tmpkmcg5q4e.cpp:30: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        } else {\n            return false;\n        }\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnckbnap3: /tmp/tmpnckbnap3.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(\";\n    std::string closing_brackets = \")\";\n    std::string\
    \ opening_brackets_index = brackets.find(opening_brackets);\n    std::string closing_brackets_index\
    \ = brackets.find(closing_brackets);\n    if (opening_brackets_index == std::string::npos\
    \ || closing_brackets_index == std::string::npos) {\n        return false;\n \
    \   }\n    std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n    if (opening_brackets_sub\
    \ == opening_brackets) {\n        return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsrdpiwk0.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpsrdpiwk0.cpp:16:55: error: conversion from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   16 |     std::string\
    \ opening_brackets_index = brackets.find(opening_brackets);\n      |         \
    \                                 ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpsrdpiwk0.cpp:17:55:\
    \ error: conversion from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   17 |     std::string\
    \ closing_brackets_index = brackets.find(closing_brackets);\n      |         \
    \                                 ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpsrdpiwk0.cpp:18:32:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} and \u2018const size_type\u2019\
    \ {aka \u2018const long unsigned int\u2019})\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |         ~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~\n      |         | \
    \                                     |\n      |         |                   \
    \                   const size_type {aka const long unsigned int}\n      |   \
    \      std::string {aka std::__cxx11::basic_string<char>}\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n            \
    \     from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::fpos<_StateT>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:64,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::pair<_T1, _T2>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/string:41,\n            \
    \     from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::allocator<_CharT>\u2019\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                ^~~~\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018const size_type\u2019 {aka \u2018const long unsigned\
    \ int\u2019}\n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/string:55,\n            \
    \     from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/string:55,\n            \
    \     from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018long unsigned int\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n   \
    \              from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  297 |   operator==(const error_code&\
    \ __lhs, const error_condition& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:304:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_code&)\u2019\n  304 |   operator==(const\
    \ error_condition& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:304:37: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::error_condition&\u2019\
    \n  311 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n         \
    \        from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:463:5: note:\
    \ candidate: \u2018template<class _Tp> constexpr bool std::operator==(const std::complex<_Tp>&,\
    \ const std::complex<_Tp>&)\u2019\n  463 |     operator==(const complex<_Tp>&\
    \ __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018const\
    \ size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/deque:67,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n            \
    \     from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/deque:67,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n            \
    \     from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::deque<_Tp, _Alloc>\u2019\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                ^~~~\nIn file included\
    \ from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::array<_Tp,\
    \ _Nm>\u2019\n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/functional:54,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n       \
    \          from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/tuple:1419:5: note:\
    \ candidate: \u2018template<class ... _TElements, class ... _UElements> constexpr\
    \ bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::tuple<_Tps ...>\u2019\n   18 |     if (opening_brackets_index == std::string::npos\
    \ || closing_brackets_index == std::string::npos) {\n      |                 \
    \                               ^~~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/functional:59,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n       \
    \          from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |   \
    \  if (opening_brackets_index == std::string::npos || closing_brackets_index ==\
    \ std::string::npos) {\n      |                                              \
    \  ^~~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n   \
    \              from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |   \
    \  if (opening_brackets_index == std::string::npos || closing_brackets_index ==\
    \ std::string::npos) {\n      |                                              \
    \  ^~~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n   \
    \              from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                ^~~~\nIn file included\
    \ from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                            ^~~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/map:61,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n              \
    \   from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc>\
    \ bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key,\
    \ _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const map<_Key, _Tp,\
    \ _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/map:62,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n              \
    \   from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n \
    \                from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |\
    \     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n \
    \                from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 | \
    \    if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n \
    \                from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                ^~~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/memory:81,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n           \
    \      from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018const\
    \ size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::vector<_Tp, _Alloc>\u2019\n   18 |    \
    \ if (opening_brackets_index == std::string::npos || closing_brackets_index ==\
    \ std::string::npos) {\n      |                                              \
    \  ^~~~\nIn file included from /usr/include/c++/9/queue:64,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n               \
    \  from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5: note:\
    \ candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::queue<_Tp,\
    \ _Seq>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                            ^~~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::set<_Key, _Compare, _Alloc>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/set:62,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n              \
    \   from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/stack:61,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n            \
    \     from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::stack<_Tp,\
    \ _Seq>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                            ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   18 |     if (opening_brackets_index ==\
    \ std::string::npos || closing_brackets_index == std::string::npos) {\n      |\
    \                                                ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   18 |     if (opening_brackets_index ==\
    \ std::string::npos || closing_brackets_index == std::string::npos) {\n      |\
    \                                                ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n        \
    \         from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   18 |     if (opening_brackets_index ==\
    \ std::string::npos || closing_brackets_index == std::string::npos) {\n      |\
    \                                                ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018const size_type\u2019 {aka \u2018\
    const long unsigned int\u2019}\n   18 |     if (opening_brackets_index == std::string::npos\
    \ || closing_brackets_index == std::string::npos) {\n      |                 \
    \                               ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018const\
    \ size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                ^~~~\nIn file included from\
    \ /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                            ^~~~\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} to\
    \ \u2018std::thread::id\u2019\n  276 |   operator==(thread::id __x, thread::id\
    \ __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::normal_distribution<_RealType>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n   \
    \              from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                            ^~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                            ^~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n   \
    \              from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                            ^~~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:48:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \     ^~~~\n/tmp/tmpsrdpiwk0.cpp:18:79: error: no match for \u2018operator==\u2019\
    \ (operand types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019})\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \             ~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~\n      |           \
    \                                             |                              \
    \        |\n      |                                                        | \
    \                                     const size_type {aka const long unsigned\
    \ int}\n      |                                                        std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::fpos<_StateT>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::pair<_T1, _T2>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::allocator<_CharT>\u2019\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                                 \
    \                              ^~~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5: note:\
    \ candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n\
    \ 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018std::__cxx11::basic_string<char>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018long unsigned int\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/ios_base.h:46,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/system_error:292:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  297 |   operator==(const error_code&\
    \ __lhs, const error_condition& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:304:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_code&)\u2019\n  304 |   operator==(const\
    \ error_condition& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:304:37: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::error_condition&\u2019\
    \n  311 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018const\
    \ size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::deque<_Tp, _Alloc>\u2019\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                                 \
    \                              ^~~~\nIn file included from /usr/include/c++/9/tuple:39,\n\
    \                 from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/array:252:5: note: candidate: \u2018\
    template<class _Tp, long unsigned int _Nm> bool std::operator==(const std::array<_Tp,\
    \ _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const array<_Tp,\
    \ _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n/usr/include/c++/9/array:252:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::array<_Tp, _Nm>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::tuple<_Tps ...>\u2019\n   18 |     if (opening_brackets_index == std::string::npos\
    \ || closing_brackets_index == std::string::npos) {\n      |                 \
    \                                                                            \
    \  ^~~~\nIn file included from /usr/include/c++/9/functional:59,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n          \
    \       from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/functional:59,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/locale_conv.h:41,\n                 from /usr/include/c++/9/locale:43,\n\
    \                 from /usr/include/c++/9/iomanip:43,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |   \
    \  if (opening_brackets_index == std::string::npos || closing_brackets_index ==\
    \ std::string::npos) {\n      |                                              \
    \                                                 ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/locale_conv.h:41,\n                 from /usr/include/c++/9/locale:43,\n\
    \                 from /usr/include/c++/9/iomanip:43,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   18 |   \
    \  if (opening_brackets_index == std::string::npos || closing_brackets_index ==\
    \ std::string::npos) {\n      |                                              \
    \                                                 ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/locale_conv.h:41,\n                 from /usr/include/c++/9/locale:43,\n\
    \                 from /usr/include/c++/9/iomanip:43,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                                 \
    \                              ^~~~\nIn file included from /usr/include/c++/9/iterator:66,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                                                                           ^~~~\n\
    In file included from /usr/include/c++/9/list:63,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/map:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/map:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019\n   18 |\
    \     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   18 | \
    \    if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/shared_ptr.h:52,\n                 from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                                 \
    \                              ^~~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018const\
    \ size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/queue:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::vector<_Tp, _Alloc>\u2019\n   18 |    \
    \ if (opening_brackets_index == std::string::npos || closing_brackets_index ==\
    \ std::string::npos) {\n      |                                              \
    \                                                 ^~~~\nIn file included from\
    \ /usr/include/c++/9/queue:64,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::queue<_Tp,\
    \ _Seq>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                                                                           ^~~~\n\
    In file included from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::set<_Key, _Compare, _Alloc>\u2019\n   18\
    \ |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/set:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/stack:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::stack<_Tp,\
    \ _Seq>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                                                                           ^~~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   18 |     if (opening_brackets_index ==\
    \ std::string::npos || closing_brackets_index == std::string::npos) {\n      |\
    \                                                                            \
    \                   ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   18 |     if (opening_brackets_index ==\
    \ std::string::npos || closing_brackets_index == std::string::npos) {\n      |\
    \                                                                            \
    \                   ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   18 |     if (opening_brackets_index ==\
    \ std::string::npos || closing_brackets_index == std::string::npos) {\n      |\
    \                                                                            \
    \                   ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018const size_type\u2019 {aka \u2018\
    const long unsigned int\u2019}\n   18 |     if (opening_brackets_index == std::string::npos\
    \ || closing_brackets_index == std::string::npos) {\n      |                 \
    \                                                                            \
    \  ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018const\
    \ size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if (opening_brackets_index\
    \ == std::string::npos || closing_brackets_index == std::string::npos) {\n   \
    \   |                                                                        \
    \                       ^~~~\nIn file included from /usr/include/c++/9/forward_list:40,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                                                                           ^~~~\n\
    In file included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} to\
    \ \u2018std::thread::id\u2019\n  276 |   operator==(thread::id __x, thread::id\
    \ __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::normal_distribution<_RealType>\u2019\n\
    \   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5: note: candidate:\
    \ \u2018template<class _OutA1, class _OutA2, class ... _InA> bool std::operator==(const\
    \ std::scoped_allocator_adaptor<_OutA1, _InA ...>&, const std::scoped_allocator_adaptor<_InnerHead,\
    \ _InnerTail ...>&)\u2019\n  489 |     operator==(const scoped_allocator_adaptor<_OutA1,\
    \ _InA...>& __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                                                                           ^~~~\n\
    In file included from /usr/include/c++/9/unordered_map:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2105 |     operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                                                                           ^~~~\n\
    In file included from /usr/include/c++/9/unordered_set:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:\
    \ candidate: \u2018template<class _Value, class _Hash, class _Pred, class _Alloc>\
    \ bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&,\
    \ const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705 |    \
    \ operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n      |\
    \     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019\n   18 |     if (opening_brackets_index == std::string::npos ||\
    \ closing_brackets_index == std::string::npos) {\n      |                    \
    \                                                                           ^~~~\n\
    In file included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7: note: candidate:\
    \ \u2018bool std::operator==(const std::allocator<char>&, const std::allocator<char>&)\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18: note:   no\
    \ known conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::allocator<char>&\u2019\n  155 |       operator==(const allocator&,\
    \ const allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \n   18 |     if (opening_brackets_index == std::string::npos || closing_brackets_index\
    \ == std::string::npos) {\n      |                                           \
    \                                                    ^~~~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n              \
    \   from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note: candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::new_allocator<char>&, const __gnu_cxx::new_allocator<_Tp>&)\u2019\
    \n  166 |  operator==(const new_allocator&, const new_allocator<_Up>&)\n     \
    \ |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:18:95: note: \
    \  mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and \u2018\
    const size_type\u2019 {aka \u2018const long unsigned int\u2019}\n   18 |     if\
    \ (opening_brackets_index == std::string::npos || closing_brackets_index == std::string::npos)\
    \ {\n      |                                                                 \
    \                              ^~~~\n/tmp/tmpsrdpiwk0.cpp:21:103: error: no match\
    \ for \u2018operator-\u2019 (operand types are \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} and \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019})\n   21 |     std::string opening_brackets_sub\
    \ = brackets.substr(opening_brackets_index, closing_brackets_index - opening_brackets_index);\n\
    \      |                                                                     \
    \           ~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~\n      |         \
    \                                                                       |    \
    \                    |\n      |                                              \
    \                                  basic_string<[...]>      basic_string<[...]>\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   21\
    \ |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1209:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> decltype ((__x.base()\
    \ - __y.base())) std::operator-(const std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1209 |     operator-(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1209:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\
    \n   21 |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:361:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator-(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  361 |     operator-(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:361:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   21 |     std::string\
    \ opening_brackets_sub = brackets.substr(opening_brackets_index, closing_brackets_index\
    \ - opening_brackets_index);\n      |                                        \
    \                                                                 ^~~~~~~~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:370:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator-(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  370 |     operator-(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:370:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   21 |     std::string\
    \ opening_brackets_sub = brackets.substr(opening_brackets_index, closing_brackets_index\
    \ - opening_brackets_index);\n      |                                        \
    \                                                                 ^~~~~~~~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:379:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator-(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  379 |     operator-(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:379:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   21 |     std::string\
    \ opening_brackets_sub = brackets.substr(opening_brackets_index, closing_brackets_index\
    \ - opening_brackets_index);\n      |                                        \
    \                                                                 ^~~~~~~~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/complex:456:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator-(const\
    \ std::complex<_Tp>&)\u2019\n  456 |     operator-(const complex<_Tp>& __x)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/complex:456:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:   \u2018\
    std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived\
    \ from \u2018const std::complex<_Tp>\u2019\n   21 |     std::string opening_brackets_sub\
    \ = brackets.substr(opening_brackets_index, closing_brackets_index - opening_brackets_index);\n\
    \      |                                                                     \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:370:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> typename\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type std::operator-(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  370 |     operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:370:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   21 |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:382:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> typename std::_Deque_iterator<_Tp, _Ref, _Ptr>::difference_type\
    \ std::operator-(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp,\
    \ _RefR, _PtrR>&)\u2019\n  382 |     operator-(const _Deque_iterator<_Tp, _RefL,\
    \ _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:382:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   21 |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/vector:68,\n\
    \                 from /usr/include/c++/9/queue:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_bvector.h:214:3:\
    \ note: candidate: \u2018std::ptrdiff_t std::operator-(const std::_Bit_iterator_base&,\
    \ const std::_Bit_iterator_base&)\u2019\n  214 |   operator-(const _Bit_iterator_base&\
    \ __x, const _Bit_iterator_base& __y)\n      |   ^~~~~~~~\n/usr/include/c++/9/bits/stl_bvector.h:214:39:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::_Bit_iterator_base&\u2019\
    \n  214 |   operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base&\
    \ __y)\n      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\nIn file included from\
    \ /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:406:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__minus,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__minus, typename\
    \ _Dom1::value_type>::result_type> std::operator-(const std::_Expr<_Dom1, typename\
    \ _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  406 |     _DEFINE_EXPR_BINARY_OPERATOR(-, __minus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:406:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   21 |     std::string opening_brackets_sub\
    \ = brackets.substr(opening_brackets_index, closing_brackets_index - opening_brackets_index);\n\
    \      |                                                                     \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:406:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__minus,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__minus,\
    \ typename _Dom1::value_type>::result_type> std::operator-(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  406\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(-, __minus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:406:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   21 |     std::string opening_brackets_sub\
    \ = brackets.substr(opening_brackets_index, closing_brackets_index - opening_brackets_index);\n\
    \      |                                                                     \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:406:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__minus,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__minus,\
    \ typename _Dom1::value_type>::result_type> std::operator-(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  406 |     _DEFINE_EXPR_BINARY_OPERATOR(-,\
    \ __minus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:406:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   21 |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:406:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__minus,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__minus,\
    \ typename _Dom1::value_type>::result_type> std::operator-(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  406 |     _DEFINE_EXPR_BINARY_OPERATOR(-, __minus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:406:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   21 |     std::string opening_brackets_sub\
    \ = brackets.substr(opening_brackets_index, closing_brackets_index - opening_brackets_index);\n\
    \      |                                                                     \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~\nIn file included\
    \ from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:406:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__minus,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__minus,\
    \ typename _Dom1::value_type>::result_type> std::operator-(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  406 |     _DEFINE_EXPR_BINARY_OPERATOR(-, __minus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:406:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   21 |     std::string opening_brackets_sub\
    \ = brackets.substr(opening_brackets_index, closing_brackets_index - opening_brackets_index);\n\
    \      |                                                                     \
    \                                    ^~~~~~~~~~~~~~~~~~~~~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1186:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__minus, std::_ValArray,\
    \ std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__minus, _Tp>::result_type>\
    \ std::operator-(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\n\
    \ 1186 | _DEFINE_BINARY_OPERATOR(-, __minus)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1186:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   21 |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1186:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__minus,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__minus,\
    \ _Tp>::result_type> std::operator-(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1186 | _DEFINE_BINARY_OPERATOR(-, __minus)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1186:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   21 |     std::string\
    \ opening_brackets_sub = brackets.substr(opening_brackets_index, closing_brackets_index\
    \ - opening_brackets_index);\n      |                                        \
    \                                                                 ^~~~~~~~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/valarray:1186:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__minus,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__minus,\
    \ _Tp>::result_type> std::operator-(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1186 | _DEFINE_BINARY_OPERATOR(-, __minus)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1186:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   21 |     std::string\
    \ opening_brackets_sub = brackets.substr(opening_brackets_index, closing_brackets_index\
    \ - opening_brackets_index);\n      |                                        \
    \                                                                 ^~~~~~~~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:974:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ decltype ((__lhs.base() - __rhs.base())) __gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\
    \n  974 |     operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:974:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:\
    \   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \n   21 |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpsrdpiwk0.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:986:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> typename __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::difference_type __gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&, const __gnu_cxx::__normal_iterator<_Iterator, _Container>&)\u2019\
    \n  986 |     operator-(const __normal_iterator<_Iterator, _Container>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:986:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpsrdpiwk0.cpp:21:105: note:\
    \   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \n   21 |     std::string opening_brackets_sub = brackets.substr(opening_brackets_index,\
    \ closing_brackets_index - opening_brackets_index);\n      |                 \
    \                                                                            \
    \            ^~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c != '(' && c != ')') {\n\
    \            result = false;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpexm41bkx: /tmp/tmpexm41bkx.cpp:28: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpg0tg7mkv: /tmp/tmpg0tg7mkv.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp04r7ubbk: /tmp/tmp04r7ubbk.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpzbpa9yut: /tmp/tmpzbpa9yut.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = 0;\n  int close_brackets = 0;\n  for (int i = 0; i < brackets.length(); i++)\
    \ {\n    if (brackets[i] == '(')\n      open_brackets++;\n    else if (brackets[i]\
    \ == ')')\n      close_brackets++;\n  }\n  if (open_brackets == close_brackets)\n\
    \    return true;\n  else\n    return false;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2on_t2sk: /tmp/tmp2on_t2sk.cpp:34: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = brackets.size();\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp0xj2lptg: /tmp/tmp0xj2lptg.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        } else {\n            return false;\n        }\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpmrzjbipl: /tmp/tmpmrzjbipl.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.length(); ++i) {\n        if (brackets[i] == '(') {\n           \
    \ ++open_brackets;\n        } else if (brackets[i] == ')') {\n            ++close_brackets;\n\
    \        }\n    }\n    return open_brackets == close_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp1fe_xg2u: /tmp/tmp1fe_xg2u.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    size_t brackets_size\
    \ = brackets.size();\n    for (size_t i = 0; i < brackets_size; ++i) {\n     \
    \   char c = brackets[i];\n        if (c == '(') {\n            open_brackets++;\n\
    \        } else if (c == ')') {\n            close_brackets++;\n        }\n  \
    \  }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp62svo9zm: /tmp/tmp62svo9zm.cpp:34: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpxqwyzf3u: /tmp/tmpxqwyzf3u.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != '(') {\n                result\
    \ = false;\n                break;\n            }\n            i += 2;\n     \
    \   } else if (brackets[i] == ')') {\n            if (brackets[i + 1] != ')')\
    \ {\n                result = false;\n                break;\n            }\n\
    \            i += 2;\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp7uo5wx_i: /tmp/tmp7uo5wx_i.cpp:34: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    for (size_t i = 0; i < opening_brackets.size(); ++i) {\n        if (opening_brackets[i]\
    \ == '(') {\n            opening_brackets[i] = '[';\n            closing_brackets[i]\
    \ = ']';\n        }\n        else if (opening_brackets[i] == '[') {\n        \
    \    opening_brackets[i] = '(';\n            closing_brackets[i] = ')';\n    \
    \    }\n        else if (opening_brackets[i] == '{') {\n            opening_brackets[i]\
    \ = '{';\n            closing_brackets[i] = '}';\n        }\n        else if (opening_brackets[i]\
    \ == '}') {\n            opening_brackets[i] = '{';\n            closing_brackets[i]\
    \ = '}';\n        }\n    }\n    return opening_brackets == closing_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp8nipiwwd: /tmp/tmp8nipiwwd.cpp:38: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = 0;\n  int close_brackets = 0;\n  for (int i = 0; i < brackets.size(); i++)\
    \ {\n    if (brackets[i] == '(') {\n      open_brackets++;\n    } else if (brackets[i]\
    \ == ')') {\n      close_brackets++;\n    }\n  }\n  return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpr3t680ct: /tmp/tmpr3t680ct.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(\";\n    std::string closing_brackets = \")\";\n    std::string\
    \ opening_brackets_reversed = closing_brackets;\n    std::string closing_brackets_reversed\
    \ = opening_brackets;\n    std::string opening_brackets_reversed_reversed = opening_brackets_reversed;\n\
    \    std::string closing_brackets_reversed_reversed = closing_brackets_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed = opening_brackets_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed = closing_brackets_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed = opening_brackets_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed;\n    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed;\n    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed;\n    std::string\
    \ closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ss2rfh0.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmp7ss2rfh0.cpp:31:117: error: \u2018closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\u2019\
    \ was not declared in this scope; did you mean \u2018opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\u2019\
    ?\n   31 |     std::string closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = closing_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    \      |                                                                     \
    \                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                                                     \
    \                                                opening_brackets_reversed_reversed_reversed_reversed_reversed_reversed_reversed\n\
    /tmp/tmp7ss2rfh0.cpp:32:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   32 | }\n      | ^\n/tmp/tmp7ss2rfh0.cpp:32:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i += 2;\n     \
    \   }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpacatd0o4: /tmp/tmpacatd0o4.cpp:29: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp2cfwf0vz: /tmp/tmp2cfwf0vz.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find('(') == std::string::npos) {\n                result = false;\n\
    \                break;\n            }\n        } else if (c == ')') {\n     \
    \       if (brackets.find(')') == std::string::npos) {\n                result\
    \ = false;\n                break;\n            }\n        } else if (c == '[')\
    \ {\n            if (brackets.find('[') == std::string::npos) {\n            \
    \    result = false;\n                break;\n            }\n        } else if\
    \ (c == ']') {\n            if (brackets.find(']') == std::string::npos) {\n \
    \               result = false;\n                break;\n            }\n     \
    \   } else if (c == '{') {\n            if (brackets.find('{') == std::string::npos)\
    \ {\n                result = false;\n                break;\n            }\n\
    \        } else if (c == '}') {\n            if (brackets.find('}') == std::string::npos)\
    \ {\n                result = false;\n                break;\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpfl80ao9h: /tmp/tmpfl80ao9h.cpp:56: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    size_t brackets_size\
    \ = brackets.size();\n    for (size_t i = 0; i < brackets_size; ++i) {\n     \
    \   if (brackets[i] == '(') {\n            open_brackets++;\n        } else if\
    \ (brackets[i] == ')') {\n            close_brackets++;\n        }\n    }\n  \
    \  return open_brackets == close_brackets;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpzygnz2uq: /tmp/tmpzygnz2uq.cpp:33: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        } else {\n            return false;\n        }\n\
    \    }\n    return open_brackets == close_brackets;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmplbvoafb0: /tmp/tmplbvoafb0.cpp:29: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.length(); ++i) {\n        if (brackets[i] == '(') {\n           \
    \ open_brackets++;\n        } else if (brackets[i] == ')') {\n            close_brackets++;\n\
    \        }\n    }\n    return open_brackets == close_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpy3m05l5i: /tmp/tmpy3m05l5i.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpy10wi_ki: /tmp/tmpy10wi_ki.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpmp71b9hl: /tmp/tmpmp71b9hl.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = brackets.size();\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpo101p3l4: /tmp/tmpo101p3l4.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = \"(){}[]\";\n    std::string closing_brackets = \"(){}[]\"\
    ;\n    std::string opening_brackets_reverse = \"{}[]()\";\n    std::string closing_brackets_reverse\
    \ = \"{}[]()\";\n    std::string opening_brackets_reverse2 = \"{}[]\";\n    std::string\
    \ closing_brackets_reverse2 = \"{}[]\";\n    std::string opening_brackets_reverse3\
    \ = \"[]{}()\";\n    std::string closing_brackets_reverse3 = \"[]{}()\";\n   \
    \ std::string opening_brackets_reverse4 = \"[]{}\";\n    std::string closing_brackets_reverse4\
    \ = \"[]{}\";\n    std::string opening_brackets_reverse5 = \"()[]{}\";\n    std::string\
    \ closing_brackets_reverse5 = \"()[]{}\";\n    std::string opening_brackets_reverse6\
    \ = \"()[]\";\n    std::string closing_brackets_reverse6 = \"()[]\";\n    std::string\
    \ opening_brackets_reverse7 = \"()\";\n    std::string closing_brackets_reverse7\
    \ = \"()\";\n    std::string opening_brackets_reverse8 = \"{}\";\n    std::string\
    \ closing_brackets_reverse8 = \"{}\";\n    std::string opening_brackets_reverse9\
    \ = \"{}()\";\n    std::string closing_brackets_reverse9 = \"{}()\";\n    std::string\
    \ opening_brackets_reverse10 = \"{}[]\";\n    std::string closing_brackets_reverse10\
    \ = \"{}[]\";\n    std::string opening_brackets_reverse11 = \"{}{}\";\n    std::string\
    \ closing_brackets_reverse11 = \"{}{}\";\n    std::string opening_brackets_reverse12\
    \ = \"{}{}()\";\n    std::string closing_brackets_reverse12 = \"{}{}()\";\n  \
    \  std::string opening_brackets_reverse13 = \"{}{}[]\";\n    std::string closing_brackets_reverse13\
    \ = \"{}{}[]\";\n    std::string opening_brackets_reverse14 = \"{}{}{}\";\n  \
    \  std::string closing_brackets_reverse14 = \"{}{}{}\";\n    std::string opening_brackets_reverse15\
    \ = \"{}{}{}()\";\n    std::string closing_brackets_reverse15 = \"{}{}{}()\";\n\
    \    std::string opening_brackets_reverse16 = \"{}{}{}[]\";\n    std::string closing_brackets_reverse16\
    \ = \"{}{}{}[]\";\n    std::string opening_brackets_reverse\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9_m8l655.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmp9_m8l655.cpp:49:1: error: expected initializer before \u2018}\u2019\
    \ token\n   49 | }\n      | ^\n/tmp/tmp9_m8l655.cpp:49:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmps1ebigq2: /tmp/tmps1ebigq2.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto it = brackets.begin(); it != brackets.end(); ++it) {\n\
    \        if (*it == '(') {\n            result &= (*(it + 1) != ')');\n      \
    \  }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmp_pmpp502: /tmp/tmp_pmpp502.cpp:24: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp73tvwgku: /tmp/tmp73tvwgku.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpvibze_j4: /tmp/tmpvibze_j4.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ brackets_size = brackets.size();\n    size_t opening_brackets_size = brackets.find_first_of(\"\
    (\") - 1;\n    size_t closing_brackets_size = brackets.find_first_of(\")\") -\
    \ 1;\n    if (opening_brackets_size == closing_brackets_size) {\n        return\
    \ true;\n    }\n    if (opening_brackets_size == brackets_size) {\n        return\
    \ false;\n    }\n    if (closing_brackets_size == brackets_size) {\n        return\
    \ false;\n    }\n    if (opening_brackets_size < closing_brackets_size) {\n  \
    \      return false;\n    }\n    for (size_t i = 0; i < opening_brackets_size;\
    \ ++i) {\n        if (brackets[i] != brackets[opening_brackets_size + i]) {\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpdlhwfvnc: /tmp/tmpdlhwfvnc.cpp:38: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            opening_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            closing_brackets++;\n \
    \       }\n    }\n    return opening_brackets == closing_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpfi48pqvs: /tmp/tmpfi48pqvs.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for(int i = 0; i < brackets.length();\
    \ i++) {\n        if(brackets[i] == '(') {\n            open_brackets++;\n   \
    \     }\n        if(brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpker9rd5d: /tmp/tmpker9rd5d.cpp:33: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    // Your\
    \ code here\n    bool flag = true;\n    for(int i = 0; i < brackets.size() - 1;\
    \ i++) {\n        if(brackets[i] == '(' && brackets[i + 1] == ')') {\n       \
    \     flag = false;\n            break;\n        }\n    }\n    return flag;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpy93ly0mw: /tmp/tmpy93ly0mw.cpp:26: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); i++) {\n        if (brackets[i] == '(') {\n    \
    \        open_brackets++;\n        } else if (brackets[i] == ')') {\n        \
    \    close_brackets++;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpj2e9vsf7: /tmp/tmpj2e9vsf7.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    if (open_brackets == close_brackets) {\n        return true;\n\
    \    } else {\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpe9s0gnaj: /tmp/tmpe9s0gnaj.cpp:36: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            open_brackets++;\n  \
    \      } else if (brackets[i] == ')') {\n            close_brackets++;\n     \
    \   }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpkns0pchl: /tmp/tmpkns0pchl.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c != '(' && c != ')') {\n\
    \            result = false;\n            break;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpp3vf2afi: /tmp/tmpp3vf2afi.cpp:29: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpdd94e73e: /tmp/tmpdd94e73e.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    opening_brackets.erase(opening_brackets.begin(), opening_brackets.begin()\
    \ + 1);\n    closing_brackets.erase(closing_brackets.begin(), closing_brackets.begin()\
    \ + 1);\n    bool result = true;\n    for (size_t i = 0; i < opening_brackets.size();\
    \ i++) {\n        if (opening_brackets[i] != '(') {\n            result = false;\n\
    \            break;\n        }\n    }\n    for (size_t i = 0; i < closing_brackets.size();\
    \ i++) {\n        if (closing_brackets[i] != ')') {\n            result = false;\n\
    \            break;\n        }\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpi7lbe59e: /tmp/tmpi7lbe59e.cpp:35: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    opening_brackets.erase(std::remove(opening_brackets.begin(), opening_brackets.end(),\
    \ '('), opening_brackets.end());\n    closing_brackets.erase(std::remove(closing_brackets.begin(),\
    \ closing_brackets.end(), ')'), closing_brackets.end());\n    return opening_brackets\
    \ == closing_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpnx5xn2jb: /tmp/tmpnx5xn2jb.cpp:22: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int open_brackets\
    \ = 0;\n  for (int i = 0; i < brackets.size(); ++i) {\n    if (brackets[i] ==\
    \ '(') {\n      ++open_brackets;\n    } else if (brackets[i] == ')') {\n     \
    \ --open_brackets;\n      if (open_brackets == 0) {\n        return true;\n  \
    \    }\n    }\n  }\n  return false;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpwtvy16yf: /tmp/tmpwtvy16yf.cpp:33: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    size_t open_brackets = brackets.size();\n    size_t close_brackets\
    \ = 0;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            ++open_brackets;\n        } else if (brackets[i] == ')')\
    \ {\n            ++close_brackets;\n        }\n    }\n    if (open_brackets !=\
    \ close_brackets) {\n        result = false;\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpfb_vet9i: /tmp/tmpfb_vet9i.cpp:31: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find('(') == std::string::npos) {\n                result = false;\n\
    \            }\n        }\n        else if (c == ')') {\n            if (brackets.find(')')\
    \ == std::string::npos) {\n                result = false;\n            }\n  \
    \      }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmp7h7h6vsi: /tmp/tmp7h7h6vsi.cpp:35: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            opening_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            closing_brackets++;\n \
    \       }\n    }\n    return opening_brackets == closing_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpi6fi1dif: /tmp/tmpi6fi1dif.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ brackets_size = brackets.size();\n    bool result = true;\n    for (size_t i\
    \ = 0; i < brackets_size; ++i) {\n        if (brackets[i] != brackets[brackets_size\
    \ - i - 1]) {\n            result = false;\n            break;\n        }\n  \
    \  }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpmtvi83sq: /tmp/tmpmtvi83sq.cpp:26: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i += 2;\n     \
    \   } else {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i += 1;\n     \
    \   }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpue5s83z2: /tmp/tmpue5s83z2.cpp:35: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp28d30gry: /tmp/tmp28d30gry.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.length(); i++) {\n        if (brackets[i] == '(') {\n           \
    \ open_brackets++;\n        } else if (brackets[i] == ')') {\n            close_brackets++;\n\
    \        }\n    }\n    return open_brackets == close_brackets;\n}\nint main()\
    \ {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"()\"))\
    \ == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp4zyk3zsd: /tmp/tmp4zyk3zsd.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int opening_brackets\
    \ = 0;\n    int closing_brackets = 0;\n    for (int i = 0; i < brackets.length();\
    \ i++) {\n        if (brackets[i] == '(') {\n            opening_brackets++;\n\
    \        } else if (brackets[i] == ')') {\n            closing_brackets++;\n \
    \       }\n    }\n    if (opening_brackets == closing_brackets) {\n        return\
    \ true;\n    } else {\n        return false;\n    }\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpcpqh9c_6: /tmp/tmpcpqh9c_6.cpp:36: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); ++i) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i += 2;\n     \
    \   } else if (brackets[i] == ')') {\n            if (brackets[i + 1] != '(')\
    \ {\n                result = false;\n                break;\n            }\n\
    \            i += 2;\n        } else {\n            result = false;\n        \
    \    break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"\
    (()())\")) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n\
    \    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"\
    ((()())))\")) == (false));\n    assert(candidate((\")(()\")) == (false));\n  \
    \  assert(candidate((\"(\")) == (false));\n    assert(candidate((\"((((\")) ==\
    \ (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpx82wl0_v: /tmp/tmpx82wl0_v.cpp:38: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n                break;\n            }\n            i++;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpp3zcobgh: /tmp/tmpp3zcobgh.cpp:29: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = brackets.size() - 1;\n    int close_brackets = 0;\n    for (int i = 0; i <\
    \ brackets.size(); i++) {\n        if (brackets[i] == '(') {\n            open_brackets--;\n\
    \        } else if (brackets[i] == ')') {\n            close_brackets++;\n   \
    \     }\n    }\n    if (open_brackets != close_brackets) {\n        return false;\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpbsw7jk14: /tmp/tmpbsw7jk14.cpp:30: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    opening_brackets.erase(std::remove(opening_brackets.begin(), opening_brackets.end(),\
    \ '('), opening_brackets.end());\n    closing_brackets.erase(std::remove(closing_brackets.begin(),\
    \ closing_brackets.end(), ')'), closing_brackets.end());\n    return opening_brackets\
    \ == closing_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmpl7sa6o4_: /tmp/tmpl7sa6o4_.cpp:22: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    std::string\
    \ opening_brackets = brackets;\n    std::string closing_brackets = brackets;\n\
    \    opening_brackets.erase(opening_brackets.begin(), opening_brackets.begin()\
    \ + 1);\n    closing_brackets.erase(closing_brackets.begin(), closing_brackets.begin()\
    \ + 1);\n    bool result = true;\n    for (auto it = opening_brackets.begin();\
    \ it != opening_brackets.end(); ++it) {\n        if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n            result = false;\n            break;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdlorpe34.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpdlorpe34.cpp:20:40: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |             ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                  |                            |\n   \
    \   |                                  |                            std::__cxx11::basic_string<char>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n\
    \      |                                  std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note: candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/iosfwd:40,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note: candidate: \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched\
    \ types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ _CharT*, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n\
    \ 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018long unsigned int\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_code&\u2019\n\
    \  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:297:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_condition&)\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:297:32: note:\
    \   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_code&\u2019\n\
    \  297 |   operator==(const error_code& __lhs, const error_condition& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_condition&\u2019\
    \n  304 |   operator==(const error_condition& __lhs, const error_code& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:311:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_condition&)\u2019\n  311 |   operator==(const error_condition& __lhs,\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37: note:   no known\
    \ conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::error_condition&\u2019\
    \n  311 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::complex<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::deque<_Tp, _Alloc>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::array<_Tp,\
    \ _Nm>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched\
    \ types \u2018const std::tuple<_Tps ...>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/functional:59,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5: note:\
    \ candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::function<_Res(_ArgTypes\
    \ ...)>\u2019\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64: note: \
    \  mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/bits/locale_conv.h:41,\n             \
    \    from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::unique_ptr<_Tp,\
    \ _Dp>\u2019\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/map:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/map:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n              \
    \   from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::__shared_ptr<_Tp,\
    \ _Lp>\u2019\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64: note: \
    \  mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::queue<_Tp,\
    \ _Seq>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::set<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/set:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/stack:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::stack<_Tp,\
    \ _Seq>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n \
    \                from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::valarray<_Tp>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\nIn\
    \ file included from /usr/include/c++/9/forward_list:40,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5: note:\
    \ candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdlorpe34.cpp:20:64: note:   mismatched types \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019} to \u2018std::thread::id\u2019\n  276 |   operator==(thread::id __x,\
    \ thread::id __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included\
    \ from /usr/include/c++/9/random:51,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64: note: \
    \  mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and\
    \ \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long unsigned\
    \ int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64: note: \
    \  mismatched types \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it) == closing_brackets.end())\
    \ {\n      |                                                                ^\n\
    In file included from /usr/include/c++/9/unordered_map:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\n\
    \ 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_multimap<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka\
    \ \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   mismatched types \u2018const std::unordered_multiset<_Value, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   20 |         if (closing_brackets.find(*it)\
    \ == closing_brackets.end()) {\n      |                                      \
    \                          ^\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdlorpe34.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdlorpe34.cpp:20:64:\
    \ note:   \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} is not derived from \u2018const __gnu_cxx::new_allocator<_Tp>\u2019\
    \n   20 |         if (closing_brackets.find(*it) == closing_brackets.end()) {\n\
    \      |                                                                ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto it = brackets.begin(); it != brackets.end(); ++it) {\n\
    \        if (*it == '(') {\n            if (brackets.find(')', it + 1) != brackets.end())\
    \ {\n                result = false;\n                break;\n            }\n\
    \        } else if (*it == ')') {\n            if (brackets.find('(', it + 1)\
    \ != brackets.end()) {\n                result = false;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgoj696t2.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmpgoj696t2.cpp:17:42: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::find(char, __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >)\u2019\n   17 |             if (brackets.find(')',\
    \ it + 1) != brackets.end()) {\n      |                                      \
    \    ^\nIn file included from /usr/include/c++/9/string:55,\n                \
    \ from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpgoj696t2.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2351:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2351 |       find(const _CharT* __s, size_type __pos, size_type\
    \ __n) const\n      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2351:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2365:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2365 |       find(const basic_string& __str, size_type __pos =\
    \ 0) const\n      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2365:32:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::__cxx11::basic_string<char>&\u2019\n 2365 |       find(const basic_string&\
    \ __str, size_type __pos = 0) const\n      |            ~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:2397:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(const\
    \ _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) const\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2397 |       find(const _CharT* __s, size_type __pos = 0) const\
    \ _GLIBCXX_NOEXCEPT\n      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2397:41:\
    \ note:   no known conversion for argument 2 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 2397 |       find(const _CharT* __s, size_type\
    \ __pos = 0) const _GLIBCXX_NOEXCEPT\n      |                               ~~~~~~~~~~^~~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:2414:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(_CharT,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) const [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2414 |       find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\
    \      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2414:34: note:   no\
    \ known conversion for argument 2 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 2414 |       find(_CharT __c, size_type\
    \ __pos = 0) const _GLIBCXX_NOEXCEPT;\n      |                        ~~~~~~~~~~^~~~~~~~~\n\
    /tmp/tmpgoj696t2.cpp:22:42: error: no matching function for call to \u2018std::__cxx11::basic_string<char>::find(char,\
    \ __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >)\u2019\
    \n   22 |             if (brackets.find('(', it + 1) != brackets.end()) {\n  \
    \    |                                          ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpgoj696t2.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2351:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2351 |       find(const _CharT* __s, size_type __pos, size_type\
    \ __n) const\n      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2351:7:\
    \ note:   candidate expects 3 arguments, 2 provided\n/usr/include/c++/9/bits/basic_string.h:2365:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2365 |       find(const basic_string& __str, size_type __pos =\
    \ 0) const\n      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2365:32:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::__cxx11::basic_string<char>&\u2019\n 2365 |       find(const basic_string&\
    \ __str, size_type __pos = 0) const\n      |            ~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:2397:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(const\
    \ _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) const\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2397 |       find(const _CharT* __s, size_type __pos = 0) const\
    \ _GLIBCXX_NOEXCEPT\n      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2397:41:\
    \ note:   no known conversion for argument 2 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 2397 |       find(const _CharT* __s, size_type\
    \ __pos = 0) const _GLIBCXX_NOEXCEPT\n      |                               ~~~~~~~~~~^~~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:2414:7: note: candidate: \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(_CharT,\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) const [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2414 |       find(_CharT __c, size_type __pos = 0) const _GLIBCXX_NOEXCEPT;\n\
    \      |       ^~~~\n/usr/include/c++/9/bits/basic_string.h:2414:34: note:   no\
    \ known conversion for argument 2 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 2414 |       find(_CharT __c, size_type\
    \ __pos = 0) const _GLIBCXX_NOEXCEPT;\n      |                        ~~~~~~~~~~^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size(); i++) {\n        if (brackets[i]\
    \ == '(') {\n            if (brackets[i + 1] != ')') {\n                result\
    \ = false;\n            }\n            i += 1;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp3hsoy3qa: /tmp/tmp3hsoy3qa.cpp:28: int main(): Assertion `candidate((\"\
    (()())\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = brackets.size();\n    size_t close_brackets = 0;\n    for (size_t\
    \ i = 0; i < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n    \
    \        ++open_brackets;\n        } else if (brackets[i] == ')') {\n        \
    \    ++close_brackets;\n        }\n    }\n    return open_brackets == close_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmplr09c19g: /tmp/tmplr09c19g.cpp:27: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    int open_brackets\
    \ = 0;\n    int close_brackets = 0;\n    for (int i = 0; i < brackets.size();\
    \ i++) {\n        if (brackets[i] == '(') open_brackets++;\n        if (brackets[i]\
    \ == ')') close_brackets++;\n        if (open_brackets != close_brackets) return\
    \ false;\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpt5a6vo43: /tmp/tmpt5a6vo43.cpp:25: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     }\n    }\n    return open_brackets == close_brackets;\n}\nint main() {\n\
    \    auto candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmppbex__hz: /tmp/tmppbex__hz.cpp:32: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (size_t i = 0; i < brackets.size() - 1; i++) {\n        if\
    \ (brackets[i] == '(' && brackets[i + 1] == ')') {\n            result = true;\n\
    \        } else if (brackets[i] == '[' && brackets[i + 1] == ']') {\n        \
    \    result = true;\n        } else if (brackets[i] == '{' && brackets[i + 1]\
    \ == '}') {\n            result = true;\n        } else if (brackets[i] == '<'\
    \ && brackets[i + 1] == '>') {\n            result = true;\n        } else if\
    \ (brackets[i] == '(' && brackets[i + 1] == ')' && brackets[i + 2] == ')') {\n\
    \            result = true;\n        } else if (brackets[i] == '[' && brackets[i\
    \ + 1] == ']' && brackets[i + 2] == ']') {\n            result = true;\n     \
    \   } else if (brackets[i] == '{' && brackets[i + 1] == '}' && brackets[i + 2]\
    \ == '}') {\n            result = true;\n        } else if (brackets[i] == '<'\
    \ && brackets[i + 1] == '>' && brackets[i + 2] == '>') {\n            result =\
    \ true;\n        } else if (brackets[i] == '(' && brackets[i + 1] == ')' && brackets[i\
    \ + 2] == ')' && brackets[i + 3] == ')') {\n            result = true;\n     \
    \   } else if (brackets[i] == '[' && brackets[i + 1] == ']' && brackets[i + 2]\
    \ == ']' && brackets[i + 3] == ']') {\n            result = true;\n        } else\
    \ if (brackets[i] == '{' && brackets[i + 1] == '}' && brackets[i + 2] == '}' &&\
    \ brackets[i + 3] == '}') {\n            result = true;\n        } else if (brackets[i]\
    \ == '<' && brackets[i + 1] == '>' && brackets[i + 2] == '>' && brackets[i + 3]\
    \ == '>') {\n            result = true;\n        } else if (brackets[i] == '('\
    \ && brackets[i + 1] == ')' && brackets[i + 2] == ')' && brackets[i + 3] == ')'\
    \ && brackets[i + 4] == ')') {\n            result = true;\n        } else if\
    \ (brackets[i] == '[' && brackets[i + 1] == ']' && brackets[i + 2] == ']' && brackets[i\
    \ + 3] == ']' && brackets[i + 4] == ']') {\n            result = true;\n     \
    \   } else if (brackets[i] == '{' && brackets[i + 1] == '}' && brackets[i + 2]\
    \ == '}' && brackets[i + 3] == '}' && brackets[i + 4] == '}') {\n            result\
    \ = true;\n        } else if (brackets[i] == '<' && brackets[i + 1] == '>' &&\
    \ brackets[i + 2] == '>' && brackets[i + 3] == '>' && brackets[i + 4] == '>')\
    \ {\n            result = true;\n        } else if (brackets[i] == '(' && brackets[i\
    \ + 1] == ')' && brackets[i + 2] == ')' && brackets[i + 3] == ')' && brackets[i\
    \ + 4] == ')' && brackets[i + 5] == ')') {\n            result = true;\n     \
    \   } else if (brackets[i] == '[' && brackets[i + 1] == ']' && brackets[i + 2]\
    \ == ']' && brackets[i + 3] == ']' && brackets[i + 4]\n}\nint main() {\n    auto\
    \ candidate = correct_bracketing;\n    assert(candidate((\"()\")) == (true));\n\
    \    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"()()(()())()\"\
    )) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\")) == (true));\n\
    \    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ppjju1w.cpp: In function \u2018bool correct_bracketing(std::string)\u2019\
    :\n/tmp/tmp7ppjju1w.cpp:50:135: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   50 |         } else if (brackets[i] == '[' && brackets[i + 1] == ']'\
    \ && brackets[i + 2] == ']' && brackets[i + 3] == ']' && brackets[i + 4]\n   \
    \   |                   ~                                                    \
    \                                                               ^\n      |   \
    \                                                                            \
    \                                                        )\n   51 | }\n      |\
    \ ~                                                                          \
    \                                                            \n/tmp/tmp7ppjju1w.cpp:51:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   51 | }\n \
    \     | ^\n/tmp/tmp7ppjju1w.cpp:52:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   52 | int main() {\n      |            ^\n\
    /tmp/tmp7ppjju1w.cpp:66:1: error: expected \u2018}\u2019 at end of input\n   66\
    \ | }\n      | ^\n/tmp/tmp7ppjju1w.cpp:13:47: note: to match this \u2018{\u2019\
    \n   13 | bool correct_bracketing(std::string brackets) {\n      |           \
    \                                    ^\n/tmp/tmp7ppjju1w.cpp:66:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   66 | }\n\
    \      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets[brackets.size() - 1] != ')') {\n                result = false;\n\
    \                break;\n            }\n        } else if (c == ')') {\n     \
    \       if (brackets[brackets.size() - 1] != '(') {\n                result =\
    \ false;\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpqto19c83: /tmp/tmpqto19c83.cpp:32: int main(): Assertion `candidate((\"\
    ()\")) == (true)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    bool result\
    \ = true;\n    for (auto c : brackets) {\n        if (c == '(') {\n          \
    \  if (brackets.find(\")\") != std::string::npos) {\n                result =\
    \ true;\n            }\n        } else if (c == ')') {\n            if (brackets.find(\"\
    (\") != std::string::npos) {\n                result = true;\n            }\n\
    \        } else {\n            result = false;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmpipq6iltg: /tmp/tmpipq6iltg.cpp:36: int main(): Assertion `candidate((\"\
    ((()())))\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n  int opening_brackets\
    \ = 0;\n  int closing_brackets = 0;\n  for (int i = 0; i < brackets.size(); i++)\
    \ {\n    if (brackets[i] == '(') opening_brackets++;\n    else if (brackets[i]\
    \ == ')') closing_brackets++;\n  }\n  return opening_brackets == closing_brackets;\n\
    }\nint main() {\n    auto candidate = correct_bracketing;\n    assert(candidate((\"\
    ()\")) == (true));\n    assert(candidate((\"(()())\")) == (true));\n    assert(candidate((\"\
    ()()(()())()\")) == (true));\n    assert(candidate((\"()()((()()())())(()()(()))\"\
    )) == (true));\n    assert(candidate((\"((()())))\")) == (false));\n    assert(candidate((\"\
    )(()\")) == (false));\n    assert(candidate((\"(\")) == (false));\n    assert(candidate((\"\
    ((((\")) == (false));\n    assert(candidate((\")\")) == (false));\n    assert(candidate((\"\
    (()\")) == (false));\n    assert(candidate((\"()()(()())())(()\")) == (false));\n\
    \    assert(candidate((\"()()(()())()))()\")) == (false));\n}\n"
  stdout: ''
  stderr: "tmp96ktm7b0: /tmp/tmp96ktm7b0.cpp:29: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// brackets is a string of\
    \ \"(\" and \")\".\n// return True if every opening bracket has a corresponding\
    \ closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"\
    ()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\"\
    )(()\")\n// False\nbool correct_bracketing(std::string brackets) {\n    size_t\
    \ open_brackets = 0;\n    size_t close_brackets = 0;\n    for (size_t i = 0; i\
    \ < brackets.size(); ++i) {\n        if (brackets[i] == '(') {\n            ++open_brackets;\n\
    \        } else if (brackets[i] == ')') {\n            ++close_brackets;\n   \
    \     } else {\n            return false;\n        }\n    }\n    return open_brackets\
    \ == close_brackets;\n}\nint main() {\n    auto candidate = correct_bracketing;\n\
    \    assert(candidate((\"()\")) == (true));\n    assert(candidate((\"(()())\"\
    )) == (true));\n    assert(candidate((\"()()(()())()\")) == (true));\n    assert(candidate((\"\
    ()()((()()())())(()()(()))\")) == (true));\n    assert(candidate((\"((()())))\"\
    )) == (false));\n    assert(candidate((\")(()\")) == (false));\n    assert(candidate((\"\
    (\")) == (false));\n    assert(candidate((\"((((\")) == (false));\n    assert(candidate((\"\
    )\")) == (false));\n    assert(candidate((\"(()\")) == (false));\n    assert(candidate((\"\
    ()()(()())())(()\")) == (false));\n    assert(candidate((\"()()(()())()))()\"\
    )) == (false));\n}\n"
  stdout: ''
  stderr: "tmp6_q1c3zi: /tmp/tmp6_q1c3zi.cpp:34: int main(): Assertion `candidate((\"\
    )(()\")) == (false)' failed.\n"
  exit_code: -6
  status: Exception
