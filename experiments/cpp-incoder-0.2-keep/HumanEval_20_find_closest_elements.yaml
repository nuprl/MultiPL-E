name: HumanEval_20_find_closest_elements
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// From a supplied list of numbers\
  \ (of length at least two) select and return two that are the closest to each\n\
  // other and return them in order (smaller number, larger number).\n// >>> find_closest_elements([1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2])\n// (2.0, 2.2)\n// >>> find_closest_elements([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0])\n// (2.0, 2.0)\nstd::tuple<float, float> find_closest_elements(std::vector<float>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = find_closest_elements;\n    assert(candidate((std::vector<float>({1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2}))) == (std::make_tuple(3.9, 4.0)));\n    assert(candidate((std::vector<float>({1.0,\
  \ 2.0, 5.9, 4.0, 5.0}))) == (std::make_tuple(5.0, 5.9)));\n    assert(candidate((std::vector<float>({1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2}))) == (std::make_tuple(2.0, 2.2)));\n    assert(candidate((std::vector<float>({1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.0}))) == (std::make_tuple(2.0, 2.0)));\n    assert(candidate((std::vector<float>({1.1,\
  \ 2.2, 3.1, 4.1, 5.1}))) == (std::make_tuple(2.2, 3.1)));\n}\n"
completions: ["    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    assert(numbers.size() >\
    \ 1);\n    float smallest_diff = std::numeric_limits<float>::max();\n    float\
    \ closest_to_smallest = numbers[0];\n    float closest_to_largest = numbers[0];\n\
    \    for (float number : numbers) {\n        float diff = std::abs(number - closest_to_smallest);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_to_smallest = number;\n        }\n        diff = std::abs(number\
    \ - closest_to_largest);\n        if (diff < smallest_diff) {\n            smallest_diff\
    \ = diff;\n            closest_to_largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(closest_to_smallest, closest_to_largest);", "    // Your code\
    \ here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n  \
    \  for (float number : numbers) {\n        if (number < smallest) {\n        \
    \    smallest = number;\n        }\n        if (number > largest) {\n        \
    \    largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Write your code here\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    // Sort numbers in ascending\
    \ order\n    std::sort(numbers.begin(), numbers.end());\n    // Find the two closest\
    \ numbers to each other\n    float closest_1 = numbers[0];\n    float closest_2\
    \ = numbers[0];\n    float closest_diff = std::abs(closest_1 - closest_2);\n \
    \   for (float number : numbers) {\n        float diff = std::abs(number - closest_1);\n\
    \        if (diff < closest_diff) {\n            closest_1 = number;\n       \
    \ } else if (diff == closest_diff) {\n            closest_2 = number;\n      \
    \  }\n    }\n    // Return the two closest numbers\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - smallest_distance);\n\
    \        if (distance < largest_distance) {\n            largest_distance = distance;\n\
    \        }\n        distance = std::abs(number - largest_distance);\n        if\
    \ (distance < smallest_distance) {\n            smallest_distance = distance;\n\
    \        }\n    }\n    return std::make_tuple(smallest_distance, largest_distance);",
  "    assert(numbers.size() > 2);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (size_t i = 1; i < numbers.size(); i++) {\n        if\
    \ (numbers[i] < smallest) {\n            smallest = numbers[i];\n        } else\
    \ if (numbers[i] > largest) {\n            largest = numbers[i];\n        }\n\
    \    }\n    return std::make_tuple(smallest, largest);", "    // Sort the numbers\
    \ in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    // Find\
    \ the two closest numbers to the first number\n    auto it = std::min_element(numbers.begin(),\
    \ numbers.end());\n    // Return the two closest numbers\n    return std::make_tuple(std::abs(*it\
    \ - numbers[0]), std::abs(*it - numbers[1]));", "    assert(numbers.size() > 1);\n\
    \    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest, largest);", "    float\
    \ smallest_distance = std::numeric_limits<float>::max();\n    float largest_distance\
    \ = std::numeric_limits<float>::min();\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (float number : numbers) {\n\
    \        float distance = std::abs(number - smallest_number);\n        if (distance\
    \ < smallest_distance) {\n            smallest_distance = distance;\n        \
    \    smallest_number = number;\n        }\n        distance = std::abs(number\
    \ - largest_number);\n        if (distance > largest_distance) {\n           \
    \ largest_distance = distance;\n            largest_number = number;\n       \
    \ }\n    }\n    return std::make_tuple(smallest_number, largest_number);", " \
    \   float smallest_distance = std::numeric_limits<float>::max();\n    float largest_distance\
    \ = std::numeric_limits<float>::min();\n    for (float number : numbers) {\n \
    \       float distance = std::abs(number - smallest_distance);\n        if (distance\
    \ < largest_distance) {\n            largest_distance = distance;\n        }\n\
    \        distance = std::abs(number - largest_distance);\n        if (distance\
    \ < smallest_distance) {\n            smallest_distance = distance;\n        }\n\
    \    }\n    return std::make_tuple(smallest_distance, largest_distance);", " \
    \   assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        }\n        if (number > largest)\
    \ {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    float smallest_diff = FLT_MAX;\n\
    \    float closest_val = numbers[0];\n    float closest_val_2 = numbers[0];\n\
    \    for (float val : numbers) {\n        float diff = std::abs(val - closest_val);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_val = val;\n            closest_val_2 = closest_val;\n      \
    \  } else if (diff == smallest_diff) {\n            closest_val_2 = val;\n   \
    \     }\n    }\n    return std::make_tuple(closest_val, closest_val_2);", "  \
    \  assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        }\n        if (number > largest)\
    \ {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float closest_1 = std::numeric_limits<float>::max();\n    float closest_2\
    \ = std::numeric_limits<float>::max();\n    float closest_3 = std::numeric_limits<float>::max();\n\
    \    float closest_4 = std::numeric_limits<float>::max();\n    float closest_5\
    \ = std::numeric_limits<float>::max();\n    float closest_6 = std::numeric_limits<float>::max();\n\
    \    float closest_7 = std::numeric_limits<float>::max();\n    float closest_8\
    \ = std::numeric_limits<float>::max();\n    float closest_9 = std::numeric_limits<float>::max();\n\
    \    float closest_10 = std::numeric_limits<float>::max();\n    float closest_11\
    \ = std::numeric_limits<float>::max();\n    float closest_12 = std::numeric_limits<float>::max();\n\
    \    float closest_13 = std::numeric_limits<float>::max();\n    float closest_14\
    \ = std::numeric_limits<float>::max();\n    float closest_15 = std::numeric_limits<float>::max();\n\
    \    float closest_16 = std::numeric_limits<float>::max();\n    float closest_17\
    \ = std::numeric_limits<float>::max();\n    float closest_18 = std::numeric_limits<float>::max();\n\
    \    float closest_19 = std::numeric_limits<float>::max();\n    float closest_20\
    \ = std::numeric_limits<float>::max();\n    float closest_21 = std::numeric_limits<float>::max();\n\
    \    float closest_22 = std::numeric_limits<float>::max();\n    float closest_23\
    \ = std::numeric_limits<float>::max();\n    float closest_24 = std::numeric_limits<float>::max();\n\
    \    float closest_25 = std::numeric_limits<float>::max();\n    float closest_26\
    \ = std::numeric_limits<float>::max();\n    float closest_27 = std::numeric_limits<float>::max();\n\
    \    float closest_28 = std::numeric_limits<float>::max();\n    float closest_29\
    \ = std::numeric_limits<float>::max();\n    float closest_30 = std::numeric_limits<float>::max();\n\
    \    float closest_31 = std::numeric_limits<float>::max();\n    float closest_32\
    \ = std::numeric_limits<float>::max();\n    float closest_33 = std::numeric_limits<float>::max();\n\
    \    float closest_34 = std::numeric_limits<float>::max();\n    float closest_35\
    \ = std::numeric_limits<float>::max();\n    float closest_36 = std::numeric_limits<float>::max();\n\
    \    float closest_37 = std::numeric_limits<float>::max();\n    float closest_38\
    \ = std::numeric_limits<float>::max();\n    float closest_39 = std::numeric_limits<float>::max();\n\
    \    float closest_40", "    assert(numbers.size() > 1);\n    float smallest_diff\
    \ = std::numeric_limits<float>::max();\n    float closest_1 = numbers[0];\n  \
    \  float closest_2 = numbers[0];\n    for (float number : numbers) {\n       \
    \ float diff = std::abs(number - closest_1);\n        if (diff < smallest_diff)\
    \ {\n            smallest_diff = diff;\n            closest_1 = number;\n    \
    \    }\n        diff = std::abs(number - closest_2);\n        if (diff < smallest_diff)\
    \ {\n            smallest_diff = diff;\n            closest_2 = number;\n    \
    \    }\n    }\n    return std::make_tuple(closest_1, closest_2);", "    assert(numbers.size()\
    \ >= 2);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        } else if (number > largest) {\n          \
    \  largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest, largest);", "    // Your\
    \ code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    assert(numbers.size() >\
    \ 1);\n    float smallest_diff = std::numeric_limits<float>::max();\n    float\
    \ closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for (float number\
    \ : numbers) {\n        float diff = std::abs(number - closest_1);\n        if\
    \ (diff < smallest_diff) {\n            smallest_diff = diff;\n            closest_1\
    \ = number;\n        }\n        diff = std::abs(number - closest_2);\n       \
    \ if (diff < smallest_diff) {\n            smallest_diff = diff;\n           \
    \ closest_2 = number;\n        }\n    }\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    assert(numbers.size() > 1);\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        }\n        if (number > largest) {\n            largest =\
    \ number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        }\n        if (number > largest) {\n            largest =\
    \ number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Sort the numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n\
    \n    // Find the two closest numbers to the first number\n    float closest_1\
    \ = numbers[0];\n    float closest_2 = numbers[0];\n    float closest_diff = std::abs(closest_1\
    \ - closest_2);\n    for (float number : numbers) {\n        float diff = std::abs(number\
    \ - closest_1);\n        if (diff < closest_diff) {\n            closest_2 = closest_1;\n\
    \            closest_1 = number;\n            closest_diff = diff;\n        }\
    \ else if (diff == closest_diff) {\n            closest_2 = number;\n        }\n\
    \    }\n\n    // Return the two closest numbers\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    // Initialize two variables to hold\
    \ the smallest and largest number\n    float smallest = numbers[0];\n    float\
    \ largest = numbers[0];\n    // Loop through each number in the list\n    for\
    \ (float number : numbers) {\n        // If the current number is smaller than\
    \ the smallest number\n        if (number < smallest) {\n            // Set the\
    \ smallest number to the current number\n            smallest = number;\n    \
    \    }\n        // If the current number is larger than the largest number\n \
    \       if (number > largest) {\n            // Set the largest number to the\
    \ current number\n            largest = number;\n        }\n    }\n    // Return\
    \ the smallest and largest numbers in order\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        } else if (number > largest) {\n          \
    \  largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest_distance =\
    \ std::numeric_limits<float>::max();\n    float largest_distance = std::numeric_limits<float>::min();\n\
    \    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        float distance = std::abs(numbers[i]\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = numbers[i];\n\
    \        }\n        distance = std::abs(numbers[i] - largest_number);\n      \
    \  if (distance > largest_distance) {\n            largest_distance = distance;\n\
    \            largest_number = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for\
    \ (float number : numbers) {\n        float diff = std::abs(number - closest_1);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_1 = number;\n        }\n        diff = std::abs(number - closest_2);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_2 = number;\n        }\n    }\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    assert(numbers.size() > 1);\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest, largest);", "    float\
    \ smallest_number = numbers[0];\n    float largest_number = numbers[0];\n    for\
    \ (float number : numbers) {\n        if (number < smallest_number) {\n      \
    \      smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        } else if (number > largest) {\n          \
    \  largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Find the two closest numbers to the first number\n    float closest_1 =\
    \ std::abs(numbers[0]);\n    float closest_2 = std::abs(numbers[0]);\n    for\
    \ (float number : numbers) {\n        float current_1 = std::abs(number);\n  \
    \      float current_2 = std::abs(number);\n        if (current_1 < closest_1)\
    \ {\n            closest_1 = current_1;\n        }\n        if (current_2 < closest_2)\
    \ {\n            closest_2 = current_2;\n        }\n    }\n    // Return the two\
    \ closest numbers in order\n    return std::make_tuple(closest_1, closest_2);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Find the two closest numbers to each other\n    float smallest_distance\
    \ = std::numeric_limits<float>::max();\n    float second_smallest_distance = std::numeric_limits<float>::max();\n\
    \    float smallest_number = numbers[0];\n    float second_smallest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   second_smallest_distance = smallest_distance;\n            second_smallest_number\
    \ = smallest_number;\n            smallest_distance = distance;\n            smallest_number\
    \ = number;\n        } else if (distance < second_smallest_distance) {\n     \
    \       second_smallest_distance = distance;\n            second_smallest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, second_smallest_number);",
  "    // Your code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Your code here\n    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float closest_number = numbers[0];\n    float closest_number_2 = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); i++) {\n        float diff = std::abs(numbers[i]\
    \ - closest_number);\n        if (diff < smallest_diff) {\n            smallest_diff\
    \ = diff;\n            closest_number = numbers[i];\n        }\n        if (diff\
    \ < smallest_diff) {\n            closest_number_2 = numbers[i];\n        }\n\
    \    }\n    return std::make_tuple(closest_number, closest_number_2);", "    float\
    \ smallest_diff = FLT_MAX;\n    float closest_1 = FLT_MAX;\n    float closest_2\
    \ = FLT_MAX;\n    float closest_3 = FLT_MAX;\n    float closest_4 = FLT_MAX;\n\
    \    float closest_5 = FLT_MAX;\n    float closest_6 = FLT_MAX;\n    float closest_7\
    \ = FLT_MAX;\n    float closest_8 = FLT_MAX;\n    float closest_9 = FLT_MAX;\n\
    \    float closest_10 = FLT_MAX;\n    float closest_11 = FLT_MAX;\n    float closest_12\
    \ = FLT_MAX;\n    float closest_13 = FLT_MAX;\n    float closest_14 = FLT_MAX;\n\
    \    float closest_15 = FLT_MAX;\n    float closest_16 = FLT_MAX;\n    float closest_17\
    \ = FLT_MAX;\n    float closest_18 = FLT_MAX;\n    float closest_19 = FLT_MAX;\n\
    \    float closest_20 = FLT_MAX;\n    float closest_21 = FLT_MAX;\n    float closest_22\
    \ = FLT_MAX;\n    float closest_23 = FLT_MAX;\n    float closest_24 = FLT_MAX;\n\
    \    float closest_25 = FLT_MAX;\n    float closest_26 = FLT_MAX;\n    float closest_27\
    \ = FLT_MAX;\n    float closest_28 = FLT_MAX;\n    float closest_29 = FLT_MAX;\n\
    \    float closest_30 = FLT_MAX;\n    float closest_31 = FLT_MAX;\n    float closest_32\
    \ = FLT_MAX;\n    float closest_33 = FLT_MAX;\n    float closest_34 = FLT_MAX;\n\
    \    float closest_35 = FLT_MAX;\n    float closest_36 = FLT_MAX;\n    float closest_37\
    \ = FLT_MAX;\n    float closest_38 = FLT_MAX;\n    float closest_39 = FLT_MAX;\n\
    \    float closest_40 = FLT_MAX;\n    float closest_41 = FLT_MAX;\n    float closest_42\
    \ = FLT_MAX;\n    float closest_43 = FLT_MAX;\n    float closest_44 = FLT_MAX;\n\
    \    float closest_45 = FLT_MAX;\n    float closest_46 = FLT_MAX;\n    float closest_47\
    \ = FLT_MAX;\n    float closest_48 = FLT_MAX;\n    float closest_49 = FLT_MAX;\n\
    \    float closest_50 = FLT_MAX;\n    float closest_51 = FLT_MAX;\n    float closest_5",
  "    // Write your code here\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        }\n        if (number > largest)\
    \ {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Write your code here\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    float smallest_number =\
    \ numbers[0];\n    float largest_number = numbers[0];\n    for (auto number :\
    \ numbers) {\n        if (number < smallest_number) {\n            smallest_number\
    \ = number;\n        }\n        if (number > largest_number) {\n            largest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    float smallest_number = sorted_numbers[0];\n   \
    \ float largest_number = sorted_numbers[0];\n    for (size_t i = 1; i < sorted_numbers.size();\
    \ i++) {\n        if (sorted_numbers[i] < smallest_number) {\n            smallest_number\
    \ = sorted_numbers[i];\n        }\n        if (sorted_numbers[i] > largest_number)\
    \ {\n            largest_number = sorted_numbers[i];\n        }\n    }\n    return\
    \ std::make_tuple(smallest_number, largest_number);", "    std::vector<float>\
    \ sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\
    \    float closest_number = sorted_numbers[0];\n    float closest_number_2 = sorted_numbers[0];\n\
    \    for (size_t i = 1; i < sorted_numbers.size(); i++) {\n        if (sorted_numbers[i]\
    \ - closest_number > closest_number_2 - sorted_numbers[i]) {\n            closest_number\
    \ = sorted_numbers[i];\n            closest_number_2 = sorted_numbers[i];\n  \
    \      }\n    }\n    return std::make_tuple(closest_number, closest_number_2);",
  "    // Your code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    float smallest_index = -1;\n    float largest_index = -1;\n    for (int i\
    \ = 1; i < numbers.size(); i++) {\n        if (numbers[i] < smallest) {\n    \
    \        smallest = numbers[i];\n            smallest_index = i;\n        }\n\
    \        if (numbers[i] > largest) {\n            largest = numbers[i];\n    \
    \        largest_index = i;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Your code here\n    float smallest = numbers[0];\n    float\
    \ largest = numbers[0];\n    for (float number : numbers) {\n        if (number\
    \ < smallest) {\n            smallest = number;\n        }\n        if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    std::vector<float> sorted_numbers(numbers);\n\
    \    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    float smallest_number\
    \ = sorted_numbers[0];\n    float largest_number = sorted_numbers[0];\n    for\
    \ (size_t i = 1; i < sorted_numbers.size(); i++) {\n        if (sorted_numbers[i]\
    \ < smallest_number) {\n            smallest_number = sorted_numbers[i];\n   \
    \     }\n        if (sorted_numbers[i] > largest_number) {\n            largest_number\
    \ = sorted_numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    // Write your code here\n    float\
    \ smallest = numbers[0];\n    float largest = numbers[0];\n    for (float number\
    \ : numbers) {\n        if (number < smallest) {\n            smallest = number;\n\
    \        }\n        if (number > largest) {\n            largest = number;\n \
    \       }\n    }\n    return std::make_tuple(smallest, largest);", "    // Write\
    \ your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float second_smallest_distance = std::numeric_limits<float>::max();\n   \
    \ float smallest_number = numbers[0];\n    float second_smallest_number = numbers[0];\n\
    \    for (int i = 1; i < numbers.size(); i++) {\n        float distance = std::abs(numbers[i]\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   second_smallest_distance = smallest_distance;\n            second_smallest_number\
    \ = smallest_number;\n            smallest_distance = distance;\n            smallest_number\
    \ = numbers[i];\n        } else if (distance < second_smallest_distance) {\n \
    \           second_smallest_distance = distance;\n            second_smallest_number\
    \ = numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ second_smallest_number);", "    // Sort the numbers in ascending order\n   \
    \ std::sort(numbers.begin(), numbers.end());\n    // Find the two closest numbers\
    \ to the first number\n    auto first_number = numbers.front();\n    auto second_number\
    \ = numbers.front();\n    auto first_difference = std::abs(first_number - second_number);\n\
    \    auto second_difference = std::abs(first_number - second_number);\n    //\
    \ Find the two closest numbers to the second number\n    for (auto number : numbers)\
    \ {\n        auto difference = std::abs(number - first_number);\n        if (difference\
    \ < first_difference) {\n            first_number = number;\n            first_difference\
    \ = difference;\n        } else if (difference < second_difference) {\n      \
    \      second_number = number;\n            second_difference = difference;\n\
    \        }\n    }\n    // Return the two closest numbers\n    return std::make_tuple(first_number,\
    \ second_number);", "    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Sort the numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n\n    // Find the two closest numbers to the first number\n\
    \    float closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for\
    \ (float number : numbers) {\n        if (number < closest_1) {\n            closest_1\
    \ = number;\n        } else if (number > closest_2) {\n            closest_2 =\
    \ number;\n        }\n    }\n\n    // Return the two closest numbers in order\n\
    \    return std::make_tuple(closest_1, closest_2);", "    assert(numbers.size()\
    \ > 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (float number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        }\n        if (number > largest) {\n       \
    \     largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = number;\n   \
    \     }\n        distance = std::abs(number - largest_number);\n        if (distance\
    \ > largest_distance) {\n            largest_distance = distance;\n          \
    \  largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    assert(numbers.size() > 1);\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest, largest);", "    assert(numbers.size()\
    \ > 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (auto number : numbers) {\n        if (number < smallest) {\n        \
    \    smallest = number;\n        } else if (number > largest) {\n            largest\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Sort the numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n\
    \    // Find the two numbers that are closest to each other\n    float smallest_distance\
    \ = std::abs(numbers[0] - numbers[1]);\n    float second_smallest_distance = std::abs(numbers[0]\
    \ - numbers[2]);\n    if (smallest_distance < second_smallest_distance) {\n  \
    \      return std::make_tuple(numbers[0], numbers[1]);\n    } else {\n       \
    \ return std::make_tuple(numbers[1], numbers[2]);\n    }", "    assert(numbers.size()\
    \ > 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (float number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        } else if (number > largest) {\n           \
    \ largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    float smallest_diff = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number_2 = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        float diff = std::abs(number - closest_number);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_number = number;\n            closest_number_2 = closest_number;\n\
    \        }\n    }\n    return std::make_tuple(closest_number, closest_number_2);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Your code here\n    float smallest = numbers[0];\n    float\
    \ largest = numbers[0];\n    for (float number : numbers) {\n        if (number\
    \ < smallest) {\n            smallest = number;\n        }\n        if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Write your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float second_smallest_distance = std::numeric_limits<float>::max();\n   \
    \ float smallest_number = numbers[0];\n    float second_smallest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   second_smallest_distance = smallest_distance;\n            second_smallest_number\
    \ = smallest_number;\n            smallest_distance = distance;\n            smallest_number\
    \ = number;\n        } else if (distance < second_smallest_distance) {\n     \
    \       second_smallest_distance = distance;\n            second_smallest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, second_smallest_number);",
  "    // Your code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest || smallest\
    \ == largest) {\n            smallest = number;\n        }\n        if (number\
    \ > largest || largest == smallest) {\n            largest = number;\n       \
    \ }\n    }\n    return std::make_tuple(smallest, largest);", "    // Write your\
    \ code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    assert(numbers.size() >\
    \ 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n   \
    \ for (float number : numbers) {\n        if (number < smallest) {\n         \
    \   smallest = number;\n        } else if (number > largest) {\n            largest\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    assert(numbers.size() > 1);\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - numbers[0]);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n        }\n        if (distance > largest_distance) {\n         \
    \   largest_distance = distance;\n        }\n    }\n    return std::make_tuple(smallest_distance,\
    \ largest_distance);", "    // Your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (float number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_distance, largest_number);",
  "    // Find the two closest numbers to the input number\n    float smallest_distance\
    \ = std::numeric_limits<float>::max();\n    float second_smallest_distance = std::numeric_limits<float>::max();\n\
    \    float smallest_number = numbers[0];\n    float second_smallest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = number;\n   \
    \     }\n        distance = std::abs(number - second_smallest_number);\n     \
    \   if (distance < second_smallest_distance) {\n            second_smallest_distance\
    \ = distance;\n            second_smallest_number = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest_number, second_smallest_number);", "    assert(numbers.size()\
    \ > 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (float number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        } else if (number > largest) {\n           \
    \ largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Write your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float closest_number = numbers[0];\n    float closest_number = numbers[0];\n\
    \    for (float number : numbers) {\n        float distance = std::abs(closest_number\
    \ - number);\n        if (distance < smallest_distance) {\n            smallest_distance\
    \ = distance;\n            closest_number = number;\n        }\n    }\n    return\
    \ std::make_tuple(closest_number, closest_number);", "    assert(numbers.size()\
    \ > 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (float number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        } else if (number > largest) {\n           \
    \ largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Your code here\n    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float smallest_number = numbers[0];\n    float largest_diff = std::numeric_limits<float>::min();\n\
    \    float largest_number = numbers[0];\n    for (auto number : numbers) {\n \
    \       float diff = std::abs(number - smallest_number);\n        if (diff < smallest_diff)\
    \ {\n            smallest_diff = diff;\n            smallest_number = number;\n\
    \        }\n        diff = std::abs(number - largest_number);\n        if (diff\
    \ > largest_diff) {\n            largest_diff = diff;\n            largest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        }\n        if (number > largest)\
    \ {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Initialize two variables to hold the smallest and largest\
    \ numbers\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    // Loop through the supplied list of numbers\n    for (float number : numbers)\
    \ {\n        // If the current number is smaller than the smallest number so far\n\
    \        if (number < smallest) {\n            // Set the smallest number to the\
    \ current number\n            smallest = number;\n        }\n        // If the\
    \ current number is larger than the largest number so far\n        else if (number\
    \ > largest) {\n            // Set the largest number to the current number\n\
    \            largest = number;\n        }\n    }\n    // Return the smallest and\
    \ largest numbers in order\n    return std::make_tuple(smallest, largest);", " \
    \   std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    float closest_distance = std::numeric_limits<float>::max();\n\
    \    float closest_number = sorted_numbers[0];\n    for (size_t i = 1; i < sorted_numbers.size();\
    \ ++i) {\n        float distance = std::abs(sorted_numbers[i] - closest_number);\n\
    \        if (distance < closest_distance) {\n            closest_distance = distance;\n\
    \            closest_number = sorted_numbers[i];\n        }\n    }\n    return\
    \ std::make_tuple(closest_number, closest_distance);", "    // Sort numbers in\
    \ ascending order\n    std::sort(numbers.begin(), numbers.end());\n\n    // Find\
    \ the two closest numbers\n    float smallest_number = numbers[0];\n    float\
    \ largest_number = numbers[0];\n    for (float number : numbers) {\n        if\
    \ (number < smallest_number) {\n            smallest_number = number;\n      \
    \  } else if (number > largest_number) {\n            largest_number = number;\n\
    \        }\n    }\n\n    // Return the two closest numbers\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    assert(numbers.size() >\
    \ 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n   \
    \ for (float number : numbers) {\n        if (number < smallest) {\n         \
    \   smallest = number;\n        }\n        if (number > largest) {\n         \
    \   largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    assert(numbers.size() > 1);\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        }\n        if (number > largest) {\n            largest =\
    \ number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    float smallest_number = sorted_numbers[0];\n   \
    \ float largest_number = sorted_numbers[0];\n    for (size_t i = 1; i < sorted_numbers.size();\
    \ ++i) {\n        if (sorted_numbers[i] < smallest_number) {\n            smallest_number\
    \ = sorted_numbers[i];\n        } else if (sorted_numbers[i] > largest_number)\
    \ {\n            largest_number = sorted_numbers[i];\n        }\n    }\n    return\
    \ std::make_tuple(smallest_number, largest_number);", "    assert(numbers.size()\
    \ > 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (float number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        }\n        if (number > largest) {\n       \
    \     largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    // Write your code here\n    float\
    \ smallest = numbers[0];\n    float largest = numbers[0];\n    for (float number\
    \ : numbers) {\n        if (number < smallest) {\n            smallest = number;\n\
    \        }\n        if (number > largest) {\n            largest = number;\n \
    \       }\n    }\n    return std::make_tuple(smallest, largest);", "    // Your\
    \ code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - smallest_distance);\n\
    \        if (distance < largest_distance) {\n            largest_distance = distance;\n\
    \        }\n        distance = std::abs(number - largest_distance);\n        if\
    \ (distance < smallest_distance) {\n            smallest_distance = distance;\n\
    \        }\n    }\n    return std::make_tuple(smallest_distance, largest_distance);",
  "    // Write your code here\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        }\n        if (number > largest)\
    \ {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        } else if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        }\n        if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    assert(numbers.size() > 1);\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest, largest);", "    // Find\
    \ the smallest and largest numbers in the list\n    float smallest = std::numeric_limits<float>::max();\n\
    \    float largest = std::numeric_limits<float>::min();\n    for (float number\
    \ : numbers) {\n        if (number < smallest) {\n            smallest = number;\n\
    \        }\n        if (number > largest) {\n            largest = number;\n \
    \       }\n    }\n\n    // Find the midpoint of the smallest and largest numbers\n\
    \    float midpoint = (smallest + largest) / 2;\n\n    // Find the two numbers\
    \ that are closest to each other\n    float closest_1 = midpoint;\n    float closest_2\
    \ = midpoint;\n    for (float number : numbers) {\n        if (number < midpoint)\
    \ {\n            if (closest_1 < number) {\n                closest_1 = number;\n\
    \            }\n            if (closest_2 < number) {\n                closest_2\
    \ = number;\n            }\n        }\n    }\n\n    // Return the two closest\
    \ numbers in order\n    return std::make_tuple(closest_1, closest_2);", "    //\
    \ Write your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (float number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    float smallest_distance = std::numeric_limits<float>::max();\n    float largest_distance\
    \ = std::numeric_limits<float>::min();\n    float smallest_number = std::numeric_limits<float>::max();\n\
    \    float largest_number = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    // Write your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = number;\n   \
    \     }\n        distance = std::abs(number - largest_number);\n        if (distance\
    \ > largest_distance) {\n            largest_distance = distance;\n          \
    \  largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    // Write your code here\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    assert(numbers.size() >\
    \ 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n   \
    \ for (float number : numbers) {\n        if (number < smallest) {\n         \
    \   smallest = number;\n        } else if (number > largest) {\n            largest\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Write your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = number;\n   \
    \     }\n        distance = std::abs(number - largest_number);\n        if (distance\
    \ > largest_distance) {\n            largest_distance = distance;\n          \
    \  largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    // Find the two closest numbers to each other.\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    // Return the two numbers in order (smaller number, larger\
    \ number).\n    return std::make_tuple(smallest, largest);", "    // Find the\
    \ two closest numbers to the first number\n    auto it = std::min_element(numbers.begin(),\
    \ numbers.end());\n    auto it2 = std::max_element(numbers.begin(), numbers.end());\n\
    \    float closest = *it;\n    float closest2 = *it2;\n    // Find the two closest\
    \ numbers to the second number\n    it = std::min_element(numbers.begin() + 1,\
    \ numbers.end());\n    it2 = std::max_element(numbers.begin() + 1, numbers.end());\n\
    \    closest = *it;\n    closest2 = *it2;\n    // Return the two closest numbers\
    \ in order\n    return std::make_tuple(closest, closest2);", "    float smallest_distance\
    \ = std::numeric_limits<float>::max();\n    float largest_distance = std::numeric_limits<float>::min();\n\
    \    float smallest_number = std::numeric_limits<float>::max();\n    float largest_number\
    \ = std::numeric_limits<float>::min();\n    float smallest_number_2 = std::numeric_limits<float>::max();\n\
    \    float largest_number_2 = std::numeric_limits<float>::min();\n    float smallest_number_3\
    \ = std::numeric_limits<float>::max();\n    float largest_number_3 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_4 = std::numeric_limits<float>::max();\n    float largest_number_4\
    \ = std::numeric_limits<float>::min();\n    float smallest_number_5 = std::numeric_limits<float>::max();\n\
    \    float largest_number_5 = std::numeric_limits<float>::min();\n    float smallest_number_6\
    \ = std::numeric_limits<float>::max();\n    float largest_number_6 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_7 = std::numeric_limits<float>::max();\n    float largest_number_7\
    \ = std::numeric_limits<float>::min();\n    float smallest_number_8 = std::numeric_limits<float>::max();\n\
    \    float largest_number_8 = std::numeric_limits<float>::min();\n    float smallest_number_9\
    \ = std::numeric_limits<float>::max();\n    float largest_number_9 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_10 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_10 = std::numeric_limits<float>::min();\n    float smallest_number_11\
    \ = std::numeric_limits<float>::max();\n    float largest_number_11 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_12 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_12 = std::numeric_limits<float>::min();\n    float smallest_number_13\
    \ = std::numeric_limits<float>::max();\n    float largest_number_13 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_14 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_14 = std::numeric_limits<float>::min();\n    float smallest_number_15\
    \ = std::numeric_limits<float>::max();\n    float largest_number_15 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_16 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_16 = std::numeric_limits<float>::min();\n    float smallest_number_17\
    \ = std::numeric_limits<float>::max();\n    float largest_number_17 = std::numeric_limits<float>::min();\n\
    \    float ", "    std::vector<float> sorted_numbers(numbers);\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    float closest_number = sorted_numbers[0];\n    float\
    \ closest_number_2 = sorted_numbers[0];\n    for (size_t i = 1; i < sorted_numbers.size();\
    \ i++) {\n        if (sorted_numbers[i] < closest_number) {\n            closest_number\
    \ = sorted_numbers[i];\n            closest_number_2 = sorted_numbers[i - 1];\n\
    \        } else if (sorted_numbers[i] > closest_number) {\n            closest_number_2\
    \ = sorted_numbers[i];\n        }\n    }\n    return std::make_tuple(closest_number,\
    \ closest_number_2);", "    // Sort numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Find the two closest numbers to each other\n    float\
    \ closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for (float number\
    \ : numbers) {\n        if (number < closest_1) {\n            closest_1 = number;\n\
    \        } else if (number > closest_2) {\n            closest_2 = number;\n \
    \       }\n    }\n    // Return the two closest numbers\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    // Find the smallest and largest numbers in the list\n  \
    \  float smallest = std::numeric_limits<float>::max();\n    float largest = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        if (smallest > number) {\n      \
    \      smallest = number;\n        }\n        if (largest < number) {\n      \
    \      largest = number;\n        }\n    }\n    // Find the two numbers that are\
    \ closest to each other\n    float closest_1 = smallest - largest;\n    float\
    \ closest_2 = smallest + largest;\n    // Return the two numbers in order\n  \
    \  return std::make_tuple(closest_1, closest_2);", "    assert(numbers.size()\
    \ >= 2);\n    float smallest_distance = std::numeric_limits<float>::max();\n \
    \   float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (auto number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    // Write your code here\n    float smallest_difference = numbers[0];\n    float\
    \ largest_difference = numbers[0];\n    float smallest_number = numbers[0];\n\
    \    float largest_number = numbers[0];\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        float difference = numbers[i] - numbers[i - 1];\n        if\
    \ (difference < smallest_difference) {\n            smallest_difference = difference;\n\
    \            smallest_number = numbers[i - 1];\n        } else if (difference\
    \ > largest_difference) {\n            largest_difference = difference;\n    \
    \        largest_number = numbers[i - 1];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    // Your code here\n   \
    \ float smallest_distance = std::numeric_limits<float>::max();\n    float largest_distance\
    \ = std::numeric_limits<float>::min();\n    for (float number : numbers) {\n \
    \       float distance = std::abs(number - smallest_distance);\n        if (distance\
    \ < largest_distance) {\n            largest_distance = distance;\n        }\n\
    \        distance = std::abs(number - largest_distance);\n        if (distance\
    \ < smallest_distance) {\n            smallest_distance = distance;\n        }\n\
    \    }\n    return std::make_tuple(smallest_distance, largest_distance);", " \
    \   assert(numbers.size() > 2);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Write your code here\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    float smallest_number =\
    \ numbers[0];\n    float largest_number = numbers[0];\n    for (float number :\
    \ numbers) {\n        if (number < smallest_number) {\n            smallest_number\
    \ = number;\n        }\n        if (number > largest_number) {\n            largest_number\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        }\n        if (number > largest) {\n            largest =\
    \ number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    assert(numbers.size() > 1);\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (float number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (auto number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    // Your code here\n   \
    \ float smallest_distance = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number2 = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - closest_number);\n        if (distance < smallest_distance) {\n          \
    \  smallest_distance = distance;\n            closest_number = number;\n     \
    \   }\n        distance = std::abs(number - closest_number2);\n        if (distance\
    \ < smallest_distance) {\n            smallest_distance = distance;\n        \
    \    closest_number2 = number;\n        }\n    }\n    return std::make_tuple(closest_number,\
    \ closest_number2);", "    // Your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = number;\n   \
    \     }\n        distance = std::abs(number - largest_number);\n        if (distance\
    \ > largest_distance) {\n            largest_distance = distance;\n          \
    \  largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (auto number\
    \ : numbers) {\n        if (number < smallest_number) {\n            smallest_number\
    \ = number;\n        }\n        if (number > largest_number) {\n            largest_number\
    \ = number;\n        }\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    // Sort numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n\
    \    // Initialize smallest and largest number\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    // Iterate through numbers and find smallest\
    \ and largest number\n    for (float number : numbers) {\n        if (number <\
    \ smallest) {\n            smallest = number;\n        }\n        if (number >\
    \ largest) {\n            largest = number;\n        }\n    }\n    // Return smallest\
    \ and largest number\n    return std::make_tuple(smallest, largest);", "    //\
    \ Write your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float closest_number = numbers[0];\n    float closest_distance = std::numeric_limits<float>::max();\n\
    \    for (float number : numbers) {\n        float distance = std::abs(closest_number\
    \ - number);\n        if (distance < closest_distance) {\n            closest_number\
    \ = number;\n            closest_distance = distance;\n        }\n    }\n    return\
    \ std::make_tuple(closest_number, closest_distance);", "    // Initialize a vector\
    \ to hold the result\n    std::vector<float> result;\n    // Initialize a vector\
    \ to hold the smallest and largest numbers\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    // Iterate over the numbers\n    for (float\
    \ number : numbers) {\n        // If the number is smaller than the smallest number\
    \ so far\n        if (number < smallest) {\n            // Set the smallest number\
    \ to the number\n            smallest = number;\n        }\n        // If the\
    \ number is larger than the largest number so far\n        if (number > largest)\
    \ {\n            // Set the largest number to the number\n            largest\
    \ = number;\n        }\n    }\n    // Iterate over the numbers again\n    for\
    \ (float number : numbers) {\n        // If the number is smaller than the smallest\
    \ number so far\n        if (number < smallest) {\n            // Set the smallest\
    \ number to the number\n            smallest = number;\n        }\n        //\
    \ If the number is larger than the largest number so far\n        if (number >\
    \ largest) {\n            // Set the largest number to the number\n          \
    \  largest = number;\n        }\n    }\n    // Iterate over the numbers again\n\
    \    for (float number : numbers) {\n        // If the number is smaller than\
    \ the smallest number so far\n        if (number < smallest) {\n            //\
    \ Set the smallest number to the number\n            smallest = number;\n    \
    \    }\n        // If the number is larger than the largest number so far\n  \
    \      if (number > largest) {\n            // Set the largest number to the number\n\
    \            largest = number;\n        }\n    }\n    // Return the smallest and\
    \ largest numbers in order\n    return std::make_tuple(smallest, largest);", " \
    \   // Your code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest || smallest\
    \ == largest) {\n            smallest = number;\n        } else if (number > largest\
    \ || largest == smallest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for\
    \ (float number : numbers) {\n        float diff = std::abs(number - closest_1);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_1 = number;\n        }\n        diff = std::abs(number - closest_2);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_2 = number;\n        }\n    }\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        } else if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        } else if (number > largest) {\n          \
    \  largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Sort numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n\
    \n    // Find the two closest numbers to each other\n    float closest_1 = numbers[0];\n\
    \    float closest_2 = numbers[0];\n    for (float number : numbers) {\n     \
    \   if (number < closest_1) {\n            closest_1 = number;\n        } else\
    \ if (number > closest_2) {\n            closest_2 = number;\n        }\n    }\n\
    \n    // Return the two closest numbers\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    // Your code here\n    float smallest = numbers[0];\n   \
    \ float largest = numbers[0];\n    for (float number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        } else if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    // Your code here\n    float smallest\
    \ = numbers[0];\n    float largest = numbers[0];\n    for (float number : numbers)\
    \ {\n        if (number < smallest) {\n            smallest = number;\n      \
    \  } else if (number > largest) {\n            largest = number;\n        }\n\
    \    }\n    return std::make_tuple(smallest, largest);", "    // Sort numbers\
    \ in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    // Find\
    \ the two closest numbers to each other\n    auto it1 = std::min_element(numbers.begin(),\
    \ numbers.end());\n    auto it2 = std::max_element(numbers.begin(), numbers.end());\n\
    \    // Return the two closest numbers in order\n    return std::make_tuple(it1,\
    \ it2);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    std::vector<float> sorted_numbers(numbers.begin(),\
    \ numbers.end());\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\
    \    float smallest_number = sorted_numbers[0];\n    float largest_number = sorted_numbers[0];\n\
    \    for (size_t i = 1; i < sorted_numbers.size(); ++i) {\n        if (sorted_numbers[i]\
    \ < smallest_number) {\n            smallest_number = sorted_numbers[i];\n   \
    \     } else if (sorted_numbers[i] > largest_number) {\n            largest_number\
    \ = sorted_numbers[i];\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Your code here\n    float smallest = numbers[0];\n    float\
    \ largest = numbers[0];\n    for (float number : numbers) {\n        if (number\
    \ < smallest) {\n            smallest = number;\n        }\n        if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    // Find the two closest numbers to\
    \ the first number\n    auto smallest_distance = std::numeric_limits<float>::max();\n\
    \    auto second_smallest_distance = std::numeric_limits<float>::max();\n    auto\
    \ smallest_number = numbers[0];\n    auto second_smallest_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        auto distance = std::abs(number -\
    \ smallest_number);\n        if (distance < smallest_distance) {\n           \
    \ smallest_distance = distance;\n            smallest_number = number;\n     \
    \   }\n        distance = std::abs(number - second_smallest_number);\n       \
    \ if (distance < second_smallest_distance) {\n            second_smallest_distance\
    \ = distance;\n            second_smallest_number = number;\n        }\n    }\n\
    \    // Return the two closest numbers in order\n    return std::make_tuple(smallest_number,\
    \ second_smallest_number);", "    // Your code here\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    assert(numbers.size() >\
    \ 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n   \
    \ for (float number : numbers) {\n        if (number < smallest) {\n         \
    \   smallest = number;\n        } else if (number > largest) {\n            largest\
    \ = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Sort the numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n\
    \    // Find the two closest numbers to the first number\n    auto smallest_distance\
    \ = std::abs(numbers[0]);\n    auto second_smallest_distance = std::abs(numbers[0]);\n\
    \    auto first_number = numbers[0];\n    for (auto number : numbers) {\n    \
    \    auto distance = std::abs(number - first_number);\n        if (distance <\
    \ smallest_distance) {\n            second_smallest_distance = smallest_distance;\n\
    \            first_number = number;\n        } else if (distance < second_smallest_distance)\
    \ {\n            second_smallest_distance = distance;\n        }\n    }\n    //\
    \ Return the two closest numbers in order\n    return std::make_tuple(first_number,\
    \ second_number);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        } else if (number\
    \ > largest) {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        }\n      \
    \  if (number > largest) {\n            largest = number;\n        }\n    }\n\
    \    return std::make_tuple(smallest, largest);", "    assert(numbers.size() >\
    \ 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n   \
    \ for (float number : numbers) {\n        if (number < smallest) {\n         \
    \   smallest = number;\n        }\n        if (number > largest) {\n         \
    \   largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    // Sort the numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Find the two closest numbers to the first number\n \
    \   auto it1 = std::lower_bound(numbers.begin(), numbers.end(), numbers[0]);\n\
    \    auto it2 = std::upper_bound(numbers.begin(), numbers.end(), numbers[0]);\n\
    \    // Return the two closest numbers in order\n    return std::make_tuple(it1,\
    \ it2);", "    std::vector<float> sorted_numbers(numbers.begin(), numbers.end());\n\
    \    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    float smallest_number\
    \ = sorted_numbers[0];\n    float largest_number = sorted_numbers[0];\n    for\
    \ (float number : sorted_numbers) {\n        if (number < smallest_number) {\n\
    \            smallest_number = number;\n        } else if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    float smallest_diff = FLT_MAX;\n    float closest_val\
    \ = numbers[0];\n    float closest_val = numbers[0];\n    for (float val : numbers)\
    \ {\n        float diff = val - closest_val;\n        if (diff < smallest_diff)\
    \ {\n            smallest_diff = diff;\n            closest_val = val;\n     \
    \   }\n    }\n    return std::make_tuple(closest_val, closest_val);", "    float\
    \ smallest = numbers[0];\n    float largest = numbers[0];\n    for (auto number\
    \ : numbers) {\n        if (number < smallest) {\n            smallest = number;\n\
    \        } else if (number > largest) {\n            largest = number;\n     \
    \   }\n    }\n    return std::make_tuple(smallest, largest);", "    assert(numbers.size()\
    \ > 1);\n    float smallest_distance = std::numeric_limits<float>::max();\n  \
    \  float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (float number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    // Write your code here\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    std::vector<float> sorted_numbers(numbers.begin(), numbers.end());\n\
    \    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    float closest_1\
    \ = sorted_numbers[0];\n    float closest_2 = sorted_numbers[0];\n    float closest_diff\
    \ = std::abs(closest_1 - closest_2);\n    for (float number : sorted_numbers)\
    \ {\n        float diff = std::abs(number - closest_1);\n        if (diff < closest_diff)\
    \ {\n            closest_2 = closest_1;\n            closest_1 = number;\n   \
    \         closest_diff = diff;\n        } else if (diff == closest_diff) {\n \
    \           closest_2 = number;\n        }\n    }\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float largest_diff = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        float diff = std::abs(number - smallest_number);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        smallest_number = number;\n        }\n        diff = std::abs(number\
    \ - largest_number);\n        if (diff > largest_diff) {\n            largest_diff\
    \ = diff;\n            largest_number = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest_number, largest_number);", "    assert(numbers.size()\
    \ > 2);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (float number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        } else if (number > largest) {\n           \
    \ largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Your code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        } else if (number > largest) {\n          \
    \  largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    // Initialize min and max to first two numbers in numbers\n    float min =\
    \ numbers[0];\n    float max = numbers[0];\n    // Initialize min and max to first\
    \ two numbers in numbers\n    float min_2 = numbers[0];\n    float max_2 = numbers[0];\n\
    \    // Initialize min and max to first two numbers in numbers\n    float min_3\
    \ = numbers[0];\n    float max_3 = numbers[0];\n    // Initialize min and max\
    \ to first two numbers in numbers\n    float min_4 = numbers[0];\n    float max_4\
    \ = numbers[0];\n    // Initialize min and max to first two numbers in numbers\n\
    \    float min_5 = numbers[0];\n    float max_5 = numbers[0];\n    // Initialize\
    \ min and max to first two numbers in numbers\n    float min_6 = numbers[0];\n\
    \    float max_6 = numbers[0];\n    // Initialize min and max to first two numbers\
    \ in numbers\n    float min_7 = numbers[0];\n    float max_7 = numbers[0];\n \
    \   // Initialize min and max to first two numbers in numbers\n    float min_8\
    \ = numbers[0];\n    float max_8 = numbers[0];\n    // Initialize min and max\
    \ to first two numbers in numbers\n    float min_9 = numbers[0];\n    float max_9\
    \ = numbers[0];\n    // Initialize min and max to first two numbers in numbers\n\
    \    float min_10 = numbers[0];\n    float max_10 = numbers[0];\n    // Initialize\
    \ min and max to first two numbers in numbers\n    float min_11 = numbers[0];\n\
    \    float max_11 = numbers[0];\n    // Initialize min and max to first two numbers\
    \ in numbers\n    float min_12 = numbers[0];\n    float max_12 = numbers[0];\n\
    \    // Initialize min and max to first two numbers in numbers\n    float min_13\
    \ = numbers[0];\n    float max_13 = numbers[0];\n    // Initialize min and max\
    \ to first two numbers in numbers\n    float min_14 = numbers[0];\n    float max_14\
    \ = numbers[0];\n    // Initialize min and max to first two numbers in numbers\n\
    \    float min_15 = numbers[0];\n    float max_15 = numbers[0];\n    // Initialize\
    \ min and max to first two numbers in numbers\n    float min_16 = numbers[0];\n\
    \    float max_16 = numbers[0];\n    // Initialize min and max to first two numbers\
    \ in numbers\n    float min_17 = numbers[0];\n    float max_17 = numbers[0];\n\
    \    // Initialize min and max to first two numbers in numbers\n    float min_18\
    \ = numbers[0];\n    float max_18 = numbers[0];\n    // Initialize min and max\
    \ to first two numbers in numbers\n    float min_19 = numbers[0];\n    float max_19\
    \ = numbers[0];\n    // Initialize min and max to ", "    // Find the two closest\
    \ numbers to each other\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - numbers[0]);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n        }\n        if (distance > largest_distance) {\n         \
    \   largest_distance = distance;\n        }\n    }\n    // Return the two closest\
    \ numbers\n    return std::make_tuple(numbers[0], numbers[1]);", "    float smallest\
    \ = numbers[0];\n    float largest = numbers[0];\n    for (float number : numbers)\
    \ {\n        if (number < smallest) {\n            smallest = number;\n      \
    \  } else if (number > largest) {\n            largest = number;\n        }\n\
    \    }\n    return std::make_tuple(smallest, largest);", "    // Sort numbers\
    \ in ascending order\n    std::sort(numbers.begin(), numbers.end());\n    // Find\
    \ the two closest numbers to the first number\n    auto first_number = numbers.front();\n\
    \    auto second_number = numbers[0];\n    auto first_difference = std::abs(first_number\
    \ - second_number);\n    auto second_difference = std::abs(first_number - second_number);\n\
    \    auto first_index = std::distance(numbers.begin(), std::min_element(numbers.begin(),\
    \ numbers.end()));\n    auto second_index = std::distance(numbers.begin(), std::min_element(numbers.begin(),\
    \ numbers.end()));\n    // Return the two numbers in order\n    return std::make_tuple(numbers[first_index],\
    \ numbers[second_index]);", "    // Find the two closest numbers to the first\
    \ number\n    float smallest = std::abs(numbers[0]);\n    float largest = std::abs(numbers[0]);\n\
    \    for (float number : numbers) {\n        if (std::abs(number) < smallest)\
    \ {\n            smallest = std::abs(number);\n        } else if (std::abs(number)\
    \ > largest) {\n            largest = std::abs(number);\n        }\n    }\n\n\
    \    // Find the two closest numbers to the second number\n    float smallest2\
    \ = std::abs(numbers[1]);\n    float largest2 = std::abs(numbers[1]);\n    for\
    \ (float number : numbers) {\n        if (std::abs(number) < smallest2) {\n  \
    \          smallest2 = std::abs(number);\n        } else if (std::abs(number)\
    \ > largest2) {\n            largest2 = std::abs(number);\n        }\n    }\n\n\
    \    // Return the two closest numbers in order\n    return std::make_tuple(smallest,\
    \ largest);", "    // Your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        float distance = std::abs(number\
    \ - smallest_number);\n        if (distance < smallest_distance) {\n         \
    \   smallest_distance = distance;\n            smallest_number = number;\n   \
    \     }\n        distance = std::abs(number - largest_number);\n        if (distance\
    \ > largest_distance) {\n            largest_distance = distance;\n          \
    \  largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    std::vector<float> sorted_numbers(numbers);\n\
    \    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    auto it = std::min_element(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    return std::make_tuple(sorted_numbers[it - sorted_numbers.begin()],\
    \ sorted_numbers[it]);", "    // Sort numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Find the two closest numbers to the first number\n \
    \   auto first_number = numbers.front();\n    auto second_number = numbers.front();\n\
    \    auto first_difference = std::abs(first_number - second_number);\n    auto\
    \ second_difference = std::abs(first_number - second_number);\n    // Iterate\
    \ through the remaining numbers and find the two closest numbers to the current\
    \ number\n    for (auto number : numbers) {\n        auto difference = std::abs(number\
    \ - first_number);\n        if (difference < first_difference) {\n           \
    \ first_number = number;\n            first_difference = difference;\n       \
    \ } else if (difference < second_difference) {\n            second_number = number;\n\
    \            second_difference = difference;\n        }\n    }\n    // Return\
    \ the two closest numbers\n    return std::make_tuple(first_number, second_number);",
  "    // Sort numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n\
    \    // Find the two closest numbers to each other\n    auto it1 = std::min_element(numbers.begin(),\
    \ numbers.end());\n    auto it2 = std::max_element(numbers.begin(), numbers.end());\n\
    \    // Return the two closest numbers in order\n    return std::make_tuple(it1,\
    \ it2);", "    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (auto number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    assert(numbers.size() > 1);\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (float number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        }\n        if (number > largest) {\n            largest =\
    \ number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - smallest_distance);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n        }\n        distance = std::abs(number - largest_distance);\n\
    \        if (distance > largest_distance) {\n            largest_distance = distance;\n\
    \        }\n    }\n    return std::make_tuple(smallest_distance, largest_distance);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < smallest) {\n            smallest = number;\n        }\n        if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float largest_diff = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = numbers[0];\n    float largest_number = numbers[0];\n    for (float number\
    \ : numbers) {\n        float diff = std::abs(number - smallest_number);\n   \
    \     if (diff < smallest_diff) {\n            smallest_diff = diff;\n       \
    \     smallest_number = number;\n        }\n        diff = std::abs(number - largest_number);\n\
    \        if (diff > largest_diff) {\n            largest_diff = diff;\n      \
    \      largest_number = number;\n        }\n    }\n    return std::make_tuple(smallest_number,\
    \ largest_number);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    assert(numbers.size() > 1);\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        }\n        if (number > largest) {\n            largest =\
    \ number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (auto number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        } else if (number > largest) {\n\
    \            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    assert(numbers.size() >= 2);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    assert(numbers.size() > 1);\n   \
    \ float smallest = numbers[0];\n    float largest = numbers[0];\n    for (float\
    \ number : numbers) {\n        if (number < smallest) {\n            smallest\
    \ = number;\n        } else if (number > largest) {\n            largest = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest, largest);", "    // Write\
    \ your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number = std::numeric_limits<float>::max();\n    float closest_number\
    \ = std::numeric_limits<float>::max();\n    float ", "    assert(numbers.size()\
    \ > 1);\n    float smallest = numbers[0];\n    float largest = numbers[0];\n \
    \   for (float number : numbers) {\n        if (number < smallest) {\n       \
    \     smallest = number;\n        } else if (number > largest) {\n           \
    \ largest = number;\n        }\n    }\n    return std::make_tuple(smallest, largest);",
  "    assert(numbers.size() > 1);\n    float smallest_number = numbers[0];\n    float\
    \ largest_number = numbers[0];\n    for (float number : numbers) {\n        if\
    \ (number < smallest_number) {\n            smallest_number = number;\n      \
    \  } else if (number > largest_number) {\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    assert(numbers.size() > 1);\n    float smallest_diff = std::numeric_limits<float>::max();\n\
    \    float closest_1 = numbers[0];\n    float closest_2 = numbers[0];\n    for\
    \ (float number : numbers) {\n        float diff = std::abs(number - closest_1);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_1 = number;\n        }\n        diff = std::abs(number - closest_2);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_2 = number;\n        }\n    }\n    return std::make_tuple(closest_1,\
    \ closest_2);", "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n\
    \    float largest = numbers[0];\n    for (float number : numbers) {\n       \
    \ if (number < smallest) {\n            smallest = number;\n        } else if\
    \ (number > largest) {\n            largest = number;\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    // Write your code here\n    float\
    \ smallest = numbers[0];\n    float largest = numbers[0];\n    for (float number\
    \ : numbers) {\n        if (number < smallest) {\n            smallest = number;\n\
    \        }\n        if (number > largest) {\n            largest = number;\n \
    \       }\n    }\n    return std::make_tuple(smallest, largest);", "    // Find\
    \ the two closest numbers to the input number\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    for (float\
    \ number : numbers) {\n        float distance = std::abs(number - smallest_distance);\n\
    \        if (distance < largest_distance) {\n            largest_distance = distance;\n\
    \        }\n        distance = std::abs(number - largest_distance);\n        if\
    \ (distance < smallest_distance) {\n            smallest_distance = distance;\n\
    \        }\n    }\n    // Return the two closest numbers in order\n    return\
    \ std::make_tuple(smallest_distance, largest_distance);", "    float smallest_diff\
    \ = std::numeric_limits<float>::max();\n    float closest_number = std::numeric_limits<float>::max();\n\
    \    float closest_number_2 = std::numeric_limits<float>::max();\n    for (float\
    \ number : numbers) {\n        float diff = std::abs(number - closest_number);\n\
    \        if (diff < smallest_diff) {\n            smallest_diff = diff;\n    \
    \        closest_number = number;\n            closest_number_2 = closest_number;\n\
    \        } else if (diff == smallest_diff) {\n            closest_number_2 = number;\n\
    \        }\n    }\n    return std::make_tuple(closest_number, closest_number_2);",
  "    assert(numbers.size() > 1);\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < smallest)\
    \ {\n            smallest = number;\n        }\n        if (number > largest)\
    \ {\n            largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    float smallest_number_2 = std::numeric_limits<float>::max();\n    float largest_number_2\
    \ = std::numeric_limits<float>::min();\n    float smallest_number_3 = std::numeric_limits<float>::max();\n\
    \    float largest_number_3 = std::numeric_limits<float>::min();\n    float smallest_number_4\
    \ = std::numeric_limits<float>::max();\n    float largest_number_4 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_5 = std::numeric_limits<float>::max();\n    float largest_number_5\
    \ = std::numeric_limits<float>::min();\n    float smallest_number_6 = std::numeric_limits<float>::max();\n\
    \    float largest_number_6 = std::numeric_limits<float>::min();\n    float smallest_number_7\
    \ = std::numeric_limits<float>::max();\n    float largest_number_7 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_8 = std::numeric_limits<float>::max();\n    float largest_number_8\
    \ = std::numeric_limits<float>::min();\n    float smallest_number_9 = std::numeric_limits<float>::max();\n\
    \    float largest_number_9 = std::numeric_limits<float>::min();\n    float smallest_number_10\
    \ = std::numeric_limits<float>::max();\n    float largest_number_10 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_11 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_11 = std::numeric_limits<float>::min();\n    float smallest_number_12\
    \ = std::numeric_limits<float>::max();\n    float largest_number_12 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_13 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_13 = std::numeric_limits<float>::min();\n    float smallest_number_14\
    \ = std::numeric_limits<float>::max();\n    float largest_number_14 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_15 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_15 = std::numeric_limits<float>::min();\n    float smallest_number_16\
    \ = std::numeric_limits<float>::max();\n    float largest_number_16 = std::numeric_limits<float>::min();\n\
    \    float smallest_number_17 = std::numeric_limits<float>::max();\n    float\
    \ largest_number_17 = std::numeric_limits<float>::min();\n    float ", "    //\
    \ Your code here\n    float smallest = numbers[0];\n    float largest = numbers[0];\n\
    \    for (float number : numbers) {\n        if (number < smallest) {\n      \
    \      smallest = number;\n        }\n        if (number > largest) {\n      \
    \      largest = number;\n        }\n    }\n    return std::make_tuple(smallest,\
    \ largest);", "    std::vector<float> sorted_numbers(numbers.begin(), numbers.end());\n\
    \    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    float closest_number\
    \ = sorted_numbers[0];\n    float closest_number_2 = sorted_numbers[1];\n    float\
    \ closest_number_3 = sorted_numbers[2];\n    float closest_number_4 = sorted_numbers[3];\n\
    \    float closest_number_5 = sorted_numbers[4];\n    float closest_number_6 =\
    \ sorted_numbers[5];\n    float closest_number_7 = sorted_numbers[6];\n    float\
    \ closest_number_8 = sorted_numbers[7];\n    float closest_number_9 = sorted_numbers[8];\n\
    \    float closest_number_10 = sorted_numbers[9];\n    float closest_number_11\
    \ = sorted_numbers[10];\n    float closest_number_12 = sorted_numbers[11];\n \
    \   float closest_number_13 = sorted_numbers[12];\n    float closest_number_14\
    \ = sorted_numbers[13];\n    float closest_number_15 = sorted_numbers[14];\n \
    \   float closest_number_16 = sorted_numbers[15];\n    float closest_number_17\
    \ = sorted_numbers[16];\n    float closest_number_18 = sorted_numbers[17];\n \
    \   float closest_number_19 = sorted_numbers[18];\n    float closest_number_20\
    \ = sorted_numbers[19];\n    float closest_number_21 = sorted_numbers[20];\n \
    \   float closest_number_22 = sorted_numbers[21];\n    float closest_number_23\
    \ = sorted_numbers[22];\n    float closest_number_24 = sorted_numbers[23];\n \
    \   float closest_number_25 = sorted_numbers[24];\n    float closest_number_26\
    \ = sorted_numbers[25];\n    float closest_number_27 = sorted_numbers[26];\n \
    \   float closest_number_28 = sorted_numbers[27];\n    float closest_number_29\
    \ = sorted_numbers[28];\n    float closest_number_30 = sorted_numbers[29];\n \
    \   float closest_number_31 = sorted_numbers[30];\n    float closest_number_32\
    \ = sorted_numbers[31];\n    float closest_number_33 = sorted_numbers[32];\n \
    \   float closest_number_34 = sorted_numbers[33];\n    float closest_number_35\
    \ = sorted_numbers[34];\n    float closest_number_36 = sorted_numbers[35];\n \
    \   float closest_number_37 = sorted_numbers[36];\n    float closest_number_38\
    \ = sorted_numbers[37];\n    float closest_number_39 = sorted_numbers[38];\n \
    \   float closest_number_40 = sorted_numbers[39];\n    float closest_number_41\
    \ = sorted_numbers[40];\n    float closest_number_42 = sorted_numbers[41];\n \
    \   ", "    // Your code here\n    float smallest_distance = std::numeric_limits<float>::max();\n\
    \    float largest_distance = std::numeric_limits<float>::min();\n    float smallest_number\
    \ = std::numeric_limits<float>::max();\n    float largest_number = std::numeric_limits<float>::min();\n\
    \    for (float number : numbers) {\n        if (number < smallest_number) {\n\
    \            smallest_number = number;\n        }\n        if (number > largest_number)\
    \ {\n            largest_number = number;\n        }\n    }\n    for (float number\
    \ : numbers) {\n        float distance = std::abs(number - smallest_number);\n\
    \        if (distance < smallest_distance) {\n            smallest_distance =\
    \ distance;\n            smallest_number = number;\n        }\n        distance\
    \ = std::abs(number - largest_number);\n        if (distance > largest_distance)\
    \ {\n            largest_distance = distance;\n            largest_number = number;\n\
    \        }\n    }\n    return std::make_tuple(smallest_number, largest_number);",
  "    // Write your code here\n    float smallest = numbers[0];\n    float largest\
    \ = numbers[0];\n    for (int i = 1; i < numbers.size(); i++) {\n        if (numbers[i]\
    \ < smallest) {\n            smallest = numbers[i];\n        } else if (numbers[i]\
    \ > largest) {\n            largest = numbers[i];\n        }\n    }\n    return\
    \ std::make_tuple(smallest, largest);", "    // Your code here\n    float smallest\
    \ = numbers[0];\n    float largest = numbers[0];\n    for (float number : numbers)\
    \ {\n        if (number < smallest) {\n            smallest = number;\n      \
    \  } else if (number > largest) {\n            largest = number;\n        }\n\
    \    }\n    return std::make_tuple(smallest, largest);"]
stop_tokens:
- "\n}"
