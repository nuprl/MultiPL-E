name: HumanEval_143_words_in_sentence
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + word;\n                flag = false;\n            }\n            word\
    \ = \"\";\n        } else {\n            word += c;\n        }\n    }\n    if\
    \ (flag) {\n        ans += \" \" + word;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmplsiya68w: /tmp/tmplsiya68w.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            } else {\n                flag = false;\n  \
    \          }\n        }\n    }\n    ans += word;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzbl_7702: /tmp/tmpzbl_7702.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = false;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n\
    \        if (sentence[i] != ' ') {\n            ans += sentence[i];\n        }\
    \ else {\n            flag = true;\n        }\n    }\n    if (flag) {\n      \
    \  return ans;\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' \n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph__84i38.cpp:144:28: warning: missing terminating ' character\n\
    \  144 |         if (sentence[i] != '\n      |                            ^\n\
    /tmp/tmph__84i38.cpp:144:28: error: missing terminating ' character\n  144 | \
    \        if (sentence[i] != '\n      |                            ^ \n/tmp/tmph__84i38.cpp:\
    \ In function \u2018std::string words_in_sentence(std::string)\u2019:\n/tmp/tmph__84i38.cpp:145:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  145 | }\n \
    \     | ^\n/tmp/tmph__84i38.cpp:144:27: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n  144 |         if (sentence[i] != '\n      |            ~    \
    \          ^\n      |                           )\n  145 | }\n      | ~      \
    \                    \n/tmp/tmph__84i38.cpp:145:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  145 | }\n      | ^\n/tmp/tmph__84i38.cpp:146:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  146 | int main() {\n      |            ^\n/tmp/tmph__84i38.cpp:155:1: error:\
    \ expected \u2018}\u2019 at end of input\n  155 | }\n      | ^\n/tmp/tmph__84i38.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmph__84i38.cpp:155:1: warning: control reaches end of non-void function\
    \ [-Wreturn-type]\n  155 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool isPrime = true;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            ans += word;\n            word = \"\"\
    ;\n        } else {\n            word += c;\n        }\n    }\n    ans += word;\n\
    \    for (int i = 3; i < ans.length(); i++) {\n        if (isPrime) {\n      \
    \      isPrime = false;\n            for (int j = i; j < ans.length(); j++) {\n\
    \                if (ans[j] % i == 0) {\n                    isPrime = true;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzph68a4g: /tmp/tmpzph68a4g.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ temp;\n                temp = \"\";\n                flag = false;\n       \
    \     } else {\n                flag = true;\n            }\n        } else {\n\
    \            temp += c;\n        }\n    }\n    if (flag) {\n        ans += temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_73kmznp: /tmp/tmp_73kmznp.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf0bxhngp: /tmp/tmpf0bxhngp.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp1xxamvce: /tmp/tmp1xxamvce.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    bool flag = false;\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] ==\
    \ ' ') {\n            flag = true;\n            ans += \" \" + word;\n       \
    \     word = \"\";\n        } else {\n            if (flag) {\n              \
    \  word += sentence[i];\n            } else {\n                word += sentence[i];\n\
    \            }\n        }\n    }\n    ans += \" \" + word;\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpobz5hu3k.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpobz5hu3k.cpp:125:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  125 | int main() {\n      |            ^\n/tmp/tmpobz5hu3k.cpp:134:1:\
    \ error: expected \u2018}\u2019 at end of input\n  134 | }\n      | ^\n/tmp/tmpobz5hu3k.cpp:120:44:\
    \ note: to match this \u2018{\u2019\n  120 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmpobz5hu3k.cpp:134:1:\
    \ error: expected \u2018}\u2019 at end of input\n  134 | }\n      | ^\n/tmp/tmpobz5hu3k.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpobz5hu3k.cpp:134:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  134 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int count = 0;\n            for(int k\
    \ = i; k <= j; k++) {\n                if(sentence[k] == ' ') {\n            \
    \        count++;\n                }\n            }\n            if(count == 2)\
    \ {\n                ans += sentence[i];\n            }\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbzd61uz7: /tmp/tmpbzd61uz7.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9lnzl9xd: /tmp/tmp9lnzl9xd.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcbi3r5ct: /tmp/tmpcbi3r5ct.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            flag = true;\n            temp\
    \ += c;\n        } else {\n            if (flag) {\n                ans += \"\
    \ \" + temp;\n                temp = \"\";\n                flag = false;\n  \
    \          }\n        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpx6070gnm: /tmp/tmpx6070gnm.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    for (int i = 0; i < n; i++) {\n        if (i\
    \ % 2 == 0) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmphvv0b_e6: /tmp/tmphvv0b_e6.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \         ans += sentence[i];\n        } else {\n            if (flag) {\n   \
    \             ans += sentence[i];\n                flag = false;\n           \
    \ }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpikde_fj4: /tmp/tmpikde_fj4.cpp:36: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    std::string prime_str = ans;\n    int n = prime_str.size();\n   \
    \ int count = 0;\n    for (int i = 0; i < n; i++) {\n        bool flag = false;\n\
    \        for (int j = i + 1; j < n; j++) {\n            if (prime_str[i] == prime_str[j])\
    \ {\n                flag = true;\n                break;\n            }\n   \
    \     }\n        if (flag) {\n            count++;\n        }\n    }\n    std::string\
    \ new_ans = prime_str;\n    for (int i = 0; i < count; i++) {\n        new_ans\
    \ += \" \";\n    }\n    return new_ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp86dn9jbh: /tmp/tmp86dn9jbh.cpp:53: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++){\n   \
    \     temp = sentence[i];\n        for(int j = i + 1; j < n; j++){\n         \
    \   if(temp == sentence[j]){\n                ans += temp;\n                temp\
    \ = sentence[j];\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpta782g4d.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpta782g4d.cpp:24:21: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |             if(temp == sentence[j]){\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpta782g4d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpta782g4d.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]){\n      |                            \
    \      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpta782g4d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5: note:\
    \   template argument deductio"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += temp;\n\
    \            temp = \"\";\n        } else {\n            if (flag) {\n       \
    \         temp += c;\n            } else {\n                ans += c;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp87bmcorv: /tmp/tmp87bmcorv.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        char\
    \ c = sentence[i];\n        if (c == ' ') {\n            int j = i;\n        \
    \    while (j < n && sentence[j] == ' ') {\n                j++;\n           \
    \ }\n            int k = j;\n            while (k < n && sentence[k] == ' ') {\n\
    \                k++;\n            }\n            int m = k;\n            while\
    \ (m < n && sentence[m] == ' ') {\n                m++;\n            }\n     \
    \       int l = m;\n            while (l < n && sentence[l] == ' ') {\n      \
    \          l++;\n            }\n            int r = l;\n            while (r <\
    \ n && sentence[r] == ' ') {\n                r++;\n            }\n          \
    \  int m = r;\n            while (m < n && sentence[m] == ' ') {\n           \
    \     m++;\n            }\n            int n = m;\n            while (n < n &&\
    \ sentence[n] == ' ') {\n                n++;\n            }\n            int\
    \ m = n;\n            while (m < n && sentence[m] == ' ') {\n                m++;\n\
    \            }\n            int l = m;\n            while (l < n && sentence[l]\
    \ == ' ') {\n                l++;\n            }\n            int r = l;\n   \
    \         while (r < n && sentence[r] == ' ') {\n                r++;\n      \
    \      }\n            int m = r;\n            while (m < n && sentence[m] == '\
    \ ') {\n                m++;\n            }\n            int n = m;\n        \
    \    while (n < n && sentence[n] == ' ') {\n                n++;\n           \
    \ }\n            int m = n;\n            while (m < n && sentence[m] == ' ') {\n\
    \                m++;\n            }\n            int l = m;\n            while\
    \ (l < n && sentence[l] == ' ') {\n                l++;\n            }\n     \
    \       int r = l;\n            while (r < n && sentence[r] == ' ') {\n      \
    \          r++;\n            }\n            int m = r;\n            while (m <\
    \ n && sentence[m] == ' ') {\n                m++;\n            }\n          \
    \  int n = m;\n            while (n < n && sentence[n] == ' ') {\n           \
    \     n++;\n            }\n            int m = n;\n            while (m < n &&\
    \ sentence[m] == ' ') {\n                m++;\n            }\n            int\
    \ l = m;\n            while (l < n && sentence[l] == ' ') {\n                l++;\n\
    \            }\n            int r = l;\n            while (r < n && sentence[r]\
    \ == ' ') {\n                r++;\n            }\n            int m = r;\n   \
    \         while (m < n && sentence[m] == ' ') {\n                m++;\n      \
    \      }\n            int n = m;\n            while (n < n && sentence[n] == '\
    \ ') {\n                n++;\n            }\n            int m = n;\n        \
    \    while (m < n && sentence[m] == ' \n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqjo6ibl4.cpp:112:44: warning: missing terminating ' character\n\
    \  112 |             while (m < n && sentence[m] == '\n      |               \
    \                             ^\n/tmp/tmpqjo6ibl4.cpp:112:44: error: missing terminating\
    \ ' character\n  112 |             while (m < n && sentence[m] == '\n      | \
    \                                           ^ \n/tmp/tmpqjo6ibl4.cpp: In function\
    \ \u2018std::string words_in_sentence(std::string)\u2019:\n/tmp/tmpqjo6ibl4.cpp:43:17:\
    \ error: redeclaration of \u2018int m\u2019\n   43 |             int m = r;\n\
    \      |                 ^\n/tmp/tmpqjo6ibl4.cpp:31:17: note: \u2018int m\u2019\
    \ previously declared here\n   31 |             int m = k;\n      |          \
    \       ^\n/tmp/tmpqjo6ibl4.cpp:51:17: error: redeclaration of \u2018int m\u2019\
    \n   51 |             int m = n;\n      |                 ^\n/tmp/tmpqjo6ibl4.cpp:31:17:\
    \ note: \u2018int m\u2019 previously declared here\n   31 |             int m\
    \ = k;\n      |                 ^\n/tmp/tmpqjo6ibl4.cpp:55:17: error: redeclaration\
    \ of \u2018int l\u2019\n   55 |             int l = m;\n      |              \
    \   ^\n/tmp/tmpqjo6ibl4.cpp:35:17: note: \u2018int l\u2019 previously declared\
    \ here\n   35 |             int l = m;\n      |                 ^\n/tmp/tmpqjo6ibl4.cpp:59:17:\
    \ error: redeclaration of \u2018int r\u2019\n   59 |             int r = l;\n\
    \      |                 ^\n/tmp/tmpqjo6ibl4.cpp:39:17: note: \u2018int r\u2019\
    \ previously declared here\n   39 |             int r = l;\n      |          \
    \       ^\n/tmp/tmpqjo6ibl4.cpp:63:17: error: redeclaration of \u2018int m\u2019\
    \n   63 |             int m = r;\n      |                 ^\n/tmp/tmpqjo6ibl4.cpp:31:17:\
    \ note: \u2018int m\u2019 previously declared here\n   31 |             int m\
    \ = k;\n      |                 ^\n/tmp/tmpqjo6ibl4.cpp:67:17: error: redeclaration\
    \ of \u2018int n\u2019\n   67 |             int n = m;\n      |              \
    \   ^\n/tmp/tmpqjo6ibl4.cpp:47:17: note: \u2018int n\u2019 previously declared\
    \ here\n   47 |             int n = m;\n      |                 ^\n/tmp/tmpqjo6ibl4.cpp:71:17:\
    \ error: redeclaration of \u2018int m\u2019\n   71 |             int m = n;\n\
    \      |                 ^\n/tmp/tmpqjo6ibl4.cpp:31:17: note: \u2018int m\u2019\
    \ previously d"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmplxuqtwgg: /tmp/tmplxuqtwgg.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsj3ui4jm: /tmp/tmpsj3ui4jm.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            temp += c;\n        } else {\n  \
    \          ans += temp;\n            temp = \"\";\n            ans += c;\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmppuhux3rc: /tmp/tmppuhux3rc.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    std::string word = \"\";\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \      ans += word;\n            word = \"\";\n        } else {\n            if\
    \ (flag) {\n                word += sentence[i];\n            } else {\n     \
    \           flag = false;\n            }\n        }\n    }\n    ans += word;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsny9lc0z: /tmp/tmpsny9lc0z.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            word += sentence[i];\n\
    \        } else {\n            ans += word;\n            word = \"\";\n      \
    \  }\n    }\n    ans += word;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmox0brz0: /tmp/tmpmox0brz0.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    int n = sentence.length();\n    int count = 0;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            count++;\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ == ' ') {\n            flag = true;\n            int j = i;\n            while\
    \ (j < n && sentence[j] != ' ') {\n                j++;\n            }\n     \
    \       int k = j;\n            while (k < n && sentence[k] != ' ') {\n      \
    \          k++;\n            }\n            if (j - i == k - j) {\n          \
    \      for (int k = i; k < j; k++) {\n                    ans += sentence[k];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3g_nrb66: /tmp/tmp3g_nrb66.cpp:49: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = false;\n    for(int i = 0; i < sentence.length(); i++) {\n        if(isalpha(sentence[i]))\
    \ {\n            if(flag) {\n                ans += \" \";\n                flag\
    \ = false;\n            }\n            ans += sentence[i];\n            flag =\
    \ true;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprmitxevz: /tmp/tmprmitxevz.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n           \
    \ word = result + word;\n            result.clear();\n        } else {\n     \
    \       result += c;\n        }\n    }\n    word = result + word;\n    std::sort(word.begin(),\
    \ word.end());\n    std::string prime;\n    for (auto &c : word) {\n        if\
    \ (std::count(word.begin(), word.end(), c) == 1) {\n            prime += c;\n\
    \        }\n    }\n    return prime;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxr3llfbg: /tmp/tmpxr3llfbg.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for (auto c : sentence) {\n \
    \       if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    if (flag) {\n        ans += word;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp79di3g_u: /tmp/tmp79di3g_u.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    bool\
    \ flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n   \
    \         flag = true;\n        }\n        if (flag) {\n            result +=\
    \ c;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf_3uokh8: /tmp/tmpf_3uokh8.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvn4upxs1: /tmp/tmpvn4upxs1.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += c;\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpg65u9bnz: /tmp/tmpg65u9bnz.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    int count = 0;\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] ==\
    \ ' ') {\n            ans += \" \" + word;\n            count = 0;\n         \
    \   word = \"\";\n        } else {\n            word += sentence[i];\n       \
    \     count++;\n        }\n    }\n    ans += \" \" + word;\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpphcid6of: /tmp/tmpphcid6of.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvgij0_ns: /tmp/tmpvgij0_ns.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    bool flag = false;\n    for (int\
    \ i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n            flag =\
    \ true;\n            temp = temp + sentence[i];\n        } else {\n          \
    \  if (flag) {\n                result.push_back(temp);\n                flag\
    \ = false;\n                temp.clear();\n            }\n        }\n    }\n \
    \   if (flag) {\n        result.push_back(temp);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0hr4jds3.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp0hr4jds3.cpp:28:34: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   28 | \
    \                result.push_back(temp);\n      |                            \
    \      ^~~~\n      |                                  |\n      |             \
    \                     std::string {aka std::__cxx11::basic_string<char>}\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0hr4jds3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmp0hr4jds3.cpp:35:26: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018char\u2019\n   35 |         result.push_back(temp);\n      |      \
    \                    ^~~~\n      |                          |\n      |       \
    \                   std::string {aka std::__cxx11::basic_string<char>}\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \            "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_d8u83z9: /tmp/tmp_d8u83z9.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpve_2rcfu: /tmp/tmpve_2rcfu.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &i : sentence)\
    \ {\n        if (i == '.') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            ans += temp;\n            temp =\
    \ \"\";\n            flag = false;\n        }\n        temp += i;\n    }\n   \
    \ ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvipzmmku: /tmp/tmpvipzmmku.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        if (std::all_of(word.begin(), word.end(),\
    \ ::isalpha)) {\n            result += word;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprq__dbmk: /tmp/tmprq__dbmk.cpp:31: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans = ans + \" \"\
    \ + temp;\n                temp = \"\";\n                flag = false;\n     \
    \       } else {\n                ans = ans + \" \" + temp;\n                temp\
    \ = \"\";\n                flag = true;\n            }\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkg9k_vcd: /tmp/tmpkg9k_vcd.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            word = result;\n          \
    \  result = \"\";\n        } else {\n            if (flag) {\n               \
    \ result += c;\n            } else {\n                result += word;\n      \
    \      }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpx6a3i0ek: /tmp/tmpx6a3i0ek.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (std::isalpha(c))\
    \ {\n            flag = true;\n            ans += c;\n        }\n    }\n    if\
    \ (flag) {\n        std::sort(ans.begin(), ans.end());\n        std::sort(sentence.begin(),\
    \ sentence.end());\n        std::set<int> primes;\n        for (auto &c : ans)\
    \ {\n            primes.insert(c);\n        }\n        for (auto &c : sentence)\
    \ {\n            primes.erase(c);\n        }\n        for (auto &c : primes) {\n\
    \            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmphj05ws0s: /tmp/tmphj05ws0s.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    std::string temp;\n    int flag = 0;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            temp.clear();\n      \
    \      flag = 0;\n            for(int j = i; j < sentence.length(); j++) {\n \
    \               if(sentence[j] == ' ') {\n                    temp.push_back(sentence[j]);\n\
    \                    flag = 1;\n                }\n            }\n           \
    \ if(flag == 1) {\n                ans.push_back(temp);\n            }\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpox2fd2na.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpox2fd2na.cpp:33:31: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   33 | \
    \                ans.push_back(temp);\n      |                               ^~~~\n\
    \      |                               |\n      |                            \
    \   std::string {aka std::__cxx11::basic_string<char>}\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpox2fd2na.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    std::string temp;\n    int n = sentence.length();\n    for (int i\
    \ = 0; i < n; i++) {\n        word = sentence[i];\n        temp = result;\n  \
    \      while (true) {\n            int flag = 0;\n            for (int j = 0;\
    \ j < temp.length(); j++) {\n                if (temp[j] == word[j]) {\n     \
    \               flag = 1;\n                    break;\n                }\n   \
    \         }\n            if (flag == 0)\n                break;\n            temp\
    \ = temp + \" \" + word;\n        }\n        result = temp;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpn7mi1mei: /tmp/tmpn7mi1mei.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string word = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      word = word + sentence[i];\n        } else {\n            if (temp.length()\
    \ != 0) {\n                ans = ans + \" \" + temp;\n                temp = \"\
    \";\n            }\n            ans = ans + \" \" + word;\n            word =\
    \ \"\";\n        }\n    }\n    if (temp.length() != 0) {\n        ans = ans +\
    \ \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp162i_zez: /tmp/tmp162i_zez.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             temp = \"\";\n                flag = false;\n            }\n   \
    \     }\n    }\n    if (flag) {\n        ans += temp;\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplw1ymkzc.cpp:92:37: warning: missing terminating ' character\n\
    \   92 |             ans[i] = ans[i] - '0' + '0\n      |                     \
    \                ^\n/tmp/tmplw1ymkzc.cpp:92:37: error: missing terminating ' character\n\
    \   92 |             ans[i] = ans[i] - '0' + '0\n      |                     \
    \                ^~\n/tmp/tmplw1ymkzc.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmplw1ymkzc.cpp:93:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   93 | }\n      | ^\n/tmp/tmplw1ymkzc.cpp:94:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   94 | int main() {\n     \
    \ |            ^\n/tmp/tmplw1ymkzc.cpp:103:1: error: expected \u2018}\u2019 at\
    \ end of input\n  103 | }\n      | ^\n/tmp/tmplw1ymkzc.cpp:90:44: note: to match\
    \ this \u2018{\u2019\n   90 |     for (int i = 0; i < ans.length(); i++) {\n \
    \     |                                            ^\n/tmp/tmplw1ymkzc.cpp:103:1:\
    \ error: expected \u2018}\u2019 at end of input\n  103 | }\n      | ^\n/tmp/tmplw1ymkzc.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmplw1ymkzc.cpp:103:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  103 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            }\n        }\n    }\n    ans += word;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpplnnuulh: /tmp/tmpplnnuulh.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    int len = sentence.length();\n    for (int i = 0; i <\
    \ len; i++) {\n        if (sentence[i] != ' ') {\n            flag = false;\n\
    \        }\n    }\n    if (flag) {\n        ans = sentence;\n    } else {\n  \
    \      ans = \"\";\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(0, ans.find(\" \"\
    ));\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0; i\
    \ < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n       \
    \     ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans + sentence[i];\n\
    \    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\" \") != std::string::npos)\
    \ {\n            ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans\
    \ = ans + sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if\
    \ (ans.find(\" \") != std::string::npos) {\n            ans = ans.substr(ans.find(\"\
    \ \") + 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int\
    \ i = 0; i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n\
    \            ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans =\
    \ ans + sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(ans.find(\" \") +\
    \ 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0;\
    \ i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n     \
    \       ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans +\
    \ sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(ans.find(\" \") +\
    \ 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0;\
    \ i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n     \
    \       ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans +\
    \ sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(ans.find(\" \") +\
    \ 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0;\
    \ i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n     \
    \       ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans +\
    \ \n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbkiqk0o1.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbkiqk0o1.cpp:96:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   96 | }\n      | ^\n/tmp/tmpbkiqk0o1.cpp:97:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   97 | int main() {\n     \
    \ |            ^\n/tmp/tmpbkiqk0o1.cpp:106:1: error: expected \u2018}\u2019 at\
    \ end of input\n  106 | }\n      | ^\n/tmp/tmpbkiqk0o1.cpp:17:53: note: to match\
    \ this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string sentence)\
    \ {\n      |                                                     ^\n/tmp/tmpbkiqk0o1.cpp:106:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  106 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            flag = true;\n            temp\
    \ += c;\n        }\n        if (flag) {\n            ans += \" \" + temp;\n  \
    \          flag = false;\n            temp = \"\";\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpavrpa_2h: /tmp/tmpavrpa_2h.cpp:36: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n   \
    \     if(sentence[i]==' '){\n            flag = true;\n        }\n        if(flag){\n\
    \            temp.push_back(sentence[i]);\n        }\n    }\n    for(int i=0;i<temp.size();i++){\n\
    \        for(int j=i+1;j<temp.size();j++){\n            if(temp[i]==temp[j]){\n\
    \                ans.push_back(temp[i]);\n                temp.erase(temp.begin()+j);\n\
    \                flag = false;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxwsdd4h4: /tmp/tmpxwsdd4h4.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        flag = false;\n        word = sentence[i];\n        for (int\
    \ j = 0; j < ans.length(); j++) {\n            if (ans[j] == word) {\n       \
    \         flag = true;\n                break;\n            }\n        }\n   \
    \     if (!flag) {\n            ans += \" \" + word;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuq9wwte2.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpuq9wwte2.cpp:25:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   25 |             if (ans[j] == word) {\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuq9wwte2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpuq9wwte2.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpuq9wwte2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5: note:\
    \   template "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        if (is_prime(i))\
    \ {\n            ans += sentence.substr(i, 1);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_t3i1kbw.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_t3i1kbw.cpp:21:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   21 |         if (is_prime(i)) {\n      |             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpuk0b_9nn: /tmp/tmpuk0b_9nn.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans += \" \";\n  \
    \              flag = false;\n            }\n            temp = sentence[i];\n\
    \            while (temp != ' ') {\n                ans += temp;\n           \
    \     temp = sentence[++i];\n            }\n            flag = true;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsnuebm9z.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpsnuebm9z.cpp:30:25: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   30 |             while (temp != ' ') {\n      |  \
    \                  ~~~~ ^~ ~~~\n      |                    |       |\n      |\
    \                    |       char\n      |                    std::string {aka\
    \ std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsnuebm9z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1037:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpsnuebm9z.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   30\
    \ |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsnuebm9z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1112:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1112 |     operator!=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      temp = sentence[i];\n        for(int j = i + 1; j < n; j++) {\n       \
    \     if(temp == sentence[j]) {\n                temp = temp + \" \";\n      \
    \          ans = ans + temp;\n                i = j;\n            }\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzqls5xqz.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpzqls5xqz.cpp:24:21: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |             if(temp == sentence[j]) {\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzqls5xqz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpzqls5xqz.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzqls5xqz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5: note:\
    \   template argument deduct"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdy1ycj50: /tmp/tmpdy1ycj50.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        bool found = false;\n        for (int j =\
    \ 0; j < n; j++) {\n            if (j == i) continue;\n            if (j % i ==\
    \ 0) {\n                found = true;\n                break;\n            }\n\
    \        }\n        if (!found) {\n            ans += \" \" + word;\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    std::string temp2;\n    std::string temp3;\n    std::string temp4;\n\
    \    std::string temp5;\n    std::string temp6;\n    std::string temp7;\n    std::string\
    \ temp8;\n    std::string temp9;\n    std::string temp10;\n    std::string temp11;\n\
    \    std::string temp12;\n    std::string temp13;\n    std::string temp14;\n \
    \   std::string temp15;\n    std::string temp16;\n    std::string temp17;\n  \
    \  std::string temp18;\n    std::string temp19;\n    std::string temp20;\n   \
    \ std::string temp21;\n    std::string temp22;\n    std::string temp23;\n    std::string\
    \ temp24;\n    std::string temp25;\n    std::string temp26;\n    std::string temp27;\n\
    \    std::string temp28;\n    std::string temp29;\n    std::string temp30;\n \
    \   std::string temp31;\n    std::string temp32;\n    std::string temp33;\n  \
    \  std::string temp34;\n    std::string temp35;\n    std::string temp36;\n   \
    \ std::string temp37;\n    std::string temp38;\n    std::string temp39;\n    std::string\
    \ temp40;\n    std::string temp41;\n    std::string temp42;\n    std::string temp43;\n\
    \    std::string temp44;\n    std::string temp45;\n    std::string temp46;\n \
    \   std::string temp47;\n    std::string temp48;\n    std::string temp49;\n  \
    \  std::string temp50;\n    std::string temp51;\n    std::string temp52;\n   \
    \ std::string temp53;\n    std::string temp54;\n    std::string temp55;\n    std::string\
    \ temp56;\n    std::string temp57;\n    std::string temp58;\n    std::string temp59;\n\
    \    std::string temp60;\n    std::string temp61;\n    std::string temp62;\n \
    \   std::string temp63;\n    std::string temp64;\n    std::string temp65;\n  \
    \  std::string temp66;\n    std::string temp67;\n    std::string temp68;\n   \
    \ std::string temp69;\n    std::string temp70;\n    std::string temp71;\n    std::string\
    \ temp72;\n    std::string temp73;\n    std::string temp74;\n    std::string temp75;\n\
    \    std::string temp76;\n    std::string temp77;\n    std::string temp78;\n \
    \   std::string temp79;\n    std::string temp80;\n    std::string temp81;\n  \
    \  std::string temp82;\n    std::string temp83;\n    std::string temp84;\n   \
    \ std::string temp85;\n    std::string temp86;\n    std::string temp87;\n    std::string\
    \ temp88;\n\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfol_1zcq: /tmp/tmpfol_1zcq.cpp:111: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    for(int i = 0; i < sentence.length(); i++) {\n      \
    \  if(sentence[i] == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if(flag) {\n            ans += sentence[i];\n            flag\
    \ = false;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp2m232ag0: /tmp/tmp2m232ag0.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf7qdsl58: /tmp/tmpf7qdsl58.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n      \
    \      flag = true;\n        }\n        if (flag) {\n            ans += temp;\n\
    \            temp = \"\";\n            flag = false;\n        }\n        else\
    \ {\n            temp += sentence[i];\n        }\n    }\n    ans += temp;\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp123n90l_: /tmp/tmp123n90l_.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    for (int i\
    \ = 0; i < temp.length(); i++) {\n        if (temp[i] != ' ') {\n            ans\
    \ = ans + temp[i];\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] % 2 == 0) {\n            ans = ans + \" \";\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            flag = true;\n       \
    \     ans += word;\n            word = \"\";\n        } else {\n            word\
    \ += sentence[i];\n        }\n    }\n    ans += word;\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpze16y94o: /tmp/tmpze16y94o.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ temp;\n                temp = \"\";\n                flag = false;\n       \
    \     }\n        } else {\n            temp += c;\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        ans += temp;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpys1v8yqi: /tmp/tmpys1v8yqi.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += \" \" + temp;\n                temp = \"\";\n               \
    \ flag = false;\n            } else {\n                flag = true;\n        \
    \    }\n        } else {\n            temp += sentence[i];\n        }\n    }\n\
    \    if (flag) {\n        ans += \" \" + temp;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp03izt_l6: /tmp/tmp03izt_l6.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \      temp += sentence[i];\n        } else {\n            if (flag) {\n     \
    \           ans += temp;\n                temp = \"\";\n                flag =\
    \ false;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpw6r5rm0n: /tmp/tmpw6r5rm0n.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n   \
    \     if(sentence[i]==' '){\n            flag = true;\n            temp.clear();\n\
    \        }\n        if(flag){\n            temp.push_back(sentence[i]);\n    \
    \    }\n    }\n    for(int i=0;i<temp.size();i++){\n        for(int j=i+1;j<temp.size();j++){\n\
    \            if(temp[i]==temp[j]){\n                flag = false;\n          \
    \  }\n        }\n        if(flag){\n            ans.push_back(temp[i]);\n    \
    \    }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_iv7ioq7: /tmp/tmp_iv7ioq7.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    bool flag = false;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        ans += \" \";\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc7gfnbj3.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpc7gfnbj3.cpp:144:21: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n  144 |         if (sentence\n      |            ~        ^\n      |\
    \                     )\n  145 | }\n      | ~                    \n/tmp/tmpc7gfnbj3.cpp:144:13:\
    \ error: could not convert \u2018sentence\u2019 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018bool\u2019\n  144 | \
    \        if (sentence\n      |             ^~~~~~~~\n      |             |\n \
    \     |             std::string {aka std::__cxx11::basic_string<char>}\n/tmp/tmpc7gfnbj3.cpp:145:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  145 | }\n \
    \     | ^\n/tmp/tmpc7gfnbj3.cpp:146:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  146 | int main() {\n      |            ^\n\
    /tmp/tmpc7gfnbj3.cpp:155:1: error: expected \u2018}\u2019 at end of input\n  155\
    \ | }\n      | ^\n/tmp/tmpc7gfnbj3.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmpc7gfnbj3.cpp:155:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  155 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    bool flag = false;\n\
    \    int len = 0;\n    for (int i = 0; i < sentence.length(); i++) {\n       \
    \ if (sentence[i] == ' ') {\n            flag = true;\n            len++;\n  \
    \      } else {\n            if (flag) {\n                ans += \" \" + word;\n\
    \                flag = false;\n                word = \"\";\n            }\n\
    \            word += sentence[i];\n        }\n    }\n    ans += \" \" + word;\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        temp = ans.substr(i, 1);\n\
    \        if (is_prime(temp.length())) {\n            ans = ans.substr(0, i) +\
    \ \" \" + ans.substr(i + 1, ans.length() - i);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbnb9wrx4.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbnb9wrx4.cpp:39:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   39 |         if (is_prime(temp.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    std::string word;\n    for (auto &c : sentence) {\n \
    \       if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    if (flag) {\n        ans += word;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsh0tr8oe: /tmp/tmpsh0tr8oe.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp = temp +\
    \ sentence[i];\n        } else {\n            ans = ans + \" \" + temp;\n    \
    \        temp = \"\";\n        }\n    }\n    ans = ans + \" \" + temp;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpep2ur97_: /tmp/tmpep2ur97_.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp7swlsrhp: /tmp/tmp7swlsrhp.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    bool flag = false;\n    for (int\
    \ i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            flag =\
    \ true;\n        }\n        if (flag) {\n            temp.push_back(sentence[i]);\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (temp[i] != '\
    \ ') {\n            result.push_back(temp[i]);\n        }\n    }\n    for (int\
    \ i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n            int count =\
    \ 0;\n            for (int j = i; j < n; j++) {\n                if (temp[j] ==\
    \ temp[i]) {\n                    count++;\n                }\n            }\n\
    \            if (count == 2) {\n                result.push_back(temp[i]);\n \
    \           }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 3) {\n\
    \                result.push_back(temp[i]);\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n          \
    \  int count = 0;\n            for (int j = i; j < n; j++) {\n               \
    \ if (temp[j] == temp[i]) {\n                    count++;\n                }\n\
    \            }\n            if (count == 4) {\n                result.push_back(temp[i]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 5) {\n\
    \                result.push_back(temp[i]);\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n          \
    \  int count = 0;\n            for (int j = i; j < n; j++) {\n               \
    \ if (temp[j] == temp[i]) {\n                    count++;\n                }\n\
    \            }\n            if (count == 6) {\n                result.push_back(temp[i]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 7) {\n\
    \                result.push_back(temp[i]);\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n          \
    \  int count = 0;\n            for (int j = i; j < n; j++) {\n               \
    \ if (temp[j] == temp[i]) {\n                    count++;\n                }\n\
    \            }\n            if (count == 8) {\n                result.push_back(temp[i]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 9\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi7wzh0ys.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpi7wzh0ys.cpp:134:27: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n  134 |             if (count == 9\n      |                ~        \
    \  ^\n      |                           )\n  135 | }\n      | ~              \
    \            \n/tmp/tmpi7wzh0ys.cpp:135:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  135 | }\n      | ^\n/tmp/tmpi7wzh0ys.cpp:136:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  136 | int main() {\n      |            ^\n/tmp/tmpi7wzh0ys.cpp:145:1: error:\
    \ expected \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmpi7wzh0ys.cpp:126:33:\
    \ note: to match this \u2018{\u2019\n  126 |     for (int i = 0; i < n; i++) {\n\
    \      |                                 ^\n/tmp/tmpi7wzh0ys.cpp:145:1: error:\
    \ expected \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmpi7wzh0ys.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpi7wzh0ys.cpp:145:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  145 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans = ans + \" \"\
    \ + temp;\n                temp = \"\";\n                flag = false;\n     \
    \       } else {\n                ans = ans + \" \" + temp;\n                temp\
    \ = \"\";\n                flag = true;\n            }\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp88da_od9: /tmp/tmp88da_od9.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      temp = temp + \" \" + sentence[i];\n        } else {\n            ans =\
    \ ans + \" \" + temp;\n            temp = sentence[i];\n        }\n    }\n   \
    \ ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n        if (ans[i]\
    \ % 2 == 0) {\n            ans = ans + \" \" + temp;\n            temp = sentence[i];\n\
    \        }\n    }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++)\
    \ {\n        if (ans[i] % 3 == 0) {\n            ans = ans + \" \" + temp;\n \
    \           temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n\
    \    for (int i = 0; i < n; i++) {\n        if (ans[i] % 5 == 0) {\n         \
    \   ans = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n  \
    \  }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n     \
    \   if (ans[i] % 7 == 0) {\n            ans = ans + \" \" + temp;\n          \
    \  temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (ans[i] % 11 == 0) {\n            ans\
    \ = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n    }\n \
    \   ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n        if (ans[i]\
    \ % 13 == 0) {\n            ans = ans + \" \" + temp;\n            temp = sentence[i];\n\
    \        }\n    }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++)\
    \ {\n        if (ans[i] % 17 == 0) {\n            ans = ans + \" \" + temp;\n\
    \            temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n\
    \    for (int i = 0; i < n; i++) {\n        if (ans[i] % 19 == 0) {\n        \
    \    ans = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n \
    \   }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n    \
    \    if (ans[i] % 23 == 0) {\n            ans = ans + \" \" + temp;\n        \
    \    temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n  \
    \  for (int i = 0; i < n; i++) {\n        if (ans[i] % 29 == 0) {\n          \
    \  ans = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n   \
    \ }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n      \
    \  if (ans[i] % 31 == 0) {\n            ans = ans + \" \" + temp;\n          \
    \  temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (ans[i] % 37 == 0) {\n\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0jf5_p7r.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp0jf5_p7r.cpp:112:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  112 | int main() {\n      |            ^\n/tmp/tmp0jf5_p7r.cpp:121:1:\
    \ error: expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmp0jf5_p7r.cpp:108:33:\
    \ note: to match this \u2018{\u2019\n  108 |     for (int i = 0; i < n; i++) {\n\
    \      |                                 ^\n/tmp/tmp0jf5_p7r.cpp:121:1: error:\
    \ expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmp0jf5_p7r.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmp0jf5_p7r.cpp:121:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  121 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word = \"\";\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            } else {\n                word += c;\n     \
    \       }\n        }\n    }\n    ans += word;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpl6srp0fj: /tmp/tmpl6srp0fj.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpunpnmsd0: /tmp/tmpunpnmsd0.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence.substr(i, 1);\n        if (is_prime(word.length())) {\n\
    \            result += word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2dfhf1ag.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp2dfhf1ag.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for(int i = 0; i < sentence.length(); i++) {\n     \
    \   if(sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        if(flag) {\n            ans += \" \";\n            flag =\
    \ false;\n        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n    \
    \    if(isPrime(ans[i])) {\n            ans += ans[i];\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2bgndbom.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp2bgndbom.cpp:31:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   31 |         if(isPrime(ans[i]))\
    \ {\n      |            ^~~~~~~\n      |            stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        word = sentence.substr(i, 1);\n  \
    \      if (is_prime(word.length())) {\n            ans += word;\n            flag\
    \ = true;\n        }\n    }\n    if (!flag) {\n        ans = ans + \" \";\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8eoc9cmn.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp8eoc9cmn.cpp:24:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   24 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpu75f_ltz: /tmp/tmpu75f_ltz.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int len1 = 0, len2 = 0;\n            while(sentence[i]\
    \ != ' ') {\n                len1++;\n                i++;\n            }\n  \
    \          while(sentence[j] != ' ') {\n                len2++;\n            \
    \    j++;\n            }\n            if(len1 == len2) {\n                ans\
    \ += sentence[i];\n                i++;\n                j++;\n            }\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpf5fr7_w3: /tmp/tmpf5fr7_w3.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp_ans = \"\";\n    bool flag =\
    \ false;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            flag = true;\n        }\n        if (flag) {\n      \
    \      ans += sentence[i];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == '.') {\n            flag = false;\n        }\n\
    \        if (flag) {\n            temp_ans += ans[i];\n        }\n    }\n    for\
    \ (int i = 0; i < temp_ans.length(); i++) {\n        temp = temp_ans.substr(0,\
    \ i);\n        if (temp == \"is\") {\n            ans += \"is\";\n        }\n\
    \        if (temp == \"for\") {\n            ans += \"for\";\n        }\n    \
    \    if (temp == \"go\") {\n            ans += \"go\";\n        }\n        if\
    \ (temp == \"swimming\") {\n            ans += \"swimming\";\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpe6w1k0z7: /tmp/tmpe6w1k0z7.cpp:57: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                flag = false;\n                temp = \"\";\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpboktoz9j: /tmp/tmpboktoz9j.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        word = sentence.substr(i, 1);\n  \
    \      if (is_prime(word.length())) {\n            ans += word;\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy52alb6f.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpy52alb6f.cpp:24:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   24 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = true;\n    std::string temp;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] != ' ') {\n            flag = false;\n          \
    \  break;\n        }\n    }\n    if (flag) {\n        ans = sentence;\n    } else\
    \ {\n        ans = sentence;\n    }\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = ans.substr(0,\
    \ i);\n            ans = ans.substr(i + 1);\n            int count = 0;\n    \
    \        for (int j = 0; j < temp.length(); j++) {\n                for (int k\
    \ = 0; k < ans.length(); k++) {\n                    if (temp[j] == ans[k]) {\n\
    \                        count++;\n                    }\n                }\n\
    \            }\n            if (count == 2) {\n                ans = temp;\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 6) > this->size() (which is 4)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      word += sentence[i];\n        } else {\n            temp = word;\n    \
    \        word = \"\";\n            ans += temp;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp1a9vbga0: /tmp/tmp1a9vbga0.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] == ' ') {\n            flag = true;\n           \
    \ ans += word;\n            word.clear();\n        } else {\n            if (flag)\
    \ {\n                word += sentence[i];\n            }\n        }\n    }\n \
    \   ans += word;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpwh_x6aed: /tmp/tmpwh_x6aed.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word = \"\";\n    std::string temp = \"\"\
    ;\n    for (char c : sentence) {\n        if (c == ' ') {\n            if (flag)\
    \ {\n                ans += \" \" + temp;\n                flag = false;\n   \
    \             temp = \"\";\n            } else {\n                flag = true;\n\
    \            }\n        } else {\n            temp += c;\n        }\n    }\n \
    \   if (flag) {\n        ans += \" \" + temp;\n    }\n    ans = ans.substr(0,\
    \ ans.length() - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"\
    ));\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9lo0lz4l: /tmp/tmp9lo0lz4l.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        bool flag = false;\n        for (int j =\
    \ i + 1; j < n; j++) {\n            if (isPrime(j - i)) {\n                if\
    \ (j - i == word.length()) {\n                    flag = true;\n             \
    \       break;\n                }\n            }\n        }\n        if (flag)\
    \ {\n            result += \" \" + word;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprboqij14.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmprboqij14.cpp:25:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   25 |             if (isPrime(j\
    \ - i)) {\n      |                 ^~~~~~~\n      |                 stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_i21m19f: /tmp/tmp_i21m19f.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            temp = ans;\n            ans = \"\";\n        \
    \    int count = 0;\n            while (temp != \"\") {\n                temp\
    \ = temp.substr(0, temp.find(\" \"));\n                count++;\n            }\n\
    \            if (count % 2 == 0) {\n                ans += temp;\n           \
    \ }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    for (int i = 2; i < n; i++) {\n        if (ans.find(std::to_string(i))\
    \ != std::string::npos) {\n            flag = false;\n        }\n        if (flag)\
    \ {\n            ans += \" \";\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk4jtrm_z: /tmp/tmpk4jtrm_z.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += c;\n        }\n    }\n \
    \   if (flag) {\n        ans += \" \" + temp;\n    }\n    ans = ans.substr(0,\
    \ ans.size() - 1);\n    int n = ans.size();\n    for (int i = 1; i < n; i++) {\n\
    \        if (ans[i] % 2 == 0) {\n            ans = ans.substr(0, i) + \" \" +\
    \ ans.substr(i, ans.size());\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpnrzyeqis: /tmp/tmpnrzyeqis.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += \" \" + temp;\n                temp = \"\";\n               \
    \ flag = false;\n            } else {\n                flag = true;\n        \
    \    }\n        } else {\n            temp += sentence[i];\n        }\n    }\n\
    \    if (flag) {\n        ans += \" \" + temp;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdvkoxgfn: /tmp/tmpdvkoxgfn.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            flag = true;\n      \
    \  }\n        if (flag) {\n            ans += sentence[i];\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        temp = ans.substr(i, 1);\n\
    \        if (is_prime(temp.length())) {\n            ans = ans.substr(0, i) +\
    \ \" \" + ans.substr(i + 1, ans.length() - i);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3uqqqgwa.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp3uqqqgwa.cpp:31:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   31 |         if (is_prime(temp.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    for (int i = 0; i < sentence.length(); i++) {\n     \
    \   if (sentence[i] != ' ') {\n            flag = false;\n        }\n    }\n \
    \   if (flag) {\n        for (int i = 0; i < sentence.length(); i++) {\n     \
    \       if (sentence[i] != ' ') {\n                ans += sentence[i];\n     \
    \       }\n        }\n    } else {\n        for (int i = 0; i < sentence.length();\
    \ i++) {\n            if (sentence[i] != ' ') {\n                ans += sentence[i];\n\
    \            }\n        }\n        for (int i = 0; i < sentence.length(); i++)\
    \ {\n            if (sentence[i] != ' ') {\n                ans += sentence[i];\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpskvxiteh: /tmp/tmpskvxiteh.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    int n = sentence.length();\n    for(int i = 0;\
    \ i < n; i++) {\n        word = sentence[i];\n        for(int j = i + 1; j < n;\
    \ j++) {\n            if(isPrime(j - i) && isPrime(j - i + 1)) {\n           \
    \     ans += word;\n                i = j;\n                break;\n         \
    \   }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7wj6wqac.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp7wj6wqac.cpp:24:16: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   24 |             if(isPrime(j\
    \ - i) && isPrime(j - i + 1)) {\n      |                ^~~~~~~\n      |     \
    \           stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word = \"\";\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            }\n        }\n    }\n    ans += word;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp1suna77w: /tmp/tmp1suna77w.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    bool\
    \ flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n   \
    \         flag = true;\n            continue;\n        }\n        if (flag) {\n\
    \            result += c;\n        }\n    }\n    std::string new_result;\n   \
    \ for (auto &c : result) {\n        if (std::find(new_result.begin(), new_result.end(),\
    \ c) == new_result.end()) {\n            new_result += c;\n        }\n    }\n\
    \    for (auto &c : new_result) {\n        if (std::find(result.begin(), result.end(),\
    \ c) == result.end()) {\n            result += c;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpo2lldk43: /tmp/tmpo2lldk43.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        ans += \" \";\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0au76pxw.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp0au76pxw.cpp:144:21: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n  144 |         if (sentence\n      |            ~        ^\n      |\
    \                     )\n  145 | }\n      | ~                    \n/tmp/tmp0au76pxw.cpp:144:13:\
    \ error: could not convert \u2018sentence\u2019 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018bool\u2019\n  144 | \
    \        if (sentence\n      |             ^~~~~~~~\n      |             |\n \
    \     |             std::string {aka std::__cxx11::basic_string<char>}\n/tmp/tmp0au76pxw.cpp:145:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  145 | }\n \
    \     | ^\n/tmp/tmp0au76pxw.cpp:146:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  146 | int main() {\n      |            ^\n\
    /tmp/tmp0au76pxw.cpp:155:1: error: expected \u2018}\u2019 at end of input\n  155\
    \ | }\n      | ^\n/tmp/tmp0au76pxw.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmp0au76pxw.cpp:155:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  155 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    int n = sentence.length();\n    int count = 0;\n    for(int i = 0;\
    \ i < n; i++) {\n        word = sentence.substr(i, 1);\n        if(isPrime(word.length()))\
    \ {\n            ans += word;\n            count++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpabhnepbe.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpabhnepbe.cpp:24:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   24 |         if(isPrime(word.length()))\
    \ {\n      |            ^~~~~~~\n      |            stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c != ' ') {\n            flag = true;\n            temp += c;\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             flag = false;\n                temp = \"\";\n            }\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4uqjm1tj: /tmp/tmp4uqjm1tj.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int len = sentence.length();\n    for (int i = 0; i\
    \ < len; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(0, ans.find(\" \"\
    ));\n        }\n    }\n    for (int i = 2; i < len / 2; i++) {\n        if (ans.find(i)\
    \ != std::string::npos) {\n            ans = ans.substr(0, ans.find(i));\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpwqvxze_2: /tmp/tmpwqvxze_2.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i = 0; i < sentence.length(); i++)\
    \ {\n        if(sentence[i] == ' ') {\n            flag = true;\n            temp.clear();\n\
    \            continue;\n        }\n        if(flag) {\n            temp.push_back(sentence[i]);\n\
    \        }\n    }\n    for(int i = 0; i < temp.length(); i++) {\n        if(i\
    \ == 0) {\n            ans += temp[i];\n            continue;\n        }\n   \
    \     for(int j = i; j < temp.length(); j++) {\n            if(temp[i] == temp[j])\
    \ {\n                ans += temp[i];\n                break;\n            }\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmptfi40nyq: /tmp/tmptfi40nyq.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    for (int i = 0; i < n; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(0, ans.find(\" \"\
    ));\n        }\n        if (ans.find(sentence[i]) == std::string::npos) {\n  \
    \          ans += sentence[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpqr_ziql1: /tmp/tmpqr_ziql1.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n            ans[i] =\
    \ ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 == 0) {\n            ans[i] = ans[i] + 1;\n \
    \       }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 3 == 0) {\n            ans[i] = ans[i] + 2;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 5 == 0) {\n          \
    \  ans[i] = ans[i] + 3;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 7 == 0) {\n            ans[i] = ans[i] + 4;\n \
    \       }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 11 == 0) {\n            ans[i] = ans[i] + 5;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 13 == 0) {\n         \
    \   ans[i] = ans[i] + 6;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 17 == 0) {\n            ans[i] = ans[i] + 7;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 19 == 0) {\n            ans[i] = ans[i] + 8;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 23 == 0) {\n         \
    \   ans[i] = ans[i] + 9;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 29 == 0) {\n            ans[i] = ans[i] + 10;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 31 == 0) {\n            ans[i] = ans[i] + 11;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 37 == 0) {\n         \
    \   ans[i] = ans[i] + 12;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 41 == 0) {\n            ans[i] = ans[i] + 13;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 43 == 0) {\n            ans[i] = ans[i] + 14;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 47 == 0) {\n         \
    \   ans[i] = ans[i] + 15;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 49 == 0) {\n            ans[i] = ans[i] + 16;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpif6mgybb.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpif6mgybb.cpp:117:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  117 | int main() {\n      |            ^\n/tmp/tmpif6mgybb.cpp:126:1:\
    \ error: expected \u2018}\u2019 at end of input\n  126 | }\n      | ^\n/tmp/tmpif6mgybb.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpif6mgybb.cpp:126:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  126 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        word = sentence[i];\n        for (int j = i + 1; j < sentence.length();\
    \ j++) {\n            if (isPrime(j - i)) {\n                ans += \" \" + word;\n\
    \                flag = true;\n                break;\n            }\n       \
    \ }\n    }\n    if (flag == false) {\n        ans += \" \" + sentence;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmhcak25d.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpmhcak25d.cpp:24:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   24 |             if (isPrime(j\
    \ - i)) {\n      |                 ^~~~~~~\n      |                 stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag ==\
    \ false) {\n        ans += \" \";\n    }\n    for (int i = 0; i < n; i++) {\n\
    \        if (ans.find(\" \") != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(\" \"));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ if (ans.find(i + 1) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 1));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 2) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 2));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 3) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 3));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 4) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 4));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 5) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 5));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 6) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 6));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 7) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 7));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 8) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 8));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 9) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 9));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 10) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 10));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n  \
    \      if (ans.find(i + 11) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaccdtx3c.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpaccdtx3c.cpp:94:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   94 | }\n      | ^\n/tmp/tmpaccdtx3c.cpp:95:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   95 | int main() {\n     \
    \ |            ^\n/tmp/tmpaccdtx3c.cpp:104:1: error: expected \u2018}\u2019 at\
    \ end of input\n  104 | }\n      | ^\n/tmp/tmpaccdtx3c.cpp:91:33: note: to match\
    \ this \u2018{\u2019\n   91 |     for (int i = 0; i < n; i++) {\n      |     \
    \                            ^\n/tmp/tmpaccdtx3c.cpp:104:1: error: expected \u2018\
    }\u2019 at end of input\n  104 | }\n      | ^\n/tmp/tmpaccdtx3c.cpp:17:53: note:\
    \ to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpaccdtx3c.cpp:104:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  104 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            temp += c;\n        } else {\n  \
    \          ans += temp;\n            temp = \"\";\n            ans += c;\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpag3k7310: /tmp/tmpag3k7310.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            word.clear();\n        } else\
    \ {\n            word += c;\n        }\n    }\n    if (flag) {\n        auto it\
    \ = std::find(word.begin(), word.end(), '\\n');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), ' ');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), '.');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), '!');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), '?');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), ';');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), ':');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), ';');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), '.');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), '!');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), '?');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), ';');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), ':');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), ';');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), '.');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), '\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzekn5pd4.cpp:90:55: warning: missing terminating ' character\n\
    \   90 |         auto it = std::find(word.begin(), word.end(), '\n      |    \
    \                                                   ^\n/tmp/tmpzekn5pd4.cpp:90:55:\
    \ error: missing terminating ' character\n/tmp/tmpzekn5pd4.cpp: In function \u2018\
    std::string words_in_sentence(std::string)\u2019:\n/tmp/tmpzekn5pd4.cpp:34:14:\
    \ error: conflicting declaration \u2018auto it\u2019\n   34 |         auto it\
    \ = std::find(word.begin(), word.end(), ' ');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:30:14:\
    \ note: previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:38:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   38 |         auto it = std::find(word.begin(),\
    \ word.end(), '.');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:42:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   42 |         auto it = std::find(word.begin(),\
    \ word.end(), '!');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:46:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   46 |         auto it = std::find(word.begin(),\
    \ word.end(), '?');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpzekn5pd4.cpp:50:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   50 |         auto it = std::find(word.begin(),\
    \ word.end(), ';');\n      |        "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvncnskv1: /tmp/tmpvncnskv1.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \      ans += word;\n            word = \"\";\n        } else {\n            if\
    \ (flag) {\n                word += sentence[i];\n            }\n        }\n \
    \   }\n    ans += word;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfsnel6u1: /tmp/tmpfsnel6u1.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c != ' ') {\n            flag = true;\n        }\n    }\n   \
    \ if (flag) {\n        std::sort(sentence.begin(), sentence.end());\n        std::sort(sentence.begin(),\
    \ sentence.end());\n        std::sort(sentence.begin(), sentence.end());\n   \
    \ }\n    for (auto &c : sentence) {\n        if (c != ' ') {\n            temp\
    \ = temp + c;\n        }\n    }\n    ans = temp;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvxw_rmij: /tmp/tmpvxw_rmij.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            if (flag) {\n               \
    \ ans += \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n            ans += c;\n        } else {\n            temp += c;\n\
    \        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpud5c6gj2: /tmp/tmpud5c6gj2.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int m = j - i;\n            int count\
    \ = 0;\n            for(int k = i; k <= j; k++) {\n                if(k % m ==\
    \ 0) {\n                    count++;\n                }\n            }\n     \
    \       if(count == 2) {\n                ans += sentence.substr(i, 1);\n    \
    \        }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4xpyvobf: /tmp/tmp4xpyvobf.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    std::string temp;\n    bool flag = false;\n    for (int i = 0; i\
    \ < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n           \
    \ flag = true;\n            temp.clear();\n        } else {\n            if (flag)\
    \ {\n                temp.push_back(sentence[i]);\n            } else {\n    \
    \            word = temp;\n                temp.clear();\n                flag\
    \ = true;\n            }\n        }\n    }\n    for (int i = 0; i < temp.length();\
    \ i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(temp.begin() + i);\n        }\n    }\n    for (int i =\
    \ 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(temp.begin() + i);\n        }\n    }\n    for (int i =\
    \ 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(temp.begin() + i);\n        }\n    }\n    for (int i =\
    \ 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk2w86fsr.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpk2w86fsr.cpp:114:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  114 | }\n      | ^\n/tmp/tmpk2w86fsr.cpp:115:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  115 | int main() {\n     \
    \ |            ^\n/tmp/tmpk2w86fsr.cpp:124:1: error: expected \u2018}\u2019 at\
    \ end of input\n  124 | }\n      | ^\n/tmp/tmpk2w86fsr.cpp:111:45: note: to match\
    \ this \u2018{\u2019\n  111 |     for (int i = 0; i < temp.length(); i++) {\n\
    \      |                                             ^\n/tmp/tmpk2w86fsr.cpp:124:1:\
    \ error: expected \u2018}\u2019 at end of input\n  124 | }\n      | ^\n/tmp/tmpk2w86fsr.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpk2w86fsr.cpp:124:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  124 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    int flag = 0;\n    for(int i = 0; i < sentence.length(); i++) {\n\
    \        if(sentence[i] == ' ') {\n            flag = 1;\n        }\n        if(flag\
    \ == 1) {\n            temp.push_back(sentence[i]);\n        }\n    }\n    for(int\
    \ i = 0; i < temp.length(); i++) {\n        if((temp[i] >= 'a' && temp[i] <= 'z')\
    \ || (temp[i] >= 'A' && temp[i] <= 'Z')) {\n            flag = 0;\n        }\n\
    \        if(flag == 1) {\n            result += temp[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkz900u9z: /tmp/tmpkz900u9z.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += temp;\n\
    \            temp = \"\";\n        } else {\n            if (flag) {\n       \
    \         temp += c;\n            } else {\n                ans += c;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmptq1dan8u: /tmp/tmptq1dan8u.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            flag = true;\n            temp +=\
    \ sentence[i];\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmxbbdtmz: /tmp/tmpmxbbdtmz.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    if (flag) {\n        ans += word;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdaioki4r: /tmp/tmpdaioki4r.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (char c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            result += word;\n         \
    \   word.clear();\n        } else {\n            word += c;\n        }\n    }\n\
    \    result += word;\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpnhz5x9u2: /tmp/tmpnhz5x9u2.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i = 0; i < sentence.length(); i++)\
    \ {\n        if(isalpha(sentence[i])) {\n            flag = true;\n          \
    \  ans += sentence[i];\n        }\n    }\n    if(flag) {\n        for(int i =\
    \ 0; i < ans.length(); i++) {\n            for(int j = i + 1; j < ans.length();\
    \ j++) {\n                if(isalpha(ans[j]) && isalpha(ans[i]) && ans[j] <= ans[i])\
    \ {\n                    temp = ans.substr(i, j);\n                    ans.replace(i,\
    \ j, temp);\n                }\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsbr23256: /tmp/tmpsbr23256.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     } else {\n            if (flag) {\n                ans += sentence[i];\n\
    \                flag = false;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_6tol21g: /tmp/tmp_6tol21g.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            temp.clear();\n        } else\
    \ {\n            if (flag) {\n                temp += c;\n            }\n    \
    \    }\n    }\n    for (auto &c : temp) {\n        ans += c;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpki6ikebo: /tmp/tmpki6ikebo.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp = temp +\
    \ sentence[i];\n        } else {\n            ans = ans + \" \" + temp;\n    \
    \        temp = \"\";\n        }\n    }\n    ans = ans + \" \" + temp;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0a2oevkg: /tmp/tmp0a2oevkg.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp2 = \"\";\n    bool flag = false;\n\
    \    int count = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    for (int i =\
    \ 0; i < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n      \
    \      flag = true;\n            count++;\n        }\n        if (flag == true)\
    \ {\n            ans += sentence[i];\n            flag = false;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            flag2 = true;\n        }\n        if (flag2 == true) {\n    \
    \        ans += ans[i];\n            flag2 = false;\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n       \
    \     flag3 = true;\n        }\n        if (flag3 == true) {\n            ans\
    \ += ans[i];\n            flag3 = false;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n            flag = true;\n\
    \        }\n        if (flag == true) {\n            ans += ans[i];\n        \
    \    flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] == ' ') {\n            flag = true;\n        }\n     \
    \   if (flag == true) {\n            ans += ans[i];\n            flag = false;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == ' ') {\n            flag = true;\n        }\n        if (flag == true) {\n\
    \            ans += ans[i];\n            flag = false;\n        }\n    }\n   \
    \ for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n   \
    \         flag = true;\n        }\n        if (flag == true) {\n            ans\
    \ += ans[i];\n            flag = false;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n            flag = true;\n\
    \        }\n        if (flag == true) {\n            ans += ans[i];\n        \
    \    flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] == ' ') {\n            flag = true;\n        }\n     \
    \   if (flag == true) {\n            ans += ans[i];\n            flag = false;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == ' ') {\n            flag = true;\n        }\n        if (flag == true) {\n\
    \            ans += ans[i];\n            flag = false;\n        }\n    }\n   \
    \ for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n   \
    \         flag = true;\n        }\n        if (flag == true) {\n            ans\
    \ += ans[i];\n            flag = false;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n            flag = true;\n\
    \        }\n        if (flag == true) {\n            ans += ans[i];\n        \
    \    flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5t0bdorq.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp5t0bdorq.cpp:134:29: error: invalid use of member function \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length()\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019 (did you forget the \u2018()\u2019 ?)\n  134 |     for (int i = 0;\
    \ i < ans.length\n      |                         ~~~~^~~~~~\n      |        \
    \                           ()\n/tmp/tmp5t0bdorq.cpp:134:35: error: expected \u2018\
    ;\u2019 before \u2018}\u2019 token\n  134 |     for (int i = 0; i < ans.length\n\
    \      |                                   ^\n      |                        \
    \           ;\n  135 | }\n      | ~                                  \n/tmp/tmp5t0bdorq.cpp:135:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  135 | }\n \
    \     | ^\n/tmp/tmp5t0bdorq.cpp:134:35: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n  134 |     for (int i = 0; i < ans.length\n      |         ~ \
    \                        ^\n      |                                   )\n  135\
    \ | }\n      | ~                                  \n/tmp/tmp5t0bdorq.cpp:135:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  135 | }\n \
    \     | ^\n/tmp/tmp5t0bdorq.cpp:135:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            result += word;\n         \
    \   word.clear();\n        } else {\n            word += c;\n        }\n    }\n\
    \    if (flag) {\n        result += word;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpwmhp91wd: /tmp/tmpwmhp91wd.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ temp;\n                flag = false;\n                temp = \"\";\n       \
    \     } else {\n                flag = true;\n            }\n        } else {\n\
    \            temp += c;\n        }\n    }\n    ans += temp;\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvydy3u2c: /tmp/tmpvydy3u2c.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp_ans = \"\";\n    int len = sentence.length();\n\
    \    for (int i = 0; i < len; i++) {\n        if (sentence[i] != ' ') {\n    \
    \        temp = temp + sentence[i];\n        } else {\n            temp_ans =\
    \ temp_ans + temp;\n            temp = \"\";\n        }\n    }\n    temp_ans =\
    \ temp_ans + temp;\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans = temp_ans.substr(0,\
    \ i);\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans = temp_ans.substr(0,\
    \ i);\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans = temp_ans.substr(0,\
    \ i);\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp76g2bv8m.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp76g2bv8m.cpp:109:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  109 | int main() {\n      |            ^\n/tmp/tmp76g2bv8m.cpp:118:1:\
    \ error: expected \u2018}\u2019 at end of input\n  118 | }\n      | ^\n/tmp/tmp76g2bv8m.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmp76g2bv8m.cpp:118:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  118 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            flag = true;\n            temp\
    \ += c;\n        } else {\n            if (flag) {\n                ans += \"\
    \ \" + temp;\n                temp = \"\";\n                flag = false;\n  \
    \          }\n        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpml9m7hhv: /tmp/tmpml9m7hhv.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == '.' || c\
    \ == '!' || c == '?') {\n            flag = true;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    int n = ans.size();\n    for\
    \ (int i = 1; i < n; i++) {\n        int count = 0;\n        for (int j = i; j\
    \ < n; j++) {\n            if (ans[j] == ans[i]) {\n                count++;\n\
    \            }\n        }\n        if (count == 2) {\n            ans = ans.substr(0,\
    \ i) + \" \" + ans.substr(i + 1, n - 1);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6q6i0x0n: /tmp/tmp6q6i0x0n.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            flag = true;\n      \
    \      temp += sentence[i];\n        } else {\n            if (flag) {\n     \
    \           ans += temp;\n                temp = \"\";\n                flag =\
    \ false;\n            }\n        }\n    }\n    if (flag) {\n        ans += temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvlto8q8d: /tmp/tmpvlto8q8d.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += temp;\n\
    \            temp = \"\";\n        } else {\n            if (flag) {\n       \
    \         temp += c;\n            } else {\n                ans += c;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpghrrihje: /tmp/tmpghrrihje.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    ans.reserve(sentence.size());\n\
    \    std::string word;\n    bool flag = false;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans.push_back(word);\n\
    \            word.clear();\n        } else {\n            word += c;\n       \
    \ }\n    }\n    if (flag) {\n        ans.push_back(word);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5sdu1f0f.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp5sdu1f0f.cpp:25:27: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   25 | \
    \            ans.push_back(word);\n      |                           ^~~~\n  \
    \    |                           |\n      |                           std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5sdu1f0f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1349:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1349 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmp5sdu1f0f.cpp:32:23: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018char\u2019\n   32 |         ans.push_back(word);\n      |         \
    \              ^~~~\n      |                       |\n      |                \
    \       std::string {aka std::__cxx11::basic_string<char>}\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n           \
    \      from /shared/centos7/gcc/9.2.0-skyl"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string word = \"\";\n    bool flag = false;\n\
    \    int count = 0;\n    \n    for (auto &c : sentence) {\n        if (c == '\
    \ ') {\n            if (flag) {\n                ans += \" \" + word;\n      \
    \          flag = false;\n                count = 0;\n                word = \"\
    \";\n            } else {\n                flag = true;\n            }\n     \
    \   } else {\n            word += c;\n            count++;\n        }\n    }\n\
    \    \n    if (flag) {\n        ans += \" \" + word;\n    }\n    \n    for (int\
    \ i = 1; i < ans.size(); i++) {\n        temp = ans.substr(0, i);\n        ans\
    \ = ans.substr(i);\n        \n        if (is_prime(temp.size())) {\n         \
    \   ans += \" \" + temp;\n        }\n    }\n    \n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9tzcs_ge.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp9tzcs_ge.cpp:48:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   48 |         if (is_prime(temp.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (!flag) {\n                ans = ans + \" \"\
    \ + temp;\n                flag = true;\n            }\n            temp = \"\"\
    ;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4f8o4avh: /tmp/tmp4f8o4avh.cpp:36: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfvyf9zx5: /tmp/tmpfvyf9zx5.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    bool flag = false;\n    int count = 0;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            flag = true;\n       \
    \     temp.clear();\n            temp.push_back(sentence[i]);\n            count++;\n\
    \        }\n        else {\n            if(flag) {\n                temp.push_back(sentence[i]);\n\
    \                count++;\n            }\n            else {\n               \
    \ result += temp;\n                temp.clear();\n                temp.push_back(sentence[i]);\n\
    \                count++;\n            }\n        }\n    }\n    result += temp;\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpessa4hk7: /tmp/tmpessa4hk7.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      word = sentence[i];\n        if(isPrime(word.length())) {\n           \
    \ result += word;\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb38d6e2p.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpb38d6e2p.cpp:23:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   23 |         if(isPrime(word.length()))\
    \ {\n      |            ^~~~~~~\n      |            stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        std::string\
    \ word = sentence.substr(i, 1);\n        ans += word;\n    }\n    for (int i =\
    \ 2; i < n; i++) {\n        if (ans.find(ans.substr(i, 1)) != std::string::npos)\
    \ {\n            ans.replace(ans.find(ans.substr(i, 1)), i, \"\");\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 6) > this->size() (which is 0)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \  }\n        if (flag) {\n            temp += sentence[i];\n        }\n    }\n\
    \    for (int i = 0; i < temp.length(); i++) {\n        flag = false;\n      \
    \  for (int j = i + 1; j < temp.length(); j++) {\n            if (isPrime(temp.length()\
    \ - j - 1) && temp.length() % j == 0) {\n                ans += temp.substr(i,\
    \ j);\n                flag = true;\n                break;\n            }\n \
    \       }\n        if (flag == false) {\n            ans += temp.substr(i, temp.length());\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7ngq24cr.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp7ngq24cr.cpp:32:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   32 |             if (isPrime(temp.length()\
    \ - j - 1) && temp.length() % j == 0) {\n      |                 ^~~~~~~\n   \
    \   |                 stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    ans = ans.substr(0, ans.length() - 1);\n    for\
    \ (int i = 0; i < n; i++) {\n        if (ans.find(\" \") != std::string::npos)\
    \ {\n            ans = ans.substr(0, ans.find(\" \"));\n        }\n    }\n   \
    \ for (int i = 2; i < n; i++) {\n        if (ans.find(i) != std::string::npos)\
    \ {\n            ans = ans.substr(0, ans.find(i));\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpb_v5hs_f: /tmp/tmpb_v5hs_f.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp2 = \"\";\n    int count = 0;\n\
    \    int count2 = 0;\n    int flag = 0;\n    std::string temp3 = \"\";\n    for\
    \ (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] != ' ') {\n\
    \            ans += sentence[i];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            count++;\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n\
    \            count2++;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            flag = 1;\n        }\n   \
    \ }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            flag = 0;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4ixx4nvz.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4ixx4nvz.cpp:113:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  113 | int main() {\n      |            ^\n/tmp/tmp4ixx4nvz.cpp:122:1:\
    \ error: expected \u2018}\u2019 at end of input\n  122 | }\n      | ^\n/tmp/tmp4ixx4nvz.cpp:106:44:\
    \ note: to match this \u2018{\u2019\n  106 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmp4ixx4nvz.cpp:122:1:\
    \ error: expected \u2018}\u2019 at end of input\n  122 | }\n      | ^\n/tmp/tmp4ixx4nvz.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmp4ixx4nvz.cpp:122:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  122 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += c;\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6r6bpiqz: /tmp/tmp6r6bpiqz.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            temp += c;\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             temp = \"\";\n                flag = false;\n            }\n   \
    \         ans += c;\n        }\n    }\n    ans += temp;\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpeyot2br3: /tmp/tmpeyot2br3.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6pqvcikp: /tmp/tmp6pqvcikp.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        char\
    \ c = sentence[i];\n        if (c == ' ') {\n            int count = 0;\n    \
    \        while (i != n - 1 && sentence[i] == sentence[i + 1]) {\n            \
    \    count++;\n                i++;\n            }\n            if (count == 2)\
    \ {\n                ans += c;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_hvrbn7p: /tmp/tmp_hvrbn7p.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    ans += word;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpslgvf1_y: /tmp/tmpslgvf1_y.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp84kv7t78: /tmp/tmp84kv7t78.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] != ' ') {\n            ans += sentence[i];\n        } else\
    \ {\n            flag = true;\n        }\n    }\n    if (flag) {\n        return\
    \ ans;\n    }\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        }\n    }\n    for (int i\
    \ = ans.length() - 1; i >= 0; i--) {\n        if (ans[i] % 2 != 0) {\n       \
    \     ans.erase(ans.begin() + i);\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9s6dwcwm: /tmp/tmp9s6dwcwm.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk1uv0ktp: /tmp/tmpk1uv0ktp.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n    \
    \    } else {\n            if (flag) {\n                ans += \" \";\n      \
    \          flag = false;\n            }\n            temp = sentence[i];\n   \
    \         for (int j = i + 1; j < sentence.length(); j++) {\n                if\
    \ (sentence[j] != ' ') {\n                    ans += sentence[j];\n          \
    \          flag = true;\n                    break;\n                }\n     \
    \       }\n            ans += temp;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpw52suaj8: /tmp/tmpw52suaj8.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    int n = sentence.length();\n    for (int i = 0; i < n;\
    \ i++) {\n        word = sentence.substr(i, 1);\n        if (is_prime(word.length()))\
    \ {\n            ans += \" \" + word;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp16t5btni.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp16t5btni.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int count = 0;\n            for(int k\
    \ = i; k <= j; k++) {\n                if(sentence[k] == ' ') {\n            \
    \        count++;\n                }\n            }\n            if(count == 2)\
    \ {\n                ans += sentence[i];\n            }\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpykr3sh61: /tmp/tmpykr3sh61.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprs8hph8z: /tmp/tmprs8hph8z.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            temp += c;\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             temp = \"\";\n                flag = false;\n            }\n   \
    \         ans += c;\n        }\n    }\n    if (flag) {\n        ans += temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpg32lk1cj: /tmp/tmpg32lk1cj.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpp46c1yi_: /tmp/tmpp46c1yi_.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        if (std::find(sentence.begin(), sentence.end(),\
    \ word) == sentence.end()) {\n            result += word;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpmz1y5fb0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Value = const std::__cxx11::basic_string<char>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Predicate\
    \ = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3899:28:\
    \   required from \u2018_IIter std::find(_IIter, _IIter, const _Tp&) [with _IIter\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_str"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n        } else {\n            flag = false;\n     \
    \   }\n        if (flag) {\n            ans += c;\n        }\n    }\n    ans =\
    \ ans.substr(0, ans.size() - 1);\n    int n = ans.size();\n    std::vector<int>\
    \ primes;\n    for (int i = 2; i <= n; i++) {\n        if (ans.find(i) == std::string::npos)\
    \ {\n            primes.push_back(i);\n        }\n    }\n    std::string ans2\
    \ = \"is\";\n    for (auto &i : primes) {\n        ans2 += ans.substr(0, i);\n\
    \    }\n    return ans2;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpco2ck748: /tmp/tmpco2ck748.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    for (auto &c : ans) {\n    \
    \    if (std::find(std::begin(ans), std::end(ans), c) == std::end(ans)) {\n  \
    \          ans.erase(std::remove(std::begin(ans), std::end(ans), c), std::end(ans));\n\
    \        }\n    }\n    std::string new_ans = \"\";\n    for (auto &c : ans) {\n\
    \        if (std::find(std::begin(ans), std::end(ans), c) == std::end(ans)) {\n\
    \            new_ans += c;\n        }\n    }\n    for (auto &c : new_ans) {\n\
    \        if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgp31lb8c.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpgp31lb8c.cpp:71:33: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   71 |         if (std::find(std::begin\n      |                   \
    \   ~          ^\n      |                                 )\n   72 | }\n     \
    \ | ~                                \n/tmp/tmpgp31lb8c.cpp:71:33: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   71 |         if (std::find(std::begin\n\
    \      |            ~                    ^\n      |                          \
    \       )\n   72 | }\n      | ~                                \n/tmp/tmpgp31lb8c.cpp:72:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   72 | }\n \
    \     | ^\n/tmp/tmpgp31lb8c.cpp:73:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n\
    /tmp/tmpgp31lb8c.cpp:82:1: error: expected \u2018}\u2019 at end of input\n   82\
    \ | }\n      | ^\n/tmp/tmpgp31lb8c.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmpgp31lb8c.cpp:82:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   82 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpetx7f78w: /tmp/tmpetx7f78w.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = false;\n    for(int i=0;i<sentence.size();i++){\n        if(isalpha(sentence[i])){\n\
    \            flag = true;\n            ans += sentence[i];\n        }\n      \
    \  if(flag){\n            flag = false;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4hd1xbou: /tmp/tmp4hd1xbou.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmrktrqdl: /tmp/tmpmrktrqdl.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool prime = true;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            prime = false;\n \
    \           break;\n        }\n    }\n    if (prime) {\n        for (int i = 0;\
    \ i < n; i++) {\n            if (sentence[i] != ' ') {\n                for (int\
    \ j = i; j < n; j++) {\n                    if (sentence[j] == ' ') {\n      \
    \                  break;\n                    }\n                }\n        \
    \        ans += sentence[i];\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmxyc9yv4: /tmp/tmpmxyc9yv4.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      flag = true;\n            temp += sentence[i];\n        } else {\n    \
    \        if (flag) {\n                ans += temp;\n                temp = \"\"\
    ;\n                flag = false;\n            }\n        }\n    }\n    if (flag)\
    \ {\n        ans += temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_icaagrx: /tmp/tmp_icaagrx.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpm9b38sc8: /tmp/tmpm9b38sc8.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool prime = true;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            prime = true;\n  \
    \      } else {\n            prime = false;\n        }\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        if (prime) {\n            ans += sentence[i];\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkjmwuo6y: /tmp/tmpkjmwuo6y.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            flag = true;\n      \
    \      temp += sentence[i];\n        } else {\n            if (flag) {\n     \
    \           ans += temp;\n                temp = \"\";\n                flag =\
    \ false;\n            }\n        }\n    }\n    if (flag)\n        ans += temp;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmps57wy7d3: /tmp/tmps57wy7d3.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == 'a' ||\
    \ i == 'e' || i == 'i' || i == 'o' || i == 'u') {\n            flag = true;\n\
    \        }\n        if (flag) {\n            ans += i;\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpui3idi90: /tmp/tmpui3idi90.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        flag = false;\n        for (int j = i + 1; j < ans.length(); j++) {\n\
    \            if (ans[j] % i == 0) {\n                flag = true;\n          \
    \      break;\n            }\n        }\n        if (!flag) {\n            ans.erase(ans.begin()\
    \ + i);\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            flag = true;\n       \
    \     ans += temp;\n            temp = \"\";\n        } else {\n            temp\
    \ += sentence[i];\n        }\n    }\n    ans += temp;\n    for(int i = 0; i <\
    \ ans.length(); i++) {\n        if(i%2 == 0) {\n            assert(ans[i] == 'a'\
    \ || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u');\n    \
    \        ans[i] = ans[i+1];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpo8ua_1on: /tmp/tmpo8ua_1on.cpp:33: std::string words_in_sentence(std::string):\
    \ Assertion `ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o'\
    \ || ans[i] == 'u'' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpo3pkcpt0: /tmp/tmpo3pkcpt0.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans = ans + \" \"\
    \ + temp;\n                temp = \"\";\n                flag = false;\n     \
    \       } else {\n                ans = ans + \" \" + temp;\n                temp\
    \ = \"\";\n                flag = true;\n            }\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpufznn50c: /tmp/tmpufznn50c.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                flag = false;\n                temp = \"\";\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfnjt754l: /tmp/tmpfnjt754l.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] >= 'a' && sentence[i] <= 'z') {\n            flag = true;\n\
    \        }\n        if (flag) {\n            ans += sentence[i];\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a'\
    \ && ans[i] <= 'z') {\n            ans[i] = ans[i] - 'a' + 'A';\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() +\
    \ i);\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n      \
    \  if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() + i);\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() +\
    \ i);\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n      \
    \  if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() + i);\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() +\
    \ i);\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n      \
    \  if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() + i);\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < an\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfeygjnx6.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpfeygjnx6.cpp:103:25: error: \u2018an\u2019 was not declared in this\
    \ scope; did you mean \u2018ans\u2019?\n  103 |     for (int i = 0; i < an\n \
    \     |                         ^~\n      |                         ans\n/tmp/tmpfeygjnx6.cpp:103:27:\
    \ error: expected \u2018;\u2019 before \u2018}\u2019 token\n  103 |     for (int\
    \ i = 0; i < an\n      |                           ^\n      |                \
    \           ;\n  104 | }\n      | ~                          \n/tmp/tmpfeygjnx6.cpp:104:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  104 | }\n \
    \     | ^\n/tmp/tmpfeygjnx6.cpp:103:27: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n  103 |     for (int i = 0; i < an\n      |         ~         \
    \        ^\n      |                           )\n  104 | }\n      | ~        \
    \                  \n/tmp/tmpfeygjnx6.cpp:104:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  104 | }\n      | ^\n/tmp/tmpfeygjnx6.cpp:104:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    bool\
    \ flag = false;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++)\
    \ {\n        flag = false;\n        for (int j = i + 1; j < n; j++) {\n      \
    \      if (isPrime(j - i)) {\n                flag = true;\n                break;\n\
    \            }\n        }\n        if (flag) {\n            result += sentence[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgbkxwxeq.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpgbkxwxeq.cpp:24:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   24 |             if (isPrime(j\
    \ - i)) {\n      |                 ^~~~~~~\n      |                 stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp = temp +\
    \ \" \" + sentence[i];\n        } else {\n            ans = ans + \" \" + temp;\n\
    \            temp = \"\";\n        }\n    }\n    ans = ans + \" \" + temp;\n \
    \   return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n  \
    \  assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4_5b_0lp: /tmp/tmp4_5b_0lp.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpifklw8f6: /tmp/tmpifklw8f6.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    bool flag = false;\n    int n = sentence.length();\n    for (int\
    \ i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            flag =\
    \ true;\n            ans += word;\n            word.clear();\n        } else {\n\
    \            if (flag) {\n                word += sentence[i];\n            }\
    \ else {\n                flag = false;\n            }\n        }\n    }\n   \
    \ ans += word;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbgh0rn0r: /tmp/tmpbgh0rn0r.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            temp = temp + \" \";\n            flag = true;\n\
    \        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ != ' ') {\n            ans = ans + temp[i];\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans = ans + \" \";\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk2r06uso: /tmp/tmpk2r06uso.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            ans += temp;\n            temp =\
    \ \"\";\n            flag = false;\n        }\n        temp += c;\n    }\n   \
    \ ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_wg4p7h6: /tmp/tmp_wg4p7h6.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &i : sentence)\
    \ {\n        if (i == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += i;\n        }\n    }\n \
    \   if (flag) {\n        ans += \" \" + temp;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8po8mrcx: /tmp/tmp8po8mrcx.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0oagy66k: /tmp/tmp0oagy66k.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] == ' ') {\n            flag = true;\n           \
    \ temp.clear();\n        } else {\n            if (flag) {\n                temp\
    \ += sentence[i];\n            } else {\n                ans += temp;\n      \
    \          temp.clear();\n                flag = false;\n            }\n     \
    \   }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3r69k0ph: /tmp/tmp3r69k0ph.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    for (int i\
    \ = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || \n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzm_0tr3y.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpzm_0tr3y.cpp:95:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   95 | }\n      | ^\n/tmp/tmpzm_0tr3y.cpp:94:30: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   94 |         if (ans[i] == '\\\
    n' ||\n      |            ~                 ^\n      |                       \
    \       )\n   95 | }\n      | ~                             \n/tmp/tmpzm_0tr3y.cpp:95:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   95 | }\n \
    \     | ^\n/tmp/tmpzm_0tr3y.cpp:96:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   96 | int main() {\n      |            ^\n\
    /tmp/tmpzm_0tr3y.cpp:105:1: error: expected \u2018}\u2019 at end of input\n  105\
    \ | }\n      | ^\n/tmp/tmpzm_0tr3y.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmpzm_0tr3y.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  105 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            temp = temp + \" \";\n            flag = true;\n\
    \        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ != ' ') {\n            ans = ans + temp[i];\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 == 0) {\n          \
    \  ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 3 == 0) {\n            ans = ans + \" \";\n   \
    \     }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 5 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 7 == 0) {\n          \
    \  ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 11 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 13 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 17 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 19 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 23 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 29 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 31 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 37 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 41 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 43 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 47 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 53 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 59 == 0) {\n            ans = \n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprxqaq5qp.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmprxqaq5qp.cpp:117:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  117 | }\n      | ^\n/tmp/tmprxqaq5qp.cpp:118:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  118 | int main() {\n     \
    \ |            ^\n/tmp/tmprxqaq5qp.cpp:127:1: error: expected \u2018}\u2019 at\
    \ end of input\n  127 | }\n      | ^\n/tmp/tmprxqaq5qp.cpp:114:44: note: to match\
    \ this \u2018{\u2019\n  114 |     for (int i = 0; i < ans.length(); i++) {\n \
    \     |                                            ^\n/tmp/tmprxqaq5qp.cpp:127:1:\
    \ error: expected \u2018}\u2019 at end of input\n  127 | }\n      | ^\n/tmp/tmprxqaq5qp.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmprxqaq5qp.cpp:127:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  127 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      temp = sentence[i];\n        for(int j = i + 1; j < n; j++) {\n       \
    \     if(temp == sentence[j]) {\n                temp = temp + \" \" + sentence[j];\n\
    \                j++;\n            }\n        }\n        ans = ans + \" \" + temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp25ytvmqa.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp25ytvmqa.cpp:24:21: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |             if(temp == sentence[j]) {\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp25ytvmqa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1026:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp25ytvmqa.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp25ytvmqa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1099:5: note:\
    \   template argument deduct"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            word.clear();\n        } else\
    \ {\n            if (flag) {\n                word += c;\n            } else {\n\
    \                result += word;\n                result += c;\n             \
    \   flag = true;\n            }\n        }\n    }\n    result += word;\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpthgs4d_x: /tmp/tmpthgs4d_x.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      word = sentence[i];\n        for(int j = i + 1; j < n; j++) {\n       \
    \     if(isPrime(j - i) && isPrime(j - i + 1)) {\n                result += \"\
    \ \" + word;\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3qk5bfuq.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp3qk5bfuq.cpp:24:16: error: \u2018isPrime\u2019 was not declared in\
    \ this scope; did you mean \u2018stime\u2019?\n   24 |             if(isPrime(j\
    \ - i) && isPrime(j - i + 1)) {\n      |                ^~~~~~~\n      |     \
    \           stime\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk27lu_zi: /tmp/tmpk27lu_zi.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for(int i = 0; i < sentence.length(); i++) {\n     \
    \   if(sentence[i] == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if(flag) {\n            ans += sentence[i];\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp7xkbsk0l: /tmp/tmp7xkbsk0l.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      temp = temp + sentence[i];\n        } else {\n            if (flag) {\n\
    \                ans = ans + \" \" + temp;\n                temp = \"\";\n   \
    \             flag = false;\n            } else {\n                ans = ans +\
    \ \" \" + temp;\n                temp = \"\";\n                flag = true;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjej3ji28: /tmp/tmpjej3ji28.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n\
    \            flag = true;\n            count++;\n        } else {\n          \
    \  if (flag) {\n                ans += temp;\n                temp = \"\";\n \
    \               flag = false;\n                count = 0;\n            }\n   \
    \         temp = temp + sentence[i];\n        }\n    }\n    ans += temp;\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfkohmhy0: /tmp/tmpfkohmhy0.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n\
    \        if(sentence[i]==' '){\n            flag = true;\n        }\n        if(flag){\n\
    \            word = word + sentence[i];\n        }\n    }\n    for(int i=0;i<word.size();i++){\n\
    \        for(int j=i+1;j<word.size();j++){\n            if(word[i]==word[j]){\n\
    \                ans = ans + word[i] + \" \";\n                word.erase(i,1);\n\
    \                word.erase(j,1);\n                flag = false;\n           \
    \ }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpeumr78c5: /tmp/tmpeumr78c5.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    for(int i = 0; i < sentence.length(); i++) {\n      \
    \  if(sentence[i] != ' ') {\n            flag = false;\n            break;\n \
    \       }\n    }\n    if(flag) {\n        for(int i = 0; i < sentence.length();\
    \ i++) {\n            if(sentence[i] != ' ') {\n                ans += sentence[i];\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5y817yop: /tmp/tmp5y817yop.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int len = 0;\n    int\
    \ count = 0;\n    for (auto c : sentence) {\n        if (c == ' ') {\n       \
    \     flag = true;\n            len++;\n            count = 0;\n        } else\
    \ {\n            if (flag) {\n                temp += c;\n                count++;\n\
    \            } else {\n                ans += temp;\n                temp = \"\
    \";\n                flag = true;\n                len++;\n                count\
    \ = 0;\n            }\n        }\n    }\n    ans += temp;\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdf4q71wr: /tmp/tmpdf4q71wr.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += sentence[i];\n         \
    \   flag = true;\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpughhnakn: /tmp/tmpughhnakn.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + word;\n                flag = false;\n                word = \"\";\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            word += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + word;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcxhclzdy: /tmp/tmpcxhclzdy.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            if (flag) {\n                temp\
    \ += sentence[i];\n            } else {\n                flag = true;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpgqu8bh_x: /tmp/tmpgqu8bh_x.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpclsso7p_: /tmp/tmpclsso7p_.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n\
    \        if(sentence[i]==' '){\n            flag = true;\n        }\n        if(flag){\n\
    \            temp += sentence[i];\n        }\n        else{\n            ans +=\
    \ temp;\n            temp = \"\";\n        }\n    }\n    ans += temp;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5dzjzytm: /tmp/tmp5dzjzytm.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
