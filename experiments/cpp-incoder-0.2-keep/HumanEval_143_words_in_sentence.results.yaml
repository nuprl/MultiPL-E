name: HumanEval_143_words_in_sentence
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + word;\n                flag = false;\n            }\n            word\
    \ = \"\";\n        } else {\n            word += c;\n        }\n    }\n    if\
    \ (flag) {\n        ans += \" \" + word;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpuklexify: /tmp/tmpuklexify.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            } else {\n                flag = false;\n  \
    \          }\n        }\n    }\n    ans += word;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp89lc21tc: /tmp/tmp89lc21tc.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = false;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n\
    \        if (sentence[i] != ' ') {\n            ans += sentence[i];\n        }\
    \ else {\n            flag = true;\n        }\n    }\n    if (flag) {\n      \
    \  return ans;\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' \n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps2l6i39b.cpp:144:28: warning: missing terminating ' character\n\
    \  144 |         if (sentence[i] != '\n      |                            ^\n\
    /tmp/tmps2l6i39b.cpp:144:28: error: missing terminating ' character\n  144 | \
    \        if (sentence[i] != '\n      |                            ^ \n/tmp/tmps2l6i39b.cpp:\
    \ In function \u2018std::string words_in_sentence(std::string)\u2019:\n/tmp/tmps2l6i39b.cpp:145:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  145 | }\n \
    \     | ^\n/tmp/tmps2l6i39b.cpp:144:27: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n  144 |         if (sentence[i] != '\n      |            ~    \
    \          ^\n      |                           )\n  145 | }\n      | ~      \
    \                    \n/tmp/tmps2l6i39b.cpp:145:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  145 | }\n      | ^\n/tmp/tmps2l6i39b.cpp:146:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  146 | int main() {\n      |            ^\n/tmp/tmps2l6i39b.cpp:155:1: error:\
    \ expected \u2018}\u2019 at end of input\n  155 | }\n      | ^\n/tmp/tmps2l6i39b.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmps2l6i39b.cpp:155:1: warning: control reaches end of non-void function\
    \ [-Wreturn-type]\n  155 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool isPrime = true;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            ans += word;\n            word = \"\"\
    ;\n        } else {\n            word += c;\n        }\n    }\n    ans += word;\n\
    \    for (int i = 3; i < ans.length(); i++) {\n        if (isPrime) {\n      \
    \      isPrime = false;\n            for (int j = i; j < ans.length(); j++) {\n\
    \                if (ans[j] % i == 0) {\n                    isPrime = true;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcng8sc3s: /tmp/tmpcng8sc3s.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ temp;\n                temp = \"\";\n                flag = false;\n       \
    \     } else {\n                flag = true;\n            }\n        } else {\n\
    \            temp += c;\n        }\n    }\n    if (flag) {\n        ans += temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpekmb3hps: /tmp/tmpekmb3hps.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmppi7dljfm: /tmp/tmppi7dljfm.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp7pi6m17z: /tmp/tmp7pi6m17z.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    bool flag = false;\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] ==\
    \ ' ') {\n            flag = true;\n            ans += \" \" + word;\n       \
    \     word = \"\";\n        } else {\n            if (flag) {\n              \
    \  word += sentence[i];\n            } else {\n                word += sentence[i];\n\
    \            }\n        }\n    }\n    ans += \" \" + word;\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == '\\n') {\n            ans =\
    \ ans.substr(0, i);\n            break;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjgbne6rf.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpjgbne6rf.cpp:125:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  125 | int main() {\n      |            ^\n/tmp/tmpjgbne6rf.cpp:134:1:\
    \ error: expected \u2018}\u2019 at end of input\n  134 | }\n      | ^\n/tmp/tmpjgbne6rf.cpp:120:44:\
    \ note: to match this \u2018{\u2019\n  120 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmpjgbne6rf.cpp:134:1:\
    \ error: expected \u2018}\u2019 at end of input\n  134 | }\n      | ^\n/tmp/tmpjgbne6rf.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpjgbne6rf.cpp:134:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  134 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int count = 0;\n            for(int k\
    \ = i; k <= j; k++) {\n                if(sentence[k] == ' ') {\n            \
    \        count++;\n                }\n            }\n            if(count == 2)\
    \ {\n                ans += sentence[i];\n            }\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmbey1cu6: /tmp/tmpmbey1cu6.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpwy4aqnle: /tmp/tmpwy4aqnle.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpo0x3yuqc: /tmp/tmpo0x3yuqc.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            flag = true;\n            temp\
    \ += c;\n        } else {\n            if (flag) {\n                ans += \"\
    \ \" + temp;\n                temp = \"\";\n                flag = false;\n  \
    \          }\n        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp7cuguwzt: /tmp/tmp7cuguwzt.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    for (int i = 0; i < n; i++) {\n        if (i\
    \ % 2 == 0) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp7res9fzm: /tmp/tmp7res9fzm.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \         ans += sentence[i];\n        } else {\n            if (flag) {\n   \
    \             ans += sentence[i];\n                flag = false;\n           \
    \ }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp697pmaqa: /tmp/tmp697pmaqa.cpp:36: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    std::string prime_str = ans;\n    int n = prime_str.size();\n   \
    \ int count = 0;\n    for (int i = 0; i < n; i++) {\n        bool flag = false;\n\
    \        for (int j = i + 1; j < n; j++) {\n            if (prime_str[i] == prime_str[j])\
    \ {\n                flag = true;\n                break;\n            }\n   \
    \     }\n        if (flag) {\n            count++;\n        }\n    }\n    std::string\
    \ new_ans = prime_str;\n    for (int i = 0; i < count; i++) {\n        new_ans\
    \ += \" \";\n    }\n    return new_ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprlkke89p: /tmp/tmprlkke89p.cpp:53: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++){\n   \
    \     temp = sentence[i];\n        for(int j = i + 1; j < n; j++){\n         \
    \   if(temp == sentence[j]){\n                ans += temp;\n                temp\
    \ = sentence[j];\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi3kei0qr.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpi3kei0qr.cpp:24:21: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |             if(temp == sentence[j]){\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]){\n      |                            \
    \      ^\nIn file included from /usr/include/c++/9/regex:62,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n             \
    \    from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]){\n      |                            \
    \      ^\nIn file included from /usr/include/c++/9/regex:62,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n             \
    \    from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/regex:62,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n       \
    \          from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/iosfwd:40,\n        \
    \         from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::fpos<_StateT>\u2019\n   24 |          \
    \   if(temp == sentence[j]){\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:64,\n                 from\
    \ /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const\
    \ std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const\
    \ pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::pair<_T1, _T2>\u2019\n   24 |         \
    \    if(temp == sentence[j]){\n      |                                  ^\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\u2019\
    \n  325 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |    \
    \ ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   24 |             if(temp == sentence[j]){\n\
    \      |                                  ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   24 |             if(temp == sentence[j]){\n\
    \      |                                  ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   24\
    \ |             if(temp == sentence[j]){\n      |                            \
    \      ^\nIn file included from /usr/include/c++/9/string:41,\n              \
    \   from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::allocator<_CharT>\u2019\n   24 |      \
    \       if(temp == sentence[j]){\n      |                                  ^\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   24 |             if(temp\
    \ == sentence[j]){\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 24 |             if(temp == sentence[j]){\n      |                         \
    \         ^\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n  \
    \               from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  297 |   operator==(const error_code&\
    \ __lhs, const error_condition& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:304:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_code&)\u2019\n  304 |   operator==(const\
    \ error_condition& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:304:37: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::error_condition&\u2019\
    \n  311 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n      \
    \           from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n     \
    \            from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/complex:463:5: note:\
    \ candidate: \u2018template<class _Tp> constexpr bool std::operator==(const std::complex<_Tp>&,\
    \ const std::complex<_Tp>&)\u2019\n  463 |     operator==(const complex<_Tp>&\
    \ __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   24 |           \
    \  if(temp == sentence[j]){\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   24 |           \
    \  if(temp == sentence[j]){\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]){\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   24 |             if(temp == sentence[j]){\n      |                       \
    \           ^\nIn file included from /usr/include/c++/9/deque:67,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n         \
    \        from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   24 |             if(temp == sentence[j]){\n      |                       \
    \           ^\nIn file included from /usr/include/c++/9/deque:67,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n         \
    \        from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::deque<_Tp, _Alloc>\u2019\n   24 |     \
    \        if(temp == sentence[j]){\n      |                                  ^\n\
    In file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::array<_Tp,\
    \ _Nm>\u2019\n   24 |             if(temp == sentence[j]){\n      |          \
    \                        ^\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::tuple<_Tps ...>\u2019\n   24 |             if(temp == sentence[j]){\n\
    \      |                                  ^\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  24 |             if(temp == sentence[j]){\n      |                        \
    \          ^\nIn file included from /usr/include/c++/9/functional:59,\n      \
    \           from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n     \
    \            from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   24 |   \
    \          if(temp == sentence[j]){\n      |                                 \
    \ ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n       \
    \          from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   24 |   \
    \          if(temp == sentence[j]){\n      |                                 \
    \ ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n       \
    \          from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   24 |             if(temp == sentence[j]){\n      |           \
    \                       ^\nIn file included from /usr/include/c++/9/iterator:66,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019\n   24 |             if(temp == sentence[j]){\n      |        \
    \                          ^\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019\n   24\
    \ |             if(temp == sentence[j]){\n      |                            \
    \      ^\nIn file included from /usr/include/c++/9/map:61,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5: note: candidate:\
    \ \u2018template<class _Key, class _Tp, class _Compare, class _Alloc> bool std::operator==(const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key, _Tp, _Compare,\
    \ _Alloc>&)\u2019\n 1455 |     operator==(const map<_Key, _Tp, _Compare, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n\
    \   24 |             if(temp == sentence[j]){\n      |                       \
    \           ^\nIn file included from /usr/include/c++/9/map:62,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n           \
    \      from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019\n   24 |\
    \             if(temp == sentence[j]){\n      |                              \
    \    ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n     \
    \            from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   24 | \
    \            if(temp == sentence[j]){\n      |                               \
    \   ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n      \
    \           from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   24 |             if(temp == sentence[j]){\n      |           \
    \                       ^\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/memory:81,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n       \
    \          from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   24 |        \
    \     if(temp == sentence[j]){\n      |                                  ^\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]){\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::vector<_Tp, _Alloc>\u2019\n   24 |    \
    \         if(temp == sentence[j]){\n      |                                  ^\n\
    In file included from /usr/include/c++/9/queue:64,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::queue<_Tp,\
    \ _Seq>\u2019\n   24 |             if(temp == sentence[j]){\n      |         \
    \                         ^\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::set<_Key, _Compare, _Alloc>\u2019\n   24\
    \ |             if(temp == sentence[j]){\n      |                            \
    \      ^\nIn file included from /usr/include/c++/9/set:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5: note:\
    \ candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool std::operator==(const\
    \ std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key, _Compare,\
    \ _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\n\
    \   24 |             if(temp == sentence[j]){\n      |                       \
    \           ^\nIn file included from /usr/include/c++/9/stack:61,\n          \
    \       from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n         \
    \        from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::stack<_Tp,\
    \ _Seq>\u2019\n   24 |             if(temp == sentence[j]){\n      |         \
    \                         ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j]){\n\
    \      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j]){\n\
    \      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j]){\n\
    \      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]){\n      |                                  ^\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   24 |          \
    \   if(temp == sentence[j]){\n      |                                  ^\nIn file\
    \ included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n      \
    \           from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]){\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]){\n      |       \
    \                           ^\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} to\
    \ \u2018std::thread::id\u2019\n  276 |   operator==(thread::id __x, thread::id\
    \ __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::normal_distribution<_RealType>\u2019\n\
    \   24 |             if(temp == sentence[j]){\n      |                       \
    \           ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]){\n      |       \
    \                           ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]){\n      |       \
    \                           ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]){\n      |       \
    \                           ^\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \n   24 |             if(temp == sentence[j]){\n      |                      \
    \            ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpi3kei0qr.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpi3kei0qr.cpp:24:34:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]){\n     \
    \ |                                  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += temp;\n\
    \            temp = \"\";\n        } else {\n            if (flag) {\n       \
    \         temp += c;\n            } else {\n                ans += c;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpmsgrpwob: /tmp/tmpmsgrpwob.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        char\
    \ c = sentence[i];\n        if (c == ' ') {\n            int j = i;\n        \
    \    while (j < n && sentence[j] == ' ') {\n                j++;\n           \
    \ }\n            int k = j;\n            while (k < n && sentence[k] == ' ') {\n\
    \                k++;\n            }\n            int m = k;\n            while\
    \ (m < n && sentence[m] == ' ') {\n                m++;\n            }\n     \
    \       int l = m;\n            while (l < n && sentence[l] == ' ') {\n      \
    \          l++;\n            }\n            int r = l;\n            while (r <\
    \ n && sentence[r] == ' ') {\n                r++;\n            }\n          \
    \  int m = r;\n            while (m < n && sentence[m] == ' ') {\n           \
    \     m++;\n            }\n            int n = m;\n            while (n < n &&\
    \ sentence[n] == ' ') {\n                n++;\n            }\n            int\
    \ m = n;\n            while (m < n && sentence[m] == ' ') {\n                m++;\n\
    \            }\n            int l = m;\n            while (l < n && sentence[l]\
    \ == ' ') {\n                l++;\n            }\n            int r = l;\n   \
    \         while (r < n && sentence[r] == ' ') {\n                r++;\n      \
    \      }\n            int m = r;\n            while (m < n && sentence[m] == '\
    \ ') {\n                m++;\n            }\n            int n = m;\n        \
    \    while (n < n && sentence[n] == ' ') {\n                n++;\n           \
    \ }\n            int m = n;\n            while (m < n && sentence[m] == ' ') {\n\
    \                m++;\n            }\n            int l = m;\n            while\
    \ (l < n && sentence[l] == ' ') {\n                l++;\n            }\n     \
    \       int r = l;\n            while (r < n && sentence[r] == ' ') {\n      \
    \          r++;\n            }\n            int m = r;\n            while (m <\
    \ n && sentence[m] == ' ') {\n                m++;\n            }\n          \
    \  int n = m;\n            while (n < n && sentence[n] == ' ') {\n           \
    \     n++;\n            }\n            int m = n;\n            while (m < n &&\
    \ sentence[m] == ' ') {\n                m++;\n            }\n            int\
    \ l = m;\n            while (l < n && sentence[l] == ' ') {\n                l++;\n\
    \            }\n            int r = l;\n            while (r < n && sentence[r]\
    \ == ' ') {\n                r++;\n            }\n            int m = r;\n   \
    \         while (m < n && sentence[m] == ' ') {\n                m++;\n      \
    \      }\n            int n = m;\n            while (n < n && sentence[n] == '\
    \ ') {\n                n++;\n            }\n            int m = n;\n        \
    \    while (m < n && sentence[m] == ' \n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpur9we3r0.cpp:112:44: warning: missing terminating ' character\n\
    \  112 |             while (m < n && sentence[m] == '\n      |               \
    \                             ^\n/tmp/tmpur9we3r0.cpp:112:44: error: missing terminating\
    \ ' character\n  112 |             while (m < n && sentence[m] == '\n      | \
    \                                           ^ \n/tmp/tmpur9we3r0.cpp: In function\
    \ \u2018std::string words_in_sentence(std::string)\u2019:\n/tmp/tmpur9we3r0.cpp:43:17:\
    \ error: redeclaration of \u2018int m\u2019\n   43 |             int m = r;\n\
    \      |                 ^\n/tmp/tmpur9we3r0.cpp:31:17: note: \u2018int m\u2019\
    \ previously declared here\n   31 |             int m = k;\n      |          \
    \       ^\n/tmp/tmpur9we3r0.cpp:51:17: error: redeclaration of \u2018int m\u2019\
    \n   51 |             int m = n;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:31:17:\
    \ note: \u2018int m\u2019 previously declared here\n   31 |             int m\
    \ = k;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:55:17: error: redeclaration\
    \ of \u2018int l\u2019\n   55 |             int l = m;\n      |              \
    \   ^\n/tmp/tmpur9we3r0.cpp:35:17: note: \u2018int l\u2019 previously declared\
    \ here\n   35 |             int l = m;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:59:17:\
    \ error: redeclaration of \u2018int r\u2019\n   59 |             int r = l;\n\
    \      |                 ^\n/tmp/tmpur9we3r0.cpp:39:17: note: \u2018int r\u2019\
    \ previously declared here\n   39 |             int r = l;\n      |          \
    \       ^\n/tmp/tmpur9we3r0.cpp:63:17: error: redeclaration of \u2018int m\u2019\
    \n   63 |             int m = r;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:31:17:\
    \ note: \u2018int m\u2019 previously declared here\n   31 |             int m\
    \ = k;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:67:17: error: redeclaration\
    \ of \u2018int n\u2019\n   67 |             int n = m;\n      |              \
    \   ^\n/tmp/tmpur9we3r0.cpp:47:17: note: \u2018int n\u2019 previously declared\
    \ here\n   47 |             int n = m;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:71:17:\
    \ error: redeclaration of \u2018int m\u2019\n   71 |             int m = n;\n\
    \      |                 ^\n/tmp/tmpur9we3r0.cpp:31:17: note: \u2018int m\u2019\
    \ previously declared here\n   31 |             int m = k;\n      |          \
    \       ^\n/tmp/tmpur9we3r0.cpp:75:17: error: redeclaration of \u2018int l\u2019\
    \n   75 |             int l = m;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:35:17:\
    \ note: \u2018int l\u2019 previously declared here\n   35 |             int l\
    \ = m;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:79:17: error: redeclaration\
    \ of \u2018int r\u2019\n   79 |             int r = l;\n      |              \
    \   ^\n/tmp/tmpur9we3r0.cpp:39:17: note: \u2018int r\u2019 previously declared\
    \ here\n   39 |             int r = l;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:83:17:\
    \ error: redeclaration of \u2018int m\u2019\n   83 |             int m = r;\n\
    \      |                 ^\n/tmp/tmpur9we3r0.cpp:31:17: note: \u2018int m\u2019\
    \ previously declared here\n   31 |             int m = k;\n      |          \
    \       ^\n/tmp/tmpur9we3r0.cpp:87:17: error: redeclaration of \u2018int n\u2019\
    \n   87 |             int n = m;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:47:17:\
    \ note: \u2018int n\u2019 previously declared here\n   47 |             int n\
    \ = m;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:91:17: error: redeclaration\
    \ of \u2018int m\u2019\n   91 |             int m = n;\n      |              \
    \   ^\n/tmp/tmpur9we3r0.cpp:31:17: note: \u2018int m\u2019 previously declared\
    \ here\n   31 |             int m = k;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:95:17:\
    \ error: redeclaration of \u2018int l\u2019\n   95 |             int l = m;\n\
    \      |                 ^\n/tmp/tmpur9we3r0.cpp:35:17: note: \u2018int l\u2019\
    \ previously declared here\n   35 |             int l = m;\n      |          \
    \       ^\n/tmp/tmpur9we3r0.cpp:99:17: error: redeclaration of \u2018int r\u2019\
    \n   99 |             int r = l;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:39:17:\
    \ note: \u2018int r\u2019 previously declared here\n   39 |             int r\
    \ = l;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:103:17: error: redeclaration\
    \ of \u2018int m\u2019\n  103 |             int m = r;\n      |              \
    \   ^\n/tmp/tmpur9we3r0.cpp:31:17: note: \u2018int m\u2019 previously declared\
    \ here\n   31 |             int m = k;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:107:17:\
    \ error: redeclaration of \u2018int n\u2019\n  107 |             int n = m;\n\
    \      |                 ^\n/tmp/tmpur9we3r0.cpp:47:17: note: \u2018int n\u2019\
    \ previously declared here\n   47 |             int n = m;\n      |          \
    \       ^\n/tmp/tmpur9we3r0.cpp:111:17: error: redeclaration of \u2018int m\u2019\
    \n  111 |             int m = n;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:31:17:\
    \ note: \u2018int m\u2019 previously declared here\n   31 |             int m\
    \ = k;\n      |                 ^\n/tmp/tmpur9we3r0.cpp:113:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n  113 | }\n      | ^\n/tmp/tmpur9we3r0.cpp:112:43:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n  112 |          \
    \   while (m < n && sentence[m] == '\n      |                   ~            \
    \           ^\n      |                                           )\n  113 | }\n\
    \      | ~                                          \n/tmp/tmpur9we3r0.cpp:113:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  113 | }\n \
    \     | ^\n/tmp/tmpur9we3r0.cpp:114:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  114 | int main() {\n      |            ^\n\
    /tmp/tmpur9we3r0.cpp:123:1: error: expected \u2018}\u2019 at end of input\n  123\
    \ | }\n      | ^\n/tmp/tmpur9we3r0.cpp:20:33: note: to match this \u2018{\u2019\
    \n   20 |     for (int i = 0; i < n; i++) {\n      |                         \
    \        ^\n/tmp/tmpur9we3r0.cpp:123:1: error: expected \u2018}\u2019 at end of\
    \ input\n  123 | }\n      | ^\n/tmp/tmpur9we3r0.cpp:17:53: note: to match this\
    \ \u2018{\u2019\n   17 | std::string words_in_sentence(std::string sentence) {\n\
    \      |                                                     ^\n/tmp/tmpur9we3r0.cpp:123:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  123 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpl9uiwkqp: /tmp/tmpl9uiwkqp.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpu7qy2h6b: /tmp/tmpu7qy2h6b.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            temp += c;\n        } else {\n  \
    \          ans += temp;\n            temp = \"\";\n            ans += c;\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpr520phfr: /tmp/tmpr520phfr.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    std::string word = \"\";\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \      ans += word;\n            word = \"\";\n        } else {\n            if\
    \ (flag) {\n                word += sentence[i];\n            } else {\n     \
    \           flag = false;\n            }\n        }\n    }\n    ans += word;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9vgsasf7: /tmp/tmp9vgsasf7.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            word += sentence[i];\n\
    \        } else {\n            ans += word;\n            word = \"\";\n      \
    \  }\n    }\n    ans += word;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpc0xcm5yc: /tmp/tmpc0xcm5yc.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    int n = sentence.length();\n    int count = 0;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            count++;\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ == ' ') {\n            flag = true;\n            int j = i;\n            while\
    \ (j < n && sentence[j] != ' ') {\n                j++;\n            }\n     \
    \       int k = j;\n            while (k < n && sentence[k] != ' ') {\n      \
    \          k++;\n            }\n            if (j - i == k - j) {\n          \
    \      for (int k = i; k < j; k++) {\n                    ans += sentence[k];\n\
    \                }\n            }\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpuprg5tud: /tmp/tmpuprg5tud.cpp:49: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = false;\n    for(int i = 0; i < sentence.length(); i++) {\n        if(isalpha(sentence[i]))\
    \ {\n            if(flag) {\n                ans += \" \";\n                flag\
    \ = false;\n            }\n            ans += sentence[i];\n            flag =\
    \ true;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpnua2xvnw: /tmp/tmpnua2xvnw.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n           \
    \ word = result + word;\n            result.clear();\n        } else {\n     \
    \       result += c;\n        }\n    }\n    word = result + word;\n    std::sort(word.begin(),\
    \ word.end());\n    std::string prime;\n    for (auto &c : word) {\n        if\
    \ (std::count(word.begin(), word.end(), c) == 1) {\n            prime += c;\n\
    \        }\n    }\n    return prime;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpyqvji6ui: /tmp/tmpyqvji6ui.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for (auto c : sentence) {\n \
    \       if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    if (flag) {\n        ans += word;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpirrsjyp4: /tmp/tmpirrsjyp4.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    bool\
    \ flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n   \
    \         flag = true;\n        }\n        if (flag) {\n            result +=\
    \ c;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpx4cz886l: /tmp/tmpx4cz886l.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpwbkfw6zh: /tmp/tmpwbkfw6zh.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += c;\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpuvbf1u0a: /tmp/tmpuvbf1u0a.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    int count = 0;\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] ==\
    \ ' ') {\n            ans += \" \" + word;\n            count = 0;\n         \
    \   word = \"\";\n        } else {\n            word += sentence[i];\n       \
    \     count++;\n        }\n    }\n    ans += \" \" + word;\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmph6654wic: /tmp/tmph6654wic.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8byp5h3z: /tmp/tmp8byp5h3z.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    bool flag = false;\n    for (int\
    \ i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n            flag =\
    \ true;\n            temp = temp + sentence[i];\n        } else {\n          \
    \  if (flag) {\n                result.push_back(temp);\n                flag\
    \ = false;\n                temp.clear();\n            }\n        }\n    }\n \
    \   if (flag) {\n        result.push_back(temp);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_h90jity.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_h90jity.cpp:28:34: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   28 | \
    \                result.push_back(temp);\n      |                            \
    \      ^~~~\n      |                                  |\n      |             \
    \                     std::string {aka std::__cxx11::basic_string<char>}\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp_h90jity.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1353:24: note:\
    \   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1353 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmp_h90jity.cpp:35:26: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018char\u2019\n   35 |         result.push_back(temp);\n      |      \
    \                    ^~~~\n      |                          |\n      |       \
    \                   std::string {aka std::__cxx11::basic_string<char>}\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp_h90jity.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1353:24: note:\
    \   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1353 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcoyznh1a: /tmp/tmpcoyznh1a.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp8h24zd1j: /tmp/tmp8h24zd1j.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &i : sentence)\
    \ {\n        if (i == '.') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            ans += temp;\n            temp =\
    \ \"\";\n            flag = false;\n        }\n        temp += i;\n    }\n   \
    \ ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxot2atzy: /tmp/tmpxot2atzy.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        if (std::all_of(word.begin(), word.end(),\
    \ ::isalpha)) {\n            result += word;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmplvykfizm: /tmp/tmplvykfizm.cpp:31: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans = ans + \" \"\
    \ + temp;\n                temp = \"\";\n                flag = false;\n     \
    \       } else {\n                ans = ans + \" \" + temp;\n                temp\
    \ = \"\";\n                flag = true;\n            }\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfk_emdlp: /tmp/tmpfk_emdlp.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            word = result;\n          \
    \  result = \"\";\n        } else {\n            if (flag) {\n               \
    \ result += c;\n            } else {\n                result += word;\n      \
    \      }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0ibeia4i: /tmp/tmp0ibeia4i.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (std::isalpha(c))\
    \ {\n            flag = true;\n            ans += c;\n        }\n    }\n    if\
    \ (flag) {\n        std::sort(ans.begin(), ans.end());\n        std::sort(sentence.begin(),\
    \ sentence.end());\n        std::set<int> primes;\n        for (auto &c : ans)\
    \ {\n            primes.insert(c);\n        }\n        for (auto &c : sentence)\
    \ {\n            primes.erase(c);\n        }\n        for (auto &c : primes) {\n\
    \            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n \
    \   auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9sdax2v0: /tmp/tmp9sdax2v0.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    std::string temp;\n    int flag = 0;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            temp.clear();\n      \
    \      flag = 0;\n            for(int j = i; j < sentence.length(); j++) {\n \
    \               if(sentence[j] == ' ') {\n                    temp.push_back(sentence[j]);\n\
    \                    flag = 1;\n                }\n            }\n           \
    \ if(flag == 1) {\n                ans.push_back(temp);\n            }\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptfuhyg7z.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmptfuhyg7z.cpp:33:31: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   33 | \
    \                ans.push_back(temp);\n      |                               ^~~~\n\
    \      |                               |\n      |                            \
    \   std::string {aka std::__cxx11::basic_string<char>}\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmptfuhyg7z.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1353:24: note:\
    \   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1353 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    std::string temp;\n    int n = sentence.length();\n    for (int i\
    \ = 0; i < n; i++) {\n        word = sentence[i];\n        temp = result;\n  \
    \      while (true) {\n            int flag = 0;\n            for (int j = 0;\
    \ j < temp.length(); j++) {\n                if (temp[j] == word[j]) {\n     \
    \               flag = 1;\n                    break;\n                }\n   \
    \         }\n            if (flag == 0)\n                break;\n            temp\
    \ = temp + \" \" + word;\n        }\n        result = temp;\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpse24p3_c: /tmp/tmpse24p3_c.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string word = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      word = word + sentence[i];\n        } else {\n            if (temp.length()\
    \ != 0) {\n                ans = ans + \" \" + temp;\n                temp = \"\
    \";\n            }\n            ans = ans + \" \" + word;\n            word =\
    \ \"\";\n        }\n    }\n    if (temp.length() != 0) {\n        ans = ans +\
    \ \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9i6jawkr: /tmp/tmp9i6jawkr.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             temp = \"\";\n                flag = false;\n            }\n   \
    \     }\n    }\n    if (flag) {\n        ans += temp;\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n\
    \            ans[i] = ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= 'A' && ans[i] <= 'Z') {\n\
    \            ans[i] = ans[i] - 'A' + 'a';\n        }\n    }\n    for (int i =\
    \ 0; i < ans.length(); i++) {\n        if (ans[i] >= '0' && ans[i] <= '9') {\n\
    \            ans[i] = ans[i] - '0' + '0\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps0qr_vr0.cpp:92:37: warning: missing terminating ' character\n\
    \   92 |             ans[i] = ans[i] - '0' + '0\n      |                     \
    \                ^\n/tmp/tmps0qr_vr0.cpp:92:37: error: missing terminating ' character\n\
    \   92 |             ans[i] = ans[i] - '0' + '0\n      |                     \
    \                ^~\n/tmp/tmps0qr_vr0.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmps0qr_vr0.cpp:93:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   93 | }\n      | ^\n/tmp/tmps0qr_vr0.cpp:94:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   94 | int main() {\n     \
    \ |            ^\n/tmp/tmps0qr_vr0.cpp:103:1: error: expected \u2018}\u2019 at\
    \ end of input\n  103 | }\n      | ^\n/tmp/tmps0qr_vr0.cpp:90:44: note: to match\
    \ this \u2018{\u2019\n   90 |     for (int i = 0; i < ans.length(); i++) {\n \
    \     |                                            ^\n/tmp/tmps0qr_vr0.cpp:103:1:\
    \ error: expected \u2018}\u2019 at end of input\n  103 | }\n      | ^\n/tmp/tmps0qr_vr0.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmps0qr_vr0.cpp:103:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  103 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            }\n        }\n    }\n    ans += word;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbxf5zt0g: /tmp/tmpbxf5zt0g.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    int len = sentence.length();\n    for (int i = 0; i <\
    \ len; i++) {\n        if (sentence[i] != ' ') {\n            flag = false;\n\
    \        }\n    }\n    if (flag) {\n        ans = sentence;\n    } else {\n  \
    \      ans = \"\";\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(0, ans.find(\" \"\
    ));\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0; i\
    \ < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n       \
    \     ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans + sentence[i];\n\
    \    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\" \") != std::string::npos)\
    \ {\n            ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans\
    \ = ans + sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if\
    \ (ans.find(\" \") != std::string::npos) {\n            ans = ans.substr(ans.find(\"\
    \ \") + 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int\
    \ i = 0; i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n\
    \            ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans =\
    \ ans + sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(ans.find(\" \") +\
    \ 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0;\
    \ i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n     \
    \       ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans +\
    \ sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(ans.find(\" \") +\
    \ 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0;\
    \ i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n     \
    \       ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans +\
    \ sentence[i];\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(ans.find(\" \") +\
    \ 1);\n        }\n        ans = ans + sentence[i];\n    }\n    for (int i = 0;\
    \ i < len; i++) {\n        if (ans.find(\" \") != std::string::npos) {\n     \
    \       ans = ans.substr(ans.find(\" \") + 1);\n        }\n        ans = ans +\
    \ \n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb6tc0f8h.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpb6tc0f8h.cpp:96:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   96 | }\n      | ^\n/tmp/tmpb6tc0f8h.cpp:97:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   97 | int main() {\n     \
    \ |            ^\n/tmp/tmpb6tc0f8h.cpp:106:1: error: expected \u2018}\u2019 at\
    \ end of input\n  106 | }\n      | ^\n/tmp/tmpb6tc0f8h.cpp:17:53: note: to match\
    \ this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string sentence)\
    \ {\n      |                                                     ^\n/tmp/tmpb6tc0f8h.cpp:106:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  106 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            flag = true;\n            temp\
    \ += c;\n        }\n        if (flag) {\n            ans += \" \" + temp;\n  \
    \          flag = false;\n            temp = \"\";\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpfa0q6gah: /tmp/tmpfa0q6gah.cpp:36: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n   \
    \     if(sentence[i]==' '){\n            flag = true;\n        }\n        if(flag){\n\
    \            temp.push_back(sentence[i]);\n        }\n    }\n    for(int i=0;i<temp.size();i++){\n\
    \        for(int j=i+1;j<temp.size();j++){\n            if(temp[i]==temp[j]){\n\
    \                ans.push_back(temp[i]);\n                temp.erase(temp.begin()+j);\n\
    \                flag = false;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpyyengqlh: /tmp/tmpyyengqlh.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        flag = false;\n        word = sentence[i];\n        for (int\
    \ j = 0; j < ans.length(); j++) {\n            if (ans[j] == word) {\n       \
    \         flag = true;\n                break;\n            }\n        }\n   \
    \     if (!flag) {\n            ans += \" \" + word;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm2yjl7iw.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpm2yjl7iw.cpp:25:24: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   25 |             if (ans[j] == word) {\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   25\
    \ |             if (ans[j] == word) {\n      |                           ^~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   25\
    \ |             if (ans[j] == word) {\n      |                           ^~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator==(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  325 |     operator==(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched\
    \ types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   25 |             if (ans[j] == word) {\n      |              \
    \             ^~~~\nIn file included from /usr/include/c++/9/string:55,\n    \
    \             from /usr/include/c++/9/bits/locale_classes.h:40,\n            \
    \     from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&)\u2019\n 6144 | \
    \    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n      | \
    \    ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note: \
    \  mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018char\u2019\n   25 |             if (ans[j] == word) {\n      |   \
    \                        ^~~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&,\
    \ const _CharT*)\u2019\n 6178 |     operator==(const basic_string<_CharT, _Traits,\
    \ _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const std::error_code&\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:297:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_condition&)\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:297:32: note:\
    \   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const std::error_condition&\u2019\
    \n  304 |   operator==(const error_condition& __lhs, const error_code& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:311:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_condition&)\u2019\n  311 |   operator==(const error_condition& __lhs,\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37: note:   no known\
    \ conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const std::error_condition&\u2019\
    \n  311 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   25 |           \
    \  if (ans[j] == word) {\n      |                           ^~~~\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::deque<_Tp, _Alloc>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   25 |             if (ans[j] == word) {\n      |              \
    \             ^~~~\nIn file included from /usr/include/c++/9/tuple:39,\n     \
    \            from /usr/include/c++/9/functional:54,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::array<_Tp,\
    \ _Nm>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched\
    \ types \u2018const std::tuple<_Tps ...>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  25 |             if (ans[j] == word) {\n      |                           ^~~~\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note: \
    \  mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   25 |             if (ans[j] == word) {\n      |              \
    \             ^~~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   25 |   \
    \          if (ans[j] == word) {\n      |                           ^~~~\nIn file\
    \ included from /usr/include/c++/9/iterator:66,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019 and\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/map:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019 and\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   25 |             if (ans[j] == word) {\n      |              \
    \             ^~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   25 | \
    \            if (ans[j] == word) {\n      |                           ^~~~\nIn\
    \ file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   25 |        \
    \     if (ans[j] == word) {\n      |                           ^~~~\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note: \
    \  mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/queue:64,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::queue<_Tp,\
    \ _Seq>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/set:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::set<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/set:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::stack<_Tp,\
    \ _Seq>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   25 |             if (ans[j] == word) {\n      |                         \
    \  ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n           \
    \      from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   25 |             if (ans[j] == word) {\n\
    \      |                           ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::valarray<_Tp>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   25 |          \
    \   if (ans[j] == word) {\n      |                           ^~~~\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note:   mismatched types \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to \u2018std::thread::id\u2019\n  276 |   operator==(thread::id\
    \ __x, thread::id __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file\
    \ included from /usr/include/c++/9/random:51,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note: \
    \  mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note: \
    \  mismatched types \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::unordered_multimap<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const std::unordered_multiset<_Value, _Hash,\
    \ _Pred, _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |             if (ans[j] == word) {\n      | \
    \                          ^~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   25 |             if (ans[j]\
    \ == word) {\n      |                           ^~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpm2yjl7iw.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpm2yjl7iw.cpp:25:27:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::new_allocator<_Tp>\u2019\n   25 |\
    \             if (ans[j] == word) {\n      |                           ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        if (is_prime(i))\
    \ {\n            ans += sentence.substr(i, 1);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdvlty3u4.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdvlty3u4.cpp:21:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   21 |         if (is_prime(i)) {\n      |             ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk4m1tue1: /tmp/tmpk4m1tue1.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans += \" \";\n  \
    \              flag = false;\n            }\n            temp = sentence[i];\n\
    \            while (temp != ' ') {\n                ans += temp;\n           \
    \     temp = sentence[++i];\n            }\n            flag = true;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdy0g5nb8.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdy0g5nb8.cpp:30:25: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   30 |             while (temp != ' ') {\n      |  \
    \                  ~~~~ ^~ ~~~\n      |                    |       |\n      |\
    \                    |       char\n      |                    std::string {aka\
    \ std::__cxx11::basic_string<char>}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1037:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   30\
    \ |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1112:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1112 |     operator!=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1112:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   30 |             while (temp != ' ') {\n      |   \
    \                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1186:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1186 |     operator!=(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1186:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   30\
    \ |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1260:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1260 |     operator!=(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1260:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   30 |             while (temp != ' ') {\n      |   \
    \                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1334:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1334 |     operator!=(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1334:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1408:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1408 |     operator!=(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1408:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   30 |             while (temp != ' ') {\n      |   \
    \                         ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:1486:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1486 |     operator!=(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1486:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/regex:62,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/regex.h:2015:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 2015 |     operator!=(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:2015:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n               \
    \  from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/postypes.h:227:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator!=(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  227 |     operator!=(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:227:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::fpos<_StateT>\u2019\n   30 |          \
    \   while (temp != ' ') {\n      |                            ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:64,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:461:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> constexpr bool std::operator!=(const std::pair<_T1,\
    \ _T2>&, const std::pair<_T1, _T2>&)\u2019\n  461 |     operator!=(const pair<_T1,\
    \ _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:461:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::pair<_T1, _T2>\u2019\n   30 |         \
    \    while (temp != ' ') {\n      |                            ^~~\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:337:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator!=(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_Iterator>&)\u2019\n  337 |     operator!=(const\
    \ reverse_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:337:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   30\
    \ |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:375:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator!=(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  375 |     operator!=(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:375:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   30 |             while (temp\
    \ != ' ') {\n      |                            ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1148:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator!=(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1148 |     operator!=(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1148:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n  \
    \               from /usr/include/c++/9/bits/char_traits.h:39,\n             \
    \    from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1154:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator!=(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1154 |     operator!=(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1154:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   30\
    \ |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/allocator.h:173:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator!=(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  173 |     operator!=(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:173:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::allocator<_CharT>\u2019\n   30 |      \
    \       while (temp != ' ') {\n      |                            ^~~\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6191:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6191 |     operator!=(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6191:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018char\u2019\n   30 |             while (temp != ' ')\
    \ {\n      |                            ^~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6204:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator!=(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6204 |     operator!=(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6204:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   30 |             while\
    \ (temp != ' ') {\n      |                            ^~~\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6216:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator!=(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6216 |     operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6216:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 30 |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/bits/ios_base.h:46,\n               \
    \  from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/system_error:319:3: note: candidate:\
    \ \u2018bool std::operator!=(const std::error_code&, const std::error_code&)\u2019\
    \n  319 |   operator!=(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:319:32: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  319 |   operator!=(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:323:3: note: candidate: \u2018bool std::operator!=(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  323 |   operator!=(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:323:32: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  323 |   operator!=(const error_code&\
    \ __lhs, const error_condition& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:327:3: note: candidate: \u2018bool std::operator!=(const\
    \ std::error_condition&, const std::error_code&)\u2019\n  327 |   operator!=(const\
    \ error_condition& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:327:37: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_condition&\u2019\n  327 |   operator!=(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:331:3: note: candidate: \u2018bool std::operator!=(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  331 |   operator!=(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:331:37:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::error_condition&\u2019\
    \n  331 |   operator!=(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:214:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator!=(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  214 |     operator!=(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:214:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n            \
    \     from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/complex:481:5: note: candidate:\
    \ \u2018template<class _Tp> constexpr bool std::operator!=(const std::complex<_Tp>&,\
    \ const std::complex<_Tp>&)\u2019\n  481 |     operator!=(const complex<_Tp>&\
    \ __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:481:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   30 |           \
    \  while (temp != ' ') {\n      |                            ^~~\nIn file included\
    \ from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/complex:486:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator!=(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  486 |     operator!=(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:486:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   30 |           \
    \  while (temp != ' ') {\n      |                            ^~~\nIn file included\
    \ from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/complex:491:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator!=(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  491 |     operator!=(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:491:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/deque:67,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n               \
    \  from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:299:5: note:\
    \ candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator!=(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  299 |     operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:299:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:306:5: note: candidate:\
    \ \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR, class _PtrR>\
    \ bool std::operator!=(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp,\
    \ _RefR, _PtrR>&)\u2019\n  306 |     operator!=(const _Deque_iterator<_Tp, _RefL,\
    \ _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:306:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/deque:67,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2338:5: note: candidate:\
    \ \u2018template<class _Tp, class _Alloc> bool std::operator!=(const std::deque<_Tp,\
    \ _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2338 |     operator!=(const\
    \ deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2338:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::deque<_Tp, _Alloc>\u2019\n   30 |     \
    \        while (temp != ' ') {\n      |                            ^~~\nIn file\
    \ included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/array:257:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator!=(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  257 |     operator!=(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:257:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::array<_Tp,\
    \ _Nm>\u2019\n   30 |             while (temp != ' ') {\n      |             \
    \               ^~~\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/tuple:1445:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator!=(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1445 |     operator!=(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1445:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::tuple<_Tps ...>\u2019\n   30 |             while (temp != ' ') {\n\
    \      |                            ^~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/std_function.h:764:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator!=(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  764 |     operator!=(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:764:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  30 |             while (temp != ' ') {\n      |                           \
    \ ^~~\nIn file included from /usr/include/c++/9/functional:59,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n            \
    \     from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/std_function.h:770:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator!=(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  770 |     operator!=(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:770:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018char\u2019\n   30 |             while (temp != ' ') {\n      |   \
    \                         ^~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:732:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator!=(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  732 |     operator!=(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:732:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   30 |   \
    \          while (temp != ' ') {\n      |                            ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/locale_conv.h:41,\n                 from\
    \ /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:738:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator!=(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  738 |     operator!=(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:738:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   30 |   \
    \          while (temp != ' ') {\n      |                            ^~~\nIn file\
    \ included from /usr/include/c++/9/bits/locale_conv.h:41,\n                 from\
    \ /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:743:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator!=(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  743 |     operator!=(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:743:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    char\u2019\n   30 |             while (temp != ' ') {\n      |               \
    \             ^~~\nIn file included from /usr/include/c++/9/iterator:66,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n  \
    \               from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:141:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator!=(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  141 |     operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:141:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019\n   30 |             while (temp != ' ') {\n      |           \
    \                 ^~~\nIn file included from /usr/include/c++/9/list:63,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n  \
    \               from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:2032:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator!=(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 2032 |     operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:2032:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019\n   30\
    \ |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/map:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1479:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator!=(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1479 |     operator!=(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1479:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/map:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1143:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc>\
    \ bool std::operator!=(const std::multimap<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1143 |     operator!=(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1143:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n    \
    \             from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1428:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator!=(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1428 |     operator!=(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1428:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019\n   30 |\
    \             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1434:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator!=(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1434 |     operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1434:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   30 | \
    \            while (temp != ' ') {\n      |                            ^~~\nIn\
    \ file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n              \
    \   from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1439:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator!=(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1439 |     operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1439:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n   30 |             while (temp != ' ') {\n      |               \
    \             ^~~\nIn file included from /usr/include/c++/9/memory:81,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n    \
    \             from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:398:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator!=(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  398 |     operator!=(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:398:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/memory:81,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:403:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator!=(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  403 |     operator!=(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:403:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   30 |        \
    \     while (temp != ' ') {\n      |                            ^~~\nIn file included\
    \ from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:408:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator!=(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  408 |     operator!=(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:408:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/vector:67,\n               \
    \  from /usr/include/c++/9/queue:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1912:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator!=(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1912 | \
    \    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1912:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::vector<_Tp, _Alloc>\u2019\n   30 |    \
    \         while (temp != ' ') {\n      |                            ^~~\nIn file\
    \ included from /usr/include/c++/9/queue:64,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:362:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator!=(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  362 |     operator!=(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:362:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::queue<_Tp,\
    \ _Seq>\u2019\n   30 |             while (temp != ' ') {\n      |            \
    \                ^~~\nIn file included from /usr/include/c++/9/set:61,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n    \
    \             from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:1003:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator!=(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n 1003 |     operator!=(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:1003:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::set<_Key, _Compare, _Alloc>\u2019\n   30\
    \ |             while (temp != ' ') {\n      |                            ^~~\n\
    In file included from /usr/include/c++/9/set:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:988:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator!=(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  988 |     operator!=(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:988:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/stack:61,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:337:5: note: candidate:\
    \ \u2018template<class _Tp, class _Seq> bool std::operator!=(const std::stack<_Tp,\
    \ _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  337 |     operator!=(const stack<_Tp,\
    \ _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_stack.h:337:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::stack<_Tp, _Seq>\u2019\n   30 |       \
    \      while (temp != ' ') {\n      |                            ^~~\nIn file\
    \ included from /usr/include/c++/9/valarray:603,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   30 |             while (temp != ' ') {\n\
    \      |                            ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  418\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   30 |             while (temp != ' ') {\n\
    \      |                            ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n   30 |             while (temp != ' ') {\n      |   \
    \                         ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   30 |             while (temp != ' ') {\n\
    \      |                            ^~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:418:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__not_equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator!=(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  418 |     _DEFINE_EXPR_BINARY_OPERATOR(!=, __not_equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:418:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018char\u2019\n   30 |            \
    \ while (temp != ' ') {\n      |                            ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/valarray:1198:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to,\
    \ _Tp>::result_type> std::operator!=(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1198 | _DEFINE_BINARY_OPERATOR(!=, __not_equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1198:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/valarray:1198:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__not_equal_to,\
    \ _Tp>::result_type> std::operator!=(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1198 | _DEFINE_BINARY_OPERATOR(!=,\
    \ __not_equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1198:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   30 |          \
    \   while (temp != ' ') {\n      |                            ^~~\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/valarray:1198:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__not_equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__not_equal_to,\
    \ _Tp>::result_type> std::operator!=(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1198 | _DEFINE_BINARY_OPERATOR(!=, __not_equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1198:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/forward_list:38,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n       \
    \          from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/forward_list.h:1451:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator!=(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n 1451 |     operator!=(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.h:1451:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019\n   30 |             while (temp != ' ') {\n      |          \
    \                  ^~~\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/thread:286:3:\
    \ note: candidate: \u2018bool std::operator!=(std::thread::id, std::thread::id)\u2019\
    \n  286 |   operator!=(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:286:25: note:   no known conversion for argument 1 from\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} to\
    \ \u2018std::thread::id\u2019\n  286 |   operator!=(thread::id __x, thread::id\
    \ __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:421:5:\
    \ note: candidate: \u2018template<class _UIntType, _UIntType __a, _UIntType __c,\
    \ _UIntType __m> bool std::operator!=(const std::linear_congruential_engine<_UIntType,\
    \ __a, __c, __m>&, const std::linear_congruential_engine<_UIntType, __a, __c,\
    \ __m>&)\u2019\n  421 |     operator!=(const std::linear_congruential_engine<_UIntType,\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:421:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::linear_congruential_engine<_UIntType, __a,\
    \ __c, __m>\u2019\n   30 |             while (temp != ' ') {\n      |        \
    \                    ^~~\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:658:5:\
    \ note: candidate: \u2018template<class _UIntType, long unsigned int __w, long\
    \ unsigned int __n, long unsigned int __m, long unsigned int __r, _UIntType __a,\
    \ long unsigned int __u, _UIntType __d, long unsigned int __s, _UIntType __b,\
    \ long unsigned int __t, _UIntType __c, long unsigned int __l, _UIntType __f>\
    \ bool std::operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n,\
    \ __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>&, const std::mersenne_twister_engine<_UIntType,\
    \ __w, __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>&)\u2019\n \
    \ 658 |     operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n,\
    \ __m,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:658:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::mersenne_twister_engine<_UIntType, __w,\
    \ __n, __m, __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>\u2019\n   30 | \
    \            while (temp != ' ') {\n      |                            ^~~\nIn\
    \ file included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:859:5:\
    \ note: candidate: \u2018template<class _UIntType, long unsigned int __w, long\
    \ unsigned int __s, long unsigned int __r> bool std::operator!=(const std::subtract_with_carry_engine<_UIntType,\
    \ __w, __s, __r>&, const std::subtract_with_carry_engine<_UIntType, __w, __s,\
    \ __r>&)\u2019\n  859 |     operator!=(const std::subtract_with_carry_engine<_UIntType,\
    \ __w,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:859:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::subtract_with_carry_engine<_UIntType, __w,\
    \ __s, __r>\u2019\n   30 |             while (temp != ' ') {\n      |        \
    \                    ^~~\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:1082:5:\
    \ note: candidate: \u2018template<class _RandomNumberEngine, long unsigned int\
    \ __p, long unsigned int __r> bool std::operator!=(const std::discard_block_engine<_RandomNumberEngine,\
    \ __p, __r>&, const std::discard_block_engine<_RandomNumberEngine, __p, __r>&)\u2019\
    \n 1082 |     operator!=(const std::discard_block_engine<_RandomNumberEngine,\
    \ __p,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1082:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::discard_block_engine<_RandomNumberEngine,\
    \ __p, __r>\u2019\n   30 |             while (temp != ' ') {\n      |        \
    \                    ^~~\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:1279:5:\
    \ note: candidate: \u2018template<class _RandomNumberEngine, long unsigned int\
    \ __w, class _UIntType> bool std::operator!=(const std::independent_bits_engine<_RandomNumberEngine,\
    \ __w, _UIntType>&, const std::independent_bits_engine<_RandomNumberEngine, __w,\
    \ _UIntType>&)\u2019\n 1279 |     operator!=(const std::independent_bits_engine<_RandomNumberEngine,\
    \ __w,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1279:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::independent_bits_engine<_RandomNumberEngine,\
    \ __w, _UIntType>\u2019\n   30 |             while (temp != ' ') {\n      |  \
    \                          ^~~\nIn file included from /usr/include/c++/9/random:49,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:1532:5:\
    \ note: candidate: \u2018template<class _RandomNumberEngine, long unsigned int\
    \ __k> bool std::operator!=(const std::shuffle_order_engine<_RandomNumberEngine,\
    \ __k>&, const std::shuffle_order_engine<_RandomNumberEngine, __k>&)\u2019\n 1532\
    \ |     operator!=(const std::shuffle_order_engine<_RandomNumberEngine,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1532:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::shuffle_order_engine<_RandomNumberEngine, __k>\u2019\n   30 |     \
    \        while (temp != ' ') {\n      |                            ^~~\nIn file\
    \ included from /usr/include/c++/9/random:49,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:1692:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::uniform_int_distribution<_IntType>&,\
    \ const std::uniform_int_distribution<_IntType>&)\u2019\n 1692 |     operator!=(const\
    \ std::uniform_int_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1692:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::uniform_int_distribution<_IntType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:1913:5: note:\
    \ candidate: \u2018template<class _IntType> bool std::operator!=(const std::uniform_real_distribution<_IntType>&,\
    \ const std::uniform_real_distribution<_IntType>&)\u2019\n 1913 |     operator!=(const\
    \ std::uniform_real_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:1913:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::uniform_real_distribution<_IntType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:2170:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::normal_distribution<_RealType>&,\
    \ const std::normal_distribution<_RealType>&)\u2019\n 2170 |     operator!=(const\
    \ std::normal_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2170:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::normal_distribution<_RealType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:2381:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::lognormal_distribution<_RealType>&,\
    \ const std::lognormal_distribution<_RealType>&)\u2019\n 2381 |     operator!=(const\
    \ std::lognormal_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2381:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::lognormal_distribution<_RealType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:2612:6: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::gamma_distribution<_RealType>&,\
    \ const std::gamma_distribution<_RealType>&)\u2019\n 2612 |      operator!=(const\
    \ std::gamma_distribution<_RealType>& __d1,\n      |      ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2612:6:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::gamma_distribution<_RealType>\u2019\n \
    \  30 |             while (temp != ' ') {\n      |                           \
    \ ^~~\nIn file included from /usr/include/c++/9/random:49,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:2836:5: note: candidate:\
    \ \u2018template<class _RealType> bool std::operator!=(const std::chi_squared_distribution<_RealType>&,\
    \ const std::chi_squared_distribution<_RealType>&)\u2019\n 2836 |     operator!=(const\
    \ std::chi_squared_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:2836:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::chi_squared_distribution<_RealType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:3010:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::cauchy_distribution<_RealType>&,\
    \ const std::cauchy_distribution<_RealType>&)\u2019\n 3010 |     operator!=(const\
    \ std::cauchy_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3010:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::cauchy_distribution<_RealType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:3274:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::fisher_f_distribution<_RealType>&,\
    \ const std::fisher_f_distribution<_RealType>&)\u2019\n 3274 |     operator!=(const\
    \ std::fisher_f_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3274:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::fisher_f_distribution<_RealType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:3496:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::student_t_distribution<_RealType>&,\
    \ const std::student_t_distribution<_RealType>&)\u2019\n 3496 |     operator!=(const\
    \ std::student_t_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3496:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::student_t_distribution<_RealType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:3684:3: note:\
    \ candidate: \u2018bool std::operator!=(const std::bernoulli_distribution&, const\
    \ std::bernoulli_distribution&)\u2019\n 3684 |   operator!=(const std::bernoulli_distribution&\
    \ __d1,\n      |   ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3684:49: note: \
    \  no known conversion for argument 1 from \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} to \u2018const std::bernoulli_distribution&\u2019\
    \n 3684 |   operator!=(const std::bernoulli_distribution& __d1,\n      |     \
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n/usr/include/c++/9/bits/random.h:3959:5:\
    \ note: candidate: \u2018template<class _IntType> bool std::operator!=(const std::binomial_distribution<_IntType>&,\
    \ const std::binomial_distribution<_IntType>&)\u2019\n 3959 |     operator!=(const\
    \ std::binomial_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:3959:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::binomial_distribution<_IntType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:4138:5: note:\
    \ candidate: \u2018template<class _IntType> bool std::operator!=(const std::geometric_distribution<_IntType>&,\
    \ const std::geometric_distribution<_IntType>&)\u2019\n 4138 |     operator!=(const\
    \ std::geometric_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:4138:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::geometric_distribution<_IntType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:4392:5: note:\
    \ candidate: \u2018template<class _IntType> bool std::operator!=(const std::negative_binomial_distribution<_IntType>&,\
    \ const std::negative_binomial_distribution<_IntType>&)\u2019\n 4392 |     operator!=(const\
    \ std::negative_binomial_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/random.h:4392:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::negative_binomial_distribution<_IntType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:4618:5: note:\
    \ candidate: \u2018template<class _IntType> bool std::operator!=(const std::poisson_distribution<_IntType>&,\
    \ const std::poisson_distribution<_IntType>&)\u2019\n 4618 |     operator!=(const\
    \ std::poisson_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:4618:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::poisson_distribution<_IntType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:4809:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::exponential_distribution<_RealType>&,\
    \ const std::exponential_distribution<_RealType>&)\u2019\n 4809 |     operator!=(const\
    \ std::exponential_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:4809:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::exponential_distribution<_RealType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:5019:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::weibull_distribution<_RealType>&,\
    \ const std::weibull_distribution<_RealType>&)\u2019\n 5019 |     operator!=(const\
    \ std::weibull_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:5019:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::weibull_distribution<_RealType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:5229:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::extreme_value_distribution<_RealType>&,\
    \ const std::extreme_value_distribution<_RealType>&)\u2019\n 5229 |     operator!=(const\
    \ std::extreme_value_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:5229:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::extreme_value_distribution<_RealType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:5494:5: note:\
    \ candidate: \u2018template<class _IntType> bool std::operator!=(const std::discrete_distribution<_IntType>&,\
    \ const std::discrete_distribution<_IntType>&)\u2019\n 5494 |     operator!=(const\
    \ std::discrete_distribution<_IntType>& __d1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/random.h:5494:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::discrete_distribution<_IntType>\u2019\n\
    \   30 |             while (temp != ' ') {\n      |                          \
    \  ^~~\nIn file included from /usr/include/c++/9/random:49,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n              \
    \   from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:5765:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::piecewise_constant_distribution<_RealType>&,\
    \ const std::piecewise_constant_distribution<_RealType>&)\u2019\n 5765 |     operator!=(const\
    \ std::piecewise_constant_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/random.h:5765:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::piecewise_constant_distribution<_RealType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/random:49,\n               \
    \  from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n             \
    \    from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/random.h:6038:5: note:\
    \ candidate: \u2018template<class _RealType> bool std::operator!=(const std::piecewise_linear_distribution<_RealType>&,\
    \ const std::piecewise_linear_distribution<_RealType>&)\u2019\n 6038 |     operator!=(const\
    \ std::piecewise_linear_distribution<_RealType>& __d1,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/random.h:6038:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::piecewise_linear_distribution<_RealType>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/scoped_allocator:498:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator!=(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  498\
    \ |     operator!=(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:498:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n      \
    \           from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2099:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator!=(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2099 |     operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2099:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   30 |             while (temp != ' ') {\n      |          \
    \                  ^~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2111:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator!=(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2111 |     operator!=(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2111:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   30 |             while (temp != ' ') {\n      |          \
    \                  ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1711:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator!=(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1711\
    \ |     operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1711:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n      \
    \           from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1723:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator!=(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1723 |     operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1723:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019\n   30 |             while (temp != ' ') {\n      |          \
    \                  ^~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/allocator.h:159:7:\
    \ note: candidate: \u2018bool std::operator!=(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  159 |       operator!=(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:159:18:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  159 |       operator!=(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n  \
    \               from /usr/include/c++/9/bits/char_traits.h:39,\n             \
    \    from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:904:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator!=(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  904 |     operator!=(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:904:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \n   30 |             while (temp != ' ') {\n      |                         \
    \   ^~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpdy0g5nb8.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:172:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator!=(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  172 |  operator!=(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:172:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpdy0g5nb8.cpp:30:28:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018char\u2019\n   30 |             while (temp != ' ') {\n      |       \
    \                     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      temp = sentence[i];\n        for(int j = i + 1; j < n; j++) {\n       \
    \     if(temp == sentence[j]) {\n                temp = temp + \" \";\n      \
    \          ans = ans + temp;\n                i = j;\n            }\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnetw8h7c.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpnetw8h7c.cpp:24:21: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |             if(temp == sentence[j]) {\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/regex:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n      \
    \           from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/regex:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n      \
    \           from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/iosfwd:40,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::fpos<_StateT>\u2019\n   24 |          \
    \   if(temp == sentence[j]) {\n      |                                  ^\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const\
    \ std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const\
    \ pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::pair<_T1, _T2>\u2019\n   24 |         \
    \    if(temp == sentence[j]) {\n      |                                  ^\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\u2019\
    \n  325 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |    \
    \ ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/string:41,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::allocator<_CharT>\u2019\n   24 |      \
    \       if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 24 |             if(temp == sentence[j]) {\n      |                        \
    \          ^\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n \
    \                from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  297 |   operator==(const error_code&\
    \ __lhs, const error_condition& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:304:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_code&)\u2019\n  304 |   operator==(const\
    \ error_condition& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:304:37: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::error_condition&\u2019\
    \n  311 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n    \
    \             from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   24 |           \
    \  if(temp == sentence[j]) {\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   24 |           \
    \  if(temp == sentence[j]) {\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::deque<_Tp, _Alloc>\u2019\n   24 |     \
    \        if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::array<_Tp,\
    \ _Nm>\u2019\n   24 |             if(temp == sentence[j]) {\n      |         \
    \                         ^\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::tuple<_Tps ...>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  24 |             if(temp == sentence[j]) {\n      |                       \
    \           ^\nIn file included from /usr/include/c++/9/functional:59,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n    \
    \             from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   24 |   \
    \          if(temp == sentence[j]) {\n      |                                \
    \  ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n      \
    \           from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   24 |   \
    \          if(temp == sentence[j]) {\n      |                                \
    \  ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n      \
    \           from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   24 |             if(temp == sentence[j]) {\n      |          \
    \                        ^\nIn file included from /usr/include/c++/9/iterator:66,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019\n   24 |             if(temp == sentence[j]) {\n      |       \
    \                           ^\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/map:61,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n               \
    \  from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc>\
    \ bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key,\
    \ _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const map<_Key, _Tp,\
    \ _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/map:62,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n          \
    \       from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019\n   24 |\
    \             if(temp == sentence[j]) {\n      |                             \
    \     ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n    \
    \             from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   24 | \
    \            if(temp == sentence[j]) {\n      |                              \
    \    ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n     \
    \            from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   24 |             if(temp == sentence[j]) {\n      |          \
    \                        ^\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/memory:81,\n       \
    \          from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n      \
    \           from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   24 |        \
    \     if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::vector<_Tp, _Alloc>\u2019\n   24 |    \
    \         if(temp == sentence[j]) {\n      |                                 \
    \ ^\nIn file included from /usr/include/c++/9/queue:64,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5: note: candidate:\
    \ \u2018template<class _Tp, class _Seq> bool std::operator==(const std::queue<_Tp,\
    \ _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const queue<_Tp,\
    \ _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   24 |       \
    \      if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::set<_Key, _Compare, _Alloc>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/set:62,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n               \
    \  from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/stack:61,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n        \
    \         from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::stack<_Tp,\
    \ _Seq>\u2019\n   24 |             if(temp == sentence[j]) {\n      |        \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   24 |          \
    \   if(temp == sentence[j]) {\n      |                                  ^\nIn\
    \ file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n \
    \                from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} to\
    \ \u2018std::thread::id\u2019\n  276 |   operator==(thread::id __x, thread::id\
    \ __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::normal_distribution<_RealType>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnetw8h7c.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpnetw8h7c.cpp:24:34:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpx0gxp9pf: /tmp/tmpx0gxp9pf.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        bool found = false;\n        for (int j =\
    \ 0; j < n; j++) {\n            if (j == i) continue;\n            if (j % i ==\
    \ 0) {\n                found = true;\n                break;\n            }\n\
    \        }\n        if (!found) {\n            ans += \" \" + word;\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    std::string temp2;\n    std::string temp3;\n    std::string temp4;\n\
    \    std::string temp5;\n    std::string temp6;\n    std::string temp7;\n    std::string\
    \ temp8;\n    std::string temp9;\n    std::string temp10;\n    std::string temp11;\n\
    \    std::string temp12;\n    std::string temp13;\n    std::string temp14;\n \
    \   std::string temp15;\n    std::string temp16;\n    std::string temp17;\n  \
    \  std::string temp18;\n    std::string temp19;\n    std::string temp20;\n   \
    \ std::string temp21;\n    std::string temp22;\n    std::string temp23;\n    std::string\
    \ temp24;\n    std::string temp25;\n    std::string temp26;\n    std::string temp27;\n\
    \    std::string temp28;\n    std::string temp29;\n    std::string temp30;\n \
    \   std::string temp31;\n    std::string temp32;\n    std::string temp33;\n  \
    \  std::string temp34;\n    std::string temp35;\n    std::string temp36;\n   \
    \ std::string temp37;\n    std::string temp38;\n    std::string temp39;\n    std::string\
    \ temp40;\n    std::string temp41;\n    std::string temp42;\n    std::string temp43;\n\
    \    std::string temp44;\n    std::string temp45;\n    std::string temp46;\n \
    \   std::string temp47;\n    std::string temp48;\n    std::string temp49;\n  \
    \  std::string temp50;\n    std::string temp51;\n    std::string temp52;\n   \
    \ std::string temp53;\n    std::string temp54;\n    std::string temp55;\n    std::string\
    \ temp56;\n    std::string temp57;\n    std::string temp58;\n    std::string temp59;\n\
    \    std::string temp60;\n    std::string temp61;\n    std::string temp62;\n \
    \   std::string temp63;\n    std::string temp64;\n    std::string temp65;\n  \
    \  std::string temp66;\n    std::string temp67;\n    std::string temp68;\n   \
    \ std::string temp69;\n    std::string temp70;\n    std::string temp71;\n    std::string\
    \ temp72;\n    std::string temp73;\n    std::string temp74;\n    std::string temp75;\n\
    \    std::string temp76;\n    std::string temp77;\n    std::string temp78;\n \
    \   std::string temp79;\n    std::string temp80;\n    std::string temp81;\n  \
    \  std::string temp82;\n    std::string temp83;\n    std::string temp84;\n   \
    \ std::string temp85;\n    std::string temp86;\n    std::string temp87;\n    std::string\
    \ temp88;\n\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    for(int i = 0; i < sentence.length(); i++) {\n      \
    \  if(sentence[i] == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if(flag) {\n            ans += sentence[i];\n            flag\
    \ = false;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpqpikclfe: /tmp/tmpqpikclfe.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_4b4yluj: /tmp/tmp_4b4yluj.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n      \
    \      flag = true;\n        }\n        if (flag) {\n            ans += temp;\n\
    \            temp = \"\";\n            flag = false;\n        }\n        else\
    \ {\n            temp += sentence[i];\n        }\n    }\n    ans += temp;\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp375ggu7p: /tmp/tmp375ggu7p.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    for (int i\
    \ = 0; i < temp.length(); i++) {\n        if (temp[i] != ' ') {\n            ans\
    \ = ans + temp[i];\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] % 2 == 0) {\n            ans = ans + \" \";\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            flag = true;\n       \
    \     ans += word;\n            word = \"\";\n        } else {\n            word\
    \ += sentence[i];\n        }\n    }\n    ans += word;\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpysv5gzuq: /tmp/tmpysv5gzuq.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ temp;\n                temp = \"\";\n                flag = false;\n       \
    \     }\n        } else {\n            temp += c;\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        ans += temp;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpp8tctfne: /tmp/tmpp8tctfne.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += \" \" + temp;\n                temp = \"\";\n               \
    \ flag = false;\n            } else {\n                flag = true;\n        \
    \    }\n        } else {\n            temp += sentence[i];\n        }\n    }\n\
    \    if (flag) {\n        ans += \" \" + temp;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp0fbc4ljl: /tmp/tmp0fbc4ljl.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \      temp += sentence[i];\n        } else {\n            if (flag) {\n     \
    \           ans += temp;\n                temp = \"\";\n                flag =\
    \ false;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsyzxpai7: /tmp/tmpsyzxpai7.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n   \
    \     if(sentence[i]==' '){\n            flag = true;\n            temp.clear();\n\
    \        }\n        if(flag){\n            temp.push_back(sentence[i]);\n    \
    \    }\n    }\n    for(int i=0;i<temp.size();i++){\n        for(int j=i+1;j<temp.size();j++){\n\
    \            if(temp[i]==temp[j]){\n                flag = false;\n          \
    \  }\n        }\n        if(flag){\n            ans.push_back(temp[i]);\n    \
    \    }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpry_i0oor: /tmp/tmpry_i0oor.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    bool flag = false;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        ans += \" \";\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaob5lsrx.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpaob5lsrx.cpp:144:21: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n  144 |         if (sentence\n      |            ~        ^\n      |\
    \                     )\n  145 | }\n      | ~                    \n/tmp/tmpaob5lsrx.cpp:144:13:\
    \ error: could not convert \u2018sentence\u2019 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018bool\u2019\n  144 | \
    \        if (sentence\n      |             ^~~~~~~~\n      |             |\n \
    \     |             std::string {aka std::__cxx11::basic_string<char>}\n/tmp/tmpaob5lsrx.cpp:145:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  145 | }\n \
    \     | ^\n/tmp/tmpaob5lsrx.cpp:146:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  146 | int main() {\n      |            ^\n\
    /tmp/tmpaob5lsrx.cpp:155:1: error: expected \u2018}\u2019 at end of input\n  155\
    \ | }\n      | ^\n/tmp/tmpaob5lsrx.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmpaob5lsrx.cpp:155:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  155 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    bool flag = false;\n\
    \    int len = 0;\n    for (int i = 0; i < sentence.length(); i++) {\n       \
    \ if (sentence[i] == ' ') {\n            flag = true;\n            len++;\n  \
    \      } else {\n            if (flag) {\n                ans += \" \" + word;\n\
    \                flag = false;\n                word = \"\";\n            }\n\
    \            word += sentence[i];\n        }\n    }\n    ans += \" \" + word;\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        temp = ans.substr(i, 1);\n\
    \        if (is_prime(temp.length())) {\n            ans = ans.substr(0, i) +\
    \ \" \" + ans.substr(i + 1, ans.length() - i);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgq152sbg.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpgq152sbg.cpp:39:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   39 |         if (is_prime(temp.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    std::string word;\n    for (auto &c : sentence) {\n \
    \       if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    if (flag) {\n        ans += word;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6wl4xwns: /tmp/tmp6wl4xwns.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp = temp +\
    \ sentence[i];\n        } else {\n            ans = ans + \" \" + temp;\n    \
    \        temp = \"\";\n        }\n    }\n    ans = ans + \" \" + temp;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzwe7btnq: /tmp/tmpzwe7btnq.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpz5iw0oxh: /tmp/tmpz5iw0oxh.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    bool flag = false;\n    for (int\
    \ i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            flag =\
    \ true;\n        }\n        if (flag) {\n            temp.push_back(sentence[i]);\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (temp[i] != '\
    \ ') {\n            result.push_back(temp[i]);\n        }\n    }\n    for (int\
    \ i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n            int count =\
    \ 0;\n            for (int j = i; j < n; j++) {\n                if (temp[j] ==\
    \ temp[i]) {\n                    count++;\n                }\n            }\n\
    \            if (count == 2) {\n                result.push_back(temp[i]);\n \
    \           }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 3) {\n\
    \                result.push_back(temp[i]);\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n          \
    \  int count = 0;\n            for (int j = i; j < n; j++) {\n               \
    \ if (temp[j] == temp[i]) {\n                    count++;\n                }\n\
    \            }\n            if (count == 4) {\n                result.push_back(temp[i]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 5) {\n\
    \                result.push_back(temp[i]);\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n          \
    \  int count = 0;\n            for (int j = i; j < n; j++) {\n               \
    \ if (temp[j] == temp[i]) {\n                    count++;\n                }\n\
    \            }\n            if (count == 6) {\n                result.push_back(temp[i]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 7) {\n\
    \                result.push_back(temp[i]);\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        if (temp[i] != ' ') {\n          \
    \  int count = 0;\n            for (int j = i; j < n; j++) {\n               \
    \ if (temp[j] == temp[i]) {\n                    count++;\n                }\n\
    \            }\n            if (count == 8) {\n                result.push_back(temp[i]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if\
    \ (temp[i] != ' ') {\n            int count = 0;\n            for (int j = i;\
    \ j < n; j++) {\n                if (temp[j] == temp[i]) {\n                 \
    \   count++;\n                }\n            }\n            if (count == 9\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxkl1953d.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpxkl1953d.cpp:134:27: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n  134 |             if (count == 9\n      |                ~        \
    \  ^\n      |                           )\n  135 | }\n      | ~              \
    \            \n/tmp/tmpxkl1953d.cpp:135:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  135 | }\n      | ^\n/tmp/tmpxkl1953d.cpp:136:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \  136 | int main() {\n      |            ^\n/tmp/tmpxkl1953d.cpp:145:1: error:\
    \ expected \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmpxkl1953d.cpp:126:33:\
    \ note: to match this \u2018{\u2019\n  126 |     for (int i = 0; i < n; i++) {\n\
    \      |                                 ^\n/tmp/tmpxkl1953d.cpp:145:1: error:\
    \ expected \u2018}\u2019 at end of input\n  145 | }\n      | ^\n/tmp/tmpxkl1953d.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpxkl1953d.cpp:145:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  145 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans = ans + \" \"\
    \ + temp;\n                temp = \"\";\n                flag = false;\n     \
    \       } else {\n                ans = ans + \" \" + temp;\n                temp\
    \ = \"\";\n                flag = true;\n            }\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmppid9v15x: /tmp/tmppid9v15x.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      temp = temp + \" \" + sentence[i];\n        } else {\n            ans =\
    \ ans + \" \" + temp;\n            temp = sentence[i];\n        }\n    }\n   \
    \ ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n        if (ans[i]\
    \ % 2 == 0) {\n            ans = ans + \" \" + temp;\n            temp = sentence[i];\n\
    \        }\n    }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++)\
    \ {\n        if (ans[i] % 3 == 0) {\n            ans = ans + \" \" + temp;\n \
    \           temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n\
    \    for (int i = 0; i < n; i++) {\n        if (ans[i] % 5 == 0) {\n         \
    \   ans = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n  \
    \  }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n     \
    \   if (ans[i] % 7 == 0) {\n            ans = ans + \" \" + temp;\n          \
    \  temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (ans[i] % 11 == 0) {\n            ans\
    \ = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n    }\n \
    \   ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n        if (ans[i]\
    \ % 13 == 0) {\n            ans = ans + \" \" + temp;\n            temp = sentence[i];\n\
    \        }\n    }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++)\
    \ {\n        if (ans[i] % 17 == 0) {\n            ans = ans + \" \" + temp;\n\
    \            temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n\
    \    for (int i = 0; i < n; i++) {\n        if (ans[i] % 19 == 0) {\n        \
    \    ans = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n \
    \   }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n    \
    \    if (ans[i] % 23 == 0) {\n            ans = ans + \" \" + temp;\n        \
    \    temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n  \
    \  for (int i = 0; i < n; i++) {\n        if (ans[i] % 29 == 0) {\n          \
    \  ans = ans + \" \" + temp;\n            temp = sentence[i];\n        }\n   \
    \ }\n    ans = ans + \" \" + temp;\n    for (int i = 0; i < n; i++) {\n      \
    \  if (ans[i] % 31 == 0) {\n            ans = ans + \" \" + temp;\n          \
    \  temp = sentence[i];\n        }\n    }\n    ans = ans + \" \" + temp;\n    for\
    \ (int i = 0; i < n; i++) {\n        if (ans[i] % 37 == 0) {\n\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu4zqbvhr.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpu4zqbvhr.cpp:112:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  112 | int main() {\n      |            ^\n/tmp/tmpu4zqbvhr.cpp:121:1:\
    \ error: expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmpu4zqbvhr.cpp:108:33:\
    \ note: to match this \u2018{\u2019\n  108 |     for (int i = 0; i < n; i++) {\n\
    \      |                                 ^\n/tmp/tmpu4zqbvhr.cpp:121:1: error:\
    \ expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmpu4zqbvhr.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpu4zqbvhr.cpp:121:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  121 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word = \"\";\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            } else {\n                word += c;\n     \
    \       }\n        }\n    }\n    ans += word;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkukrfx4f: /tmp/tmpkukrfx4f.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmptczmgo9q: /tmp/tmptczmgo9q.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence.substr(i, 1);\n        if (is_prime(word.length())) {\n\
    \            result += word;\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppk2izwe0.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmppk2izwe0.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for(int i = 0; i < sentence.length(); i++) {\n     \
    \   if(sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        if(flag) {\n            ans += \" \";\n            flag =\
    \ false;\n        }\n    }\n    for(int i = 0; i < ans.length(); i++) {\n    \
    \    if(isPrime(ans[i])) {\n            ans += ans[i];\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpefo26hju.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpefo26hju.cpp:31:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   31 |         if(isPrime(ans[i])) {\n      |            ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        word = sentence.substr(i, 1);\n  \
    \      if (is_prime(word.length())) {\n            ans += word;\n            flag\
    \ = true;\n        }\n    }\n    if (!flag) {\n        ans = ans + \" \";\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwx_q7jgc.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpwx_q7jgc.cpp:24:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   24 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcimb7t74: /tmp/tmpcimb7t74.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int len1 = 0, len2 = 0;\n            while(sentence[i]\
    \ != ' ') {\n                len1++;\n                i++;\n            }\n  \
    \          while(sentence[j] != ' ') {\n                len2++;\n            \
    \    j++;\n            }\n            if(len1 == len2) {\n                ans\
    \ += sentence[i];\n                i++;\n                j++;\n            }\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpcy8bfvs6: /tmp/tmpcy8bfvs6.cpp:42: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp_ans = \"\";\n    bool flag =\
    \ false;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            flag = true;\n        }\n        if (flag) {\n      \
    \      ans += sentence[i];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == '.') {\n            flag = false;\n        }\n\
    \        if (flag) {\n            temp_ans += ans[i];\n        }\n    }\n    for\
    \ (int i = 0; i < temp_ans.length(); i++) {\n        temp = temp_ans.substr(0,\
    \ i);\n        if (temp == \"is\") {\n            ans += \"is\";\n        }\n\
    \        if (temp == \"for\") {\n            ans += \"for\";\n        }\n    \
    \    if (temp == \"go\") {\n            ans += \"go\";\n        }\n        if\
    \ (temp == \"swimming\") {\n            ans += \"swimming\";\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpw4m1iw_u: /tmp/tmpw4m1iw_u.cpp:57: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                flag = false;\n                temp = \"\";\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpsnyrocj8: /tmp/tmpsnyrocj8.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        word = sentence.substr(i, 1);\n  \
    \      if (is_prime(word.length())) {\n            ans += word;\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu4viy20s.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpu4viy20s.cpp:24:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   24 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = true;\n    std::string temp;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] != ' ') {\n            flag = false;\n          \
    \  break;\n        }\n    }\n    if (flag) {\n        ans = sentence;\n    } else\
    \ {\n        ans = sentence;\n    }\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = ans.substr(0,\
    \ i);\n            ans = ans.substr(i + 1);\n            int count = 0;\n    \
    \        for (int j = 0; j < temp.length(); j++) {\n                for (int k\
    \ = 0; k < ans.length(); k++) {\n                    if (temp[j] == ans[k]) {\n\
    \                        count++;\n                    }\n                }\n\
    \            }\n            if (count == 2) {\n                ans = temp;\n \
    \           }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 6) > this->size() (which is 4)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    std::string temp = \"\";\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      word += sentence[i];\n        } else {\n            temp = word;\n    \
    \        word = \"\";\n            ans += temp;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpc_cj0vvn: /tmp/tmpc_cj0vvn.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] == ' ') {\n            flag = true;\n           \
    \ ans += word;\n            word.clear();\n        } else {\n            if (flag)\
    \ {\n                word += sentence[i];\n            }\n        }\n    }\n \
    \   ans += word;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbnlw6hti: /tmp/tmpbnlw6hti.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word = \"\";\n    std::string temp = \"\"\
    ;\n    for (char c : sentence) {\n        if (c == ' ') {\n            if (flag)\
    \ {\n                ans += \" \" + temp;\n                flag = false;\n   \
    \             temp = \"\";\n            } else {\n                flag = true;\n\
    \            }\n        } else {\n            temp += c;\n        }\n    }\n \
    \   if (flag) {\n        ans += \" \" + temp;\n    }\n    ans = ans.substr(0,\
    \ ans.length() - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"\
    ));\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxsxmp_34: /tmp/tmpxsxmp_34.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        bool flag = false;\n        for (int j =\
    \ i + 1; j < n; j++) {\n            if (isPrime(j - i)) {\n                if\
    \ (j - i == word.length()) {\n                    flag = true;\n             \
    \       break;\n                }\n            }\n        }\n        if (flag)\
    \ {\n            result += \" \" + word;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbdl24oht.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpbdl24oht.cpp:25:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   25 |             if (isPrime(j - i)) {\n      |             \
    \    ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp627n17os: /tmp/tmp627n17os.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            temp = ans;\n            ans = \"\";\n        \
    \    int count = 0;\n            while (temp != \"\") {\n                temp\
    \ = temp.substr(0, temp.find(\" \"));\n                count++;\n            }\n\
    \            if (count % 2 == 0) {\n                ans += temp;\n           \
    \ }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    for (int i = 2; i < n; i++) {\n        if (ans.find(std::to_string(i))\
    \ != std::string::npos) {\n            flag = false;\n        }\n        if (flag)\
    \ {\n            ans += \" \";\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpt443j73c: /tmp/tmpt443j73c.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += c;\n        }\n    }\n \
    \   if (flag) {\n        ans += \" \" + temp;\n    }\n    ans = ans.substr(0,\
    \ ans.size() - 1);\n    int n = ans.size();\n    for (int i = 1; i < n; i++) {\n\
    \        if (ans[i] % 2 == 0) {\n            ans = ans.substr(0, i) + \" \" +\
    \ ans.substr(i, ans.size());\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpinug3ken: /tmp/tmpinug3ken.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += \" \" + temp;\n                temp = \"\";\n               \
    \ flag = false;\n            } else {\n                flag = true;\n        \
    \    }\n        } else {\n            temp += sentence[i];\n        }\n    }\n\
    \    if (flag) {\n        ans += \" \" + temp;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxsqn86uu: /tmp/tmpxsqn86uu.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            flag = true;\n      \
    \  }\n        if (flag) {\n            ans += sentence[i];\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        temp = ans.substr(i, 1);\n\
    \        if (is_prime(temp.length())) {\n            ans = ans.substr(0, i) +\
    \ \" \" + ans.substr(i + 1, ans.length() - i);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6atjfxob.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp6atjfxob.cpp:31:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   31 |         if (is_prime(temp.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    for (int i = 0; i < sentence.length(); i++) {\n     \
    \   if (sentence[i] != ' ') {\n            flag = false;\n        }\n    }\n \
    \   if (flag) {\n        for (int i = 0; i < sentence.length(); i++) {\n     \
    \       if (sentence[i] != ' ') {\n                ans += sentence[i];\n     \
    \       }\n        }\n    } else {\n        for (int i = 0; i < sentence.length();\
    \ i++) {\n            if (sentence[i] != ' ') {\n                ans += sentence[i];\n\
    \            }\n        }\n        for (int i = 0; i < sentence.length(); i++)\
    \ {\n            if (sentence[i] != ' ') {\n                ans += sentence[i];\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp94l9rul9: /tmp/tmp94l9rul9.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    int n = sentence.length();\n    for(int i = 0;\
    \ i < n; i++) {\n        word = sentence[i];\n        for(int j = i + 1; j < n;\
    \ j++) {\n            if(isPrime(j - i) && isPrime(j - i + 1)) {\n           \
    \     ans += word;\n                i = j;\n                break;\n         \
    \   }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwiykh8ol.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpwiykh8ol.cpp:24:16: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   24 |             if(isPrime(j - i) && isPrime(j - i + 1)) {\n\
    \      |                ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word = \"\";\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            if (flag) {\n       \
    \         word += c;\n            }\n        }\n    }\n    ans += word;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk02v5zli: /tmp/tmpk02v5zli.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    bool\
    \ flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n   \
    \         flag = true;\n            continue;\n        }\n        if (flag) {\n\
    \            result += c;\n        }\n    }\n    std::string new_result;\n   \
    \ for (auto &c : result) {\n        if (std::find(new_result.begin(), new_result.end(),\
    \ c) == new_result.end()) {\n            new_result += c;\n        }\n    }\n\
    \    for (auto &c : new_result) {\n        if (std::find(result.begin(), result.end(),\
    \ c) == result.end()) {\n            result += c;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp203nxk53: /tmp/tmp203nxk53.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        ans += \" \";\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        } else {\n            flag\
    \ = true;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (sentence\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcg1j1z_6.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpcg1j1z_6.cpp:144:21: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n  144 |         if (sentence\n      |            ~        ^\n      |\
    \                     )\n  145 | }\n      | ~                    \n/tmp/tmpcg1j1z_6.cpp:144:13:\
    \ error: could not convert \u2018sentence\u2019 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018bool\u2019\n  144 | \
    \        if (sentence\n      |             ^~~~~~~~\n      |             |\n \
    \     |             std::string {aka std::__cxx11::basic_string<char>}\n/tmp/tmpcg1j1z_6.cpp:145:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  145 | }\n \
    \     | ^\n/tmp/tmpcg1j1z_6.cpp:146:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n  146 | int main() {\n      |            ^\n\
    /tmp/tmpcg1j1z_6.cpp:155:1: error: expected \u2018}\u2019 at end of input\n  155\
    \ | }\n      | ^\n/tmp/tmpcg1j1z_6.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmpcg1j1z_6.cpp:155:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  155 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    int n = sentence.length();\n    int count = 0;\n    for(int i = 0;\
    \ i < n; i++) {\n        word = sentence.substr(i, 1);\n        if(isPrime(word.length()))\
    \ {\n            ans += word;\n            count++;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwr50e17m.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpwr50e17m.cpp:24:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   24 |         if(isPrime(word.length())) {\n      |          \
    \  ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c != ' ') {\n            flag = true;\n            temp += c;\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             flag = false;\n                temp = \"\";\n            }\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmplo1nz_g4: /tmp/tmplo1nz_g4.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int len = sentence.length();\n    for (int i = 0; i\
    \ < len; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    for (int i = 0; i < len; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(0, ans.find(\" \"\
    ));\n        }\n    }\n    for (int i = 2; i < len / 2; i++) {\n        if (ans.find(i)\
    \ != std::string::npos) {\n            ans = ans.substr(0, ans.find(i));\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprz_qv3zr: /tmp/tmprz_qv3zr.cpp:45: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i = 0; i < sentence.length(); i++)\
    \ {\n        if(sentence[i] == ' ') {\n            flag = true;\n            temp.clear();\n\
    \            continue;\n        }\n        if(flag) {\n            temp.push_back(sentence[i]);\n\
    \        }\n    }\n    for(int i = 0; i < temp.length(); i++) {\n        if(i\
    \ == 0) {\n            ans += temp[i];\n            continue;\n        }\n   \
    \     for(int j = i; j < temp.length(); j++) {\n            if(temp[i] == temp[j])\
    \ {\n                ans += temp[i];\n                break;\n            }\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp2ywn8g45: /tmp/tmp2ywn8g45.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    for (int i = 0; i < n; i++) {\n        if (ans.find(\"\
    \ \") != std::string::npos) {\n            ans = ans.substr(0, ans.find(\" \"\
    ));\n        }\n        if (ans.find(sentence[i]) == std::string::npos) {\n  \
    \          ans += sentence[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp55wngg2r: /tmp/tmp55wngg2r.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] >= 'a' && ans[i] <= 'z') {\n            ans[i] =\
    \ ans[i] - 'a' + 'A';\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 == 0) {\n            ans[i] = ans[i] + 1;\n \
    \       }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 3 == 0) {\n            ans[i] = ans[i] + 2;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 5 == 0) {\n          \
    \  ans[i] = ans[i] + 3;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 7 == 0) {\n            ans[i] = ans[i] + 4;\n \
    \       }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 11 == 0) {\n            ans[i] = ans[i] + 5;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 13 == 0) {\n         \
    \   ans[i] = ans[i] + 6;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 17 == 0) {\n            ans[i] = ans[i] + 7;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 19 == 0) {\n            ans[i] = ans[i] + 8;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 23 == 0) {\n         \
    \   ans[i] = ans[i] + 9;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 29 == 0) {\n            ans[i] = ans[i] + 10;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 31 == 0) {\n            ans[i] = ans[i] + 11;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 37 == 0) {\n         \
    \   ans[i] = ans[i] + 12;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 41 == 0) {\n            ans[i] = ans[i] + 13;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 43 == 0) {\n            ans[i] = ans[i] + 14;\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 47 == 0) {\n         \
    \   ans[i] = ans[i] + 15;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 49 == 0) {\n            ans[i] = ans[i] + 16;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpapryhpgv.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpapryhpgv.cpp:117:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  117 | int main() {\n      |            ^\n/tmp/tmpapryhpgv.cpp:126:1:\
    \ error: expected \u2018}\u2019 at end of input\n  126 | }\n      | ^\n/tmp/tmpapryhpgv.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpapryhpgv.cpp:126:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  126 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        word = sentence[i];\n        for (int j = i + 1; j < sentence.length();\
    \ j++) {\n            if (isPrime(j - i)) {\n                ans += \" \" + word;\n\
    \                flag = true;\n                break;\n            }\n       \
    \ }\n    }\n    if (flag == false) {\n        ans += \" \" + sentence;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4uyqge7c.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4uyqge7c.cpp:24:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   24 |             if (isPrime(j - i)) {\n      |             \
    \    ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag ==\
    \ false) {\n        ans += \" \";\n    }\n    for (int i = 0; i < n; i++) {\n\
    \        if (ans.find(\" \") != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(\" \"));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ if (ans.find(i + 1) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 1));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 2) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 2));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 3) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 3));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 4) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 4));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 5) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 5));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 6) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 6));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 7) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 7));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 8) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 8));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 9) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 9));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n   \
    \     if (ans.find(i + 10) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.find(i + 10));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n  \
    \      if (ans.find(i + 11) != std::string::npos) {\n            ans = ans.substr(0,\
    \ ans.\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpn9duz6e5.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpn9duz6e5.cpp:94:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   94 | }\n      | ^\n/tmp/tmpn9duz6e5.cpp:95:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   95 | int main() {\n     \
    \ |            ^\n/tmp/tmpn9duz6e5.cpp:104:1: error: expected \u2018}\u2019 at\
    \ end of input\n  104 | }\n      | ^\n/tmp/tmpn9duz6e5.cpp:91:33: note: to match\
    \ this \u2018{\u2019\n   91 |     for (int i = 0; i < n; i++) {\n      |     \
    \                            ^\n/tmp/tmpn9duz6e5.cpp:104:1: error: expected \u2018\
    }\u2019 at end of input\n  104 | }\n      | ^\n/tmp/tmpn9duz6e5.cpp:17:53: note:\
    \ to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpn9duz6e5.cpp:104:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  104 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            temp += c;\n        } else {\n  \
    \          ans += temp;\n            temp = \"\";\n            ans += c;\n   \
    \     }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmphbuztx77: /tmp/tmphbuztx77.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            word.clear();\n        } else\
    \ {\n            word += c;\n        }\n    }\n    if (flag) {\n        auto it\
    \ = std::find(word.begin(), word.end(), '\\n');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), ' ');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), '.');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), '!');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), '?');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), ';');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), ':');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), ';');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), '.');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), '!');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), '?');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), ';');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), ':');\n        if (it != word.end())\
    \ {\n            word.erase(it);\n        }\n        auto it = std::find(word.begin(),\
    \ word.end(), ';');\n        if (it != word.end()) {\n            word.erase(it);\n\
    \        }\n        auto it = std::find(word.begin(), word.end(), '.');\n    \
    \    if (it != word.end()) {\n            word.erase(it);\n        }\n       \
    \ auto it = std::find(word.begin(), word.end(), '\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpov4a6is6.cpp:90:55: warning: missing terminating ' character\n\
    \   90 |         auto it = std::find(word.begin(), word.end(), '\n      |    \
    \                                                   ^\n/tmp/tmpov4a6is6.cpp:90:55:\
    \ error: missing terminating ' character\n/tmp/tmpov4a6is6.cpp: In function \u2018\
    std::string words_in_sentence(std::string)\u2019:\n/tmp/tmpov4a6is6.cpp:34:14:\
    \ error: conflicting declaration \u2018auto it\u2019\n   34 |         auto it\
    \ = std::find(word.begin(), word.end(), ' ');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14:\
    \ note: previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:38:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   38 |         auto it = std::find(word.begin(),\
    \ word.end(), '.');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:42:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   42 |         auto it = std::find(word.begin(),\
    \ word.end(), '!');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:46:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   46 |         auto it = std::find(word.begin(),\
    \ word.end(), '?');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:50:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   50 |         auto it = std::find(word.begin(),\
    \ word.end(), ';');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:54:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   54 |         auto it = std::find(word.begin(),\
    \ word.end(), ':');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:58:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   58 |         auto it = std::find(word.begin(),\
    \ word.end(), ';');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:62:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   62 |         auto it = std::find(word.begin(),\
    \ word.end(), '.');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:66:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   66 |         auto it = std::find(word.begin(),\
    \ word.end(), '!');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:70:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   70 |         auto it = std::find(word.begin(),\
    \ word.end(), '?');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:74:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   74 |         auto it = std::find(word.begin(),\
    \ word.end(), ';');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:78:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   78 |         auto it = std::find(word.begin(),\
    \ word.end(), ':');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:82:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   82 |         auto it = std::find(word.begin(),\
    \ word.end(), ';');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:86:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   86 |         auto it = std::find(word.begin(),\
    \ word.end(), '.');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:90:14: error: conflicting\
    \ declaration \u2018auto it\u2019\n   90 |         auto it = std::find(word.begin(),\
    \ word.end(), '\n      |              ^~\n/tmp/tmpov4a6is6.cpp:30:14: note: previous\
    \ declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > it\u2019\n   30 |         auto it = std::find(word.begin(), word.end(), '\\\
    n');\n      |              ^~\n/tmp/tmpov4a6is6.cpp:91:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   91 | }\n      | ^\n/tmp/tmpov4a6is6.cpp:92:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   92 | int main() {\n      |            ^\n/tmp/tmpov4a6is6.cpp:101:1: error:\
    \ expected \u2018}\u2019 at end of input\n  101 | }\n      | ^\n/tmp/tmpov4a6is6.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpov4a6is6.cpp:101:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  101 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxb28l5zd: /tmp/tmpxb28l5zd.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \      ans += word;\n            word = \"\";\n        } else {\n            if\
    \ (flag) {\n                word += sentence[i];\n            }\n        }\n \
    \   }\n    ans += word;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_dusocy3: /tmp/tmp_dusocy3.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c != ' ') {\n            flag = true;\n        }\n    }\n   \
    \ if (flag) {\n        std::sort(sentence.begin(), sentence.end());\n        std::sort(sentence.begin(),\
    \ sentence.end());\n        std::sort(sentence.begin(), sentence.end());\n   \
    \ }\n    for (auto &c : sentence) {\n        if (c != ' ') {\n            temp\
    \ = temp + c;\n        }\n    }\n    ans = temp;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp9e38_l3u: /tmp/tmp9e38_l3u.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            if (flag) {\n               \
    \ ans += \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n            ans += c;\n        } else {\n            temp += c;\n\
    \        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkuuohzv6: /tmp/tmpkuuohzv6.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int m = j - i;\n            int count\
    \ = 0;\n            for(int k = i; k <= j; k++) {\n                if(k % m ==\
    \ 0) {\n                    count++;\n                }\n            }\n     \
    \       if(count == 2) {\n                ans += sentence.substr(i, 1);\n    \
    \        }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpyxv_9srh: /tmp/tmpyxv_9srh.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    std::string temp;\n    bool flag = false;\n    for (int i = 0; i\
    \ < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n           \
    \ flag = true;\n            temp.clear();\n        } else {\n            if (flag)\
    \ {\n                temp.push_back(sentence[i]);\n            } else {\n    \
    \            word = temp;\n                temp.clear();\n                flag\
    \ = true;\n            }\n        }\n    }\n    for (int i = 0; i < temp.length();\
    \ i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(temp.begin() + i);\n        }\n    }\n    for (int i =\
    \ 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(temp.begin() + i);\n        }\n    }\n    for (int i =\
    \ 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(temp.begin() + i);\n        }\n    }\n    for (int i =\
    \ 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n            temp.erase(temp.begin()\
    \ + i);\n        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n   \
    \     if (temp[i] == '\\'') {\n            temp.erase(temp.begin() + i);\n   \
    \     }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ == '\\'') {\n            temp.erase(temp.begin() + i);\n        }\n    }\n \
    \   for (int i = 0; i < temp.length(); i++) {\n        if (temp[i] == '\\'') {\n\
    \            temp.erase(\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx_gm0pu8.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpx_gm0pu8.cpp:114:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  114 | }\n      | ^\n/tmp/tmpx_gm0pu8.cpp:115:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  115 | int main() {\n     \
    \ |            ^\n/tmp/tmpx_gm0pu8.cpp:124:1: error: expected \u2018}\u2019 at\
    \ end of input\n  124 | }\n      | ^\n/tmp/tmpx_gm0pu8.cpp:111:45: note: to match\
    \ this \u2018{\u2019\n  111 |     for (int i = 0; i < temp.length(); i++) {\n\
    \      |                                             ^\n/tmp/tmpx_gm0pu8.cpp:124:1:\
    \ error: expected \u2018}\u2019 at end of input\n  124 | }\n      | ^\n/tmp/tmpx_gm0pu8.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpx_gm0pu8.cpp:124:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  124 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    int flag = 0;\n    for(int i = 0; i < sentence.length(); i++) {\n\
    \        if(sentence[i] == ' ') {\n            flag = 1;\n        }\n        if(flag\
    \ == 1) {\n            temp.push_back(sentence[i]);\n        }\n    }\n    for(int\
    \ i = 0; i < temp.length(); i++) {\n        if((temp[i] >= 'a' && temp[i] <= 'z')\
    \ || (temp[i] >= 'A' && temp[i] <= 'Z')) {\n            flag = 0;\n        }\n\
    \        if(flag == 1) {\n            result += temp[i];\n        }\n    }\n \
    \   return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpja12fpib: /tmp/tmpja12fpib.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += temp;\n\
    \            temp = \"\";\n        } else {\n            if (flag) {\n       \
    \         temp += c;\n            } else {\n                ans += c;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpd0d87eg5: /tmp/tmpd0d87eg5.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            flag = true;\n            temp +=\
    \ sentence[i];\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp29ek_0lr: /tmp/tmp29ek_0lr.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    std::string word;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    if (flag) {\n        ans += word;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjc8p_hhp: /tmp/tmpjc8p_hhp.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (char c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            result += word;\n         \
    \   word.clear();\n        } else {\n            word += c;\n        }\n    }\n\
    \    result += word;\n    return result;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdrpp2ab1: /tmp/tmpdrpp2ab1.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for(int i = 0; i < sentence.length(); i++)\
    \ {\n        if(isalpha(sentence[i])) {\n            flag = true;\n          \
    \  ans += sentence[i];\n        }\n    }\n    if(flag) {\n        for(int i =\
    \ 0; i < ans.length(); i++) {\n            for(int j = i + 1; j < ans.length();\
    \ j++) {\n                if(isalpha(ans[j]) && isalpha(ans[i]) && ans[j] <= ans[i])\
    \ {\n                    temp = ans.substr(i, j);\n                    ans.replace(i,\
    \ j, temp);\n                }\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3cp3gphm: /tmp/tmp3cp3gphm.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     } else {\n            if (flag) {\n                ans += sentence[i];\n\
    \                flag = false;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpswph_394: /tmp/tmpswph_394.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            temp.clear();\n        } else\
    \ {\n            if (flag) {\n                temp += c;\n            }\n    \
    \    }\n    }\n    for (auto &c : temp) {\n        ans += c;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6hqakfu_: /tmp/tmp6hqakfu_.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp = temp +\
    \ sentence[i];\n        } else {\n            ans = ans + \" \" + temp;\n    \
    \        temp = \"\";\n        }\n    }\n    ans = ans + \" \" + temp;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpgf45dzir: /tmp/tmpgf45dzir.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp2 = \"\";\n    bool flag = false;\n\
    \    int count = 0;\n    int flag2 = 0;\n    int flag3 = 0;\n    for (int i =\
    \ 0; i < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n      \
    \      flag = true;\n            count++;\n        }\n        if (flag == true)\
    \ {\n            ans += sentence[i];\n            flag = false;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            flag2 = true;\n        }\n        if (flag2 == true) {\n    \
    \        ans += ans[i];\n            flag2 = false;\n        }\n    }\n    for\
    \ (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n       \
    \     flag3 = true;\n        }\n        if (flag3 == true) {\n            ans\
    \ += ans[i];\n            flag3 = false;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n            flag = true;\n\
    \        }\n        if (flag == true) {\n            ans += ans[i];\n        \
    \    flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] == ' ') {\n            flag = true;\n        }\n     \
    \   if (flag == true) {\n            ans += ans[i];\n            flag = false;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == ' ') {\n            flag = true;\n        }\n        if (flag == true) {\n\
    \            ans += ans[i];\n            flag = false;\n        }\n    }\n   \
    \ for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n   \
    \         flag = true;\n        }\n        if (flag == true) {\n            ans\
    \ += ans[i];\n            flag = false;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n            flag = true;\n\
    \        }\n        if (flag == true) {\n            ans += ans[i];\n        \
    \    flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length(); i++)\
    \ {\n        if (ans[i] == ' ') {\n            flag = true;\n        }\n     \
    \   if (flag == true) {\n            ans += ans[i];\n            flag = false;\n\
    \        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ == ' ') {\n            flag = true;\n        }\n        if (flag == true) {\n\
    \            ans += ans[i];\n            flag = false;\n        }\n    }\n   \
    \ for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n   \
    \         flag = true;\n        }\n        if (flag == true) {\n            ans\
    \ += ans[i];\n            flag = false;\n        }\n    }\n    for (int i = 0;\
    \ i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n            flag = true;\n\
    \        }\n        if (flag == true) {\n            ans += ans[i];\n        \
    \    flag = false;\n        }\n    }\n    for (int i = 0; i < ans.length\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfnw94uo8.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpfnw94uo8.cpp:134:29: error: invalid use of member function \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length()\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019 (did you forget the \u2018()\u2019 ?)\n  134 |     for (int i = 0;\
    \ i < ans.length\n      |                         ~~~~^~~~~~\n      |        \
    \                           ()\n/tmp/tmpfnw94uo8.cpp:134:35: error: expected \u2018\
    ;\u2019 before \u2018}\u2019 token\n  134 |     for (int i = 0; i < ans.length\n\
    \      |                                   ^\n      |                        \
    \           ;\n  135 | }\n      | ~                                  \n/tmp/tmpfnw94uo8.cpp:135:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  135 | }\n \
    \     | ^\n/tmp/tmpfnw94uo8.cpp:134:35: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n  134 |     for (int i = 0; i < ans.length\n      |         ~ \
    \                        ^\n      |                                   )\n  135\
    \ | }\n      | ~                                  \n/tmp/tmpfnw94uo8.cpp:135:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  135 | }\n \
    \     | ^\n/tmp/tmpfnw94uo8.cpp:135:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            result += word;\n         \
    \   word.clear();\n        } else {\n            word += c;\n        }\n    }\n\
    \    if (flag) {\n        result += word;\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdbmv5n8y: /tmp/tmpdbmv5n8y.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ temp;\n                flag = false;\n                temp = \"\";\n       \
    \     } else {\n                flag = true;\n            }\n        } else {\n\
    \            temp += c;\n        }\n    }\n    ans += temp;\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzag_mqta: /tmp/tmpzag_mqta.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp_ans = \"\";\n    int len = sentence.length();\n\
    \    for (int i = 0; i < len; i++) {\n        if (sentence[i] != ' ') {\n    \
    \        temp = temp + sentence[i];\n        } else {\n            temp_ans =\
    \ temp_ans + temp;\n            temp = \"\";\n        }\n    }\n    temp_ans =\
    \ temp_ans + temp;\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans = temp_ans.substr(0,\
    \ i);\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans = temp_ans.substr(0,\
    \ i);\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans = temp_ans.substr(0,\
    \ i);\n        }\n    }\n    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i]\
    \ == ' ') {\n            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n\
    \    for (int i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n\
    \            temp_ans = temp_ans.substr(0, i);\n        }\n    }\n    for (int\
    \ i = 0; i < len - 1; i++) {\n        if (temp_ans[i] == ' ') {\n            temp_ans\
    \ = temp_ans.substr(0, i);\n        }\n    }\n    for (int i = 0; i < len - 1;\
    \ i++) {\n\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_16qsmez.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp_16qsmez.cpp:109:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  109 | int main() {\n      |            ^\n/tmp/tmp_16qsmez.cpp:118:1:\
    \ error: expected \u2018}\u2019 at end of input\n  118 | }\n      | ^\n/tmp/tmp_16qsmez.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmp_16qsmez.cpp:118:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  118 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (std::isalpha(c)) {\n            flag = true;\n            temp\
    \ += c;\n        } else {\n            if (flag) {\n                ans += \"\
    \ \" + temp;\n                temp = \"\";\n                flag = false;\n  \
    \          }\n        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjqrr9tax: /tmp/tmpjqrr9tax.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == '.' || c\
    \ == '!' || c == '?') {\n            flag = true;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    int n = ans.size();\n    for\
    \ (int i = 1; i < n; i++) {\n        int count = 0;\n        for (int j = i; j\
    \ < n; j++) {\n            if (ans[j] == ans[i]) {\n                count++;\n\
    \            }\n        }\n        if (count == 2) {\n            ans = ans.substr(0,\
    \ i) + \" \" + ans.substr(i + 1, n - 1);\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpewk4llzz: /tmp/tmpewk4llzz.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            flag = true;\n      \
    \      temp += sentence[i];\n        } else {\n            if (flag) {\n     \
    \           ans += temp;\n                temp = \"\";\n                flag =\
    \ false;\n            }\n        }\n    }\n    if (flag) {\n        ans += temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpih8g0srg: /tmp/tmpih8g0srg.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += temp;\n\
    \            temp = \"\";\n        } else {\n            if (flag) {\n       \
    \         temp += c;\n            } else {\n                ans += c;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpyacdli7r: /tmp/tmpyacdli7r.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    ans.reserve(sentence.size());\n\
    \    std::string word;\n    bool flag = false;\n    for (auto &c : sentence) {\n\
    \        if (c == ' ') {\n            flag = true;\n            ans.push_back(word);\n\
    \            word.clear();\n        } else {\n            word += c;\n       \
    \ }\n    }\n    if (flag) {\n        ans.push_back(word);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpijrqjd_4.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpijrqjd_4.cpp:25:27: error: cannot convert \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018char\u2019\n   25 | \
    \            ans.push_back(word);\n      |                           ^~~~\n  \
    \    |                           |\n      |                           std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpijrqjd_4.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1353:24:\
    \ note:   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1353 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n/tmp/tmpijrqjd_4.cpp:32:23: error: cannot\
    \ convert \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018char\u2019\n   32 |         ans.push_back(word);\n      |         \
    \              ^~~~\n      |                       |\n      |                \
    \       std::string {aka std::__cxx11::basic_string<char>}\nIn file included from\
    \ /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpijrqjd_4.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1353:24: note:\
    \   initializing argument 1 of \u2018void std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::push_back(_CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n 1353 |       push_back(_CharT __c)\n\
    \      |                 ~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string word = \"\";\n    bool flag = false;\n\
    \    int count = 0;\n    \n    for (auto &c : sentence) {\n        if (c == '\
    \ ') {\n            if (flag) {\n                ans += \" \" + word;\n      \
    \          flag = false;\n                count = 0;\n                word = \"\
    \";\n            } else {\n                flag = true;\n            }\n     \
    \   } else {\n            word += c;\n            count++;\n        }\n    }\n\
    \    \n    if (flag) {\n        ans += \" \" + word;\n    }\n    \n    for (int\
    \ i = 1; i < ans.size(); i++) {\n        temp = ans.substr(0, i);\n        ans\
    \ = ans.substr(i);\n        \n        if (is_prime(temp.size())) {\n         \
    \   ans += \" \" + temp;\n        }\n    }\n    \n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpahmwalls.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpahmwalls.cpp:48:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   48 |         if (is_prime(temp.size())) {\n      |          \
    \   ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (!flag) {\n                ans = ans + \" \"\
    \ + temp;\n                flag = true;\n            }\n            temp = \"\"\
    ;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp6u20nzv_: /tmp/tmp6u20nzv_.cpp:36: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3ce7kny8: /tmp/tmp3ce7kny8.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ temp;\n    bool flag = false;\n    int count = 0;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            flag = true;\n       \
    \     temp.clear();\n            temp.push_back(sentence[i]);\n            count++;\n\
    \        }\n        else {\n            if(flag) {\n                temp.push_back(sentence[i]);\n\
    \                count++;\n            }\n            else {\n               \
    \ result += temp;\n                temp.clear();\n                temp.push_back(sentence[i]);\n\
    \                count++;\n            }\n        }\n    }\n    result += temp;\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3wmxp28_: /tmp/tmp3wmxp28_.cpp:47: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      word = sentence[i];\n        if(isPrime(word.length())) {\n           \
    \ result += word;\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdbiamh5v.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpdbiamh5v.cpp:23:12: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   23 |         if(isPrime(word.length())) {\n      |          \
    \  ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        std::string\
    \ word = sentence.substr(i, 1);\n        ans += word;\n    }\n    for (int i =\
    \ 2; i < n; i++) {\n        if (ans.find(ans.substr(i, 1)) != std::string::npos)\
    \ {\n            ans.replace(ans.find(ans.substr(i, 1)), i, \"\");\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 6) > this->size() (which is 0)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n      \
    \  }\n        if (flag) {\n            temp += sentence[i];\n        }\n    }\n\
    \    for (int i = 0; i < temp.length(); i++) {\n        flag = false;\n      \
    \  for (int j = i + 1; j < temp.length(); j++) {\n            if (isPrime(temp.length()\
    \ - j - 1) && temp.length() % j == 0) {\n                ans += temp.substr(i,\
    \ j);\n                flag = true;\n                break;\n            }\n \
    \       }\n        if (flag == false) {\n            ans += temp.substr(i, temp.length());\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmxop44nn.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpmxop44nn.cpp:32:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   32 |             if (isPrime(temp.length() - j - 1) && temp.length()\
    \ % j == 0) {\n      |                 ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n\
    \        } else {\n            flag = true;\n        }\n    }\n    if (flag) {\n\
    \        return ans;\n    }\n    ans = ans.substr(0, ans.length() - 1);\n    for\
    \ (int i = 0; i < n; i++) {\n        if (ans.find(\" \") != std::string::npos)\
    \ {\n            ans = ans.substr(0, ans.find(\" \"));\n        }\n    }\n   \
    \ for (int i = 2; i < n; i++) {\n        if (ans.find(i) != std::string::npos)\
    \ {\n            ans = ans.substr(0, ans.find(i));\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpl41yhn_x: /tmp/tmpl41yhn_x.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    std::string temp2 = \"\";\n    int count = 0;\n\
    \    int count2 = 0;\n    int flag = 0;\n    std::string temp3 = \"\";\n    for\
    \ (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] != ' ') {\n\
    \            ans += sentence[i];\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            count++;\n        }\n    }\n\
    \    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ') {\n\
    \            count2++;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            flag = 1;\n        }\n   \
    \ }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            flag = 0;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] == ' ')\
    \ {\n            temp = ans.substr(0, i);\n            ans = ans.substr(i + 1);\n\
    \            ans += temp;\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] == ' ') {\n            temp = ans.substr(0, i);\n\
    \            ans = ans.substr(i + 1);\n            ans += temp;\n\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpac3pazzb.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpac3pazzb.cpp:113:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  113 | int main() {\n      |            ^\n/tmp/tmpac3pazzb.cpp:122:1:\
    \ error: expected \u2018}\u2019 at end of input\n  122 | }\n      | ^\n/tmp/tmpac3pazzb.cpp:106:44:\
    \ note: to match this \u2018{\u2019\n  106 |     for (int i = 0; i < ans.length();\
    \ i++) {\n      |                                            ^\n/tmp/tmpac3pazzb.cpp:122:1:\
    \ error: expected \u2018}\u2019 at end of input\n  122 | }\n      | ^\n/tmp/tmpac3pazzb.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpac3pazzb.cpp:122:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  122 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += c;\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        ans += \" \" + temp;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpx9j9y0u2: /tmp/tmpx9j9y0u2.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            temp += c;\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             temp = \"\";\n                flag = false;\n            }\n   \
    \         ans += c;\n        }\n    }\n    ans += temp;\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpkjjkzurb: /tmp/tmpkjjkzurb.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpr9hsq6fr: /tmp/tmpr9hsq6fr.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n        char\
    \ c = sentence[i];\n        if (c == ' ') {\n            int count = 0;\n    \
    \        while (i != n - 1 && sentence[i] == sentence[i + 1]) {\n            \
    \    count++;\n                i++;\n            }\n            if (count == 2)\
    \ {\n                ans += c;\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpu5a3kcuk: /tmp/tmpu5a3kcuk.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            ans += word;\n\
    \            word = \"\";\n        } else {\n            word += c;\n        }\n\
    \    }\n    ans += word;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpa60bwkqj: /tmp/tmpa60bwkqj.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4qjubrxk: /tmp/tmp4qjubrxk.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] != ' ') {\n            ans += sentence[i];\n        } else\
    \ {\n            flag = true;\n        }\n    }\n    if (flag) {\n        return\
    \ ans;\n    }\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ != ' ') {\n            ans += sentence[i];\n        }\n    }\n    for (int i\
    \ = ans.length() - 1; i >= 0; i--) {\n        if (ans[i] % 2 != 0) {\n       \
    \     ans.erase(ans.begin() + i);\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmphg8z3qx3: /tmp/tmphg8z3qx3.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n            ans += sentence[i];\n\
    \        }\n        else if (flag) {\n            ans += sentence[i];\n      \
    \      flag = false;\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmprf9enqu0: /tmp/tmprf9enqu0.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] != ' ') {\n            ans += sentence[i];\n    \
    \    } else {\n            if (flag) {\n                ans += \" \";\n      \
    \          flag = false;\n            }\n            temp = sentence[i];\n   \
    \         for (int j = i + 1; j < sentence.length(); j++) {\n                if\
    \ (sentence[j] != ' ') {\n                    ans += sentence[j];\n          \
    \          flag = true;\n                    break;\n                }\n     \
    \       }\n            ans += temp;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpgyrfyils: /tmp/tmpgyrfyils.cpp:44: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    int n = sentence.length();\n    for (int i = 0; i < n;\
    \ i++) {\n        word = sentence.substr(i, 1);\n        if (is_prime(word.length()))\
    \ {\n            ans += \" \" + word;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfrig27jt.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpfrig27jt.cpp:23:13: error: \u2018is_prime\u2019 was not declared in\
    \ this scope\n   23 |         if (is_prime(word.length())) {\n      |        \
    \     ^~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = i + 1; j < n; j++) {\n            int count = 0;\n            for(int k\
    \ = i; k <= j; k++) {\n                if(sentence[k] == ' ') {\n            \
    \        count++;\n                }\n            }\n            if(count == 2)\
    \ {\n                ans += sentence[i];\n            }\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n   \
    \ assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp1m2hlt8e: /tmp/tmp1m2hlt8e.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxmi1ppvo: /tmp/tmpxmi1ppvo.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            temp += c;\n\
    \        } else {\n            if (flag) {\n                ans += temp;\n   \
    \             temp = \"\";\n                flag = false;\n            }\n   \
    \         ans += c;\n        }\n    }\n    if (flag) {\n        ans += temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp1odfx44b: /tmp/tmp1odfx44b.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpp2cnaj2y: /tmp/tmpp2cnaj2y.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++) {\n \
    \       word = sentence[i];\n        if (std::find(sentence.begin(), sentence.end(),\
    \ word) == sentence.end()) {\n            result += word;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n    \
    \             from /usr/include/c++/9/bits/char_traits.h:39,\n               \
    \  from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h: In instantiation\
    \ of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Value = const std::__cxx11::basic_string<char>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Predicate\
    \ = __gnu_cxx::__ops::_Iter_equals_val<const std::__cxx11::basic_string<char>\
    \ >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:161:23:   required from \u2018\
    _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const\
    \ std::__cxx11::basic_string<char> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:3944:28:\
    \   required from \u2018_IIter std::find(_IIter, _IIter, const _Tp&) [with _IIter\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; _Tp\
    \ = std::__cxx11::basic_string<char>]\u2019\n/tmp/tmp6gzddd9h.cpp:23:61:   required\
    \ from here\n/usr/include/c++/9/bits/predefined_ops.h:241:17: error: no match\
    \ for \u2018operator==\u2019 (operand types are \u2018char\u2019 and \u2018const\
    \ std::__cxx11::basic_string<char>\u2019)\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>\u2019 and \u2018char\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/iosfwd:40,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::fpos<_StateT>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const\
    \ std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const\
    \ pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::pair<_T1, _T2>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\u2019\
    \n  325 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |    \
    \ ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:   template argument\
    \ deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorL>&)\u2019\
    \n 1142 |     operator==(const move_iterator<_Iterator>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1142:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::move_iterator<_IteratorL>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5: note: candidate:\
    \ \u2018template<class _T1, class _T2> bool std::operator==(const std::allocator<_CharT>&,\
    \ const std::allocator<_T2>&)\u2019\n  167 |     operator==(const allocator<_T1>&,\
    \ const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::allocator<_CharT>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/string:55,\n   \
    \              from /usr/include/c++/9/bits/locale_classes.h:40,\n           \
    \      from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  241 | \
    \ { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:297:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_code&, const std::error_condition&)\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:297:32: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const std::error_code&\u2019\
    \n  297 |   operator==(const error_code& __lhs, const error_condition& __rhs)\
    \ noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/system_error:304:3:\
    \ note: candidate: \u2018bool std::operator==(const std::error_condition&, const\
    \ std::error_code&)\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:304:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  304 |   operator==(const error_condition& __lhs,\
    \ const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::error_condition&\u2019\n  311 |   operator==(const error_condition& __lhs,\n\
    \      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\nIn file included from /usr/include/c++/9/bits/locale_facets.h:48,\n\
    \                 from /usr/include/c++/9/bits/basic_ios.h:37,\n             \
    \    from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\n\
    \  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018char\u2019\n\
    \  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::complex<_Tp>\u2019\n  241 |  { return *__it == _M_value; }\n      |\
    \           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/deque:67,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/deque:67,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n   \
    \              from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/deque:67,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n   \
    \              from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::deque<_Tp, _Alloc>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::array<_Tp, _Nm>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/functional:54,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/tuple:1419:5: note: candidate: \u2018\
    template<class ... _TElements, class ... _UElements> constexpr bool std::operator==(const\
    \ std::tuple<_Tps ...>&, const std::tuple<_Elements ...>&)\u2019\n 1419 |    \
    \ operator==(const tuple<_TElements...>& __t,\n      |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::tuple<_Tps ...>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/functional:59,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5: note:\
    \ candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::function<_Res(_ArgTypes ...)>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_conv.h:41,\n            \
    \     from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::unique_ptr<_Tp, _Dp>\u2019\n  241 |  { return *__it == _M_value; }\n\
    \      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/iterator:66,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/list:63,\n \
    \                from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/map:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const\
    \ std::map<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const\
    \ map<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/map:62,\n      \
    \           from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n     \
    \            from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n             \
    \    from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__shared_ptr<_Tp, _Lp>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::shared_ptr<_Tp>\u2019\n  241 |  { return *__it == _M_value; }\n   \
    \   |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/queue:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::vector<_Tp, _Alloc>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/queue:64,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::queue<_Tp, _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const\
    \ queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_queue.h:338:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::queue<_Tp, _Seq>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::set<_Key, _Compare, _Alloc>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/set:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/stack:61,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n   \
    \              from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::stack<_Tp, _Seq>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/valarray:603,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5: note:\
    \ candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\n  241 |  { return *__it\
    \ == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\n  241 |  { return *__it\
    \ == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018char\u2019\
    \n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::valarray<_Tp>\u2019\n  241 |  { return *__it == _M_value; }\n     \
    \ |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/forward_list:40,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::forward_list<_Tp, _Alloc>\u2019 and \u2018\
    char\u2019\n  241 |  { return *__it == _M_value; }\n      |           ~~~~~~^~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/future:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018char\u2019 to \u2018std::thread::id\u2019\n  276 |   operator==(thread::id\
    \ __x, thread::id __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file\
    \ included from /usr/include/c++/9/random:51,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::normal_distribution<_RealType>\u2019 and\
    \ \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |          \
    \ ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n\
    \      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \ and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n      |      \
    \     ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   mismatched types \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019 and \u2018char\u2019\n  241 |  { return *__it == _M_value; }\n\
    \      |           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ std::allocator<char>&\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |                  ^~~~~~~~~~~~~~~~\nIn\
    \ file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/stl_algobase.h:71,\n                 from /usr/include/c++/9/bits/char_traits.h:39,\n\
    \                 from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp6gzddd9h.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:241:17: note:\
    \   \u2018const std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const __gnu_cxx::new_allocator<_Tp>\u2019\n  241 |  { return *__it == _M_value;\
    \ }\n      |           ~~~~~~^~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n        } else {\n            flag = false;\n     \
    \   }\n        if (flag) {\n            ans += c;\n        }\n    }\n    ans =\
    \ ans.substr(0, ans.size() - 1);\n    int n = ans.size();\n    std::vector<int>\
    \ primes;\n    for (int i = 2; i <= n; i++) {\n        if (ans.find(i) == std::string::npos)\
    \ {\n            primes.push_back(i);\n        }\n    }\n    std::string ans2\
    \ = \"is\";\n    for (auto &i : primes) {\n        ans2 += ans.substr(0, i);\n\
    \    }\n    return ans2;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp94ioqe8n: /tmp/tmp94ioqe8n.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    for (auto &c : ans) {\n    \
    \    if (std::find(std::begin(ans), std::end(ans), c) == std::end(ans)) {\n  \
    \          ans.erase(std::remove(std::begin(ans), std::end(ans), c), std::end(ans));\n\
    \        }\n    }\n    std::string new_ans = \"\";\n    for (auto &c : ans) {\n\
    \        if (std::find(std::begin(ans), std::end(ans), c) == std::end(ans)) {\n\
    \            new_ans += c;\n        }\n    }\n    for (auto &c : new_ans) {\n\
    \        if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin(new_ans), std::end(new_ans), c) == std::end(new_ans))\
    \ {\n            new_ans.erase(std::remove(std::begin(new_ans), std::end(new_ans),\
    \ c), std::end(new_ans));\n        }\n    }\n    for (auto &c : new_ans) {\n \
    \       if (std::find(std::begin\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy560acz9.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpy560acz9.cpp:71:33: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   71 |         if (std::find(std::begin\n      |                   \
    \   ~          ^\n      |                                 )\n   72 | }\n     \
    \ | ~                                \n/tmp/tmpy560acz9.cpp:71:33: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   71 |         if (std::find(std::begin\n\
    \      |            ~                    ^\n      |                          \
    \       )\n   72 | }\n      | ~                                \n/tmp/tmpy560acz9.cpp:72:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   72 | }\n \
    \     | ^\n/tmp/tmpy560acz9.cpp:73:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n\
    /tmp/tmpy560acz9.cpp:82:1: error: expected \u2018}\u2019 at end of input\n   82\
    \ | }\n      | ^\n/tmp/tmpy560acz9.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmpy560acz9.cpp:82:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   82 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    ans = ans.substr(0, ans.size()\
    \ - 1);\n    ans = ans.substr(0, ans.find_first_not_of(\"0123456789\"));\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp3au4fkin: /tmp/tmp3au4fkin.cpp:35: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    bool flag\
    \ = false;\n    for(int i=0;i<sentence.size();i++){\n        if(isalpha(sentence[i])){\n\
    \            flag = true;\n            ans += sentence[i];\n        }\n      \
    \  if(flag){\n            flag = false;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdqa753m7: /tmp/tmpdqa753m7.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbc8zf6oi: /tmp/tmpbc8zf6oi.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool prime = true;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] != ' ') {\n            prime = false;\n \
    \           break;\n        }\n    }\n    if (prime) {\n        for (int i = 0;\
    \ i < n; i++) {\n            if (sentence[i] != ' ') {\n                for (int\
    \ j = i; j < n; j++) {\n                    if (sentence[j] == ' ') {\n      \
    \                  break;\n                    }\n                }\n        \
    \        ans += sentence[i];\n            }\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5_ehw0rk: /tmp/tmp5_ehw0rk.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      flag = true;\n            temp += sentence[i];\n        } else {\n    \
    \        if (flag) {\n                ans += temp;\n                temp = \"\"\
    ;\n                flag = false;\n            }\n        }\n    }\n    if (flag)\
    \ {\n        ans += temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp905dqwa1: /tmp/tmp905dqwa1.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp084whvpa: /tmp/tmp084whvpa.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool prime = true;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            prime = true;\n  \
    \      } else {\n            prime = false;\n        }\n    }\n    for (int i\
    \ = 0; i < n; i++) {\n        if (prime) {\n            ans += sentence[i];\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmptd983ma9: /tmp/tmptd983ma9.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            flag = true;\n      \
    \      temp += sentence[i];\n        } else {\n            if (flag) {\n     \
    \           ans += temp;\n                temp = \"\";\n                flag =\
    \ false;\n            }\n        }\n    }\n    if (flag)\n        ans += temp;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n \
    \   assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpxt1sagdy: /tmp/tmpxt1sagdy.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == 'a' ||\
    \ i == 'e' || i == 'i' || i == 'o' || i == 'u') {\n            flag = true;\n\
    \        }\n        if (flag) {\n            ans += i;\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp4zdxbryo: /tmp/tmp4zdxbryo.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp += sentence[i];\n\
    \        } else {\n            ans += temp;\n            temp = \"\";\n      \
    \  }\n    }\n    ans += temp;\n    for (int i = 0; i < ans.length(); i++) {\n\
    \        flag = false;\n        for (int j = i + 1; j < ans.length(); j++) {\n\
    \            if (ans[j] % i == 0) {\n                flag = true;\n          \
    \      break;\n            }\n        }\n        if (!flag) {\n            ans.erase(ans.begin()\
    \ + i);\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -8
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        if(sentence[i] == ' ') {\n            flag = true;\n       \
    \     ans += temp;\n            temp = \"\";\n        } else {\n            temp\
    \ += sentence[i];\n        }\n    }\n    ans += temp;\n    for(int i = 0; i <\
    \ ans.length(); i++) {\n        if(i%2 == 0) {\n            assert(ans[i] == 'a'\
    \ || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u');\n    \
    \        ans[i] = ans[i+1];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpbkls265r: /tmp/tmpbkls265r.cpp:33: std::string words_in_sentence(std::string):\
    \ Assertion `ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o'\
    \ || ans[i] == 'u'' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp5k1hqn0q: /tmp/tmp5k1hqn0q.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            if (flag) {\n                ans = ans + \" \"\
    \ + temp;\n                temp = \"\";\n                flag = false;\n     \
    \       } else {\n                ans = ans + \" \" + temp;\n                temp\
    \ = \"\";\n                flag = true;\n            }\n        }\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp94u3hhwp: /tmp/tmp94u3hhwp.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (char c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                flag = false;\n                temp = \"\";\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            temp += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpibt_0_lj: /tmp/tmpibt_0_lj.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] >= 'a' && sentence[i] <= 'z') {\n            flag = true;\n\
    \        }\n        if (flag) {\n            ans += sentence[i];\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] >= 'a'\
    \ && ans[i] <= 'z') {\n            ans[i] = ans[i] - 'a' + 'A';\n        }\n \
    \   }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() +\
    \ i);\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n      \
    \  if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() + i);\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() +\
    \ i);\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n      \
    \  if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() + i);\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() +\
    \ i);\n        }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n      \
    \  if (ans[i] % 2 != 0) {\n            ans.erase(ans.begin() + i);\n        }\n\
    \    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 !=\
    \ 0) {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans.erase(ans.begin() + i);\n        }\n    }\n    for (int i = 0; i < an\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgthv050l.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpgthv050l.cpp:103:25: error: \u2018an\u2019 was not declared in this\
    \ scope; did you mean \u2018ans\u2019?\n  103 |     for (int i = 0; i < an\n \
    \     |                         ^~\n      |                         ans\n/tmp/tmpgthv050l.cpp:103:27:\
    \ error: expected \u2018;\u2019 before \u2018}\u2019 token\n  103 |     for (int\
    \ i = 0; i < an\n      |                           ^\n      |                \
    \           ;\n  104 | }\n      | ~                          \n/tmp/tmpgthv050l.cpp:104:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n  104 | }\n \
    \     | ^\n/tmp/tmpgthv050l.cpp:103:27: error: expected \u2018)\u2019 before \u2018\
    }\u2019 token\n  103 |     for (int i = 0; i < an\n      |         ~         \
    \        ^\n      |                           )\n  104 | }\n      | ~        \
    \                  \n/tmp/tmpgthv050l.cpp:104:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n  104 | }\n      | ^\n/tmp/tmpgthv050l.cpp:104:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    bool\
    \ flag = false;\n    int n = sentence.length();\n    for (int i = 0; i < n; i++)\
    \ {\n        flag = false;\n        for (int j = i + 1; j < n; j++) {\n      \
    \      if (isPrime(j - i)) {\n                flag = true;\n                break;\n\
    \            }\n        }\n        if (flag) {\n            result += sentence[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0q_3a_zs.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp0q_3a_zs.cpp:24:17: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   24 |             if (isPrime(j - i)) {\n      |             \
    \    ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    int n = sentence.length();\n    for (int i = 0;\
    \ i < n; i++) {\n        if (sentence[i] != ' ') {\n            temp = temp +\
    \ \" \" + sentence[i];\n        } else {\n            ans = ans + \" \" + temp;\n\
    \            temp = \"\";\n        }\n    }\n    ans = ans + \" \" + temp;\n \
    \   return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n  \
    \  assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpz1tbzs_8: /tmp/tmpz1tbzs_8.cpp:34: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    int n = sentence.length();\n    for (int i = 0; i <\
    \ n; i++) {\n        if (sentence[i] == ' ') {\n            flag = true;\n   \
    \     }\n        if (flag) {\n            ans += sentence[i];\n        }\n   \
    \ }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp103f_lzp: /tmp/tmp103f_lzp.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ word;\n    bool flag = false;\n    int n = sentence.length();\n    for (int\
    \ i = 0; i < n; i++) {\n        if (sentence[i] == ' ') {\n            flag =\
    \ true;\n            ans += word;\n            word.clear();\n        } else {\n\
    \            if (flag) {\n                word += sentence[i];\n            }\
    \ else {\n                flag = false;\n            }\n        }\n    }\n   \
    \ ans += word;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpaeybz6p3: /tmp/tmpaeybz6p3.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            temp = temp + \" \";\n            flag = true;\n\
    \        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ != ' ') {\n            ans = ans + temp[i];\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 != 0) {\n          \
    \  ans = ans + \" \";\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmplfnkorkr: /tmp/tmplfnkorkr.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &c : sentence)\
    \ {\n        if (c == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if (flag) {\n            ans += temp;\n            temp =\
    \ \"\";\n            flag = false;\n        }\n        temp += c;\n    }\n   \
    \ ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvqeccdbe: /tmp/tmpvqeccdbe.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (auto &i : sentence)\
    \ {\n        if (i == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += i;\n        }\n    }\n \
    \   if (flag) {\n        ans += \" \" + temp;\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdc4q5x0c: /tmp/tmpdc4q5x0c.cpp:39: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (char c : sentence) {\n        if (c == ' ') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += c;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpccn9og68: /tmp/tmpccn9og68.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    bool flag = false;\n    for (int i = 0; i < sentence.length(); i++)\
    \ {\n        if (sentence[i] == ' ') {\n            flag = true;\n           \
    \ temp.clear();\n        } else {\n            if (flag) {\n                temp\
    \ += sentence[i];\n            } else {\n                ans += temp;\n      \
    \          temp.clear();\n                flag = false;\n            }\n     \
    \   }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpv58p56wm: /tmp/tmpv58p56wm.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    for (int i\
    \ = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || ans[i] == '\\\
    r') {\n            ans.erase(ans.begin() + i);\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] == '\\n' || \n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4e1x7fk3.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp4e1x7fk3.cpp:95:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   95 | }\n      | ^\n/tmp/tmp4e1x7fk3.cpp:94:30: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   94 |         if (ans[i] == '\\\
    n' ||\n      |            ~                 ^\n      |                       \
    \       )\n   95 | }\n      | ~                             \n/tmp/tmp4e1x7fk3.cpp:95:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   95 | }\n \
    \     | ^\n/tmp/tmp4e1x7fk3.cpp:96:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   96 | int main() {\n      |            ^\n\
    /tmp/tmp4e1x7fk3.cpp:105:1: error: expected \u2018}\u2019 at end of input\n  105\
    \ | }\n      | ^\n/tmp/tmp4e1x7fk3.cpp:17:53: note: to match this \u2018{\u2019\
    \n   17 | std::string words_in_sentence(std::string sentence) {\n      |     \
    \                                                ^\n/tmp/tmp4e1x7fk3.cpp:105:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  105 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] != ' ') {\n            temp = temp + sentence[i];\n\
    \        } else {\n            temp = temp + \" \";\n            flag = true;\n\
    \        }\n    }\n    for (int i = 0; i < temp.length(); i++) {\n        if (temp[i]\
    \ != ' ') {\n            ans = ans + temp[i];\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 2 == 0) {\n          \
    \  ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 3 == 0) {\n            ans = ans + \" \";\n   \
    \     }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 5 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 7 == 0) {\n          \
    \  ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 11 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 13 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 17 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 19 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 23 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 29 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 31 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 37 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 41 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 43 == 0) {\n            ans = ans + \" \";\n  \
    \      }\n    }\n    for (int i = 0; i < ans.length(); i++) {\n        if (ans[i]\
    \ % 47 == 0) {\n            ans = ans + \" \";\n        }\n    }\n    for (int\
    \ i = 0; i < ans.length(); i++) {\n        if (ans[i] % 53 == 0) {\n         \
    \   ans = ans + \" \";\n        }\n    }\n    for (int i = 0; i < ans.length();\
    \ i++) {\n        if (ans[i] % 59 == 0) {\n            ans = \n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu_zb8bn7.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpu_zb8bn7.cpp:117:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  117 | }\n      | ^\n/tmp/tmpu_zb8bn7.cpp:118:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  118 | int main() {\n     \
    \ |            ^\n/tmp/tmpu_zb8bn7.cpp:127:1: error: expected \u2018}\u2019 at\
    \ end of input\n  127 | }\n      | ^\n/tmp/tmpu_zb8bn7.cpp:114:44: note: to match\
    \ this \u2018{\u2019\n  114 |     for (int i = 0; i < ans.length(); i++) {\n \
    \     |                                            ^\n/tmp/tmpu_zb8bn7.cpp:127:1:\
    \ error: expected \u2018}\u2019 at end of input\n  127 | }\n      | ^\n/tmp/tmpu_zb8bn7.cpp:17:53:\
    \ note: to match this \u2018{\u2019\n   17 | std::string words_in_sentence(std::string\
    \ sentence) {\n      |                                                     ^\n\
    /tmp/tmpu_zb8bn7.cpp:127:1: warning: no return statement in function returning\
    \ non-void [-Wreturn-type]\n  127 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans;\n    std::string\
    \ temp;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      temp = sentence[i];\n        for(int j = i + 1; j < n; j++) {\n       \
    \     if(temp == sentence[j]) {\n                temp = temp + \" \" + sentence[j];\n\
    \                j++;\n            }\n        }\n        ans = ans + \" \" + temp;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu3vk22my.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmpu3vk22my.cpp:24:21: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   24 |             if(temp == sentence[j]) {\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5: note:\
    \ candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1173:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&, std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>&)\u2019\n 1173 |     operator==(const sub_match<_Bi_iter>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1173:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \ candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type*, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1247 |     operator==(typename iterator_traits<_Bi_iter>::value_type const*\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1247:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1321:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type*)\u2019\
    \n 1321 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1321:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/regex:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n      \
    \           from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1395:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ typename std::iterator_traits<_Iter>::value_type&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1395 |     operator==(typename iterator_traits<_Bi_iter>::value_type const&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1395:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1473:5:\
    \ note: candidate: \u2018template<class _Bi_iter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const typename std::iterator_traits<_Iter>::value_type&)\u2019\
    \n 1473 |     operator==(const sub_match<_Bi_iter>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1473:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/regex:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n      \
    \           from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/regex.h:1991:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Alloc> bool std::__cxx11::operator==(const\
    \ std::__cxx11::match_results<_BiIter, _Alloc>&, const std::__cxx11::match_results<_BiIter,\
    \ _Alloc>&)\u2019\n 1991 |     operator==(const match_results<_Bi_iter, _Alloc>&\
    \ __m1,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1991:5: note: \
    \  template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::match_results<_BiIter, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/iosfwd:40,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/postypes.h:222:5: note: candidate:\
    \ \u2018template<class _StateT> bool std::operator==(const std::fpos<_StateT>&,\
    \ const std::fpos<_StateT>&)\u2019\n  222 |     operator==(const fpos<_StateT>&\
    \ __lhs, const fpos<_StateT>& __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/postypes.h:222:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::fpos<_StateT>\u2019\n   24 |          \
    \   if(temp == sentence[j]) {\n      |                                  ^\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:64,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> constexpr bool std::operator==(const\
    \ std::pair<_T1, _T2>&, const std::pair<_T1, _T2>&)\u2019\n  448 |     operator==(const\
    \ pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_pair.h:448:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::pair<_T1, _T2>\u2019\n   24 |         \
    \    if(temp == sentence[j]) {\n      |                                  ^\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/char_traits.h:39,\n                 from /usr/include/c++/9/ios:40,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:325:5:\
    \ note: candidate: \u2018template<class _Iterator> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_Iterator>&)\u2019\
    \n  325 |     operator==(const reverse_iterator<_Iterator>& __x,\n      |    \
    \ ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:325:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\
    \n  363 |     operator==(const reverse_iterator<_IteratorL>& __x,\n      |   \
    \  ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:363:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::reverse_iterator<_Iterator>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1136:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR> bool std::operator==(const\
    \ std::move_iterator<_IteratorL>&, const std::move_iterator<_IteratorR>&)\u2019\
    \n 1136 |     operator==(const move_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_iterator.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \ candidate: \u2018template<class _Iterator> bool std::operator==(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorL>&)\u2019\n 1142 |     operator==(const move_iterator<_Iterator>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:1142:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::move_iterator<_IteratorL>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/string:41,\n             \
    \    from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note: candidate: \u2018template<class _T1, class _T2> bool std::operator==(const\
    \ std::allocator<_CharT>&, const std::allocator<_T2>&)\u2019\n  167 |     operator==(const\
    \ allocator<_T1>&, const allocator<_T2>&)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:167:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::allocator<_CharT>\u2019\n   24 |      \
    \       if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6144:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&)\u2019\n 6144 |     operator==(const basic_string<_CharT,\
    \ _Traits, _Alloc>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6144:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note: candidate: \u2018template<class _CharT> typename __gnu_cxx::__enable_if<std::__is_char<_Tp>::__value,\
    \ bool>::__type std::operator==(const std::__cxx11::basic_string<_CharT>&, const\
    \ std::__cxx11::basic_string<_CharT>&)\u2019\n 6152 |     operator==(const basic_string<_CharT>&\
    \ __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6152:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__cxx11::basic_string<_CharT>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6166:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool\
    \ std::operator==(const _CharT*, const std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>&)\u2019\n 6166 |     operator==(const _CharT* __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6166:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   mismatched types \u2018const _CharT*\u2019\
    \ and \u2018std::__cxx11::basic_string<char>\u2019\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:\
    \ candidate: \u2018template<class _CharT, class _Traits, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*)\u2019\n\
    \ 6178 |     operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6178:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const _CharT*\u2019 and \u2018char\u2019\n  \
    \ 24 |             if(temp == sentence[j]) {\n      |                        \
    \          ^\nIn file included from /usr/include/c++/9/bits/ios_base.h:46,\n \
    \                from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/system_error:292:3: note: candidate:\
    \ \u2018bool std::operator==(const std::error_code&, const std::error_code&)\u2019\
    \n  292 |   operator==(const error_code& __lhs, const error_code& __rhs) noexcept\n\
    \      |   ^~~~~~~~\n/usr/include/c++/9/system_error:292:32: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  292 |   operator==(const error_code&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:297:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_code&, const std::error_condition&)\u2019\n  297 |   operator==(const\
    \ error_code& __lhs, const error_condition& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:297:32: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_code&\u2019\n  297 |   operator==(const error_code&\
    \ __lhs, const error_condition& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:304:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_code&)\u2019\n  304 |   operator==(const\
    \ error_condition& __lhs, const error_code& __rhs) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/system_error:304:37: note:   no known conversion for argument\
    \ 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const std::error_condition&\u2019\n  304 |   operator==(const error_condition&\
    \ __lhs, const error_code& __rhs) noexcept\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/system_error:311:3: note: candidate: \u2018bool std::operator==(const\
    \ std::error_condition&, const std::error_condition&)\u2019\n  311 |   operator==(const\
    \ error_condition& __lhs,\n      |   ^~~~~~~~\n/usr/include/c++/9/system_error:311:37:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::error_condition&\u2019\
    \n  311 |   operator==(const error_condition& __lhs,\n      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /usr/include/c++/9/bits/locale_facets.h:48,\n          \
    \       from /usr/include/c++/9/bits/basic_ios.h:37,\n                 from /usr/include/c++/9/ios:44,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note: candidate: \u2018template<class _CharT, class _Traits> bool std::operator==(const\
    \ std::istreambuf_iterator<_CharT, _Traits>&, const std::istreambuf_iterator<_CharT,\
    \ _Traits>&)\u2019\n  208 |     operator==(const istreambuf_iterator<_CharT, _Traits>&\
    \ __a,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/streambuf_iterator.h:208:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istreambuf_iterator<_CharT, _Traits>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n    \
    \             from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/complex:463:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  463 |     operator==(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:463:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   24 |           \
    \  if(temp == sentence[j]) {\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/complex:468:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ std::complex<_Tp>&, const _Tp&)\u2019\n  468 |     operator==(const complex<_Tp>&\
    \ __x, const _Tp& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:468:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::complex<_Tp>\u2019\n   24 |           \
    \  if(temp == sentence[j]) {\n      |                                  ^\nIn file\
    \ included from /usr/include/c++/9/ccomplex:39,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/complex:473:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr bool std::operator==(const\
    \ _Tp&, const std::complex<_Tp>&)\u2019\n  473 |     operator==(const _Tp& __x,\
    \ const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:473:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::complex<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/deque:67,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:286:5:\
    \ note: candidate: \u2018template<class _Tp, class _Ref, class _Ptr> bool std::operator==(const\
    \ std::_Deque_iterator<_Tp, _Ref, _Ptr>&, const std::_Deque_iterator<_Tp, _Ref,\
    \ _Ptr>&)\u2019\n  286 |     operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:286:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note: candidate: \u2018template<class _Tp, class _RefL, class _PtrL, class _RefR,\
    \ class _PtrR> bool std::operator==(const std::_Deque_iterator<_Tp, _Ref, _Ptr>&,\
    \ const std::_Deque_iterator<_Tp, _RefR, _PtrR>&)\u2019\n  293 |     operator==(const\
    \ _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:293:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::_Deque_iterator<_Tp, _Ref, _Ptr>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/deque:67,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:68,\n        \
    \         from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::deque<_Tp, _Alloc>&, const std::deque<_Tp, _Alloc>&)\u2019\n 2312 |   \
    \  operator==(const deque<_Tp, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_deque.h:2312:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::deque<_Tp, _Alloc>\u2019\n   24 |     \
    \        if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/tuple:39,\n                 from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/array:252:5:\
    \ note: candidate: \u2018template<class _Tp, long unsigned int _Nm> bool std::operator==(const\
    \ std::array<_Tp, _Nm>&, const std::array<_Tp, _Nm>&)\u2019\n  252 |     operator==(const\
    \ array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/array:252:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::array<_Tp,\
    \ _Nm>\u2019\n   24 |             if(temp == sentence[j]) {\n      |         \
    \                         ^\nIn file included from /usr/include/c++/9/functional:54,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/tuple:1419:5:\
    \ note: candidate: \u2018template<class ... _TElements, class ... _UElements>\
    \ constexpr bool std::operator==(const std::tuple<_Tps ...>&, const std::tuple<_Elements\
    \ ...>&)\u2019\n 1419 |     operator==(const tuple<_TElements...>& __t,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/tuple:1419:5: note:   template argument\
    \ deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} is not derived from \u2018\
    const std::tuple<_Tps ...>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/functional:59,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(const\
    \ std::function<_Res(_ArgTypes ...)>&, std::nullptr_t)\u2019\n  746 |     operator==(const\
    \ function<_Res(_Args...)>& __f, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:746:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::function<_Res(_ArgTypes ...)>\u2019\n \
    \  24 |             if(temp == sentence[j]) {\n      |                       \
    \           ^\nIn file included from /usr/include/c++/9/functional:59,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:71,\n    \
    \             from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note: candidate: \u2018template<class _Res, class ... _Args> bool std::operator==(std::nullptr_t,\
    \ const std::function<_Res(_ArgTypes ...)>&)\u2019\n  752 |     operator==(nullptr_t,\
    \ const function<_Res(_Args...)>& __f) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/std_function.h:752:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::function<_Res(_ArgTypes ...)>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n\
    \                 from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:715:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp, class _Up, class _Ep>\
    \ bool std::operator==(const std::unique_ptr<_Tp, _Dp>&, const std::unique_ptr<_Up,\
    \ _Ep>&)\u2019\n  715 |     operator==(const unique_ptr<_Tp, _Dp>& __x,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:715:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   24 |   \
    \          if(temp == sentence[j]) {\n      |                                \
    \  ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n      \
    \           from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(const\
    \ std::unique_ptr<_Tp, _Dp>&, std::nullptr_t)\u2019\n  721 |     operator==(const\
    \ unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:721:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unique_ptr<_Tp, _Dp>\u2019\n   24 |   \
    \          if(temp == sentence[j]) {\n      |                                \
    \  ^\nIn file included from /usr/include/c++/9/bits/locale_conv.h:41,\n      \
    \           from /usr/include/c++/9/locale:43,\n                 from /usr/include/c++/9/iomanip:43,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:72,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note: candidate: \u2018template<class _Tp, class _Dp> bool std::operator==(std::nullptr_t,\
    \ const std::unique_ptr<_Tp, _Dp>&)\u2019\n  726 |     operator==(nullptr_t, const\
    \ unique_ptr<_Tp, _Dp>& __x) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unique_ptr.h:726:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::unique_ptr<_Tp, _Dp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   24 |             if(temp == sentence[j]) {\n      |          \
    \                        ^\nIn file included from /usr/include/c++/9/iterator:66,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:77,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stream_iterator.h:134:5:\
    \ note: candidate: \u2018template<class _Tp, class _CharT, class _Traits, class\
    \ _Dist> bool std::operator==(const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>&, const std::istream_iterator<_Tp, _CharT, _Traits, _Dist>&)\u2019\n\
    \  134 |     operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stream_iterator.h:134:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::istream_iterator<_Tp, _CharT, _Traits,\
    \ _Dist>\u2019\n   24 |             if(temp == sentence[j]) {\n      |       \
    \                           ^\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1991:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::__cxx11::list<_Tp, _Alloc>&, const std::__cxx11::list<_Tp, _Alloc>&)\u2019\
    \n 1991 |     operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1991:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::list<_Tp, _Alloc>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/map:61,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n               \
    \  from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1455:5: note:\
    \ candidate: \u2018template<class _Key, class _Tp, class _Compare, class _Alloc>\
    \ bool std::operator==(const std::map<_Key, _Tp, _Compare, _Alloc>&, const std::map<_Key,\
    \ _Tp, _Compare, _Alloc>&)\u2019\n 1455 |     operator==(const map<_Key, _Tp,\
    \ _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:1455:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::map<_Key, _Tp, _Compare, _Alloc>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/map:62,\n           \
    \      from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n          \
    \       from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Compare, class\
    \ _Alloc> bool std::operator==(const std::multimap<_Key, _Tp, _Compare, _Alloc>&,\
    \ const std::multimap<_Key, _Tp, _Compare, _Alloc>&)\u2019\n 1119 |     operator==(const\
    \ multimap<_Key, _Tp, _Compare, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multimap.h:1119:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multimap<_Key, _Tp, _Compare, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n\
    \                 from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5:\
    \ note: candidate: \u2018template<class _Tp1, class _Tp2, __gnu_cxx::_Lock_policy\
    \ _Lp> bool std::operator==(const std::__shared_ptr<_Tp1, _Lp>&, const std::__shared_ptr<_Tp2,\
    \ _Lp>&)\u2019\n 1412 |     operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1412:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp1, _Lp>\u2019\n   24 |\
    \             if(temp == sentence[j]) {\n      |                             \
    \     ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n    \
    \             from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(const std::__shared_ptr<_Tp, _Lp>&, std::nullptr_t)\u2019\n\
    \ 1418 |     operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1418:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__shared_ptr<_Tp, _Lp>\u2019\n   24 | \
    \            if(temp == sentence[j]) {\n      |                              \
    \    ^\nIn file included from /usr/include/c++/9/bits/shared_ptr.h:52,\n     \
    \            from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5:\
    \ note: candidate: \u2018template<class _Tp, __gnu_cxx::_Lock_policy _Lp> bool\
    \ std::operator==(std::nullptr_t, const std::__shared_ptr<_Tp, _Lp>&)\u2019\n\
    \ 1423 |     operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr_base.h:1423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::__shared_ptr<_Tp, _Lp>\u2019 and \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019}\n   24 |             if(temp == sentence[j]) {\n      |          \
    \                        ^\nIn file included from /usr/include/c++/9/memory:81,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:383:5:\
    \ note: candidate: \u2018template<class _Tp, class _Up> bool std::operator==(const\
    \ std::shared_ptr<_Tp>&, const std::shared_ptr<_Tp>&)\u2019\n  383 |     operator==(const\
    \ shared_ptr<_Tp>& __a, const shared_ptr<_Up>& __b) noexcept\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/shared_ptr.h:383:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::shared_ptr<_Tp>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/memory:81,\n       \
    \          from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n      \
    \           from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(const std::shared_ptr<_Tp>&,\
    \ std::nullptr_t)\u2019\n  388 |     operator==(const shared_ptr<_Tp>& __a, nullptr_t)\
    \ noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:388:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::shared_ptr<_Tp>\u2019\n   24 |        \
    \     if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/memory:81,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:82,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note: candidate: \u2018template<class _Tp> bool std::operator==(std::nullptr_t,\
    \ const std::shared_ptr<_Tp>&)\u2019\n  393 |     operator==(nullptr_t, const\
    \ shared_ptr<_Tp>& __a) noexcept\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/shared_ptr.h:393:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::shared_ptr<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/queue:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1888:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::vector<_Tp, _Alloc>&, const std::vector<_Tp, _Alloc>&)\u2019\n 1888 | \
    \    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1888:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::vector<_Tp, _Alloc>\u2019\n   24 |    \
    \         if(temp == sentence[j]) {\n      |                                 \
    \ ^\nIn file included from /usr/include/c++/9/queue:64,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:86,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_queue.h:338:5: note: candidate:\
    \ \u2018template<class _Tp, class _Seq> bool std::operator==(const std::queue<_Tp,\
    \ _Seq>&, const std::queue<_Tp, _Seq>&)\u2019\n  338 |     operator==(const queue<_Tp,\
    \ _Seq>& __x, const queue<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_queue.h:338:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::queue<_Tp, _Seq>\u2019\n   24 |       \
    \      if(temp == sentence[j]) {\n      |                                  ^\n\
    In file included from /usr/include/c++/9/set:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::set<_Key, _Compare, _Alloc>&, const std::set<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  979 |     operator==(const set<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_set.h:979:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::set<_Key, _Compare, _Alloc>\u2019\n   24\
    \ |             if(temp == sentence[j]) {\n      |                           \
    \       ^\nIn file included from /usr/include/c++/9/set:62,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:87,\n               \
    \  from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note: candidate: \u2018template<class _Key, class _Compare, class _Alloc> bool\
    \ std::operator==(const std::multiset<_Key, _Compare, _Alloc>&, const std::multiset<_Key,\
    \ _Compare, _Alloc>&)\u2019\n  964 |     operator==(const multiset<_Key, _Compare,\
    \ _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_multiset.h:964:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::multiset<_Key, _Compare, _Alloc>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/c++/9/stack:61,\n         \
    \        from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n        \
    \         from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:313:5:\
    \ note: candidate: \u2018template<class _Tp, class _Seq> bool std::operator==(const\
    \ std::stack<_Tp, _Seq>&, const std::stack<_Tp, _Seq>&)\u2019\n  313 |     operator==(const\
    \ stack<_Tp, _Seq>& __x, const stack<_Tp, _Seq>& __y)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/stl_stack.h:313:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::stack<_Tp,\
    \ _Seq>\u2019\n   24 |             if(temp == sentence[j]) {\n      |        \
    \                          ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_Constant, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const typename _Dom::value_type&)\u2019\n  417\
    \ |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const typename _Dom::value_type&,\
    \ const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==,\
    \ __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Expr, std::_ValArray, _Dom, typename _Dom::value_type>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>&, const std::valarray<typename _Dom::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019\n   24 |             if(temp == sentence[j])\
    \ {\n      |                                  ^\nIn file included from /usr/include/c++/9/valarray:603,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/valarray_after.h:417:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Expr, typename _Dom::value_type, _Dom>, typename std::__fun<std::__equal_to,\
    \ typename _Dom1::value_type>::result_type> std::operator==(const std::valarray<typename\
    \ _Dom::value_type>&, const std::_Expr<_Dom1, typename _Dom1::value_type>&)\u2019\
    \n  417 |     _DEFINE_EXPR_BINARY_OPERATOR(==, __equal_to)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/valarray_after.h:417:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   mismatched types \u2018const std::_Expr<_Dom1,\
    \ typename _Dom1::value_type>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n               \
    \  from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/valarray:1197:1: note: candidate:\
    \ \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const std::valarray<_Tp>&)\u2019\
    \n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/valarray:1197:1: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::valarray<_Tp>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_ValArray, std::_Constant, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const std::valarray<_Tp>&, const typename\
    \ std::valarray<_Tp>::value_type&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==,\
    \ __equal_to)\n      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::valarray<_Tp>\u2019\n   24 |          \
    \   if(temp == sentence[j]) {\n      |                                  ^\nIn\
    \ file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n \
    \                from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/valarray:1197:1:\
    \ note: candidate: \u2018template<class _Tp> std::_Expr<std::__detail::_BinClos<std::__equal_to,\
    \ std::_Constant, std::_ValArray, _Tp, _Tp>, typename std::__fun<std::__equal_to,\
    \ _Tp>::result_type> std::operator==(const typename std::valarray<_Tp>::value_type&,\
    \ const std::valarray<_Tp>&)\u2019\n 1197 | _DEFINE_BINARY_OPERATOR(==, __equal_to)\n\
    \      | ^~~~~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/valarray:1197:1: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const std::valarray<_Tp>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |             if(temp\
    \ == sentence[j]) {\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/forward_list:40,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:104,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/forward_list.tcc:393:5:\
    \ note: candidate: \u2018template<class _Tp, class _Alloc> bool std::operator==(const\
    \ std::forward_list<_Tp, _Alloc>&, const std::forward_list<_Tp, _Alloc>&)\u2019\
    \n  393 |     operator==(const forward_list<_Tp, _Alloc>& __lx,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/forward_list.tcc:393:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpu3vk22my.cpp:24:34: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::forward_list<_Tp,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/future:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:105,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/thread:276:3:\
    \ note: candidate: \u2018bool std::operator==(std::thread::id, std::thread::id)\u2019\
    \n  276 |   operator==(thread::id __x, thread::id __y) noexcept\n      |   ^~~~~~~~\n\
    /usr/include/c++/9/thread:276:25: note:   no known conversion for argument 1 from\
    \ \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019} to\
    \ \u2018std::thread::id\u2019\n  276 |   operator==(thread::id __x, thread::id\
    \ __y) noexcept\n      |              ~~~~~~~~~~~^~~\nIn file included from /usr/include/c++/9/random:51,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:108,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/random.tcc:1884:5:\
    \ note: candidate: \u2018template<class _RealType1> bool std::operator==(const\
    \ std::normal_distribution<_RealType>&, const std::normal_distribution<_RealType>&)\u2019\
    \n 1884 |     operator==(const std::normal_distribution<_RealType>& __d1,\n  \
    \    |     ^~~~~~~~\n/usr/include/c++/9/bits/random.tcc:1884:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::normal_distribution<_RealType>\u2019\n\
    \   24 |             if(temp == sentence[j]) {\n      |                      \
    \            ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:111,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/scoped_allocator:489:5:\
    \ note: candidate: \u2018template<class _OutA1, class _OutA2, class ... _InA>\
    \ bool std::operator==(const std::scoped_allocator_adaptor<_OutA1, _InA ...>&,\
    \ const std::scoped_allocator_adaptor<_InnerHead, _InnerTail ...>&)\u2019\n  489\
    \ |     operator==(const scoped_allocator_adaptor<_OutA1, _InA...>& __a,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/scoped_allocator:489:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const std::scoped_allocator_adaptor<_OutA1, _InA ...>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>&, const std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&)\u2019\
    \n 2093 |     operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2093:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:117,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note: candidate: \u2018template<class _Key, class _Tp, class _Hash, class _Pred,\
    \ class _Alloc> bool std::operator==(const std::unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>&, const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>&)\u2019\n 2105 |     operator==(const unordered_multimap<_Key, _Tp,\
    \ _Hash, _Pred, _Alloc>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:2105:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multimap<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1705:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_set<_Value, _Hash, _Pred, _Alloc>&)\u2019\n 1705\
    \ |     operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n \
    \     |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1705:5: note:  \
    \ template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_set<_Value, _Hash, _Pred, _Alloc>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note: candidate: \u2018template<class _Value, class _Hash, class _Pred, class\
    \ _Alloc> bool std::operator==(const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>&, const std::unordered_multiset<_Value, _Hash, _Pred, _Alloc>&)\u2019\
    \n 1717 |     operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>&\
    \ __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/unordered_set.h:1717:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::unordered_multiset<_Value, _Hash, _Pred,\
    \ _Alloc>\u2019\n   24 |             if(temp == sentence[j]) {\n      |      \
    \                            ^\nIn file included from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/allocator.h:155:7:\
    \ note: candidate: \u2018bool std::operator==(const std::allocator<char>&, const\
    \ std::allocator<char>&)\u2019\n  155 |       operator==(const allocator&, const\
    \ allocator&) _GLIBCXX_NOTHROW\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/allocator.h:155:18:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const std::allocator<char>&\u2019\
    \n  155 |       operator==(const allocator&, const allocator&) _GLIBCXX_NOTHROW\n\
    \      |                  ^~~~~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:\
    \ candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34: note: \
    \  \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019}\
    \ is not derived from \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/char_traits.h:39,\n           \
    \      from /usr/include/c++/9/ios:40,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5: note:\
    \ candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator==(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)\u2019\n  890 |     operator==(const __normal_iterator<_Iterator,\
    \ _Container>& __lhs,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const __gnu_cxx::__normal_iterator<_Iterator, _Container>\u2019\
    \n   24 |             if(temp == sentence[j]) {\n      |                     \
    \             ^\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpu3vk22my.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:166:2: note:\
    \ candidate: \u2018template<class _Up> bool __gnu_cxx::operator==(const __gnu_cxx::new_allocator<char>&,\
    \ const __gnu_cxx::new_allocator<_Tp>&)\u2019\n  166 |  operator==(const new_allocator&,\
    \ const new_allocator<_Up>&)\n      |  ^~~~~~~~\n/usr/include/c++/9/ext/new_allocator.h:166:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpu3vk22my.cpp:24:34:\
    \ note:   mismatched types \u2018const __gnu_cxx::new_allocator<_Tp>\u2019 and\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |             if(temp == sentence[j]) {\n    \
    \  |                                  ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    bool flag = false;\n    for (auto &c : sentence) {\n        if (c\
    \ == ' ') {\n            flag = true;\n            word.clear();\n        } else\
    \ {\n            if (flag) {\n                word += c;\n            } else {\n\
    \                result += word;\n                result += c;\n             \
    \   flag = true;\n            }\n        }\n    }\n    result += word;\n    return\
    \ result;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjb9ut4z7: /tmp/tmpjb9ut4z7.cpp:40: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string result;\n    std::string\
    \ word;\n    int n = sentence.length();\n    for(int i = 0; i < n; i++) {\n  \
    \      word = sentence[i];\n        for(int j = i + 1; j < n; j++) {\n       \
    \     if(isPrime(j - i) && isPrime(j - i + 1)) {\n                result += \"\
    \ \" + word;\n            }\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"This is\
    \ a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) ==\
    \ (\"go for\"));\n    assert(candidate((\"there is no place available here\"))\
    \ == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1lifz1xj.cpp: In function \u2018std::string words_in_sentence(std::string)\u2019\
    :\n/tmp/tmp1lifz1xj.cpp:24:16: error: \u2018isPrime\u2019 was not declared in\
    \ this scope\n   24 |             if(isPrime(j - i) && isPrime(j - i + 1)) {\n\
    \      |                ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (auto &i : sentence) {\n        if (i == '.') {\n\
    \            flag = true;\n            continue;\n        }\n        if (flag)\
    \ {\n            ans += i;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpvlt8uibw: /tmp/tmpvlt8uibw.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for(int i = 0; i < sentence.length(); i++) {\n     \
    \   if(sentence[i] == ' ') {\n            flag = true;\n            continue;\n\
    \        }\n        if(flag) {\n            ans += sentence[i];\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n\
    \    assert(candidate((\"This is a test\")) == (\"is\"));\n    assert(candidate((\"\
    lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"there is no\
    \ place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpzdp16x3b: /tmp/tmpzdp16x3b.cpp:33: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int n = sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        if (sentence[i] != ' ') {\n      \
    \      temp = temp + sentence[i];\n        } else {\n            if (flag) {\n\
    \                ans = ans + \" \" + temp;\n                temp = \"\";\n   \
    \             flag = false;\n            } else {\n                ans = ans +\
    \ \" \" + temp;\n                temp = \"\";\n                flag = true;\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpn_p8s3u8: /tmp/tmpn_p8s3u8.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int count = 0;\n    for\
    \ (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n\
    \            flag = true;\n            count++;\n        } else {\n          \
    \  if (flag) {\n                ans += temp;\n                temp = \"\";\n \
    \               flag = false;\n                count = 0;\n            }\n   \
    \         temp = temp + sentence[i];\n        }\n    }\n    ans += temp;\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmplzzx4t2n: /tmp/tmplzzx4t2n.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word;\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n\
    \        if(sentence[i]==' '){\n            flag = true;\n        }\n        if(flag){\n\
    \            word = word + sentence[i];\n        }\n    }\n    for(int i=0;i<word.size();i++){\n\
    \        for(int j=i+1;j<word.size();j++){\n            if(word[i]==word[j]){\n\
    \                ans = ans + word[i] + \" \";\n                word.erase(i,1);\n\
    \                word.erase(j,1);\n                flag = false;\n           \
    \ }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"));\n\
    \    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpk2xdz61y: /tmp/tmpk2xdz61y.cpp:43: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = true;\n    for(int i = 0; i < sentence.length(); i++) {\n      \
    \  if(sentence[i] != ' ') {\n            flag = false;\n            break;\n \
    \       }\n    }\n    if(flag) {\n        for(int i = 0; i < sentence.length();\
    \ i++) {\n            if(sentence[i] != ' ') {\n                ans += sentence[i];\n\
    \            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpjh4bv_aw: /tmp/tmpjh4bv_aw.cpp:37: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    int len = 0;\n    int\
    \ count = 0;\n    for (auto c : sentence) {\n        if (c == ' ') {\n       \
    \     flag = true;\n            len++;\n            count = 0;\n        } else\
    \ {\n            if (flag) {\n                temp += c;\n                count++;\n\
    \            } else {\n                ans += temp;\n                temp = \"\
    \";\n                flag = true;\n                len++;\n                count\
    \ = 0;\n            }\n        }\n    }\n    ans += temp;\n    return ans;\n}\n\
    int main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp_uimoveo: /tmp/tmp_uimoveo.cpp:46: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            temp += sentence[i];\n         \
    \   flag = true;\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmptimrxden: /tmp/tmptimrxden.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string word = \"\";\n    bool flag = false;\n    for (auto c : sentence)\
    \ {\n        if (c == ' ') {\n            if (flag) {\n                ans +=\
    \ \" \" + word;\n                flag = false;\n                word = \"\";\n\
    \            } else {\n                flag = true;\n            }\n        }\
    \ else {\n            word += c;\n        }\n    }\n    if (flag) {\n        ans\
    \ += \" \" + word;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = words_in_sentence;\n    assert(candidate((\"This is a test\")) == (\"is\"\
    ));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"));\n    assert(candidate((\"\
    there is no place available here\")) == (\"there is no place\"));\n    assert(candidate((\"\
    Hi I am Hussein\")) == (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\"\
    )) == (\"go for it\"));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"\
    here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmpdvf_5jtg: /tmp/tmpdvf_5jtg.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] == ' ') {\n            if (flag) {\n       \
    \         ans += temp;\n                temp = \"\";\n                flag = false;\n\
    \            }\n        } else {\n            if (flag) {\n                temp\
    \ += sentence[i];\n            } else {\n                flag = true;\n      \
    \      }\n        }\n    }\n    ans += temp;\n    return ans;\n}\nint main() {\n\
    \    auto candidate = words_in_sentence;\n    assert(candidate((\"This is a test\"\
    )) == (\"is\"));\n    assert(candidate((\"lets go for swimming\")) == (\"go for\"\
    ));\n    assert(candidate((\"there is no place available here\")) == (\"there\
    \ is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) == (\"Hi am Hussein\"\
    ));\n    assert(candidate((\"go for it\")) == (\"go for it\"));\n    assert(candidate((\"\
    here\")) == (\"\"));\n    assert(candidate((\"here is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp7xhtj_xr: /tmp/tmp7xhtj_xr.cpp:41: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ bool flag = false;\n    for (int i = 0; i < sentence.length(); i++) {\n    \
    \    if (sentence[i] == ' ') {\n            flag = true;\n        }\n        if\
    \ (flag) {\n            ans += sentence[i];\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmp7s9fr_85: /tmp/tmp7s9fr_85.cpp:32: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string\
    \ representing a sentence,\n// the sentence contains some words separated by a\
    \ space,\n// and you have to return a string that contains the words from the\
    \ original sentence,\n// whose lengths are prime numbers,\n// the order of the\
    \ words in the new string should be the same as the original one.\n// Example\
    \ 1:\n// Input: sentence = \"This is a test\"\n// Output: \"is\"\n// Example 2:\n\
    // Input: sentence = \"lets go for swimming\"\n// Output: \"go for\"\n// Constraints:\n\
    // * 1 <= len(sentence) <= 100\n// * sentence contains only letters\nstd::string\
    \ words_in_sentence(std::string sentence) {\n    std::string ans = \"\";\n   \
    \ std::string temp = \"\";\n    bool flag = false;\n    for(int i=0;i<sentence.size();i++){\n\
    \        if(sentence[i]==' '){\n            flag = true;\n        }\n        if(flag){\n\
    \            temp += sentence[i];\n        }\n        else{\n            ans +=\
    \ temp;\n            temp = \"\";\n        }\n    }\n    ans += temp;\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
    This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
    )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
    )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
    \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
    ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
    \ is\")) == (\"is\"));\n}\n"
  stdout: ''
  stderr: "tmphdwmgdwu: /tmp/tmphdwmgdwu.cpp:38: int main(): Assertion `candidate((\"\
    This is a test\")) == (\"is\")' failed.\n"
  exit_code: -6
  status: Exception
